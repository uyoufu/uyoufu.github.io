[{"title":"Bentley-Free 安装教程","url":"/posts/2020/G353ND.html","content":"本文介绍如何安装 Bentley-Free 达到免费使用 Bentley\r\n系列软件的目的。\r\n\r\n操作文档\r\n\r\n使用超级管理员打开 powershell 终端\r\n在里面输入以下内容，并按 Enter\r\nirm https://app-installer.pages.dev/active-bentley | iex\r\n若出现\r\nbecause the execution of scripts is disabled on this system\r\n类似错误，则需要启用远程脚本执行权限，在终端中输入下列命令开启：\r\nSet-ExecutionPolicy -Scope CurrentUser RemoteSigned\r\n根据提示输入激活码，详见下图\r\n\r\n\r\nimage-20241127141302147\r\n\r\n\r\n视频介绍\r\n若使用文档有困难，可以参考下面的操作视频\r\n\r\n\r\n\r\n其它说明\r\n\r\n激活码可在闲鱼查找\r\n经测试，每个激活码可激活两台电脑\r\n\r\n","categories":["Apps"],"tags":["Apps"]},{"title":"主流开源许可证之间的区别","url":"/posts/2022/345RS77.html","content":"世界上的开源许可证，大概有上百种。很少有人搞得清楚它们的区别。即使在最流行的六种----GPL、BSD、MIT、Mozilla、Apache和LGPL----之中做选择，也很复杂。\r\n\r\n其主要区别如下图：\r\n\r\n参考\r\n本文主要参考以下文章，在此表示诚挚感谢！\r\n\r\n阮一峰:如何选择开源许可证？\r\n\r\n","categories":["Develop"],"tags":["许可证"]},{"title":"Scoop, 超好用的个人/企业软件管家","url":"/posts/2025/7CTYV9.html","content":"简介\r\n推荐指数：⭐⭐⭐⭐⭐\r\n本期推荐一款超级好用的软件安装管家：开源免费、无任何广告打扰、可一键安装和卸载。\r\n它就是 Scoop\r\nScoop 在 Github 上拥有 21.4k star，开源协议为\r\nMIT。它不仅适用于个人，同样适用于中小企业的软件管理。个人用户可以通过它快速查找、安装和卸载软件，网管可以通过提供统一的软件仓库，统一软件分发，提升网络安全。\r\n\r\n什么是 Scoop\r\nScoop 是 Windows 中的一款命令行软件安装器, 官方原文：\"A command-line\r\ninstaller for Windows.\"\r\n它的灵感来自于 Homebrew 和 Sub,\r\n可以让用户高效、优雅地安装软件。\r\n为什么选择 Scoop\r\n由于 Windows 上的程序打包方式多，比如 .exe、.msi、.appx、.msix\r\n等，再加上 windows 的向后兼容性，从而导致在 Windows\r\n上没有形成统一的软件安装器。用户可以通过 Microsoft Store\r\n安装，也可以自行下载安装，但这对于电脑不太熟悉的同学，就很可能出现被下载流氓全家桶的情况，导致自己的电脑被弄得一团糟，最后只能被迫重装系统。\r\nScoop 有以下优点，这是选择它的主要理由：\r\n\r\n可以很方便地自定义和使用软件仓库\r\n消除了用户账户控制(UAC)弹窗提示\r\n可以静默安装\r\n防止 PATH 环境变量污染\r\n自动安装软件依赖\r\n可以自定义安装和卸载逻辑\r\n\r\n为什么不是其它软件\r\nMicrosoft Store\r\n相较于 Scoop，Microsoft Store\r\n不能自定义软件仓库，一些开源的软件无法安装。\r\n360/腾讯等软件管家\r\n这种软件管家与 Microsoft Store\r\n一样，它不能自定义软件仓库，部分开源软件找不到，无法安装。\r\n对于电脑小白来说，使用这种软件很可能被诱导安装它的全家桶，让自己的电脑处于混乱状态。\r\nWinget\r\nWinget 与 Scoop\r\n的区别在于前者不能很方便地添加软件存储库，如果想根据自己的需求自定义很麻烦。\r\nScoop 应用场景\r\nScoop 可以应用在下列场景中：\r\n个人软件安装管理\r\n\r\n便捷省心：通过简单的命令行操作，快速安装和管理各种常用软件和开发工具。\r\n依赖管理：自动处理软件依赖关系，避免手动下载和配置依赖包的麻烦。\r\n版本控制：轻松管理软件的不同版本，方便切换和回滚到特定版本。\r\n自动更新：通过命令行检查和更新已安装的软件，保持工具的最新状态。\r\n\r\n企业软件安装管理\r\n\r\n集中管理：通过脚本和配置文件，集中管理企业内部的所有软件安装和更新，简化\r\nIT 管理工作。\r\n一致性：确保所有员工使用相同版本的软件和工具，避免因版本不一致导致的问题。\r\n快速部署：快速部署开发环境和生产环境，减少新员工上手时间和环境配置时间。\r\n安全性：通过 Scoop\r\n的存储库管理，确保下载的软件来自可信来源，减少安全风险。\r\n成本节约：减少手动安装和维护软件的时间和成本，提高工作效率。\r\n\r\n开始安装 Scoop\r\n安装条件\r\n\r\nPowerShell 最新版本或者 Windows PowerShell 5.1\r\nPowershell 的执行策略为 RemoteSigned,\r\nUnrestricted or ByPass 之一\r\n\r\n安装步骤\r\n安装详细步骤如下：\r\n\r\n查看 Powershell 版本是否匹配\r\n打开 Powershell 后，会显示版本号，如下图所示：\r\n\r\n\r\nimage-20241128141201328\r\n\r\n一般 Win10 及以上的版本都满足要求。\r\n修改 Powershell 执行策略\r\n使用管理员身份打开 Powershell（可以通过 Win+X\r\n弹出菜单选择），然后输入下列命令：\r\nSet-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser\r\n开始安装\r\n使用 非管理员 打开\r\nPowershell，然后逐行输入下列命令进行安装（每输入一条命令，需要按 Enter\r\n执行）\r\n# 指定安装位置[可选], 不指定，默认安装在 ~/scoop 目录下[environment]::setEnvironmentVariable(&#x27;SCOOP&#x27;,&#x27;D:\\scoop&#x27;,&#x27;User&#x27;)# 安装软件irm https://app-installer.pages.dev/install | iex\r\n\r\n上面的安装脚本针对 app-installer\r\n进行定制，若需要安装官方原版，请直接从文末的参考中跳转\r\n\r\n\r\n至此，安装就完成了\r\nScoop 使用\r\n常用命令\r\n以下列出常用的操作命令\r\n\r\n\r\n\r\n命令\r\n概述\r\n使用示例\r\n\r\n\r\n\r\n\r\nsearch\r\n搜索软件\r\nscoop search wechat\r\n\r\n\r\ninstall\r\n安装软件\r\nscoop install wechat\r\n\r\n\r\nuninstall\r\n卸载软件\r\nscoop uninstall wechat\r\n\r\n\r\nlist\r\n查看已安装软件\r\nscoop list\r\n\r\n\r\nupdate\r\n更新软件\r\nscoop update wechat\r\n\r\n\r\ncleanup\r\n清除之前的版本\r\nsccop cleanup wechat\r\n\r\n\r\n\r\n完整命令\r\n可以使用 scoop -h 查看所有的命令及介绍\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nCommand\r\nSummary\r\n\r\n\r\n\r\n\r\nalias\r\nManage scoop aliases\r\n\r\n\r\nbucket\r\nManage Scoop buckets\r\n\r\n\r\ncache\r\nShow or clear the download cache\r\n\r\n\r\ncat\r\nShow content of specified manifest.\r\n\r\n\r\ncheckup\r\nCheck for potential problems\r\n\r\n\r\ncleanup\r\nCleanup apps by removing old versions\r\n\r\n\r\nconfig\r\nGet or set configuration values\r\n\r\n\r\ncreate\r\nCreate a custom app manifest\r\n\r\n\r\ndepends\r\nList dependencies for an app, in the order they'll be installed\r\n\r\n\r\ndownload\r\nDownload apps in the cache folder and verify hashes\r\n\r\n\r\nexport\r\nExports installed apps, buckets (and optionally configs) in JSON\r\nformat\r\n\r\n\r\nhelp\r\nShow help for a command\r\n\r\n\r\nhold\r\nHold an app to disable updates\r\n\r\n\r\nhome\r\nOpens the app homepage\r\n\r\n\r\nimport\r\nImports apps, buckets and configs from a Scoopfile in JSON\r\nformat\r\n\r\n\r\ninfo\r\nDisplay information about an app\r\n\r\n\r\ninstall\r\nInstall apps\r\n\r\n\r\nlist\r\nList installed apps\r\n\r\n\r\nprefix\r\nReturns the path to the specified app\r\n\r\n\r\nreset\r\nReset an app to resolve conflicts\r\n\r\n\r\nsearch\r\nSearch available apps\r\n\r\n\r\nshim\r\nManipulate Scoop shims\r\n\r\n\r\nstatus\r\nShow status and check for new app versions\r\n\r\n\r\nunhold\r\nUnhold an app to enable updates\r\n\r\n\r\nuninstall\r\nUninstall an app\r\n\r\n\r\nupdate\r\nUpdate apps, or Scoop itself\r\n\r\n\r\nvirustotal\r\nLook for app's hash or url on virustotal.com\r\n\r\n\r\nwhich\r\nLocate a shim/executable (similar to 'which' on Linux)\r\n\r\n\r\n\r\n若不知道每个命令如何使用，可以输入 scoop [command] -h\r\n来查看，例如 scoop alias -h, 会输出如下结果：\r\n⚡galens ❯❯ scoop alias -hUsage: scoop alias &lt;subcommand&gt; [options] [&lt;args&gt;]Available subcommands: add, rm, list.Aliases are custom Scoop subcommands that can be created to make common tasks easier.To add an alias:    scoop alias add &lt;name&gt; &lt;command&gt; [&lt;description&gt;]e.g.,    scoop alias add rm &#x27;scoop uninstall $args[0]&#x27; &#x27;Uninstall an app&#x27;    scoop alias add upgrade &#x27;scoop update *&#x27; &#x27;Update all apps, just like &quot;brew&quot; or &quot;apt&quot;&#x27;To remove an alias:    scoop alias rm &lt;name&gt;To list all aliases:    scoop alias list [-v|--verbose]Options:  -v, --verbose  Show alias description and table headers (works only for &quot;list&quot;)\r\n应用场景\r\n下面针对一些应用场景进行专题介绍，以满足不同的使用需求。\r\n搜索软件\r\n\r\n通过 scoop search xxx 搜索\r\n可以在命令行中，通过 scoop search xxx 来搜索，例如\r\nscoop search wechat\r\n\r\n\r\nimage-20241129124347513\r\n\r\n若搜索到结果后，可以直接使用 scoop install name\r\n进行安装\r\n在 scoop.sh 网站搜索\r\n该网站 由 gpailler\r\n创建，它包含了很多其它开源的仓库，搜索之后，即可根据命令进行安装\r\n\r\n\r\nimage-20241129124913119\r\n\r\n\r\n添加仓库\r\n可以通过 scoop bucket add 仓库名 仓库地址\r\n不添加，对于官方仓库，可以省略仓库地址。\r\n\r\n官方维护的仓库\r\n可以通过 scoop bucket known 获取官方仓库名称\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名称\r\n概述\r\n\r\n\r\n\r\n\r\nmain\r\n符合scoop收录标准的软件, 参考 Main\r\nCriteria\r\n\r\n\r\nextras\r\n不符合 scoop 收录标准的软件\r\n\r\n\r\nversions\r\n主仓库中软件的其它版本\r\n\r\n\r\nnirsoft\r\n由 NirSoft 收集的小工具安装合集\r\n\r\n\r\nsysinternals\r\nsysinternals\r\n网站上的系统工具\r\n\r\n\r\nphp\r\nphp 开发环境相关\r\n\r\n\r\nnerd-fonts\r\nnerd 字段\r\n\r\n\r\nnonportable\r\n\r\n\r\n\r\njava\r\njava 开发环境相关\r\n\r\n\r\ngames\r\n包含了大量免费/开源的小游戏\r\n\r\n\r\n\r\n社区提供的仓库\r\n可以跳转到 scoop-directory 查看\r\nby-xxx.md 文件，它们分别按 app、score、forks、start\r\n等进行排序。\r\n\r\n\r\nimage-20241129133038471\r\n\r\nGitee 或 Github 搜索获取仓库\r\n可以自行通过 Gitee 或者 Github 搜索 scoop bucket\r\n关键字进行搜索\r\n自建 Git 仓库\r\n若这些仓库都不满足使用要求，则可以进行自建仓库\r\n\r\n备份迁移\r\n当重装系统或更换电脑时，可以使用下列方式进行重新安装\r\n\r\n重装系统时\r\n若安装在非系统盘，可以使用 scoop reset *\r\n重置所有的软件即可\r\n更换新电脑\r\n使用 scoop install name1 name2 ... nameN\r\n批量安装\r\n\r\n仓库定制\r\n仓库定制参考 App\r\nManifests · ScoopInstaller/Scoop Wiki\r\nScoop 可视化\r\n目前暂未发现比较好用的 Scoop 可视化软件，可以尝试使用 UniGetUI\r\n视频介绍\r\n未完待续...\r\n致谢\r\n本文参考以下文章，在此致以诚挚谢意！\r\n\r\nScoopInstaller/Scoop\r\nscoop-directory\r\n给 Scoop\r\n加上这些软件仓库，让它变成强大的 Windows 软件管理器\r\n\r\n","categories":["Apps"],"tags":["Apps"]},{"title":"怀孕第一个月饮食推荐","url":"/posts/2022/C1JWDT.html","content":"第一个月的孕妇一般感觉比较轻松，没有什么特别的不适，但是这个时期对胎儿的发育来说非常重要，所以准妈妈的营养摄入也不能放松。\r\n这个月孕妇营养食谱要富含叶酸、蛋白质、维生素和矿物质，饮食以清淡可口的食物为佳。\r\n\r\n所需营养\r\n第一个月孕期所需营养及建议的食物如下：\r\n蛋白质\r\n有些准妈妈在月末早晨会有恶心的症状，可以早晨先摄入一些蛋白质，例如\r\n温牛奶加苏打饼干，以缓解症状。供给量需摄入\r\n60-80克/天，主要来源于鱼类、乳类、豆制品、肉类、蛋类等。\r\n碳水化合物\r\n蔗糖、葡萄糖、果糖、乳糖等简单碳水化合物能迅速被消化道吸收，提供“应急能量”。碳水化合物的需摄入\r\n150克/天，食物主要来源于蔗糖、粮食作物。\r\n叶酸\r\n需摄入\r\n400微克/天，食物主要来源于蔬菜如青菜、卷心菜、柑橘、香蕉、牛肉、动物肝等。\r\n除了生吃新鲜的水果，还可以用水果自制一些小吃。\r\n维生素C\r\n需摄入\r\n130毫克/天，食物主要来源于柑橘、草莓、猕猴桃、番茄、彩椒、豆芽等。\r\n维生素C\r\n容易被破坏，所以蔬菜水果应即买即吃。洗果蔬时速度要快，先洗后切，可以减少营养流失。\r\n铁\r\n需摄入\r\n25毫克/天，食物主要来源于动物肝脏和血、瘦肉、红糖、坚果、蛋、豆类、桃、梨。\r\n\r\n注意\r\n植物中的植酸、草酸、膳食纤维、茶与咖啡、牛奶中的蛋白质会抑制铁质的吸收，尽量分开食用。\r\n\r\n饮食基本原则\r\n\r\n易消化、少油腻、味清淡\r\n补充维生素\r\n孕 1 月胎儿脑部和神经系统迅速分化，补充维生素有利。\r\n保证营养均衡\r\n补充热量、蛋白质和脂肪酸\r\n蛋白质是构成有机体的重要元素，脂肪酸有助于胎儿脑部发育\r\n少吃多餐\r\n有助于孕妇吸收营养\r\n\r\n饮食要点\r\n孕 1月，吃得多不如吃的好。每天仅需补充 500千焦热量，相当食用\r\n100克坚果。只要保证吃的食物有各种营养，饮食可以根据自己的食欲而定。\r\n吃什么\r\n饮食的原则是易消化、少油腻、味清淡。\r\n多吃富含蛋白质、维生素和矿物质的食物，适当吃点香蕉、动物内脏、坚果等。\r\n不吃什么\r\n不宜吃芦荟、螃蟹、甲鱼、薏米、马齿苋，开始向烟、酒、咖啡说不。\r\n营养补充\r\n第 17 至 30\r\n天是胎儿神经管发育的关键时期，补叶酸可降低胎儿脊柱裂或者其他神经管缺陷的危险。从计划怀孕到怀孕头三个月，每天补充\r\n400微克的叶酸。绿叶叶酸含量最高，其次为肝、豆类、花生。\r\n适合孕 1 月的食物\r\n\r\n\r\n\r\n各类\r\n名称\r\n\r\n\r\n\r\n\r\n新鲜蔬菜\r\n生菜、油菜、小白菜。这些蔬菜富含丰富的叶酸\r\n\r\n\r\n水果\r\n水果中的维生素有助于细胞的合成\r\n\r\n\r\n海鱼\r\n含钙、碘、铁等有助于胎儿大脑发育的物质\r\n\r\n\r\n核桃\r\n可补脑益智、有助于胎儿脑部发育\r\n\r\n\r\n多喝水\r\n1000~1500 ml，可用水果代替\r\n\r\n\r\n\r\n食谱推荐\r\n基于以下原则制定食谱：\r\n\r\n富含蛋白质、维生素和无机盐\r\n少吃荤腻食品或大补之物\r\n包含以清淡可口的食物为佳\r\n\r\n早餐\r\n\r\n\r\n\r\n方案\r\n主食\r\n辅食\r\n\r\n\r\n\r\n\r\n1\r\n二米枣粥（二米指大米+小米）\r\n葡萄 100g\r\n\r\n\r\n\r\n中餐\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n方案\r\n主食\r\n辅食\r\n\r\n\r\n\r\n\r\n1\r\n米饭 2 小碗或挂面一碗\r\n炒菜（小白菜150g、胡萝卜50g、青椒50g）,煎焖刀鱼，牛奶鲫鱼汤 2\r\n小碗，苹果一个\r\n\r\n\r\n\r\n晚餐\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n方案\r\n主食\r\n辅食\r\n\r\n\r\n\r\n\r\n1\r\n米饭 2 小碗\r\n鸡蛋小菜汤 2 碗，香蕉 2 个，清炖牛腩（牛肉约150 g，土豆、胡罗卜各\r\n100g，炒青菜（菜心人200 g））\r\n\r\n\r\n\r\n水果\r\n饭前1小时和饭后2个小时左右食用\r\n\r\n葡萄\r\n苹果\r\n香蕉\r\n西柚\r\n柑橘\r\n火龙果\r\n猕猴桃\r\n\r\n参考\r\n\r\n育儿百科\r\nhttps://m.maigoo.com/goomai/182190.html\r\n这9种水果怀孕后应该多吃\r\nDHA对宝宝到底有多重要？\r\n\r\n","categories":["ChildCare"],"tags":["育儿"]},{"title":"新的生命开始绽放","url":"/posts/2022/19JPMSG.html","content":"今日早晨，老婆发现一个小家伙已经悄悄出现在了我们的生命里。\r\n\r\n\r\n\r\nimage-20220326091350522\r\n\r\n得知这个消息，心里有些惊喜，又有些担心，担心测的结果有误。所以，虽然有开心，但是保持了理智，需再过几天完全确定后，心里才能真正踏实下来。\r\n经过这个事情，我知道，必需要提前准备育儿相关的知识了。所以今日起，开一个主题育儿篇，用于分享育儿知识，记录小家伙的成长。\r\n","categories":["ChildCare"],"tags":["育儿"]},{"title":"一文带你全面了解蚕豆病","url":"/posts/2023/2BNMYWB.html","content":"\r\n什么是蚕豆病\r\n蚕豆病是一种遗传性疾病，它的学名为红细胞葡萄糖-6-磷酸脱氢酶(Glucose-6-phosphate\r\ndehydrogenase，简称 G-6-PD)缺乏症。由于体内缺乏\r\nG-6-PD，在孩子食用蚕豆等诱病源后，引发红细胞破裂，血红蛋白经过尿液被排出体外，导致重度贫血，尿出酱油尿，精神不济，如果不及时治疗，可致昏迷、惊厥和急性肾衰竭，孩子甚至有生命危险，所以发病后应及时就医诊治。\r\n\r\n遗传机理\r\n蚕豆病是一种X连锁隐性遗传（X-linked recessive\r\ninheritance）疾病。若父母双方都是正常的，则其遗传图如下：\r\n\r\n由上面的遗传图可以得知，若父母双方都是正常的，但母亲为基因携带者，则所生子女中有\r\n25% 概率会患病，如果生女孩，都是健康的，但有 50%\r\n的机率是致病基因携带者；如果生男孩，则有 50% 机率患病。\r\n病理介绍\r\n磷酸戊糖途径是部分细胞（如红细胞）赖以产生能量的代谢途径，以及维持\r\nNADPH 的水平，而 G6PD 酶则属于该代谢途径的一员。NADPH\r\n的含量，亦直接影响谷胱甘肽于细胞中的含量，而谷胱甘肽亦能保护红细胞免受氧化反应的破坏。G6PD\r\n酶对磷酸盐戊糖代谢途径有速度限制作用，以及能转化葡萄糖-6-磷酸为6-磷酸葡萄糖酸-δ-内酯。\r\n当 G6PD 患者的 氧化反应转趋剧烈\r\n便有可能出现溶血性贫血现象；这种情况可能会由严重感染、药物治疗及部分食物引起。蚕豆含有大量蚕豆嘧啶葡糖苷、蚕豆嘧啶、伴蚕豆嘧啶核苷及异脲咪─这些全都是\r\n氧化剂。\r\n在剧烈的氧化反应下，谷胱甘肽会被耗尽，接着酵素及各种蛋白质（如血红蛋白）亦会被氧化物破坏，导致体内电解质失衡、细胞膜cross-bonding、巨噬作用及脾脏隔离红细胞等现象。血红蛋白会被代谢为胆红素，于高浓度时会引致黄疸，或直接经肾脏排出，于严重情况下可导致肾衰竭。\r\n发病症状\r\n蚕豆病起病急剧，大多在进食新鲜蚕豆后 1～2 天内发生溶血，最短者只有 2\r\n小时，最长者可相隔 9 天。\r\n潜伏期的长短与症状的轻重无关。蚕豆病的贫血程度和症状大多很严重。症状有：\r\n\r\n脸色苍白，疲倦乏力，食欲变差，身体状况普遍恶化\r\n体温突然升高，皮肤和粘膜变黄\r\n呼吸沉重，呼吸急促，心律过快\r\n巩膜轻度黄染（眼角处的眼球发黄）\r\n尿色如浓红茶或甚至如酱油\r\n严重时，呼吸窘迫或是意识不清、休克\r\n\r\n根据发病程度，症状如下：\r\n\r\n初期症状\r\n起病急，1-2天内出现急性血管内溶血，来势凶猛，表现为全身不适、脸色苍白、微热、头昏、倦怠无力、厌食、腹痛、恶心、尿色加深等。\r\n后续症状\r\n出现黄疸、贫血、血红蛋白尿、尿呈酱油色、此后体温升高、倦怠乏力加重。可持续3日左右。\r\n并发症\r\n出现呕吐、腹泻和腹痛加剧、肝脏肿大、肝功能异常，约50%患者脾大。严重时可能导致昏迷、休克、全身衰竭，若急救不及时，会出现生命危险。\r\n\r\n本节参考：\r\nWhat Is G6PD\r\nDeficiency-g6pd.org\r\n蚕豆病\r\n(rah.com.tw)\r\n诱病因素\r\n一切能加剧红细胞氧化反应的物品都可以诱发蚕豆病，在日常生活、学习、工作中应避免接触氧化物，常见的物品如下：\r\n食物\r\n\r\n蚕豆、蚕豆花粉或蚕豆制品\r\n\r\n蚕豆制品主要是【豆瓣酱】\r\n在外出就餐时需要特别注意，因为一些餐馆（尤其是川菜馆）喜欢用干的蚕豆熬汤底（例如担担面的汤），以及用豆瓣酱烹饪菜肴，豆瓣酱在广东一带主要用黄豆作为主要材料，但在四川等地则是用蚕豆作为原料。\r\n薄荷叶是西餐常用的材料，孩子忌食。\r\n苦瓜\r\n铁苋菜\r\n\r\n红酒、蓝莓、菠萝、大豆慎用\r\n\r\n日常用品\r\n\r\n樟脑\r\n萘丸 (人工合成的樟脑丸)\r\n龙胆紫 (紫药水)\r\n蓝色 的人工食用色素和染料\r\n黑色指甲花染料（木蓝）、埃及红指甲花和其他相关染料纹身、染发等。\r\n薄荷牙膏\r\n\r\n西药\r\n\r\n加粗字体为 禁用 药，其它为慎用，原则上不用\r\n\r\n“蚕豆病”是一种急性溶血性疾病，不宜服用氧化性药物，需严格掌握用药禁忌，在医生指导下用药。\r\n\r\n维生素类\r\n维生素 K3、K4\r\n维生素 C、K1\r\n大剂量的维生素 C 应避免服用，否则会产生溶血反应。\r\n解热镇痛类\r\n乙酰苯胺、乙酰苯肼\r\n对乙酰氨基酚、安乃近、扑热息痛(泰诺、百服宁、小儿退热栓)、阿司匹灵、非那酊、氨基比林、安替匹林、保泰松、安他唑啉等。\r\n磺胺类抗生素\r\n磺胺甲恶唑，磺胺二甲嘧啶，磺胺吡啶，柳氮磺胺吡啶\r\n磺胺嘧啶，磺胺甲嘧啶\r\n砜类：噻唑砜、氨苯砜\r\n抗疟药类\r\n伯氨喹，氯喹，扑疟喹，戊胺喹，阿的平\r\n奎宁， 乙胺嘧啶\r\n外用药物\r\n跌打酒（含牛黄）、白花油、万金油、红花油（含有水杨酸）\r\n其他含硫磺的药品\r\n血糖平\r\n呋喃妥因：治疗尿道感染的抗生素\r\n其它忌服药物\r\n呋喃坦啶，呋喃唑酮，呋喃西林，呋喃妥英，黄连素，\r\n硝咪唑，硝酸异山梨醇， 二巯基丙醇，亚甲蓝，三 氢化砷，维生素\r\nK3、K4\r\n氯霉素，链霉素，异烟肼， 环丙沙星，氧氟沙星，\r\n左氧氟沙星，诺氟沙星，萘啶酸，布林佐胺， 多佐胺，甲氧苄氨嘧\r\n啶，普鲁卡因酰胺，奎尼丁，格列本脲，苯海\r\n拉明，扑尔敏，秋水仙碱，左旋多巴，苯妥英\r\n钠，苯海索，丙磺舒，对氨基苯甲酸，维生素 C，维生素 K1\r\n\r\n完整的西药禁用清单：\r\nUnsafe\r\nto Take (g6pd.org)\r\n中药\r\n\r\n加粗字体为 禁用 药，其它为慎用，原则上不用\r\n\r\n\r\n黄连、川莲 (四川产黄莲)\r\n金银花\r\n茵桅黄 (含金银花提取物)\r\n腊梅花\r\n牛黄\r\n珍珠粉\r\n保婴丹\r\n薄荷\r\n口香糖、冰淇淋、牙膏、外用贴布、漱口水等可能含有薄荷的食品或卫生用品都应该避免\r\n生地\r\n丹皮\r\n冰片\r\n大黄\r\n熊胆\r\n虎杖\r\n番泻叶\r\n八宝粉\r\n\r\n疾病\r\n病毒性肝炎、流感、肺炎、伤寒、腮腺炎也可能会诱发蚕豆病。\r\n哺乳期注意\r\n哺乳期妈妈吃了上述食品或药器后，也容易诱发宝宝的蚕豆病。\r\n治疗\r\n蚕豆病属于遗传疾病，无法被根治，会随着年龄的长大，抗性会逐渐增强。在日常生活中，主要以预防为主，不接触和信用强氧化性的物品。若诱发了蚕豆病，应及时就医治疗。\r\n蚕豆病的治疗有以下方式：\r\n\r\n去除诱发因素：停食蚕豆及其制品，严重者可人工催吐、洗胃及导泻；\r\n对症处理：输液补充血容量等；\r\n输血：贫血较轻者不需要输血，去除发病诱因后可自行恢复，贫血较重时，可输正常的红细胞\r\n1～2 次；\r\n激素治疗：激素对阻止疾病的发展无特殊疗效，但对危重病例，如高热、剧烈头痛、昏迷和休克出现时，可使用地塞米松或氢化可的松缓解症状，但不能以此代替输血、补液等治疗措施。\r\n肾衰竭者行血液透析等治疗。\r\n\r\n参考\r\n\r\n中华人民共和国药典临床用药须知-2020年版\r\nWhat Is G6PD\r\nDeficiency (g6pd.org)\r\nUnsafe\r\nto Take (g6pd.org)\r\nG6PD缺乏症-广西壮族自治区人民医院\r\nGlucose6_Phosphate_Dehydrogenase_Deficiency_chi.pdf-香港医院管理局\r\nG6PD缺乏症宣传单及携带卡-绵阳市儿童医院\r\n(mysfybjy.com)\r\n葡萄糖-６-磷酸脱氢酶缺乏症新生儿筛查、\r\n诊断和治疗专家共识\r\n红细胞葡萄糖-6-磷酸脱氢酶缺陷症\r\n- 中华儿科杂志 (cmaped.org.cn)\r\nG6PD\r\nDeficiency: Symptoms, Triggers &amp; Treatment\r\n(clevelandclinic.org)\r\n蠶豆症\r\n(rah.com.tw)\r\n葡萄糖-6-磷酸脱氢酶缺乏症\r\n- 维基百科\r\n“蚕豆病”患儿生活中要注意哪些方面？\r\n葡萄糖-6-磷酸脱氢酶缺乏症-wiki\r\n葡萄糖-6-磷酸脱氢酶缺乏症的发病机制及诊疗现状\r\n蠶豆症不能吃什麼？蠶豆症發作症狀、禁忌食物藥物列表\r\n8岁前吃蚕豆容易诱发蚕豆病？这样养护才安全\r\n蚕豆病者禁用的常见药物，看了这篇，你就明白！-MedSci.cn\r\nhttps://www.kch.nhs.uk/wp-content/uploads/2023/01/pl-296.2-glucose-6-phosphate-dehydrogenase-deficiency-favism-or-g6pd-deficiency.pdf\r\nMedications\r\nto Avoid in Patients with G6PD Deficiency Due to Risk of Hemolysis\r\n(ebmconsult.com)\r\n\r\n","categories":["ChildCare"],"tags":["育儿"]},{"title":"一步步在 github pages 上用 jekyll 搭建属于自己的博客","url":"/posts/2019/3PCKARV.html","content":"\r\n\r\nimage-20191123112911663.jpg\r\n\r\n序\r\n我的专业与互联网没有太大关系，接触博客还是工作以后的事情。随着工作的经验增加，总想将自己的所思所得记录下来，毕竟，好记性不如烂笔头。\r\n\r\n开始是将自己的总结在本地保存，但是本地有一个劣势，就是不能随时随地的查看，最重要的是，不能随时随地的装X，所以，最后转到了简书，转到简书，是17年的时候，那个时候，简书的质量还是有保证，但是，随着简书的发展，广告越来越多，文章质量越来越差，而且首页推送的文章太多关于性的东西，重要是，慢慢地也出现了好多标题党，让人烦不胜烦。\r\n无奈之下，只有尝试去寻找新的平台...\r\n此时，盯了很多家，比如，csdn,\r\n知乎，少数派等。除了博客园，知乎让我比较满意外，其它都有广告，当然，知乎和博客园也有，不过，知乎的质量在那儿，所以，广告也就不那么在意了，而博客园，是可以自定义界面风格的，可以查看我的博客园主页李有福呀，广告什么的都可以去掉，所以影响不大。但是知乎是问答型社区，与自己这无病呻吟小年轻的风格又有点不搭，在上面写一篇文章，确实是要一定的专业深度的，当然，灌水这种事情，我不愿意去做。而博客园虽然有一定的自由度，但是总想有一方完完全全属于自己的一方空间。\r\n最后，结论就是各个平台都不满意。\r\n那就自己搭建一个博客平台吧...\r\n博客选择\r\n搭建个人博客，有很多种方案。\r\n因最近经济压力大，所以，本着能省几毛是几毛的理念，便选择了平台免费，功能强大，上手简单的组合：github\r\npages +jekyll 来搭建自己的博客 李有福呀。\r\n\r\n\r\nimage-20191123112746605.png\r\n\r\n为什么选择这个组合呢？\r\n\r\n服务器选择\r\n收费的云服务器什么的就不考虑了，那么免费且还能搭建博客的，主要的选择就是\r\ngithub pages 和 gittee pages。\r\n前者的服务器在国外，因为墙的原因，速度较慢，但是上面的资源多，为微软家的东西，质量有保证，生态齐全，且自带了\r\njekyll 编译器，这个是很重要的一点，如果用 jekyll\r\n作为博客平台，那么只需要上传源文件，本地不需要进行编译，这样本地就不需要安装复杂的环境了。\r\n后者的服务器在中国，响应速度快，每次上传文件之后，需要在仓库中的\r\npages 界面进行进行手动更新生成静态页面，比较麻烦。\r\n如果推荐的话，个从建议用 gitee,\r\n虽然每次要手动，但是的服务器在国内，速度快，而且它支持三种方式的在线编译，虽然每次推送修改后要手动操作一下，但是与它的优点相比，这就不算什么缺点了。\r\n顺便也介绍下 gitee 的自动编译依据：\r\n\r\n编译 Hugo\r\n依据：仓库编译目录下存在config.toml|json|yaml文件和content目录的时候，会使用hugo生成静态文件。\r\n编译 Hexo\r\n依据：仓库编译目录下存在package.json，_config.yml文件和scaffolds目录的，会使用hexo generate生成静态文件，由于每次部署编译需要重新克隆编译并进行npm install，所以使用\r\nHexo 的时间相对 Hugo 和 Jekyll 会长一些。\r\n当不符合上述1和2条件的时候，就默认使用Jekyll编译\r\n\r\n语言选择 构建 pages 有三种方式，分别是 jekyll ， hexo 和 Hugo\r\n，因为本人选择了 github ，而它只支持 jekyll 自动编译，所以，便选择了\r\njekyll。\r\n\r\n开始部署\r\n\r\n建立自己的 github 账户，请自行百度或者点击下面的链接。\r\n\r\n创建我的GitHub账号及使用\r\n\r\nFork 本主题的仓库\r\n\r\n\r\n进入galensgan.github.io\r\n点击右上角的Fork按钮，见下图\r\n\r\n\r\n\r\nhowtoforkrepo.PNG\r\n\r\n\r\n进入自己的克隆的仓库,然后点击 Settings,\r\n也可以直接输入这个地址：https://github.com/你的用户名/galensgan.github.io/settings\r\n将仓库名称改为：你的用户名.github.io 形式,点击\r\nRename 重命名\r\n\r\n\r\n自己的博客网站就初步建立了，你可以在浏览器中输入自己的网址访问：你的用户名.github.io\r\n开始定制博客内容\r\n\r\n\r\n下载并安装git 传送门-Git安装\r\n进入到自己的仓库：点击 Clone or download,\r\n然后复制框中显示的URL\r\n\r\n\r\n\r\nTIM截图20191123125227.png\r\n\r\n\r\n在你想将代码放置的目录处，右键 &gt;&gt; Git Bash Here\r\n\r\n\r\n\r\nTIM截图20191123125621.png\r\n\r\n\r\n在弹出的黑窗体中输入：git clone 你复制的url &gt;&gt;\r\n回车，开始克隆代码\r\n\r\n\r\n\r\nTIM截图20191123125857.png\r\n\r\n\r\n克隆完成以后，进入目录修改相关内容，变成自己的信息，下面列出经常用到或者是需要修改的目录：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n目录名称\r\n作用\r\n\r\n\r\n\r\n\r\n_drafts\r\n草稿，如果未完成的文章，可以放在里面，在里面的文章不会显示在博客上\r\n\r\n\r\n_post\r\n发表的文章放在这里\r\n\r\n\r\nabout\r\n关于中的内容写在这里\r\n\r\n\r\n_config.yml\r\n此为网站的配置文件，所有的界面的信息和功能，都里面进行设置\r\n\r\n\r\n...\r\n...\r\n\r\n\r\n修改 _config.yml 为你自己的博客内容，同时，在post放入自己的 markdown\r\n格式的文章\r\n\r\n\r\n\r\n\r\n对文章格式的要求：\r\n\r\n标题名称：年-月-日-唯一识别号,比如 2019-11-23-template\r\n正文内容：每个头部要有如下格式\r\n\r\n\r\ntitle: this is a templatetags:   - template  - blog\r\n同时注意，每一个冒号后面需有一个空格\r\n\r\n推送到github完成更新\r\n\r\n你进入你的本地仓库目录里面（与.git目录同级），右键 &gt;&gt; 右键\r\n&gt;&gt; Git Bash Here &gt;&gt;\r\n在弹出的黑窗体中依次输入下面的内容，每输入一行，按一次回车\r\ngit add . git commit -m &quot;这里是你提交的内容的描述，比如：初始化自己的博客&quot;git push\r\n到此，属于自己的博客就完成了，再次在网页中打开你的用户名.github.io,\r\n看看效果吧~\r\n致谢\r\n\r\nsimpleyyt.github.io\r\n\r\n","categories":["Blog"],"tags":["个人博客","jekyll","Hexo","李有福呀"]},{"title":"了解孩子生长规律，呵护宝宝健康成长","url":"/posts/2023/3VB08HW.html","content":"\r\n\r\nimage-20230727230001381\r\n\r\n当孩子出生以后，我们就要开始时刻关注孩子的生长情况，了解孩子在成长过程中不同阶段的发育特点，我们通过观察、分析相关的参考值，\r\n了解孩子身心发展的现状是否在正常范围内，为孩子的茁壮健康成长保驾护航。\r\n\r\n前言\r\n孩子的生长标准主要有：\r\n\r\n身长/身高\r\n体重\r\n头围\r\n体重指数\r\n\r\n标准值\r\n标准值可以参考卫健委发布的标准进行查阅，此处只截取了部分：\r\n\r\n\r\n\r\n\r\n\r\nimage-20230727084610493\r\n\r\n更多相关的标准值可以打开下列链接查看：\r\n\r\n7\r\n岁以下儿童生长标准 - 中华人民共和国国家卫生健康委员会\r\n(nhc.gov.cn)\r\n7\r\n岁～18 岁儿童青少年身高发育等级评价 - 中华人民共和国国家卫生健康委员会\r\n(nhc.gov.cn)\r\n\r\n评价方法\r\n7\r\n岁以下儿童生长水平的标准差评价方法\r\n\r\n\r\nimage-20230725132955904\r\n\r\n查 7\r\n岁以下儿童生长标准 - 中华人民共和国国家卫生健康委员会 (nhc.gov.cn)\r\n第 27 页表。\r\n7\r\n岁以下儿童营养状况的标准差评价方法\r\n\r\n\r\nimage-20230725133544445\r\n\r\n查 7\r\n岁以下儿童生长标准 - 中华人民共和国国家卫生健康委员会 (nhc.gov.cn)\r\n第 25 页表。\r\n7~18岁儿童青少年身高发育等级\r\n\r\n\r\nimage-20230726131322027\r\n\r\n生长曲线图\r\n\r\n\r\n\r\n\r\n生长特点\r\n从上面和生长曲线图我们可以看出：\r\n\r\n0-6 月宝宝身高增长速度很快\r\n青春期：男孩 10-16 岁、女孩 10-14 岁身高开始快速增高\r\n其它阶段，孩子的身高成线性比例增加\r\n\r\n综上分析：在孩子未成年时，都应保证他们摄入充足的营养、养成运动的良好习惯，使其健康地成长。特别是在\r\n6\r\n个月以内和青春期之间，更要格外关注孩子们的成长，保证良好的生成发育环境。\r\n如何让孩子长得高\r\n想要长高，关键在于“生长板”。医生常说“生长板”是身高的关键。究竟什么是增长板？生长板位于全身骨骼的上下两端。在脑垂体分泌的生长激素的刺激下，它们会不断增生软骨组织，新生的软骨经过钙化后会变成硬骨，从而骨骼变得更长更宽，这也是孩子能够长高的原因。当生长板闭合的时候，然而，当生长板到了一定的年龄，它就会闭合，骨骼不再生长，于是就决定了一个人的身高。生长板闭合后，即使用任何生长激素或增强剂刺激，也达不到增高的效果。\r\n\r\n除了先天身高的遗传限制，如果孩子在青春期前出现第二性征，也就是所谓的性早熟，会使生长板过早闭合，影响生长。\r\n如果不想让孩子的青春期过早开始，需要注意以下四点：\r\n\r\n少吃精致的食物和快餐\r\n一定要避免油炸食品、精致甜食、快餐，这些都有可能抑制生长激素的分泌，降低身高的增长。\r\n防止儿童肥胖\r\n超重的孩子容易性早熟，因为脂肪细胞会转化成性激素，影响发育。\r\n避免接触环境荷尔蒙\r\n生活中过多接触环境激素，如塑化剂、表面活性剂、油漆或清漆，也会催化孩子早熟。孩子容易接触到的塑化剂大多来自饮食，比如塑料碗、塑料袋装的热食，或者塑料杯装的饮料。最好用不锈钢或玻璃容器代替。\r\n\r\n长高秘诀：\r\n\r\n保证充足的营养\r\n除了均衡饮食外，还要保证摄入足够的钙和蛋白质。\r\n保证充足的睡眠\r\n晚上10点到凌晨2点是生长激素高峰期，晚睡会减缓孩子的生长发育。最好要求每天晚上9点前入睡，尽量不要熬夜\r\n\r\n参考\r\n\r\n7\r\n岁以下儿童生长标 - 中华人民共和国国家卫生健康委员会\r\n(nhc.gov.cn)\r\n7\r\n岁～18 岁儿童青少年身高发育等级评价 - 中华人民共和国国家卫生健康委员会\r\n(nhc.gov.cn)\r\n中国幼儿生长曲线图计算器:\r\n身长年龄 0-3 岁 (infantchart.com)\r\n儿童早期发展 |\r\n联合国儿童基金会 (unicef.org)\r\n0～6岁儿童发展的里程碑.pdf\r\n(unicef.cn)\r\nchild-growth-standards\r\n新华专家教你看懂《儿童正常生长曲线表》（0-18岁）\r\n怎么知道身高增长是否正常-首都儿科研究所\r\n想长高？生长板闭合前别做3件事！让孩子身高多长\r\n10 公分\r\n\r\n","categories":["ChildCare"],"tags":["育儿"]},{"title":"博客 CDN 加速和增加 Live2d","url":"/posts/2019/2YZ5NBS.html","content":"\r\n\r\nTIM截图20191124131312.png\r\n\r\n序\r\n辛辛苦苦终于将自己的博客建设起来了，但是因为挂载在 github page\r\n的原因，导致国内访问速度有点慢得让人不能接受，偶然间在一个大神的文章 基于Jekyll搭建个人博客\r\n里面获得了一个方法，可以对 js , css 进行 cdn\r\n加速，同时，也在她的博客里看到了 Live2d\r\n有意思的扩展，于是在原来的基础上进行了修改。\r\n\r\nCDN 加速\r\nCDN 我用的是 Jsdelivr\r\nJsdelivr 网站是一个致力于为开发者提供数千种 Javascript、CSS 等超过\r\n1650 多种 Libraries 加速的免费 CDN\r\n服务，该平台是首个「打通中国大陆与海外的免费 CDN\r\n服务」，网页开发者无须担心中国防火墙问题而影响使用。\r\n打开博客的配置文件 _config.yml , 找到配置标签的\r\nvendors，里面所有值都可以替换成 cdn 服务器上的地址。\r\nvendors:  # Internal path prefix. Please do not edit it.  _internal: assets/lib  # Internal version: 2.1.3  jquery: https://cdn.jsdelivr.net/npm/jquery@2.1.3/dist/jquery.min.js  # Internal version: 2.1.5  # See: http://fancyapps.com/fancybox/  fancybox: https://cdn.jsdelivr.net/npm/fancybox@2.1.5/dist/fancybox.jquery.cjs.min.js  fancybox_css: https://cdn.jsdelivr.net/npm/fancybox@2.1.5/dist/css/jquery.fancybox.css  # Internal version: 1.0.6  # See: https://github.com/ftlabs/fastclick  fastclick: https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js  # Internal version: 1.9.7  # See: https://github.com/tuupola/jquery_lazyload  lazyload: https://cdn.jsdelivr.net/npm/jquery-lazyload@1.9.7/jquery.lazyload.min.js  # Internal version: 1.2.1  # See: http://VelocityJS.org  velocity: https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js  # Internal version: 1.2.1  # See: http://VelocityJS.org  velocity_ui: https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.js  # Internal version: 0.7.9  # See: https://faisalman.github.io/ua-parser-js/  ua_parser: https://cdn.jsdelivr.net/npm/ua-parser-js@0.7.9/src/ua-parser.min.js  # Internal version: 4.6.2 -real 4.7.0  # See: http://fontawesome.io/  fontawesome: https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css  # Internal version: 1  # https://www.algolia.com  algolia_instant_js: https://cdn.jsdelivr.net/npm/instantsearch.js@4.0.0/dist/instantsearch.production.min.js  algolia_instant_css:  # Internal version: 1.0.2  # See: https://github.com/HubSpot/pace  # Or use direct links below:  # pace: //cdn.bootcss.com/pace/1.0.2/pace.min.js  # pace_css: //cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css  pace:  pace_css:  # Internal version: 1.0.0  # https://github.com/hustcc/canvas-nest.js  canvas_nest: https://cdn.jsdelivr.net/npm/canvas-nest.js@1.0.0/canvas-nest.min.js  # three  three:  # three_waves  # https://github.com/jjandxa/three_waves  three_waves:  # three_waves  # https://github.com/jjandxa/canvas_lines  canvas_lines:  # three_waves  # https://github.com/jjandxa/canvas_sphere  canvas_sphere:  # Internal version: 1.0.0  # https://github.com/zproo/canvas-ribbon  canvas_ribbon:  # Internal version: 3.3.0  # https://github.com/ethantw/Han  han:\r\n\r\n引用 CDN 上存在的 jquery 库和 css\r\n打开 Jsdelivr 官网，在搜索中搜索相应库的，如果存在，则直接引用。\r\n\r\n\r\nTIM截图20191124133634.png\r\n\r\n对于 github 上的文件加速\r\n比如自己的网站图标，个人头像，一些 js 库是直接存储在 github\r\n的仓库里面的，则可以用下面的方式进行加速。\r\nhttps://cdn.jsdelivr.net/gh/用户名/仓库名/文件路径\r\n例如，在配置文件中，可以看到我对个人的头像进行了加速\r\n# Sidebar Avatar# in directory: /assets/images/avatar.gifavatar: https://cdn.jsdelivr.net/gh/galensgan/galensgan.github.io/assets/images/info/author.jpg\r\n经过上面的操作之后，博客访问速度可以达到正常的使用水平。如果是采用的我的博客模板，则不需要再进行加速配置，都已经配置好了。\r\n\r\n增加Live2D\r\n配置 Live2d 的方法来自于 传送门:stevenjoezhang\r\n本博客默认开启，如果要关闭，请在配置文件 _config.yml 中将下面的\r\nenable 改成 false 即可。\r\n#增加看板娘#live2d:    enable: true    live2d_widget: https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget/autoload.js\r\n致谢\r\n\r\n本博客模板来自 simpleyyt.github.io\r\nCDN 加速的灵感来自 今、情热が岚になって\r\nstevenjoezhang 大大的 Live2d-widget\r\n\r\n","categories":["Blog"],"tags":["jekyll","个人博客搭建","CDN 加速"]},{"title":"博客搭建历程","url":"/posts/2019/24BB768.html","content":"本文记录本人搭建博客的历程，虽不精彩，但于我来说是一份难得的回忆，值此保留。\r\n\r\n2019/08/18 博客建立\r\n初时接触博客，对 html, js\r\n一窍不通，好在有一点编程基础，结合网上的教程，历经千山万水，饱受风吹日晒之困难，最终，浑浑噩噩地将博客建立起来了。\r\n2019/11/23 博客更换主题：NEXT\r\n✅ 2019/11/24 增加 Live2d 功能\r\n✅ 2019/11/25 增加对 reveal.js\r\n的支持，可以推送slides到博客，实现在线预览\r\n✅ 2019/11/26 增加对 mermaid 的支持，官方的 mermaid 不支持 markdown\r\n中的 mermaid\r\n✅ 2020/10/04 增加文章主题\r\n2021/08/13 博客从 jekyll\r\n引擎换成 hexo 引擎\r\n用了这么久的 jekyll，为什么突然就换了呢？\r\n其实换之前我也挣扎很久，因为我不舍得 github 对 jekyll\r\n友好的支持，使用 jekyll，我增加或者修改完文章，直接推送就可以了，github\r\n会自动进行编译。\r\n今天微风正好，我想给自己的主题美化一下，既然要美化，当然要安装环境咯，开始下载\r\njekyll 的 windows 版本安装，安装完成后，运行不起来，google\r\n无果后，又尝试用 docker 安装 jekyll\r\n环境，安装完成后，还是跑不起来...\r\n一怒之下，我决定换成 hexo 了，起码它环境好安装，插件多，NexT\r\n主题也一直在维护。\r\n初次使用\r\nHexo,又成功了趟了满地的坑，填啊填，终于填完了，于是才有了这段总结。\r\n...... 纵有千言万语，亦道不尽万般辛酸！\r\n\r\n原引擎的主题放在当前仓库的 jekyll\r\n分支中，有需要的可以自行食用。\r\n\r\n","categories":["Blog"],"tags":["Blog","Hexo","NexT"]},{"title":"给博客增加revealjs功能","url":"/posts/2019/ARMN8G.html","content":"\r\n\r\nreveal.js封面展示.gif\r\n\r\n序\r\n汇报一直用 ppt ，审美疲劳了~ 对，简直是平淡无奇，用 ppt\r\n汇报，总感觉与自己的帅气（简称X格）完全配不上，所以，汇报时，至少是\r\nprezi 或者 focusky 。但自从搭建了个人博客之后，发现 prezi 之流依旧太\r\nlow。 那要用什么呢？当然是reveal.js啦~\r\n\r\nreveal.js介绍\r\n先看看什么是reveal.js。 \r\nReveal.JS 是 Hakim El Hattab\r\n开发的一个演示文稿制作工具，能够制作绚丽的演示文稿并生成 HTML\r\n格式，将它发布到 web 上。它使用了 CSS3 变换功能和\r\nJavaScript，这个工具大受 web\r\n开发者的青睐，因为它容易创造美丽的演示。\r\n想法的形成\r\n开始接触到 reveal.js 的时候，因为它的 Web\r\n特性，一下子就被迷上了，所以想将其移植到自己的博客里面，当点击博客标题时，就自动开始播放。\r\n这样，博客里便可以同时存放文章和 PPT（在接下来的表达中，用 Slides\r\n来表达用reveal.js生成的幻灯片，与 PPT 区别开来）。\r\n但是，但是，但是...网上并没有现成的解决方案，百度了下，大家主流的方案如下：\r\n\r\n将 reveal.js 源码下载下来，然后修改之后打开。传送门\r\n对这种操作，简直不能忍好吗？做一个\r\nPPT，居然要下载一堆与PPT内容不相关的源代码，加起来人 2M\r\n多了，有的幻灯片如果用 offce 做，也就几百 K。\r\n并且这还有个问题是，如果汇报结束，别人找你要 PPT，\r\n你还得压缩源代码，等其他人拿到你的 slides 时，首先要解压，然后找到其中的\r\nindex.html ，再双击打开。\r\n如果是个 Web\r\n小白，根本不懂哪个文件是入口，这种方式，对于分享太不友好了。\r\n虽然我们装X，但起码得比其它方式的有优势才行，否则不是智障么？\r\n将 reveal.js 部署到 pages 上面。传送门\r\n这种方案，先是用方案1生成本地 Slides，然后将它部署到 pages\r\n上面。这对我也不适用，我的 pages 都用作个从博客了，没地方。\r\n\r\n上面的两个方式我不喜欢的地方在于\r\n\r\n一般人看到源代码文件，头大，不会编辑\r\n会编辑的人，如果要制作满意的，复杂点的 PPT,\r\n也比较费时间\r\n\r\n在百般凉凉的状态下，终于让我发现了一个基于 reveal.js 的在线版本 Slides。它可以直接线上制作，制作完成后，通用浏览器线访问。\r\n从这个地方便得到了灵感，我可以在线上制作完成，然后导出到本地，制作成\r\nmarkdown 格式的文章，再推送到个人博客，这样今后在博客里面就可以查看\r\nSlides 了。\r\n开始实现\r\n注册 Slides 账号\r\n和正常注册账号的流程一样\r\n\r\n打开官网https://slides.com\r\n右上角有一个 Sign Up, 点击开始注册\r\n\r\n\r\nslideSignUp.png\r\n\r\n特别注意的是，注册是需要科学上网（你懂的）才行，因为它采用了谷歌的验证系统进行非机器验证。\r\n\r\n新建 slides\r\n点击新建，和制件 ppt 一样的流程。\r\n导出到本地\r\n\r\n点击左侧导出按钮 \r\n选择 Export to reveal.js \r\n打开我的 reveal.js 模板，位于 _post/revealjs\r\n里面，替换对应的head和body,然后修改ini的相关参数。\r\n更新文章，文章的链接就是 slides 了。\r\n效果传送门\r\n\r\n声明\r\n\r\n本方首发于李有福呀，转载请注明出处。\r\n\r\n","categories":["Blog"],"tags":["个人博客","jekyll","李有福呀"]},{"title":"中文文案排版指北（简体中文版）","url":"/posts/2019/B17J0X.html","content":"统一中文文案、排版的相关用法，降低团队成员之间的沟通成本，增强网站气质。\r\n\r\n{:toc}\r\n空格\r\n「有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在\r\n34\r\n岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。\r\n与大家共勉之。」——vinta/paranoid-auto-spacing\r\n中英文之间需要增加空格\r\n正确：\r\n\r\n在 LeanCloud 上，数据存储是围绕 AVObject 进行的。\r\n\r\n错误：\r\n\r\n在LeanCloud上，数据存储是围绕AVObject进行的。\r\n\r\n\r\n在 LeanCloud上，数据存储是围绕AVObject 进行的。\r\n\r\n完整的正确用法：\r\n\r\n在 LeanCloud 上，数据存储是围绕 AVObject 进行的。每个\r\nAVObject 都包含了与 JSON 兼容的 key-value\r\n对应的数据。数据是 schema-free 的，你不需要在每个 AVObject\r\n上提前指定存在哪些键，只要直接设定对应的 key-value 即可。\r\n\r\n例外：「豆瓣FM」等产品名词，按照官方所定义的格式书写。\r\n中文与数字之间需要增加空格\r\n正确：\r\n\r\n今天出去买菜花了 5000 元。\r\n\r\n错误：\r\n\r\n今天出去买菜花了 5000元。\r\n\r\n\r\n今天出去买菜花了5000元。\r\n\r\n数字与单位之间无需增加空格\r\n正确：\r\n\r\n我家的光纤入户宽带有 10Gbps，SSD 一共有 10TB。\r\n\r\n错误：\r\n\r\n我家的光纤入户宽带有 10 Gbps，SSD 一共有 20 TB。\r\n\r\n另外，度／百分比与数字之间不需要增加空格：\r\n正确：\r\n\r\n今天是 233° 的高温。\r\n\r\n\r\n新 MacBook Pro 有 15% 的 CPU 性能提升。\r\n\r\n错误：\r\n\r\n今天是 233 ° 的高温。\r\n\r\n\r\n新 MacBook Pro 有 15 % 的 CPU 性能提升。\r\n\r\n全角标点与其他字符之间不加空格\r\n正确：\r\n\r\n刚刚买了一部 iPhone，好开心！\r\n\r\n错误：\r\n\r\n刚刚买了一部 iPhone ，好开心！\r\n\r\n-ms-text-autospace\r\nto the rescue?\r\nMicrosoft 有个 -ms-text-autospace\r\n的 CSS\r\n属性可以实现自动为中英文之间增加空白。不过目前并未普及，另外在其他应用场景，例如\r\nOS X、iOS\r\n的用户界面目前并不存在这个特性，所以请继续保持随手加空格的习惯。\r\n标点符号\r\n不重复使用标点符号\r\n正确：\r\n\r\n德国队竟然战胜了巴西队！\r\n\r\n\r\n她竟然对你说「喵」？！\r\n\r\n错误：\r\n\r\n德国队竟然战胜了巴西队！！\r\n\r\n\r\n德国队竟然战胜了巴西队！！！！！！！！\r\n\r\n\r\n她竟然对你说「喵」？？！！\r\n\r\n\r\n她竟然对你说「喵」？！？！？？！！\r\n\r\n全角和半角\r\n不明白什么是全角（全形）与半角（半形）符号？请查看维基百科词条『全角和半角』。\r\n使用全角中文标点\r\n正确：\r\n\r\n嗨！你知道嘛？今天前台的小妹跟我说「喵」了哎！\r\n\r\n\r\n核磁共振成像（NMRI）是什么原理都不知道？JFGI！\r\n\r\n错误：\r\n\r\n嗨! 你知道嘛? 今天前台的小妹跟我说 \"喵\" 了哎!\r\n\r\n\r\n嗨!你知道嘛?今天前台的小妹跟我说\"喵\"了哎!\r\n\r\n\r\n核磁共振成像 (NMRI) 是什么原理都不知道? JFGI!\r\n\r\n\r\n核磁共振成像(NMRI)是什么原理都不知道?JFGI!\r\n\r\n数字使用半角字符\r\n正确：\r\n\r\n这件蛋糕只卖 1000 元。\r\n\r\n错误：\r\n\r\n这件蛋糕只卖 １０００ 元。\r\n\r\n例外：在设计稿、宣传海报中如出现极少量数字的情形时，为方便文字对齐，是可以使用全角数字的。\r\n遇到完整的英文整句、特殊名词，其內容使用半角标点\r\n正确：\r\n\r\n乔布斯那句话是怎么说的？「Stay hungry, stay foolish.」\r\n\r\n\r\n推荐你阅读《Hackers &amp; Painters: Big Ideas from the Computer\r\nAge》，非常的有趣。\r\n\r\n错误：\r\n\r\n乔布斯那句话是怎么说的？「Stay hungry，stay foolish。」\r\n\r\n\r\n推荐你阅读《Hackers＆Painters：Big Ideas from the Computer\r\nAge》，非常的有趣。\r\n\r\n名词\r\n专有名词使用正确的大小写\r\n大小写相关用法原属于英文书写范畴，不属于本 wiki\r\n讨论內容，在这里只对部分易错用法进行简述。\r\n正确：\r\n\r\n使用 GitHub 登录\r\n\r\n\r\n我们的客户有 GitHub、Foursquare、Microsoft\r\nCorporation、Google、Facebook, Inc.。\r\n\r\n错误：\r\n\r\n使用 github 登录\r\n\r\n\r\n使用 GITHUB 登录\r\n\r\n\r\n使用 Github 登录\r\n\r\n\r\n使用 gitHub 登录\r\n\r\n\r\n使用 gｲんĤЦ8 登录\r\n\r\n\r\n我们的客户有 github、foursquare、microsoft\r\ncorporation、google、facebook, inc.。\r\n\r\n\r\n我们的客户有 GITHUB、FOURSQUARE、MICROSOFT\r\nCORPORATION、GOOGLE、FACEBOOK, INC.。\r\n\r\n\r\n我们的客户有 Github、FourSquare、MicroSoft\r\nCorporation、Google、FaceBook, Inc.。\r\n\r\n\r\n我们的客户有 gitHub、fourSquare、microSoft\r\nCorporation、google、faceBook, Inc.。\r\n\r\n\r\n我们的客户有 gｲんĤЦ8、ｷouЯƧquﾑгє、๓เςг๏ร๏Ŧt\r\nς๏гק๏гคtเ๏ภn、900913、ƒ4ᄃëв๏๏к, IПᄃ.。\r\n\r\n注意：当网页中需要配合整体视觉风格而出现全部大写／小写的情形，HTML\r\n中请使用标准的大小写规范进行书写；并通过\r\ntext-transform: uppercase;／text-transform: lowercase;\r\n对表现形式进行定义。\r\n不要使用不地道的缩写\r\n正确：\r\n\r\n我们需要一位熟悉 JavaScript、HTML5，至少理解一种框架（如\r\nBackbone.js、AngularJS、React 等）的前端开发者。\r\n\r\n错误：\r\n\r\n我们需要一位熟悉 Js、h5，至少理解一种框架（如 backbone、angular、RJS\r\n等）的 FED。\r\n\r\n争议\r\n以下用法略带有个人色彩，既：无论是否遵循下述规则，从语法的角度来讲都是正确的。\r\n链接之间增加空格\r\n用法：\r\n\r\n请 提交一个 issue 并分配给相关同事。\r\n\r\n\r\n访问我们网站的最新动态，请 点击这里 进行订阅！\r\n\r\n对比用法：\r\n\r\n请提交一个 issue 并分配给相关同事。\r\n\r\n\r\n访问我们网站的最新动态，请点击这里进行订阅！\r\n\r\n简体中文使用直角引号\r\n用法：\r\n\r\n「老师，『有条不紊』的『紊』是什么意思？」\r\n\r\n对比用法：\r\n\r\n“老师，‘有条不紊’的‘紊’是什么意思？”\r\n\r\n工具\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n仓库\r\n语言\r\n\r\n\r\n\r\n\r\nvinta/paranoid-auto-spacing\r\nJavaScript\r\n\r\n\r\nhuei90/pangu.node\r\nNode.js\r\n\r\n\r\nhuacnlee/auto-correct\r\nRuby\r\n\r\n\r\nsparanoid/space-lover\r\nPHP (WordPress)\r\n\r\n\r\nnauxliu/auto-correct\r\nPHP\r\n\r\n\r\nhotoo/pangu.vim\r\nVim\r\n\r\n\r\nsparanoid/grunt-auto-spacing\r\nNode.js (Grunt)\r\n\r\n\r\nhjiang/scripts/add-space-between-latin-and-cjk\r\nPython\r\n\r\n\r\n\r\n谁在这样做？\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n网站\r\n文案\r\nUGC\r\n\r\n\r\n\r\n\r\nApple 中国\r\nYes\r\nN/A\r\n\r\n\r\nApple 香港\r\nYes\r\nN/A\r\n\r\n\r\nApple 台湾\r\nYes\r\nN/A\r\n\r\n\r\nMicrosoft 中国\r\nYes\r\nN/A\r\n\r\n\r\nMicrosoft 香港\r\nYes\r\nN/A\r\n\r\n\r\nMicrosoft 台湾\r\nYes\r\nN/A\r\n\r\n\r\nLeanCloud\r\nYes\r\nN/A\r\n\r\n\r\n知乎\r\nYes\r\n部分用户达成\r\n\r\n\r\nV2EX\r\nYes\r\nYes\r\n\r\n\r\nSegmentFault\r\nYes\r\n部分用户达成\r\n\r\n\r\nApple4us\r\nYes\r\nN/A\r\n\r\n\r\n豌豆荚\r\nYes\r\nN/A\r\n\r\n\r\nRuby China\r\nYes\r\n标题达成\r\n\r\n\r\nPHPHub\r\nYes\r\n标题达成\r\n\r\n\r\n\r\n参考文献\r\n\r\nGuidelines\r\nfor Using Capital Letters\r\nLetter case -\r\nWikipedia\r\nPunctuation -\r\nOxford Dictionaries\r\nPunctuation - The\r\nPurdue OWL\r\nHow to\r\nUse English Punctuation Corrently - wikiHow\r\n格式\r\n- openSUSE\r\n全角和半角\r\n- 维基百科\r\n引号 -\r\n维基百科\r\n疑问惊叹号\r\n- 维基百科\r\n\r\n致谢\r\n本文转载至 中文文案排版指北（简体中文版）并在其基础上进行了修改整理。\r\n","categories":["Blog"],"tags":["个人博客","书写规范"]},{"title":"快速搭建Hexo编译环境","url":"/posts/2021/2D12FH.html","content":"有时候我们需要在其它电脑上编译 Hexo\r\n博客，那么要如何快速搭建编译的环境呢，且听本文娓娓道来。如果涉及的环境已经存在或步骤已经执行过，请自行跳过。\r\n\r\n安装 npm\r\nnpm 是随 nodejs 安装而自动安装的，所以，我们只需要安装 nodejs\r\n即可。本人一般安装 nodejs 使用 scoop 来安装，命令行如下：\r\nscoop install nodejs\r\n安装 Git\r\nGit 用于克隆源代码，当然源代码也可以手动下载，但是用 Git\r\n的话可以在另一台电脑修改博客后将更新推送到 GitHub。scoop\r\n安装命令如下：\r\nscoop install git\r\n克隆仓库\r\n由于主题是作为博客的子模块，所以需要递归克隆整个项目：\r\ngit clone github地址 --recursive\r\n安装依赖包\r\n命令行进入到博客主目录中，运行下列语句安装依赖包：\r\nnpm install\r\n进入到 ./themes/next\r\n目录，运行下列语句安装主题依赖包：\r\nnpm install\r\n安装Pandoc\r\nhexo 需要 pandoc 支持，采用 scoop 安装，其命令如下：\r\nscoop install pandoc\r\n编译\r\nnpx hexo cleannpx hexo generatenpx hexo deploy\r\n","categories":["Blog"],"tags":["个人博客","Hexo","NexT"]},{"title":"基于Hexo 5.x 创建NexT主题的个人博客","url":"/posts/2021/1224JG.html","content":"花了大概两天的时间，终于把博客从 Jekyll 迁移到了\r\nHexo，期间淌过了很多的坑，作此记录，以醒来者。\r\n\r\n概述\r\n一开始为什么选择 jekyll ?\r\n选择 jekyll 的原因主要是 github\r\n支持推送编译，所以只需要将自己的文章（.md文件）推送到 master\r\n即可部署了，而 Hexo 需要在本地编译好，再上传，所以本机要安装\r\nnodejs，比较麻烦。\r\n为什么会选择从 jekyll 更改到 Hexo 呢？\r\n我的博客从 2018年就开始建立了，最近想着美化一下主题吧，然后就开始配置\r\njekyll 开发环境，但是 jekyll 它本身只支持 linux, 从网上下载了一个 jekyll\r\n的 windows 安装程序，按照教程安装，然后百般倒腾，就是运行不起来！\r\n好吧，我想，既然你原生支持 linux, 那我下载个 docker\r\n安装你吧，网上一搜，还真有专门针对 pages 的 docker\r\n镜像，安装完成后，还是运行不起来，蛋疼~\r\n不折腾了，直接用 Hexo 吧。\r\n我原来用的是 NexT 主题，所以，在 Hexo\r\n的主题商店一搜，好家伙，恕我以前没见识！\r\n“哇，主题真多”，“哇，插件真多”，“兴奋~”。\r\n好了，话不多说，接下来开开心心地安装 Hexo 加 NexT 主题吧。\r\n安装 Hexo 及 NexT\r\n扫盲\r\n要特别注意的是，咱们从 github 上下载的 NexT 只是 Hexo\r\n的一个主题，它不包含主程序，主程序需要用 Hexo 初始化。\r\n安装 Hexo\r\n查看 Hexo安装官方教程\r\n进行安装\r\n安装 Hexo 时，直接使用 npm install -g hexo-cli\r\n进行安装，不建议采用 进阶安装 方式\r\n用 Hexo 初始化一个博客\r\n假设我的安装目录为：D:\\Personal,\r\n博客的目录为：hexo-site\r\ncd d:cd D:\\Personalhexo init hexo-sitecd hexo-sitenpm install# 安装 hexo-server，进行本地编译及运行npm install hexo-server --save# 安装 hexo-deployer-git,一键部署到 github 等平台npm install hexo-deployer-git --save\r\n安装完成后目录如下：\r\n.├── _config.yml // 博客配置文件├── package.json  // npm包配置文件├── scaffolds  // 模版文件夹├── source // 存放用户资源的地方|   ├── _drafts // 存放草稿|   └── _posts  // 存放需要编译的文章└── themes  // 存放主题\r\n官方教程\r\n下载 NexT 主题\r\nhexo 的主题都是放在 themes 目录下，一般每个主题都是一个\r\nGit\r\n仓库，所以，为了方便今后在其它电脑上下载自己的博客仓库进行编译，我们需要把主题作为\r\nhexo 的子模块。\r\n添加子模块\r\ngit submodule add https://github.com/iissnan/hexo-theme-next themes/next\r\n更新子模块\r\n保持上面的命令行窗口不变，输入以下命令：\r\n// 更新项目内子模块到最新版本git submodule update// 更新子模块为远程项目的最新版本git submodule update --remote\r\n主题安装完成后的目录如下：\r\nD:\\Personal\\hexo-site├── _config.yml // 博客配置文件├── package.json  // npm包配置文件├── scaffolds  // 模版文件夹├── source // 存放用户资源的地方|   ├── _drafts // 存放草稿|   └── _posts  // 存放需要编译的文章└── themes  // 存放主题    ├── next    |   ├── _config.yml // 主题配置文件    |   ├── source    |   ├── ...    |   └── script    └── .gitkeep // 让 git 忽略当前文件夹及其子文件夹内所文件和文件夹 \r\n\r\n关于子模块的使用，可以参考：Git submodule\r\n子模块的管理和使用\r\n\r\n启用主题\r\n打开 博客配置文件，搜索 theme\r\n字段，将其改成如下：\r\ntheme: next\r\n安装主题依赖包\r\ncd themes/nextnpm install\r\n官方安装教程\r\n配置 NexT 主题\r\n我们需要修改 themes\\next\\_config.yml\r\n来进行主题配置，但是如果直接修改它，会使得今后更新主题时出现冲突情况，所以我们使用\r\n代替主题配置文件\r\n来进行个性化配置。它的文件名格式为：_config.[theme].yml\r\n。\r\n在网站根目录 D:\\Personal\\hexo-site 新建\r\n_config.next.yml 文件，在里面进行博客配置。\r\n配置优先级\r\nHexo 在合并主题配置时，Hexo 配置文件（博客配置文件）中的\r\ntheme_config 的优先级最高，其次是\r\n_config.[theme].yml 文件，最后是位于主题目录下的\r\n_config.yml 文件。\r\n# _config.ymltheme: &quot;next&quot;theme_config:  bio: &quot;My awesome bio&quot;  foo:    bar: &#x27;a&#x27;\r\n# _config.next.ymllogo: &quot;a-cool-image.png&quot;  foo:    baz: &#x27;b&#x27;\r\n# themes/next/_config.ymlbio: &quot;Some generic bio&quot;logo: &quot;a-cool-image.png&quot;  foo:    baz: &#x27;c&#x27;    bay: &#x27;d&#x27;\r\n最终主题配置的输出是：\r\n&#123;  bio: &quot;My awesome bio&quot;,  logo: &quot;a-cool-image.png&quot;,  foo: &#123;    bar: &quot;a&quot;,    baz: &quot;b&quot;,    bay: &#x27;d&#x27;  &#125;&#125;\r\n关键配置\r\nHexo 和 NexT\r\n安装完成后，还需要进行一些关键的配置，才能有更好的使用体验。\r\nNexT 主题配置：\r\n# _config.next.yml# Define custom file paths.# Create your custom files in site directory `source/_data` and uncomment needed files below.custom_file_path:  #head: source/_data/head.njk  #header: source/_data/header.njk  #sidebar: source/_data/sidebar.njk  #postMeta: source/_data/post-meta.njk  #postBodyEnd: source/_data/post-body-end.njk  #footer: source/_data/footer.njk  #bodyEnd: source/_data/body-end.njk  #variable: source/_data/variables.styl  #mixin: source/_data/mixins.styl,在该文件中修改 css 样式，达到更多的定制化  style: source/_data/styles.styl# Schemes，主题类型选择#scheme: Muse#scheme: Mistscheme: Pisces#scheme: Gemini# 打开 menu 中的其它菜单# 配置教程：https://theme-next.js.org/docs/theme-settings/custom-pages.html# 打开后，还要进行额外的配置，详见下文menu:  home: / || fa fa-home  about: /about/ || fa fa-user  tags: /tags/ || fa fa-tags  categories: /categories/ || fa fa-th  archives: /archives/ || fa fa-archive  #schedule: /schedule/ || fa fa-calendar  #sitemap: /sitemap.xml || fa fa-sitemap  #commonweal: /404/ || fa fa-heartbeat# Enable / Disable menu icons / item badges.menu_settings:  icons: true  badges: true # 显示文章数量# 显示返回顶部按钮back2top:  enable: true  # Back to top in sidebar.  sidebar: true  # Scroll percent label in b2t button.  scrollpercent: true# Local Search，本地搜索# Dependencies: https://github.com/next-theme/hexo-generator-searchdblocal_search:  enable: true  # If auto, trigger search by changing input.  # If manual, trigger search by pressing enter key or search button.  trigger: auto  # Show top n results per article, show all results by setting to -1  top_n_per_article: 5  # Unescape html strings to the readable one.  unescape: false  # Preload the search data when the page loads.  preload: false# Reading progress bar# 阅读进度条reading_progress:  enable: true  # Available values: left | right  start_at: left  # Available values: top | bottom  position: top  reversed: false  color: &quot;#37c6c0&quot;  height: 3px# ---------------------------------------------------------------# Sidebar Settings# See: https://theme-next.js.org/docs/theme-settings/sidebar# ---------------------------------------------------------------# Sidebar Avataravatar:  # Replace the default image and set the url here.  url: https://i.loli.net/2021/08/13/uOIcVFAlDbYRiCk.png  # If true, the avatar will be dispalyed in circle.  rounded: false  # If true, the avatar will be rotated with the cursor.  rotated: false# Social Links# Usage: `Key: permalink || icon`# Key is the link label showing to end users.# Value before `||` delimiter is the target permalink, value after `||` delimiter is the name of Font Awesome icon.social:  GitHub: https://github.com/galensgan || fab fa-github  简  书: https://www.jianshu.com/u/08760e791f9e || fa fa-book-reader  #Weibo: https://weibo.com/yourname || fab fa-weibo  #Google: https://plus.google.com/yourname || fab fa-google  #Twitter: https://twitter.com/yourname || fab fa-twitter  #FB Page: https://www.facebook.com/yourname || fab fa-facebook  #StackOverflow: https://stackoverflow.com/yourname || fab fa-stack-overflow  #YouTube: https://youtube.com/yourname || fab fa-youtube  #Instagram: https://instagram.com/yourname || fab fa-instagram  #Skype: skype:yourname?call|chat || fab fa-skype# ---------------------------------------------------------------# Post Settings# See: https://theme-next.js.org/docs/theme-settings/posts# ---------------------------------------------------------------# Post meta display settingspost_meta:  item_text: true  created_at: true  updated_at:    enable: true    another_day: true  categories: true# Use icon instead of the symbol # to indicate the tag at the bottom of the posttag_icon: true# Donate (Sponsor) settings# Front-matter variable (unsupport animation).reward_settings:  # If true, a donate button will be displayed in every article by default.  enable: true  animation: true  comment: Buy me a coffeereward:  wechatpay: https://i.loli.net/2021/08/13/JOw9cxomhBAZFW8.png  alipay: https://i.loli.net/2021/08/13/U2s7gKn1zRw3uP4.png  #paypal: /images/paypal.png  #bitcoin: /images/bitcoin.png# Subscribe through Telegram Channel, Twitter, etc.# Usage: `Key: permalink || icon` (Font Awesome)follow_me:  公众号: https://i.loli.net/2021/08/13/QMRtHE2b4czd7OA.jpg || fab fa-weixin  简书: https://www.jianshu.com/u/08760e791f9e || fa fa-book-reader  #Twitter: https://twitter.com/username || fab fa-twitter    #WeChat: /images/wechat_channel.jpg || fab fa-weixin  #RSS: /atom.xml || fa fa-rss# Mermaid tag# 开启 mermaid 展示mermaid:  enable: true  # Available themes: default | dark | forest | neutral  theme: forest# 代码块设置codeblock:  # Code Highlight theme  # All available themes: https://theme-next.js.org/highlight/  theme:    light: github    dark: github  # Add copy button on codeblock  copy_button:    enable: true    # Available values: default | flat | mac    style: flat# Easily enable fast Ajax navigation on your website.# For more information: https://github.com/next-theme/pjax# 该设置使得切换页面不会重复刷新，提高响应速度pjax: true\r\n配置\r\nAbout，Tags，Categories 页面\r\n初始化的博客只有首页和归档两个菜单，一般我们还需要添加关于、标签、分类菜单栏，可以通过下列步骤进行增加。\r\n**修改 _config.next.yml 配置**\r\n# _config.next.yml# ... 其它配置# 打开 menu 中的其它菜单# 配置教程：https://theme-next.js.org/docs/theme-settings/custom-pages.html# 打开后，还要进行额外的配置，详见下文menu:  home: / || fa fa-home  about: /about/ || fa fa-user  tags: /tags/ || fa fa-tags  categories: /categories/ || fa fa-th  archives: /archives/ || fa fa-archive  #schedule: /schedule/ || fa fa-calendar  #sitemap: /sitemap.xml || fa fa-sitemap  #commonweal: /404/ || fa fa-heartbeat\r\n新建页面\r\n在终端中，将目录定位到博客根目录（D:\\Personal\\hexo-site）\r\n# 定位到根目录cd d:cd D:\\Personal\\hexo-site# 新建页面hexo new page abouthexo new page tagshexo new page categories\r\n修改页面类型\r\n通过上述命令后，会在博客根目录下的 source 目录中生成\r\nabout、tags、categories\r\n三个目录，每个目录中分别有一个 index.md\r\n文件，打开该文件，并添加 type 属性。以\r\nsource/tags/index.md 为例:\r\n---title: 标签date: 2021-08-13 00:09:00type: tagscomments: false---\r\n每个菜单的类型如下：\r\n\r\n\r\n\r\n菜单\r\ntype\r\n\r\n\r\n\r\n\r\nabout\r\nabout\r\n\r\n\r\ntags\r\ntags\r\n\r\n\r\ncategories\r\ncategories\r\n\r\n\r\n\r\n显示优化\r\n通过上述步骤后，就可以运行\r\nhexo clean &amp;&amp; hexo g &amp;&amp; hexo s，然后在浏览器中查看效果了（网址：http://127.0.0.1:4000）。\r\n但是，当某些界面显示不符合我们的审美时，我们也可以对样式进行自定义。\r\n打开自定义样式配置\r\n# _config.next.yml# Define custom file paths.# Create your custom files in site directory `source/_data` and uncomment needed files below.custom_file_path:  #head: source/_data/head.njk  #header: source/_data/header.njk  #sidebar: source/_data/sidebar.njk  #postMeta: source/_data/post-meta.njk  #postBodyEnd: source/_data/post-body-end.njk  #footer: source/_data/footer.njk  #bodyEnd: source/_data/body-end.njk  #variable: source/_data/variables.styl  #mixin: source/_data/mixins.styl,在该文件中修改 css 样式，达到更多的定制化  style: source/_data/styles.styl\r\n新建 source/_data/styles.styl 文件\r\n在 styles.styl 文件中自定义样式\r\n下面是我做的一点更改，以供参考：\r\n// 侧边目录行距.post-toc .nav-item &#123;    line-height: 2;&#125;// 链接p a &#123;    color: #fc6423;&#125;// 头部没有进度条时的黑框.headband &#123;    display: none;&#125;// 侧边栏名称底色.site-brand-container &#123;    background: #333333c7;&#125;// 边栏阅读进度背景色.back-to-top.back-to-top-on &#123;    background-color: #fc6423;&#125;\r\n插件推荐\r\n到上面一步为止，咱们的博客已经处于生产水平了，正常使用完全没问题了，如果不感兴趣，可以直接跳到\r\n部署 章节。\r\nhexo-enhancer\r\nhexo-enhancer是一个 Hexo\r\n功能增强插件。它可以自动生成日期，标题，标签等等，在使用中很方便。\r\n官方网址：https://sulin.me/2019/Z726F8.html\r\nhexo-uuid\r\n给文章添加设置一个永久链接，这样文章变动后，链接将不会改变。\r\n官方网址：https://www.npmjs.com/package/hexo-uuid\r\n部署\r\n本人采用 hexo-deployer-git\r\n来实现一键部署。\r\n按 官方说明文档\r\n配置即可。\r\n其它参考文档\r\ntheme-next\r\n","categories":["Blog"],"tags":["Hexo","NexT"]},{"title":"免费的静态托管网站推荐","url":"/posts/2023/3G50H3P.html","content":"搭建了个人博客之后，如何托管博客网站就成了必须要解决的问题，基于国内的网络环境，如果部署在国外的网站上，访问速度上不去；如果选择国内的托管，大部分收费；如果使用家庭服务器，则备案又是一个问题。\r\n\r\n补充说明下为什么要备案：\r\n\r\n备案后，可以通过 Http\r\n默认端口访问网站，否则就得在域名后缀一个:端口，很难看\r\n没备案，你将网站发给其他人，像微信、QQ会提示链接有风险，别人不敢打开\r\n\r\n\r\n当然，此处不讨论自己付费租一个云服务器的方案，本文主打的一个就是“白嫖”！\r\n\r\n本文只根据自己的日常使用进行总结推荐，受限于认知，可能并不全面，欢迎联系我进行补充。\r\nGitee Pages\r\n简介：国内最大的代码托管平台。\r\n优点：稳定性强，由于服务器位于上海，国内访问速度非常快。\r\n缺点：仓库的最大容量和单个文件大小有限制，对仓库内容非常敏感，需要实名认证，自定义域名和自动部署都需要收费。\r\n个人观点：Gitee Pages\r\n非常适合不需要自定义域名并且网站内容少、内容几乎不变的场景，例如小说精品屋官网。由于 Gitee Pages\r\n对仓库内容非常敏感，每次部署前都会对仓库内容进行检查，部署博客的话会经常遇到部署失败的情况，而且内容校验规则也会发生变化，如果网站内容比较多，有时候排查整改起来会比较麻烦，所以建博客我现在几乎不考虑使用\r\nGitee Pages 了。\r\n👉 前往官网\r\nGitHub Pages\r\n简介：全球最大的代码托管平台。\r\n优点：稳定性强，部署简单，使用方便，支持自定义域名。\r\n缺点：国内访问速度一般，拒绝百度爬虫访问。\r\n个人观点：如果不想太折腾并且对百度收录没有要求的话可以选择 GitHub\r\nPages。\r\n👉 前往官网\r\nCloudflare Pages\r\n简介：Cloudflare 推出的全新网页托管服务。\r\n优点：不限站点数、请求数和带宽，全球都拥有 CDN\r\n节点，支持自定义域名和自动部署。\r\n缺点：国内访问速度和稳定性一般，每月构建次数、文件数量和大小都有限制。\r\n个人观点：放弃 Gitee Pages 和 GitHub Pages\r\n后的一个选择，稳定性不好，经常超时，不过有时候挺快的。\r\n👉 前往官网\r\nVercel\r\n简介：一个开箱即用的网站托管服务，全球都拥有 CDN\r\n节点，支持自定义域名和自动部署，前身叫 ZEIT。\r\n优点：国内访问速度比 Github Pages 和 Cloudflare Pages\r\n要快，支持自定义域名和自动部署。\r\n缺点：构建次数和构建时长有限制，每月带宽限制 100G。\r\n个人观点：博客托管的最终选择，国内访问速度是除了 Gitee Pages\r\n外目前使用过最快的，个人博客现已托管到 Vercel 上。\r\n👉 前往官网\r\n不同平台网站速度对比\r\n以部署在不同平台上的个人博客网站作为测试网站，右边为\r\nVercel 部署的网站：\r\nCloudflare Pages 与 Vercel\r\n对比\r\n\r\nGithub Pages 与 Vercel 和\r\n对比\r\n\r\nGitee Pages 与 Vercel 对比\r\n\r\n推荐分析\r\nGitee Pages 限制太多。\r\n国外首选 Vercel，否则 GitHub Pages 和 Cloudflare Pages 相差不大，但\r\nGitHub Pages\r\n的稳定性更好，如果想要自己的博客网站被百度搜索引擎收录，那么选择\r\nCloudflare Pages，否则选择 GitHub Pages。\r\n其它静态网站托管平台\r\n其它常见的托管平台还有：\r\n\r\nCoding\r\nPages：被腾讯收购，收费，送代金劵可以试用几个月\r\nNetlify：\r\n国外、免费，国内访问速度还可以，但和 Vercel 一样，带宽限制为每月\r\n100G，可作为 Vercel 的替代方案\r\nCloudBase\r\n静态网站托管：腾讯云推出的静态网站托管服务，收费\r\n\r\n致谢\r\n本文转载至\r\n几个免费的静态网站托管平台对比\r\n| xxyopen\r\n","categories":["Blog"],"tags":["Blog"]},{"title":"hexo-blog-encrypt目录消失","url":"/posts/2023/26YRMRD.html","content":"使用 hexo-blog-encrypt\r\n对文章进行加密，解密后发现目录消失，本文将介绍如何通过修改 NexT\r\n主题的源码来实现加密文章的目录显示。\r\n\r\n本教程针对 hexo 下的 NexT 主题\r\n\r\n\r\n原因\r\n从插件的 github issues 中我找到了相关的讨论：解密后目录不会更新\r\n· Issue #16 · D0n9X1n/hexo-blog-encrypt\r\n原因是：\r\n\r\n加密的时候，post.content 会变成加密后的串，所以原来的\r\nTOC 生成逻辑就会针对加密后的内容。\r\n所以这边我只能把原来的内容存进 post.origin 字段。\r\n\r\n优化代码\r\n打开\r\n/thems/next/layout/_micro/sidebar.njk文件，进行如下修改\r\n找到包含 set toc = toc(page.content...\r\n的代码段，将其中的内容替换为如下代码：\r\n&#123;%- if display_toc %&#125;  &#123;%- if (page.encrypt) %&#125;    &#123;%- set toc = toc(page.origin, &#123; class: &#x27;nav&#x27;, list_number: page.toc.number, max_depth: page.toc.max_depth &#125;) %&#125;  &#123;%- else %&#125;    &#123;%- set toc = toc(page.content, &#123; class: &#x27;nav&#x27;, list_number: page.toc.number, max_depth: page.toc.max_depth &#125;) %&#125;  &#123;%- endif %&#125;  &#123;%- set display_toc = toc.length &gt; 1 and display_toc %&#125;&#123;%- endif %&#125;\r\n上述代码的作用是当有加密时，从 page.origin 中读取目录信息。\r\n找到包含 &lt;div class=\"post-toc-wrap sidebar-panel\"&gt;\r\n的代码段，将其修改为：\r\n&lt;!--noindex--&gt;&lt;div class=&quot;post-toc-wrap sidebar-panel&quot;&gt;  &#123;%- if display_toc %&#125;    &#123;%- if (page.encrypt) %&#125;      &lt;div id=&quot;toc-div&quot; class=&quot;post-toc animated&quot; style=&quot;display:none&quot;&gt;&#123;&#123; toc &#125;&#125;&lt;/div&gt;    &#123;%- else %&#125;      &lt;div class=&quot;post-toc animated&quot;&gt;&#123;&#123; toc &#125;&#125;&lt;/div&gt;    &#123;%- endif %&#125;  &#123;%- endif %&#125;&lt;/div&gt;\r\n上述代码的原理是：在文章加密的前提下，通过将目录部分加入到一个\r\n不可见的div 中来实现 隐藏目录 的效果。在 hexo-blog-encrypt/lib/hbe.js\r\n源码中，我们可以看到解密后会修改 id 值为\r\ntoc-div 的元素为 display:inline\r\n来显示内容。\r\n参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\nHexo博客文章加密\r\n","categories":["Blog"],"tags":["Blog","Hexo","NexT"]},{"title":"12 Egnlish Tenses","url":"/posts/2020/B9PE5D.html","content":"I decide to learn the 12 basic English tenses. There\r\nare some notes bellow.\r\n\r\nSummarize\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nTense\r\nHow and when to use\r\nExample\r\n\r\n\r\n\r\n\r\n1. Present Simple\r\ngeneral facts; regular actions; schedules\r\nI work on Mondays.I don't eat lunch at 2 PM.\r\n\r\n\r\n2. Present Continuous\r\ncontinuing actions(now); one time actions for the future\r\nI'm swiming this Saturday.\r\n\r\n\r\n3. Present Perfect\r\ngeneral life experience(or lack thereof)\r\nHe has never been to spain\r\n\r\n\r\n4. Present Perfect Continuous\r\naction that started in the past and continue\r\nI've been studying English for 2 years.\r\n\r\n\r\n/\r\n/\r\n/\r\n\r\n\r\n1.Past Simple\r\nactions that started and finished in the past\r\nI worked all night.They didn't come.\r\n\r\n\r\n2. Past Continuous\r\nactions that were continuing in the past\r\nWe were listening music.\r\n\r\n\r\n3. Past Perfect\r\nactions completed/not completed at a nonspecific point in the\r\npast\r\nThe hadn't departed yet.I had taken my lunch break.\r\n\r\n\r\n4. Past Perfect Continuous\r\nactions that started the past and continued and finished as\r\nwell\r\nThe had been waiting since 3 PM.\r\n\r\n\r\n/\r\n/\r\n/\r\n\r\n\r\n1. Future Simple\r\nactions planed/unplaned for the future\r\nI'll have a glass of wine.He's going to cookdinner.\r\n\r\n\r\n2. Future Continuous\r\nactions that you think will/won't be continuing in the future\r\nI'm not going to be working at company A.\r\n\r\n\r\n3. Future Perfect\r\nactions that you think will/won't have begun in the future\r\nI'll have lived in China for 2 years in 2020.\r\n\r\n\r\n4. Future Perfcet Continuous\r\nactions that you think will/won't have started and will be continung\r\nin the future\r\nI won't have been eating meat for 3 months.\r\n\r\n\r\n\r\nResource And Thanks\r\n\r\nthe article from:\r\nhttps://www.englishclub.com/grammar/verb-tenses.htm\r\nthe video form:\r\nhttps://www.youtube.com/watch?v=d0wV9EC3t14\r\n\r\n","categories":["English"],"tags":["English"]},{"title":"使用80和443端口访问其它任意端口","url":"/posts/2023/3J27R22.html","content":"\r\n现在的云服务器有些小贵，而且带宽很小，像阿里云 5M 的带宽就要\r\n125元/月。因此，有些同学可能会选择利用家庭宽带自建一个服务器。但是家庭宽带有个问题，运营商会封禁\r\n80 8080 443 8443\r\n等这些常用的端口，导致我们不能使用http的默认端口，在使用域名进行访问时，必须要指定端口，这有点不够优雅。\r\n本文将提供一个不加端口访问自建服务器资源的方法。\r\n\r\n\r\n本文介绍如何配置80或443访问，对于文中提到的其它知识点，需要自行去学习。\r\n\r\n宽带\r\n自建家庭服务器要求宽带支持动态 IP，目前来说，电信的宽带可以申请动态\r\nIP，安装好宽带后，打电话给客服申请就可以了。\r\n移动和联通会给你打马哈哈，说不能开通。\r\n实现思路\r\n通过 cloudflare 的 Origin Rules\r\n来实现端口转发。\r\n配置步骤\r\n\r\n注册 cloudflare\r\n选择【网站】/【新增网站】\r\n添加自己的域名信息，作为一条网站记录\r\n将 cloudflare 作为自己域名的 dns 解析服务器\r\n在域名购买商处将域名的名称服务器改成\r\nclounflare，自行查找教程实现\r\n当 dns 解析服务器修改完成后，添加 dns 记录\r\n\r\n\r\nimage-20230718234900986\r\n\r\n对于要进行端口转发的域名，要选择代理模式并启动代理\r\n切换到【SSL/TLS】，选择加密模式为“完全”\r\n\r\n\r\nimage-20230718235131963\r\n\r\n切换到【规则/Origin Rules】，添加 Origin 规则\r\n按下图进行操作：\r\n\r\n\r\nimage-20230718235550513\r\n\r\n其中，重写到一定要填写自己服务器的端口\r\n\r\n","categories":["Blog"],"tags":["个人博客","Hexo"]},{"title":"American accent","url":"/posts/2020/317EM2J.html","content":"There are the notes of American accent.\r\n\r\n15 vowel sounds\r\nthe video url:\r\nhttps://www.youtube.com/watch?v=X3aOsOUM06c&amp;list=PL7sOfomcE2Tdq0N-_nb7tvdm4S5gBEr0N\r\nVowel rules（元音规则）\r\nUnderstanding\r\nneutral/relaxed and tense vowels (认识中性元音和紧无音)\r\n\r\n4 neutral vowels（四个中性元音，要短促）\r\n/ɪ/, /ɜ/, /ə/, /ʊ/\r\n重读\r\n音节重读时，要拉长元音。\r\n对于单词，重读突出关键词，一般重读名词和动词。\r\nReduced vowels（弱化元音）\r\n元音组成弱化音节时，都可以读成 /ə/ 音\r\n在句子里面也是一样，我们要强调动词和名词，对介词和冠词以及无关紧要的词进行弱化。比如：\r\nin, on, at, for, with, by，发音要短。\r\n\r\nConsonant rules（辅音规则）\r\n\r\n把每个辅音发到位\r\nvoiced and voiceless consonnants（浊辅音和清辅音）\r\n浊辅音前面的元音发声要长。ice / EYEs\r\nl 发音稍长\r\nstop and continuants (停顿和连续音)\r\n对于停顿辅音，比如 b,d,m\r\n等等，发音后嘴唇不要张开，不要释放最后的停顿，造成发出了该音的效果。比如\r\nsometimes, pop music。\r\n去除 t 的发音\r\n两个元音之间的 t\r\n当 t 位于两个元音之间时，发单似 d,不要很重，要快速\r\n对于两个单词间也是如此\r\n当 t+字母+n 时，直接发 n 音\r\ning 发音\r\n发单时，舌头不要放下来\r\ntr dr 发音 /tr/,/dr/\r\ntu 发音 /tʃu/, du 发音 /dʒu/. 比如：would you, did you\r\ned 结尾发音\r\n当单词以 t 或者 d 结尾 + ed，发 /Id/，比如 want, wanted\r\n清辅音后 + ed, 发 /t/ 音，比如 passed\r\n浊辅音后 + ed, 发 /d/ 音，比如 called\r\n\r\nRythm and Intonation\r\n(节奏和发音)\r\n一个句子某些词要 louder, longer and higher in pitch\r\n\r\n当一个名词存在 2 个音节时，90%\r\n情况下，第一个章节重读。对于动词，有60%的情况是相反的。\r\nate 结尾的单词\r\n如果是动词，发 /eit/, 如果是形容词或者名词，发 /et/\r\n单词以 ese,eer,ique 结尾，重读这些后缀，如果是 ic\r\n结尾，重读前面的章节\r\n句子中单词重读的依据\r\n重读实意词（content words):\r\n去掉功能词后，用这些实意词，可以大概知道句子的意思\r\n对于功能词（function words，并不需要重读\r\n当有两个实意词时，第二个通常要更加的重读\r\nfocus words and thought group (焦点词和虚拟分组)\r\n先对长句进行分组，然后找到组中最重要的词，这个词就叫做焦点词\r\n怎么分组呢？根据语速不同，分组也会不同，分组的基本原则是保证语句通顺。\r\n句子中的停顿多数发生在分组之间或者出现关键词的时候\r\n怎样重读形容词和名词\r\n当 adj + n 时，重读名词，而不是形容词\r\n如果是 be + adj, 重读形容词\r\n复合名词（compunt nouns）的重读\r\n重读第一个名词，比如：HAIRcolor\r\n动词短语重读\r\n重读第二个单词，重读介词，比如：pick UP, break DOWN\r\n如果动词短语当成名词使用时，重读第一个\r\n人名和地名\r\n重读最后一个单词\r\n缩写词和数字\r\n缩写重读最后一个字母，比如 CNN\r\n数字重读最后部分\r\n特殊重读\r\n当要特别强调时，可以选择重读。一般这种是带有感情色彩的，也要根据语境\r\n\r\nRising and Falling inonation\r\n\r\n对于陈述句，用降调\r\n对于 yes/no 型，用升调。比如 Are you ok? (升调)\r\n对于 wh- 型，用降调。比如 how,where,when,what\r\n声调变化\r\n对于排比型句子或者单词，前面都是升，最后一个降调\r\n升调表示话还没说完\r\n当给别人选择时，用升调\r\n\r\n10 rules you need to know\r\n辅音和元音连续（Linking)\r\n\r\n第一个单词以辅音结尾，后一个单词以元音开头，要进行连读\r\n在连读的时候，不要忘记焦点词的重读\r\n在断句或者逗号的时候，不用连读\r\n\r\n辅音结尾+辅音开头\r\n\r\n两个辅音一样时，只发一次。比如 he likes swiming\r\n当两个辅音发音点相同时，只读后面一个，比如 i used to, 发 /I us\r\n2/\r\n当第一个元音是 o 时，不发 /ou/音，而是发 /w/单\r\n\r\n元音结尾+元音开头\r\n在后一个元音前加 y /yuh/ 进行连读\r\n单词轻读\r\n重读实意词，轻读功能词\r\n\r\n当轻读介词时，介词中的元音变成中性元音 /ə/。 比如 as /əs/\r\n\r\n\r\n\r\n\r\nas\r\n/əs/\r\n\r\n\r\n\r\n\r\non\r\n/ən/\r\n\r\n\r\nat\r\n/ət/\r\n\r\n\r\nto\r\n/tə/\r\n\r\n\r\nfor\r\n/fə/\r\n\r\n\r\nor\r\n/ər/\r\n\r\n\r\nour\r\n/ər/\r\n\r\n\r\nand\r\n/n/\r\n\r\n\r\n\r\n\r\n轻读代词\r\n省略第一个 h 或者 th 发音。 比如 did he /dide/\r\n在正式场合也不省略\r\n用缩写\r\n一般使用缩写，比如 don't\r\n强调时，用全写，do not\r\nI'd: I would\r\nthey're: they are\r\ncould've: could have,have 在省略中发 /əv/\r\n\r\nSome Rules\r\nResource And Thanks\r\n\r\nthe video form:\r\nhttps://www.youtube.com/watch?v=X3aOsOUM06c&amp;list=PL7sOfomcE2Tdq0N-_nb7tvdm4S5gBEr0N\r\n\r\n","categories":["English"],"tags":["English"]},{"title":"功能分析与硬件选择","url":"/posts/2021/BGHDM6.html","content":"小伙伴们，大家好，我是李有福呀。最近准备搭建一个all in\r\none家庭服务器，于是将搭建过程做成系列视频，抛砖引玉，希望对新入门的小伙伴们有所帮助。\r\n\r\n什么是all in one\r\nAll In One\r\n主机是指在底层虚拟机平台上创建软路由、NAS主机、Windows主机等虚拟主机，使一台主机可以扮演不同的角色来到达用户不同的需求。\r\n对于虚拟机，目前流行的有三个： https://zhuanlan.zhihu.com/p/166352130\r\n三者各有利弊，基于我的硬件情况，我选择了esxi。\r\n需求分析\r\n我本人开始使用的软路由，但是随着需求增加，比如想具备nas功能，部署一个自己的网站，安装数据库等，软路由已经不能满足我的需求了。\r\n目前我的需求主要有以下几个：\r\n\r\n家庭网关\r\n出国旅游\r\nNAS\r\nWindows\r\nserver(网站，数据库，当家庭电脑使用，如果今后内存增加，会考虑再安装一个win10，然后服务器换成Linux)\r\n\r\n硬件选择\r\n\r\n\r\n\r\n名称\r\n品牌\r\n型号\r\n价格与数量\r\n入手渠道\r\n\r\n\r\n\r\n\r\n机箱\r\n途腾\r\n\r\n123\r\n\r\n\r\n\r\n风扇\r\n\r\n\r\n10.26*2\r\n\r\n\r\n\r\nCPU\r\nXEON(至强)\r\ne5 2650 v3\r\n180\r\n拼多多\r\n\r\n\r\nCPU散热器\r\n\r\n\r\n56.16\r\n拼多多\r\n\r\n\r\n主板\r\n华南金牌\r\nx99 zd4 matx\r\n440\r\n\r\n\r\n\r\n固态\r\n\r\n512G\r\n262\r\n拼多多\r\n\r\n\r\n硬盘\r\n希捷酷狼\r\n2T\r\n465*2\r\n淘宝\r\n\r\n\r\n内存\r\n光威\r\nddr4 3000 8G\r\n120*2\r\n闲鱼\r\n\r\n\r\n网卡\r\n\r\n4口\r\n110\r\n闲鱼\r\n\r\n\r\n显卡\r\n\r\nGTX650 2G\r\n240\r\n闲鱼\r\n\r\n\r\n电源\r\n金牌\r\n500w\r\n95\r\n闲鱼\r\n\r\n\r\n显示器\r\n\r\n红米\r\n500\r\n闲鱼\r\n\r\n\r\n\r\n\r\n合计\r\n3196.68\r\n\r\n\r\n\r\n\r\n","categories":["HomeServer"],"tags":["家庭服务器","All in one","李有福呀"]},{"title":"American accent practice","url":"/posts/2020/15QDG6.html","content":"There are some experience in my studying.\r\n\r\n\r\n辅音后的无音要中性化\r\nwhat are you\r\n/ wad ər ju /\r\nng 音后如果是元音，ng 发 n 音\r\nlaughing at\r\n/ lafen ai / at 中的 t 是 stop t\r\nI wouldn't / ai wuln /\r\nyou said somefunny /ju sei sʌm‘m fʌni: /\r\ndidn't you / dn jə /\r\n两个辅音相连，且不一样时，前一个发音后不要释放，像停止单一样\r\nthe guy's a joke machine / dʒouk məʃn /\r\n当两个辅音发音差不多一样时，发重的那个音，省略轻的那个音\r\n当只有回答 yes no 时，才用升调\r\nSomeone who / sʌmwan u /\r\ncan 一般 /kən/\r\n\r\n","categories":["English"],"tags":["English"]},{"title":"移动已安装软件程序文件夹：FreeMove","url":"/posts/2020/YY2KY2.html","content":"FreeMove\r\n是一款可以移动已安装软件程序文件夹的软件，很多时候软件在安装的时候选在了\r\nA 分区，但是使用过一段时间后想移动到 B\r\n分区，但是又不想卸载重新安装，这时候就需要用到这款 FreeMove 软件了。\r\n\r\n应用简介\r\nFreeMove 的用法很简单，在「Move\r\nFrom」处选择你需要移动的软件文件夹位置，再在「To」处选择目标移动位置，最后点击「Move」按钮即可。\r\n这款小工具的原理跟我们之前介绍过的 Steam Mover\r\n的原理是一样的，都是为文件夹创建一个软链接，之后指向到新位置，就可以实现移动的功能了。\r\n功能特点\r\n\r\nFreeMove不需要安装，解压即可使用\r\nFreeMove软件占用系统内存少，简单易用\r\n\r\nFreeMove使用方法\r\n1、打开FreeMove软件 \r\n2、在Move From处选择你需要移动的软件文件夹位置 \r\n3、在To处选择目标移动位置 \r\n4、最后点击Move按钮即可 \r\n下载\r\n软件下载传送门\r\n48kb\r\n致谢\r\n本文摘抄至西西软件\r\n","categories":["Software"],"tags":["佳软"]},{"title":"js常用链接小飞机","url":"/posts/2020/3CGWMS0.html","content":"此处主要记录了一些在编程过程中需要使用或者可以参考学习的文档地址，方便快速跳转查看。\r\n\r\n学习\r\n设计模式\r\nhttps://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/creational.html\r\nJavaScript\r\n阅读需知\r\n\r\n建议阅读英文版本。有时候中文翻译省略了很多内容，表达不是很完整。\r\n\r\n数组 Array\r\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array\r\n字符串\r\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String\r\n图标库\r\n阿里：https://www.iconfont.cn/\r\nMaterial: https://material.io/resources/icons/?style=baseline\r\n工具类\r\nlodash: https://lodash.com/docs/4.17.15#differenceWith\r\nunderscore: https://underscorejs.org\r\n","categories":["Navigation"],"tags":["编程"]},{"title":"代理和镜像源配置方式汇总","url":"/posts/2024/2625AHG.html","content":"本文记录工作中用到的软件的代理或镜像配置方式。\r\n\r\nGit\r\n# 配置代理git config --global http.proxy http://127.0.0.1:1080git config --global https.proxy https://127.0.0.1:1080# 删除代理git config --global --unset http.proxygit config --global --unset https.proxy\r\nNode\r\nNPM设置代理：\r\nnpm config set proxy=&quot;&lt;http_proxy&gt;&quot;npm config set https-proxy=&quot;&lt;https_proxy&gt;&quot;\r\nNPM删除代理：\r\nnpm config delete proxy npm config delete https-proxy\r\nYARN设置代理:\r\nyarn config set proxy &lt;http_proxy&gt;yarn config set https-proxy &lt;https_proxy&gt;\r\nYARN删除代理:\r\nyarn config delete proxy  yarn config delete https-proxy\r\n设置registry:\r\nnpm config set registry https://registry.npm.taobao.org/npm config set registry https://registry.npmjs.org/yarn config set registry https://registry.npm.taobao.org/yarn config set registry https://registry.npmjs.org/\r\n\r\n若安装包时，包名是 git:// 协议，可以通过\r\ngit config --global url.\"https://\".insteadOf git:// 将 git\r\n协议转为 https 协议。\r\n\r\n","categories":["Software"],"tags":["proxy","registry"]},{"title":"Filezilla 安装及配置教程","url":"/posts/2021/3KHWK77.html","content":"本文为 FileZilla的安装教程及其配置，主要是方便今后快速搭建一个 Ftp\r\n服务器。\r\n\r\n下载\r\n\r\n通过 scoop 安装\r\nscoop install extras/scoop install filezilla-server\r\n从官网下载\r\n也可以直接从官网下载安装\r\n\r\nFileZilla 配置\r\n设置管理界面密码\r\n\r\n修改 FTP\r\n管理端口，增强安全性，比如：20001，同时设置管理密码。设置管理界面密码是为了提高\r\nFTP 的安全性，防止其他人修改 FTP 配置。\r\n修改通信端口\r\n\r\n\r\nimage-20210810142154949\r\n\r\nFileZilla 的默认通信端口是 21，需要将其改成其它端口，提高安全性。\r\n设置主动模式端口\r\n\r\n\r\nimage-20210810114551377\r\n\r\n设置端口范围，至少需要两个端口。该端口用于文件上传下载的数据传输。\r\n配置 TLS\r\n\r\n\r\nimage-20210810142603777\r\n\r\n按步骤生成证书即可。\r\n生成完成后，还需要修改TLS端口为自定义的端口，提高安全性。\r\n防火墙配置\r\n上述配置完成后，即可在本机进行连接使用，但是如果想在其它机器连接，则需要在安装电脑上的防火墙中添加入站规则，允许FTP相关的端口通过。上面的端口包括：\r\n\r\n通信端口（默认21）\r\n文件上传下载端口（默认1-65535）\r\nTLS 验证端口（默认990）\r\n\r\n通过上述几步，便完成了整个整个配置，现在开始愉快地使用吧！\r\n","categories":["Software"],"tags":["佳软","Filezilla"]},{"title":"Windows 中使用 rsync 同步文件","url":"/posts/2025/14AF74D.html","content":"rsync 是 Unix\r\n下的一款应用软件，它能同步更新两处计算机的文件与目录，并适当利用差分编码以减少数据传输量，可以实现增量同步。\r\n本文介绍如何在 windows 安装 rsync 并同步到 linux 中。\r\n\r\n安装\r\n在 Windows 中，使用 cwRsync -\r\nRsync for Windows ，可以在此处下载 cwrsync\r\nDownloads。\r\n可以进入到下载界面，选择合适版本，右键，然后复制下载链接，然后打开\r\nPowershell，输入 wget download-url 进行下载。\r\n复制目录\r\nrsync -avz --progress /cygdrive/d/ username@linuxHost:/targetDir/# 若上面的命令出错，可尝试使用下面命令rsync -avz -e &quot;/bin/ssh -i .ssh/id_rsa&quot; --progress /cygdrive/d/ username@linuxHost:/targetDir/\r\n\r\n/cygdrive/d/：cwRsync 使用 Cygwin 环境，Windows 的 D\r\n盘路径需要转换为 /cygdrive/d/\r\n-a：归档模式，保留文件权限、时间戳、符号链接等。\r\n-v：详细模式，显示详细信息。\r\n-z：压缩传输数据，节省带宽。\r\n--progress：显示每个文件的传输进度。\r\n\r\n参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\n\r\ncwRsync - Rsync for\r\nWindows\r\nwindows\r\n- rsync error: error in rsync protocol data stream (code 12) - Server\r\nFault\r\n\r\n","categories":["Software"],"tags":["rsync"]},{"title":"常用软件列表","url":"/posts/2020/18MAEYX.html","content":"本文将自己一些常用的软件及其安装方式记录下来，方便因为更换电脑后，可以快速安装。\r\n\r\n软件安装\r\n软件名称：scoop github：https://github.com/lukesampson/scoop\r\n命令行工具\r\n\r\n\r\n\r\n序号\r\n软件名称\r\n安装方式\r\n特点\r\n\r\n\r\n\r\n\r\n1\r\nvim\r\nscoop\r\n基于命令行的文本编辑器\r\n\r\n\r\n2\r\nsudo\r\nscoop\r\n命令行提权\r\n\r\n\r\n3\r\nbusybox\r\nscoop\r\n集成了一百多个最常用Linux 命令和工具\r\n\r\n\r\n\r\n数据库管理\r\n软件名称：Navicat\r\n下载地址：\r\nMarkdown\r\n\r\n\r\n\r\n序号\r\n软件名称\r\n安装方式\r\n特点\r\n\r\n\r\n\r\n\r\n1\r\ntypora\r\nscoop\r\n简洁，内存占用少，免费今后可能会收费\r\n\r\n\r\n2\r\nmarktext\r\nscoop\r\n功能丰富，内存占用高，MIT开源\r\n\r\n\r\n\r\n本人原来一直使用的是 typora，但是近来发现 marktext\r\n有很多体验很好的功能，所以开始改用后者，但是 marktext\r\n有个缺陷是，内存占用高。\r\n读书笔记\r\n软件名称：bookxnote\r\n下载地址：http://www.bookxnote.com/\r\n快速搜索\r\n软件名称：\r\n\r\neverything\r\nflow-launcher\r\n开源项目 wox 据说合并到 powertoys 中了，但是 powertoys\r\n有点不好用，有人根据 wox 开发了 flow-launcher\r\n\r\n安装方式： scoop\r\n全局手势\r\n软件名称：wgestures\r\n下载地址：https://www.yingdev.com/projects/wgestures\r\n浏览器\r\n软件名称：googlechrome\r\n安装方式：scoop\r\n开发工具\r\n\r\nvscode\r\nnginx\r\nMongoDB\r\nnodejs\r\nredis\r\ngit\r\n\r\n安装方式：scoop\r\n广告拦截\r\n软件名称：Adguard\r\n下载地址：https://adguard.com/zh_cn/welcome.html\r\n备注：收费\r\nDNS解析及广告拦截\r\n软件名称：AdguardHome\r\n下载地址：https://adguard.com/zh_cn/welcome.html\r\n解压缩软件\r\n软件名称：7zip\r\n安装方式：scoop\r\n同步软件\r\n软件名称：微力同步\r\n下载地址：http://www.verysync.com/\r\n备注：如果有开源洁癖的话，可以使用 sycthing\r\nnodeJs进程守护\r\npm2\r\n安装方式：npm\r\n视屏录制\r\n软件名称：\r\n\r\ncaptura\r\n小巧,但是使用了 ffmpeg，这个软件有点大\r\nobs-studio\r\n功能强大，可以编辑视屏\r\n\r\n安装方式：scoop\r\n视屏播放器\r\n软件名称：PotPlayer\r\n安装方式：scoop\r\n图片查看器\r\n软件名称：imageglass\r\n安装方式：scoop\r\n密码管理\r\n软件名称：KeePass\r\n安装方式：scoop\r\nPDF编辑\r\n\r\n\r\n\r\n软件名称\r\n安装方式\r\n\r\n\r\n\r\n\r\npdfsam\r\nscoop\r\n\r\n\r\npdfgear\r\npdfgear.com\r\n\r\n\r\n\r\n多台电脑共用一套鼠标键盘\r\n软件名称：MouseWithoutBorders\r\n安装方式：官网下载\r\n极客工具\r\n反编译\r\n软件名称：dnspy\r\n安装方式：scoop\r\n脱壳\r\n软件名称：de4dot\r\n安装方式：官网下载\r\n图片压缩\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名称\r\n下载地址\r\n\r\n\r\n\r\n\r\nImagine\r\nReleases ·\r\nmeowtec/Imagine (github.com)\r\n\r\n\r\n图压\r\nhttps://tuya.xinxiao.tech/#open-source\r\n\r\n\r\n\r\nWiki系统\r\n软件名称：docsify\r\n来源：https://www.jianshu.com/p/bbcbd2359974\r\n修改系统字体\r\n软件名称：MacType\r\n下载地址：https://www.mactype.net\r\nwin10 资源管理器扩展\r\n软件名称：极客多标签文件管理器\r\n下载地址：http://www.pcsuperx.com/ExplorerX\r\n文本编辑器\r\n软件名称：NotePadPlusPlus\r\n下载方式：scoop\r\n截图\r\n软件名称：snipaste\r\n安装方式：scoop\r\nwindows 服务封装\r\n软件名称：\r\n\r\nnssm\r\nwinsw\r\n\r\n安装方式：scoop\r\nnssm 介绍：http://phantom0301.cc/2016/07/19/NSSM\r\n中文搜索引擎\r\n软件名称：solr\r\n下载地址：https://solr.apache.org/\r\n安装为服务：https://www.sitecoreblog.cz/how-to-install-solr-as-a-windows-service\r\nISO启动引导程序\r\n软件名称：ventoy\r\n安装方式：scoop\r\nNPM镜像管理\r\n软件名称：nrm\r\n安装方式：npm install nrm -g\r\nYarn镜像管理\r\n软件名称：yrm\r\n安装方式：npm install yrm -g\r\n磁盘空间使用分析\r\n软件名称：SpaceSniffer\r\n安装方式：scoop install SpaceSniffer\r\n","categories":["Software"],"tags":["常用软件"]},{"title":"作息时间规划","url":"/posts/2022/3AYW43.html","content":"我不聪明，但愿意用努力和汗水，搏一条康庄大道。鉴于本人工作与专业基本不相关，所以计划至少学习\r\n1050 小时。现在是 2 月 23 日，按复习到 9 月 31 日算，每天需要保证 5\r\n小时的学习时长。\r\n\r\n作息时间安排\r\n每天必须保证不小于 5 个小时的学习。\r\n工作日作息时间表\r\n\r\n\r\n\r\n时间\r\n事件\r\n\r\n\r\n\r\n\r\n23:00-06:00\r\n洗漱+睡觉\r\n\r\n\r\n06:00\r\n起床\r\n\r\n\r\n06:00-06:20\r\n洗漱，出门必须保证20分之前出门\r\n\r\n\r\n06:20-06:40\r\n等公交，吃早餐\r\n\r\n\r\n06:40-08:30\r\n看书，上下车会耽搁时间，算 70 分钟\r\n\r\n\r\n08:30-12:00\r\n工作\r\n\r\n\r\n12:00-12:30\r\n吃饭\r\n\r\n\r\n12:30-13:20\r\n看书，计 50 分钟。如果因为工作耽搁，则不计入\r\n\r\n\r\n13:20-13:58\r\n休息\r\n\r\n\r\n14:00-18:00\r\n上班\r\n\r\n\r\n18:00-19:10\r\n回家，在车上看书，上下车会耽搁时间，算 30 分钟\r\n\r\n\r\n19:10-20:00\r\n炒菜，吃饭\r\n\r\n\r\n20:00-23:00\r\n看书，算 180 分钟\r\n\r\n\r\n23:00-06:00\r\n洗漱+睡觉\r\n\r\n\r\n\r\n\r\n工作日每天可学习：300 分钟\r\n\r\n休息日作息时间安排\r\n\r\n\r\n\r\n时间\r\n事件\r\n\r\n\r\n\r\n\r\n23:00-06:00\r\n洗漱+睡觉\r\n\r\n\r\n06:00\r\n起床\r\n\r\n\r\n06:00-07:00\r\n出门锻炼\r\n\r\n\r\n07:00-08:00\r\n洗澡，早餐\r\n\r\n\r\n08:00-12:00\r\n学习\r\n\r\n\r\n12:00-14:00\r\n午餐\r\n\r\n\r\n14:00-18:00\r\n学习\r\n\r\n\r\n18:00-20:00\r\n晚餐\r\n\r\n\r\n20:00-23:00\r\n自由安排\r\n\r\n\r\n23:00-06:00\r\n洗漱+睡觉\r\n\r\n\r\n\r\n\r\n每个休息日看 8 个小时\r\n\r\n注：\r\n\r\n自由安排时间用来陪老婆\r\n其它时间占用后，用自由时间来抵消\r\n自由时间可积累，用于挪用到其它时间处理紧急的事情\r\n\r\n","categories":["RegisteredStructure"],"tags":["一注结构专业","考试"]},{"title":"在 Docker 中安装 pure-ftpd 并配置虚拟用户","url":"/posts/2025/3YCE81Q.html","content":"本文介绍如何在 Docker 中安装\r\npure-ftpd，然后配置多个虚拟用户，实现对同一目录的读写权限控制。\r\n\r\n容器启动\r\n使用下面的 docker-compose 文件来启动容器：\r\nservices:  ftpd_server:    image: stilliard/pure-ftpd    container_name: pure-ftpd    ports:      - &quot;21:21&quot;      - &quot;30000-30009:30000-30009&quot;    volumes:      # remember to replace /folder_on_disk/ with the path to where you want to store the files on the host machine      - &quot;./data/data:/home&quot;      - &quot;./data/pure-ftpd:/etc/pure-ftpd&quot;      # ssl 证书      - &quot;./data/cert/cert.pem:/etc/ssl/private/pure-ftpd-cert.pem&quot;      - &quot;./data/data/cert/key.pem:/etc/ssl/private/pure-ftpd-key.pem&quot;    environment:      PUBLICHOST: &quot;xx.xx.xx.xx&quot;      FTP_USER_NAME: admin      FTP_USER_PASS: adminPassword      FTP_USER_HOME: /home/user_admin      # also for ssl/tls:      ADDED_FLAGS: &quot;--tls=2&quot;      FTP_PASSIVE_PORTS: 30000:30009 # 默认是 30000:30009, 可通过这个环境变量修改    restart: always\r\n启动命令为：sudo docker compose up -d\r\n添加不同权限的用户\r\n与 Window 不同的是，Linux 中 ftp\r\n用户的权限是通过文件的权限控制的。若我们要配置多个用户，且 A\r\n用户具有上传下载权限，B 用户只有下载权限，具体的步骤如下：\r\n\r\n进入容器\r\nsudo docker exec -it pure-ftpd bash\r\n创建两个用户\r\n# 管理(可读、可写)useradd ftpadmin -g ftpgroup -d /dev/null -s /sbin/nologin# 普通(只读)useradd ftpuser -g ftpgroup -d /dev/null -s /sbin/nologin\r\n创建两个虚拟用户\r\n创建两个虚拟用户，分别关联到实际的用户上\r\n# admin 关联到 ftpadmin 用户上，数据目录为 /data/sharepure-pw useradd admin -u ftpadmin -g ftpadmingroup -d /data/share# user 关联到 ftpuser 用户上，数据目录为 /data/sharepure-pw useradd user -u ftpuser -g ftpadmingroup -d /data/share# 保存到数据库pure-pw mkdb\r\n创建数据目录并设置权限\r\nmkdir -p /data/share# 将目录所有者改为 ftpadminchown ftpadmin:ftpgroup /data/share -R# 将目录设置仅所有者可读, 这样，ftpuser 对于目录 /data/share 只有读和执行权限，从而保证虚拟用户 user 只读chmod 755 /data/share\r\n\r\n其它\r\n当使用 docker compose up -d 重建容器后，需要进入容器执行\r\npure-pw mkdb 命令，否则登录时会报 503 错误。\r\n参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\n\r\nstilliard/docker-pure-ftpd:\r\nDocker Pure-ftpd Server\r\nPure-FTPd\r\n:: Pure-FTPd\r\nPure-ftpd\r\n如何配置多用户，且A用户具有上传下载权限，B用户只有下载权限？ - 啊里个东\r\n- 博客园\r\n\r\n","categories":["Software"],"tags":["Docker","pure-ftpd"]},{"title":"每日学习总结","url":"/posts/2022/3F4M78Z.html","content":"此处记录备考以来的所有情况。\r\n\r\n总结的主要内容为：\r\n\r\n作息时间说明\r\n学习时间说明\r\n复习知识点简要总结\r\n\r\n2022-02-23\r\n\r\n按时起床\r\n学习时间 &gt;= 5 h\r\n\r\n","categories":["RegisteredStructure"],"tags":["一注结构专业","考试"]},{"title":"先积跬步，再至千里","url":"/posts/2022/380JK61.html","content":"已经是 2022 年了，本人自从 2019\r\n年基础考过后，由于工作时间关系，一直没有报考专业考试。2020\r\n年正值疫情爆发，本应是准备考试的好时机，但是恰巧公司 BIM\r\n研发战略转向，开始开发基于网页的 BIM\r\n应用。由于本人在这方面完全是一个新手，不得不放弃考试，学习网页开发知识。而\r\n2021\r\n年由于职称评聘需要写论文、新房交付、并要准备结婚，考试又这样被搁置了一年。\r\n此时，春风渐暖，我寻思着，今年必须要发奋图强一次了，为至千里，先得积跬步。\r\n\r\n对于专业考试，在此之前只是略有耳闻，仅有的印象是很难、需要坚持。所以，在开始之前，需要借鉴前人的一些经验，然后根据自己情况，制定适合自己的学习计划。\r\n73分！个人一注专业经验，有目标才有动力\r\n\r\n该文章值得仔细拜读\r\n\r\n作者从 08 年毕业到 12 年，短短 4\r\n年，先后通过了结构基础，岩土基础，GRE，托福，一注结构专业考试。这份履历看得主人热血上涌，我也希望像他那样，活得充实精彩。\r\n还是自己的圈子太小，没有前人经验借鉴和激励，导致现在毕业已经 5\r\n年半，还是一条咸鱼，本领不够硬，工作能力也不突出。今后，要多与牛人交流，开拓自己的视野。\r\n时间安排\r\n提升自己工作效率，节约时间复习。\r\n复习流程\r\n\r\n第一阶段就是学习施岚青老师的专业考试应试指南\r\n先按应试指南的内容对照着规范熟悉各条款，在这个环节要注意各条款之间的关系，在规范上标注与这一条相关的其它条款的编号和页码，关键字写在书签上贴在规范书页的上方。\r\n举个例子，对于地下室顶板嵌固问题，混规、抗规、高规上可能都有涉及，而且分布在不同章节，比如地下一层与地上一层的刚度比比值，比如地下一层框架柱1.1倍，比如正负零框架梁的放大，比如正负零板的厚度、配筋率的要求。在每一条相关条款旁边列出其它相关条款的页码，就像网页上的超链接一样，构成一个互相引用的网络。这个不仅仅是为了考试的时候能够迅速便捷的找到其它相关条文，也是一个知识的整理和掌握的过程。\r\n第二阶段就是做模拟题\r\n一定要真正的定时定量模拟考试，越多越好。\r\n我用的是兰定筠老师的2012年一、二级注册结构工程师专业考试考前实战训练(第三版)\r\n。你也可以用历年真题或者其它模拟题。其实用什么书不重要，重要的是练习的过程。不能因为一些错误就认为这些习题不值得做。可能是结构设计工作的原因，我发现很多同行们喜欢抠细节，比如体积配箍率的计算到底是算到箍筋中线还是内皮等等。这些其实不必过多关心，毕竟计算误差一点点，哪种都可以。还是应该多着眼于大局。所谓的大局就是做题的速度和质量。要的不是知识点抠的准，要的是做题做得多做得快。\r\n\r\n临近考试\r\n临近考试的时候，我觉得应该把规范再熟悉一遍。\r\n做不到熟练掌握，也至少得做到“水过地皮湿”。\r\n其一是再次巩固计算题的出题点，看到某个计算题，就能知道它在考什么，尽快的找到计算题所考的公式和参数。熟记长度系数、截面稳定系数等等在规范中所在的位置以及相关的注意事项。对于可能的陷阱点也要烂记于心，比如体积配箍率时混凝土是不是C35以下、钢结构稳定系数求算钢材可能不是Q235的、砌体是不是水泥砂浆。\r\n其二是熟悉概念题的关键字。\r\n全面的掌握规范是不可能的，但是可以做到对大多数关键字的掌握。比如今年考的“规定作用下的水平地震力”，你不需要知道它的具体内容，你只要知道它大概在哪本规范的哪个章节就足够了。考试中看到这个关键字，快速检索大脑中的记忆，找到这个关键字在规范中的位置，然后对照条文和条文说明，就很容易应对概念题。\r\n其它准备\r\n\r\n注意休息\r\n注意锻炼身体\r\n准备好计算器\r\n\r\n一注结构复习经验（1）——\r\n9个月，顺利通过一注71分\r\n复习资料的准备\r\n\r\n在第一证书论坛上查看通过人的经验贴\r\n参考书：兰定筠的《一二级注册结构工程师专业考试应试技巧与题解》\r\n\r\n复习流程\r\n\r\n以兰的应试技巧与题解为主线去系统学习规范\r\n\r\n把兰书上的对规范条文的注意点誊写到规范相应条文处。\r\n先整体过一遍。难的可以先放一放，复习到一定深度后\r\n\r\n复习完兰的书，张的二、一级真题\r\n\r\n2016-02：张庆芳的《二级注册结构工程师专业考试历年试题和考试分析》\r\n2016-03-2016-05：张庆芳的《一级注册结构工程师专业考试历年真题.疑问解答.专业聚焦》\r\n\r\n一级真题+兰的模拟题+老朱的书\r\n定时且按考试要求做兰的21套题（当时给自己定的时间是：上午：混凝土16题90min，钢结构14题80min，砌体10题50min，预留20min涂卡；下午：木+地基基础16题90min，高层16题90min，桥梁8题40min\r\n预留20min涂卡，考试基本上也是按这个给自己分配的时间）。\r\n遇到不会的直接跳过，做完一科或者两科再对答案，完成一套后统计得分情况及把错题标出来。\r\n\r\n复习建议\r\n每个题翻到规范动手做，而不是看一看；加了班还要看书学习确实比较累，所以当时我是根据自己当天的状态选做哪一科的题目，比如太累了，状态不好就做砌体这些比较简单的科目，每天保证做题的数量，状态好就做混凝土这些计算量比较大的科目。\r\n定时定量做题，严格按到考试的要求做题。\r\n另外对规范的阅读贯穿在整个复习阶段，没有固定时间，不想做题，或者在办公室有时间，就把规范拿来翻一翻，读一读。\r\n对主要规范的二级标题基本上都比较熟悉\r\n如果决定考，就一定要坚持下去，三天打鱼两天晒网，基本没得戏得。\r\n考试带书\r\n\r\n全套规范\r\n兰的应试技巧下册\r\n教材类\r\n\r\n钢结构本科教材\r\n混凝土本科教材\r\n结构力学本科教材\r\n材料力学本科教材\r\n土力学、基础工程本科教材\r\n土木工程材料本科教材\r\n\r\n老朱的书\r\n\r\n一注结构专业71分经验之谈\r\n很多人考了好几年差1分2分的，都是以为自己实力到了只是运气差一点点，来年运气好了就过了，但是这样的人往往一而再再而三的死在了运气上，他寄希望于运气，而没有想过其实差1分2分有可能是自己的知识有结构性的缺陷，有可能是自己的解题思路做题方法有致命的缺陷，其实还差的远。\r\n一是看规范，几本对照着一起看，看条文说明，把同一个知识点的几本规范的条文说明对照着看。\r\n这几年的考题充分证明，条文说明是一定会考的，而且考的越来越多，很多知识点，你只看规范原文，没看条文说明，相当于没看，因为你看了也没用，你会的人不考啊，要都考你会的，怎么区别出人是老师你是考生啊。\r\n条文说明不仅要看，而且要把相关知识点几本规范的条文说明对照看，理解透，这样你才记得住，要不到时考试的时候你记得有看过，但硬是找不到在哪里，也不记得条文说明怎么说，那就只能说明你实力不济，花的时间不够了\r\n做兰的题目不是非要把他的题搞多透，而是要从他的题目中熟悉出题思路、了解人是怎么通过设置题目考查规范的知识点的、几个知识点是怎么串起来考的，练习到解题的能力、计算的速度，有些太难的题、感觉有错的题，我也囫囵吞枣，跳着过。\r\n基础没有很好的，也不建议做兰的题，以免打击信心，拉偏思维，只是建议做真题，多做几遍，再做几遍，从真题中延伸，对照着看规范。\r\n一注结构专业考试之天山六阳掌\r\n\r\n通过答题指导来快速熟悉规范\r\n通过真题加深对规范的理解和记忆，达到看题知规范的境界\r\n\r\n按考试要求答题\r\n学会使用计算器\r\n学会总结\r\n\r\n模拟题、真题穿插\r\n准备小抄\r\n\r\n经典题的计算步骤\r\n包括规范条目\r\n\r\n\r\n一级注册结构工程师复习经验四字经\r\n充分准备 规范为本 题海战术 坚持不懈\r\n对土木工程注册考试证书性价比的一点浅见，主观性很强\r\n又谈一级注册结构工程师复习经验by天空\r\n\r\n首先问自己为什么要考这个证书，如果不是从事结构设计，只是为了挂靠的钱，建议不要考了。可以考性价比高的证书：http://www.cectcc.com/thread-11717-1-1.html\r\n保证有足够的复习时间，到底多少算足够，因为基础不同，所以每个人情况不一。我觉得应该保证在500个小时左右的复习时间（不是绝对的，仅供参考，大概6个月时间）。\r\n处理好工作与考试的关系，如果可能建议在复习的这半年里尽量少做工程，可以让给其他同事，钱是永远赚不完的。\r\n争取家人的支持，家里的杂事在这半年内和你绝缘。\r\n规范为本，真题至少要过两遍，最后一遍一定要是自己动手按照真实考试的要求来做的。而且大家在每一次做真题的时候，建议按照新题来对待，不要想着我以前做过了，考的是什么什么。你就当是你从来没见过的题，重新去审题，然后去做。\r\n珍惜生活中的每一点空闲时间。\r\n\r\n对注册结构工程师参加培训辅导班的一些个人看法\r\n优点\r\n\r\n既然你决定报辅导班了，那么我想你肯定还是有通过的信念的。因为报辅导班，一般学费5000，住宿费5000，生活费2000，交通费1000，误工费10000，总计直接损失2.3万。你能下定决心花这个钱，说明你肯定会努力的。一个意志不坚的人或者只是为了凑数考试的人是不会去花这个钱的，当然不排除有冤大头，或者说叫活雷锋。花了这个钱之后，你平时复习不努力的时候你都会觉得非常愧疚，对不起自己的钱，对不起家人等等，所以你会而且也只能更加努力才对。\r\n参加了辅导班有老师对知识点做一个梳理，对规范知识点进行讲解或者总结，对其中的疑问进行解答，而且最主要的是可以对我们的问题进行讲解，当你有不会的问题时可以请教他们，而不会找不到人。这一点可能是很多人报辅导班的原因吧，因为自己身边找不到可以一起讨论的人，最主要的是找不到可以解答我们问题的人。而报了培训班之后，我们的很多问题可能很快就被解决，加上有人带路，复习效率会提高很多很多。\r\n参加了辅导班会有一个月的集中培训期，这一个月里你集中学习规范，其实就算老师讲得再差，也比你一边上班一边看书的效果要好很多很多。\r\n\r\n缺点\r\n\r\n费钱…费时间……大部分设计院每年789月份都是比较忙的，而且越到考试反而越忙，你几乎请不了假。\r\n去了辅导班之后你可能发现和你想的不太一样，虽然有人讲，虽然讲的人是大师，虽然你能听懂，但是做题还是不会，还是会做错，实际上还是需要你自己去理解。如果你报班之前没有自己先去复习，想指望在辅导班上才去学习，我想可能很难。规范的解读和大学教材不一样，你不提前做预习，去听也跟不上思路。\r\n辅导班的时候可能大部分或者说100%都是老师在讲，如果他不讲，那么我们会觉得我们的钱花得不值，如果讲，那么你自己消化或者练习的时间就短了，知识没变成自己的，也不行。而且我们既然报班了，总觉得有什么问题可以找老师问啊，但是这个恐怕要让你失望了吧，辅导班的老师应该是没有时间答疑的，因为他需要给更多的人讲课，如果有答疑时间的话，那么可能我们根本插不上话，因为毕竟是大班上课，不可能照顾到所有人，所以其实最终还是要靠我们自己。\r\n\r\n总体评价\r\n不要指望报辅导班会让你提高很多，在我看来辅导班最大的好处就是有一段集中学习的时间，如果你能拿出这段时间来自己复习也会提高很多，当然这里没有否定辅导班的作用，好的辅导班确实能大大提高复习效率，节省复习时间。\r\n如果非要报辅导班的话，我建议一定要自己复习一轮以上再去，建议在6、7月份参加，后面一定要留一个月的自我消化自我练习的阶段，否则意义也不大。\r\n最后其实还有很多人报辅导班的原因是看到了某某大师的辅导班通过率50%以上，这里我要提醒大家一下，那个数据首先你无法证明是真实的，如果真的是真实的，那么也是有可能的，因为报辅导班的人整体水平或者说基础要比一般人要强太多太多，很多都是考过多次的，很多都是差1、2分的。\r\n最后就是我知道的一个大师的辅导班的通过率是有水分的，这个大师相信很多人都知道，他的培训通过率不是通过人数/总的报名人数，而是通过人数/报分的人数，也就是说分母是那些考后告诉他自己成绩的人，而我们知道一般人没考过的话是不会和培训老师报分的，这个消息不是我瞎编的，而是事实。当然这么做的人不是我们的大师，而是他的代理人这么做的。\r\n目前比较好的培训班\r\n\r\n施岚青\r\n兰定筠\r\n张庆芳\r\n\r\n再次谈谈我的一级注册结构工程师复习经历、经验\r\n实际上我的复习经验在原一注论坛说了太多了，新的一注论坛再次总结下，希望可以能供大家参考。\r\n准备时间\r\n2011年4月-考试前夕\r\n准备规范\r\n单行本（小本）：荷载、木结构、混凝土、钢结构、地基基础、桩基础、高层、抗震、地基处理、桥梁通用规范、人行天桥以及一本规范合集。\r\n复习资料\r\n一级注册结构工程师历年真题、二级注册结构工程师历年真题、施岚青应试指南、张庆芳一级注册结构工程师历年真题、施岚青的抗震精讲。\r\n复习计划\r\n说实话我没有做计划，就是用施岚青的应试指南的页数/复习天数=每天看的页数。\r\n复习经历\r\n从2011年4月中旬开始复习的，因为4月之前有别的事情。4月到7月底一直在看规范和施岚青的应试指南，这期间没有做真题。\r\n因为我的基础较差，很多规范之前都没有接触，所以我先把所有规范从头到尾看了一遍，包含条文说明，很多人说规范条文太难看了，看不下去，这个我觉得还是应该多读几遍的。\r\n通读完规范之后，开始看应试指南（之所以选这本书，是因为认识的人都推荐这本，当时也没去选择就买了这本），应试指南很细致，很多东西不看他的书根本想不到。当时的计划是先把应试指南看一遍，争取看懂（不要觉得这个很快，至少我在看的时候感觉很费劲，几乎所有题都不会，全是靠看答案），然后第二轮再做一遍。毕竟只有通过自己动手才能发现更多的问题。\r\n看施岚青指南的时候，把规范要注意的部分都标在规范上了，中间复习的过程没什么好说的了，总之除了上班就是看书，这期间其他的事情都很少去做，比如逛街、去超市之类的能省就省了。在这里要特别感谢我媳妇，她的毅力要比我好太多。复习期间看过几次电影，但是很少。就这样日子很快到了7月底，我发现应试指南还没有看完。所以8月份抓紧时间草草看了下，施岚青的桥梁部分几乎都放弃了，因为感觉太难了，很多都不懂，所以考试之前实际上我都已经放弃了。\r\n对别人来说考试是48/80,但是我在心里已经定下了我的标准48/72。这时候已经8月多了，马上就要考试了，而现在我除了看题之外都没有自己动手做过题，所以这时候很着急。这时候选择了做二级真题，白天做一套，晚上对答案和写总结，这段时间我和我媳妇每天晚上基本上就在住的地方吃炒饭，吃饭的时候看非诚勿扰，什么时候看完，什么时候才吃完然后再做总结。\r\n看完施岚青的应试指南，做二级题感觉还行，那时候的做题速度大概是3个小时能做完，昨晚之后认真核对每一道题，哪里错了，为什么错的，都标上了。\r\n同时也在规范上标注上，错的地方在规范上划一个大大的叉号。二级题好像只有06年没做，其他年的大概得分是48左右，基本上可以保证48以上，只有一年好像不及格。那时候错误总结里写得最多的就是：审题不严，很多已知条件看错，或者看错了所求量。\r\n做完二级题目之后，开始做规范总结，贴上标签（也有人叫规范索引，总之差不多），贴标签这个工作觉得简单，但是实际上挺难做的，等动手时才发现想得太简单了，哪些要做、哪些不做、做在什么地方。都应该想好的。原则就是把常用的贴在最醒目的地方。\r\n做完这些之后，我和我媳妇开始讲规范，是的没错，就是讲规范。对每一本单行本规范，从第一条开始讲，比如规范1.1.1条考试的时候应该怎么做，计算过程是什么，比如先算什么，再算什么，有哪些有注意的地方。\r\n做完这些之后已经9月份了，而且这时候还没有做一级的真题，本来想认真做一遍的，但是算了下时间不够，所以就是看一题写下思路和大概过程，然后对比答案，比较下，做完之后再在规范上补充，就这么“做完”一级真题，发现很多真题没看懂，也找不到人问，所以在考前几天又买了张庆芳的真题（当时觉得这本书真贵啊），买了之后发现很多不懂的题目看张的都能明白。最后考前再浏览了下规范，并再次浏览了规范。\r\n总结\r\n有些话不知道在复习经历里怎么写，就再列个总结吧。看了上面的经历，可能很多人觉得好像很轻松，但是从我个人经历来看，真的非常累。但是现在回头对比下我的经历和很多朋友的经历，看起来我的似乎有点轻松过头了。仔细思考了下，觉得我通过除了运气之外，可能得益于以下几点：\r\n\r\n施岚青的应试指南非常认真地看了。\r\n充分做了规范总结，对于常考的计算，在规范上全部写出了计算过程和注意事项。常用的表格也做了一些。比如2012年大家反映说，题目没给混凝土的强度。而我实际上在每一条需要用到强度的条文所在页都标上了。再举个例子：抗规P64，公式6.3.9，这道题常错的地方就是fc的取值，那除了在规范上标记fc≥c35之外，我在规范上还写上了混凝土的强度表C20\r\n16.7 C25 16.7 C30 16.7 C35\r\n16.7,这样绝对不会犯错。类似的情况还有很多，总之考试之前把你能想到的错误都标记上，会大大降低考试犯错的概率。\r\n桥梁在看施岚青的时候放弃了，但是看了历年真题之后觉得考得都不是太难，拿个常规的4-5分还是可以的。所以着重复习了和桥梁历年真题相关的条文，通用规范必须好好看下，这个分数很好拿的。\r\n\r\n答题顺序\r\n因为我自己已经习惯了按自然顺序作答，而且也没法去判断考试哪年哪些简单，哪些难。所以还是从头开始做的。基本上保证6分钟一道题，看完不知道什么意思的题，不要有任何犹豫，直接放弃。不要觉得可惜，也不要去想我放弃这么多还能过吗？放弃是为了先保证把基本的题目，也就是简单的分数先拿到手。做完简单的再去做其他的，基本上不会浪费太多时间的。这么做不一定是最好的方式，但是肯定可以保证你把简单的题都做完，而不会出现考完之后说“后面的题我还没看呢”或者“后面简单的题瞪着眼没时间做”。**\r\n考后感受\r\n\r\n考试还是以规范为根本，规范永远是最重要的，而且也是考场上最有力的武器,不要尝试任何脱离规范的行为。\r\n一定要大量练习。这一点我没有做好，因为时间不够了，但是我觉得很重要，而且从大多数通过的经验来看，这点是毋庸置疑的。只看不动手是不行的。有的即使你做了总结、做了标注，但是不做题还是体会不深的。另外通过做题可以练习下答题顺序，不要到了考场上再去练习！！！\r\n考试的时候几乎看完题目之后就得条件反射地想到怎么去做，直接动笔，不可能有太多的时间让你去慢慢考虑，我先做什么，再做什么，要注意什么，这些工作一定要在考试之前做好。\r\n考试的时候几乎没有时间去再复核的，所以争取一次成功吧，怎么做到呢？请参考第二条。\r\n做什么事情之前最好考虑好，如果决定要做了，请一定坚持下去，不要半途而废。\r\n\r\n考试结果和不足\r\n2011年的考试做了71道题，都是有计算过程的，当然包含有一些明显错误的。上午做了39，得分33，下午做了32，得分26，下午高层放弃了很多。实际上得分并不高，虽然很多人会说过了48就行了，但是分数的高低毕竟可以反映对规范的理解程度。\r\n考过之后回头总结，感觉有以下不足：\r\n\r\n练习太少太少了，做题的时候明显觉得吃力。\r\n对规范还是不太熟悉，主要表现在概念题答得不好，下午的题很多都没找到。这点是和复习时间有关的，因为复习时间短，所以我把精力放在常规题目上。\r\n\r\n其他感言\r\n2011年考完之后很多人发帖说2011年史上最难之类的话，我看2012年考试之后也有人这么说。实际上每年都会有难题的，这点朱炳寅在博客上都已经说过了，简单的多少，中等的多少，难的多少，都是有梯度的。如果全是简单的，全国人都考过了，这个证书还会有人需要吗？这个是选拨考试，都考1+1=2的问题能区分开吗？\r\n另外有人说如果让命题组的人来做，他们8个小时肯定做不完。从我个人经历来看，我觉得复习充分，做完绝对是没有问题的，但是要想80分都拿到那应该是不可能的。现在让你做高中甚至初中的题我想大部分人是无法拿满分的，难道说我们都不合格？都应该去重读吗？\r\n总之，一注考试永远是属于那些做好充分准备的人，现在的考试想不复习或者简单复习就通过几乎是不可能的事情。\r\n一级注册结构工程师专业考试之如何复习规范\r\n枯燥期\r\n先通读一边规范，我说的通读不是看小说的那种读法，是一字一句的来读，任何条文都不要略过，包含规范开头的名词解释。看的时候一定要对照规范后面的条文说明对比来看，通过条文说明你会明白规范规定的原因，其次很多考题考的就是规范条文说明，所以一定要看。\r\n需要说明的是，很多规范条文说明很长很长，很枯燥，但是我还是建议读一遍，因为是第一次看规范，肯定很多东西都不懂，不懂的内容建议标记出来，也不要忙着去查或者去问（当然你愿意也可以），等第二遍的时候再去解决，很多时候问题在你读完整本规范时已经明白了。\r\n需要说明的是：\r\n\r\n因为是第一遍，而且是通读，所以没有必要去仔细体会每一条规范，只要有个印象就行（当然你也可以仔细去理解）。\r\n很多人都会觉得看完之后前面的内容都忘了，很烦躁，其实这是大多数人的反应，至少我就属于这种大众类型。\r\n\r\n欣喜期\r\n通读完第一遍之后，我建议对照应试指南来看规范（指南买谁的都行，施岚青、兰定筠的都可以），通过辅导书来理解规范，这时候你会发现原来考题可以这么出，原来还有这么多地方自己都没看到。\r\n加固期\r\n看完指南之后，建议再精读一遍规范，从头到尾再读一遍，这次你可以分清轻重了，重要的条文多花时间，多读几遍，次要的条文少花时间。这次阅读顺便去解决第一次读规范留下的疑问。\r\n练习期\r\n精读完规范之后，可以尝试去做题了。\r\n因为标题已经写明了是如何看规范，所以其他的也不再啰嗦了。\r\n规范一定要多读多读多读，重要的条文甚至可以朗读，每一次阅读你可能都会有不同的收获。\r\n据说要通过考试，每本规范至少读10遍以上。\r\n2019一注复习经验交流会录音：男神专场\r\n刘妈妈\r\n\r\n一定要有一颗强大内心，坚持下去\r\n高效的复习方法\r\n\r\n选择一本参考书，推荐看朱炳寅(老朱)的四大名著\r\n定制计划，如果不够自律，加入一个群共同进步\r\n\r\n要有良好考试的心态，这是一个通过性考试，不要在难题上浪费时间\r\n\r\n简单题全拿\r\n中等题\r\n难题\r\n\r\n\r\n谭浩\r\n\r\n每天最少 3.5 h，合计 1000 个小时\r\n心理准备，要有坚定的信念，当成今年最重要的事情准备\r\n书籍选择\r\n\r\n天空全套，一级二级真题，计算手册\r\n老朱的高抗规，高钢规和四大名著\r\n\r\n每周都要规划好，每天学习到晚上12点\r\n复习计划\r\n\r\n1月-4月：看视屏学规范，根据条文解析来熟悉规范\r\n建议从荷载规范开始看\r\n4.9-5.12：做二级真题一遍\r\n\r\n不会的，上第一证书真题模块查看答案\r\n\r\n5.13-7.12: 做一级真题，二级过度到一级，真的很难\r\n7.13-10月，过真题第二遍或三遍\r\n查看其他人的总结\r\n\r\n天空的总结\r\n易错点总结\r\n\r\n考前看错误，考前做半套题找手感\r\n\r\n经验总结\r\n\r\n坚持\r\n多做真题，要把真题练熟，争取到3个小时内达到70分以上，计算量超大题8分钟以内\r\n先有初步计划，然后再慢慢细化，并执行下去，认真复习很快就过去了\r\n做笔记，看天空等大神怎么做笔记的\r\n多交流，建立个小群一起努力\r\n考试策略，三轮、计算量大跳过\r\n先从砌体做，因为坑比较少\r\n考试时，要有知识体系，看到一个题，就知道要考什么\r\n可以将规范目录背一背\r\n跟着大神意见走\r\n\r\n\r\n蹦蹦\r\n\r\n考试准备\r\n\r\n复习时间一定要 800-1000 小时\r\n规范的准备，要买单行本，不要买合集\r\n准备一个好的计算器，考试时，再买一个计算器备用\r\n要会用计算器解二元一次方程\r\n找一个qq群，用来共同进步\r\n\r\n天空群\r\n\r\n网站：一注论坛，规范条文版块、真题版块\r\n\r\n有时候想不出来的时候，看一下版块\r\n\r\n全程用真题来复习，天空的全套书\r\n做真题，做完真题后，将考点划到规范上面去\r\n\r\n\r\n\r\n","categories":["RegisteredStructure"],"tags":["一注结构专业","考试"]},{"title":"考试复习计划","url":"/posts/2022/36TCWHD.html","content":"通过在一注论坛参考多篇考试经验，自己总结了一套适合自己节奏和复习方案出来，规划如下：\r\n\r\n考试基本信息\r\n考试时间分配\r\n考试时间为上、下午各4小时，但不确定各科目在上、下午的配题数量。\r\n考试分值分布情况\r\n\r\n\r\n\r\n序号\r\n类型\r\n题量\r\n考试用时分配待定\r\n\r\n\r\n\r\n\r\n1\r\n钢筋混凝土结构\r\n15\r\n\r\n\r\n\r\n2\r\n钢结构\r\n14\r\n\r\n\r\n\r\n3\r\n砌体结构与木结构\r\n14\r\n\r\n\r\n\r\n4\r\n地基与基础\r\n14\r\n\r\n\r\n\r\n5\r\n高层建筑、高耸结构与横向作用\r\n15\r\n\r\n\r\n\r\n6\r\n桥梁结构\r\n8\r\n\r\n\r\n\r\n\r\n\r\n合计 80 分，48 分合格\r\n\r\n复习计划\r\n充分准备、规范为本、题海战术、坚持不懈\r\n按应试指南复习\r\n参考书：\r\n兰定筠的《一二级注册结构工程师专业考试应试技巧与题解》\r\n技巧：\r\n先按应试指南的内容对照着规范熟悉各条款，在这个环节要注意各条款之间的关系，在规范上标注与这一条相关的其它条款的编号和页码，关键字写在书签上贴在规范书页的上方。\r\n举个例子，对于地下室顶板嵌固问题，混规、抗规、高规上可能都有涉及，而且分布在不同章节，比如地下一层与地上一层的刚度比比值，比如地下一层框架柱1.1倍，比如正负零框架梁的放大，比如正负零板的厚度、配筋率的要求。在每一条相关条款旁边列出其它相关条款的页码，就像网页上的超链接一样，构成一个互相引用的网络。\r\n详细计划：\r\n该书共有 2091 页，计划在 2 个月内看完，则每天要至少要看 35\r\n页，按周结算进度，每周至少到看 44 页。\r\n计划从 2022-02-28 开始执行。\r\n详细通读规范\r\n定时定量模拟，越多越好\r\n看到某个计算题，就能知道它在考什么，尽快的找到计算题所考的公式和参数。\r\n熟记长度系数、截面稳定系数等等在规范中所在的位置以及相关的注意事项。\r\n对于可能的陷阱点也要烂记于心，比如体积配箍率时混凝土是不是C35以下、钢结构稳定系数求算钢材可能不是Q235的、砌体是不是水泥砂浆。\r\n复习注意事项\r\n\r\n把兰书上的对规范条文的注意点誊写到规范相应条文处。\r\n每个题翻到规范动手做，而不是看一看\r\n从题目中\r\n熟悉出题思路、了解人是怎么通过设置题目考查规范的知识点的、几个知识点是怎么串起来考的，练习到解题的能力、计算的速度\r\n\r\n其它技巧\r\n买不同颜色的笔来做笔记\r\n","categories":["RegisteredStructure"],"tags":["一注结构专业","考试"]},{"title":"一文理清设计组合的使用","url":"/posts/2022/243ZBZ4.html","content":"在进行设计时，不同的设计状况或设计条件，采用不同的设计组合。但是看规范的时候，规范里零零散散这个地方讲一点，那个地方提一句，看到最后，自己都混乱了。所以，本文对荷载组合进行系统的梳理，让人能很方便的区分各个组合的使用。\r\n\r\n荷载组合分类\r\n目前共有 6 种荷载组合，分别是：\r\n\r\n基本组合\r\n偶然组合\r\n地震组合\r\n标准组合\r\n频遇组合\r\n准永久组合\r\n\r\n其中，前三种仅用于\r\n承载能力极限状态设计，后三种仅用于\r\n正常使用极限状态设计。\r\n设计状况对应极限设计的类型\r\n\r\n\r\n\r\n设计状况\r\n承载能力\r\n正常使用\r\n耐久性\r\n\r\n\r\n\r\n\r\n持久状况指使用时正常的情况\r\n应\r\n应\r\n宜\r\n\r\n\r\n短暂状况\r\n应\r\n按需\r\n\r\n\r\n\r\n偶然状况\r\n应\r\n可不\r\n可不\r\n\r\n\r\n地震状况\r\n应\r\n按需\r\n\r\n\r\n\r\n\r\n承载能力极限与荷载组合\r\n\r\n\r\n\r\n设计状况\r\n荷载组合\r\n\r\n\r\n\r\n\r\n持久状况`指使用时正常的情况\r\n基本\r\n\r\n\r\n短暂状况\r\n基本\r\n\r\n\r\n偶然状况\r\n偶然\r\n\r\n\r\n地震状况\r\n地震\r\n\r\n\r\n\r\n正常使用极限与荷载组合\r\n\r\n\r\n\r\n设计状况\r\n荷载组合\r\n\r\n\r\n\r\n\r\n不可逆 正常使用极限状态设计\r\n标准\r\n\r\n\r\n可逆 正常使用极限状态设计\r\n频遇\r\n\r\n\r\n长期效应是决定因素\r\n准永久\r\n\r\n\r\n\r\n各个荷载组合计算的区别\r\n\r\n\r\nimage-20220226232739346\r\n\r\n参考\r\n\r\nGB50068-2018《建筑结构可靠性设计统一标准》\r\n\r\n","categories":["RegisteredStructure"],"tags":["一注结构专业","考试"]},{"title":"一张图弄懂规范中各个作用值的区别","url":"/posts/2022/3DC5WC5.html","content":"规范中各个作用值的描述，绕来绕去，让人看得云里雾里的，通过仔细研读，将其总结如下图。\r\n\r\n\r\n\r\nimage-20220225233730878\r\n\r\n\r\n说明：\r\n不同的设计条件时，可变荷载会取不同的值作为代表值。各个代表的值的大小关系如下：\r\n标准值 &gt;= 组合值 &gt;= 频遇值 &gt;= 准永久值\r\n\r\n参考：\r\n\r\nGB 50068-2018 《建筑结构可靠性设计统一标准》P7-8\r\n\r\n","categories":["RegisteredStructure"],"tags":["一注结构专业","考试"]},{"title":"希腊字母大小写及发音","url":"/posts/2022/3DAB2TW.html","content":"希腊字母表是希腊语中使用的字母，其广泛应用到学术领域，如数学、物理、生物、天文等学科。在规范里面大量使用希腊字母表示特定值，所以，学会发音后，可以记得更牢。\r\n\r\n\r\n\r\n\r\n序号\r\n大写\r\n小写\r\n英文\r\n汉字注音\r\n英语音标注音\r\n\r\n\r\n\r\n\r\n1\r\nΑ\r\nα\r\nalpha\r\n阿尔法\r\n/'ælfə/\r\n\r\n\r\n2\r\nΒ\r\nβ\r\nbeta\r\n贝塔\r\n/'bi:tə/或/'beɪtə/\r\n\r\n\r\n3\r\nΓ\r\nγ\r\ngamma\r\n格玛\r\n/'gæmə/\r\n\r\n\r\n4\r\nΔ\r\nδ\r\ndelta\r\n德尔塔\r\n/'deltə/\r\n\r\n\r\n5\r\nΕ\r\nε\r\nepsilon\r\n埃普西龙\r\n/'epsɪlɒn/\r\n\r\n\r\n6\r\nΖ\r\nζ\r\nzeta\r\n泽塔\r\n/'zi:tə/\r\n\r\n\r\n7\r\nΗ\r\nη\r\neta\r\n艾塔\r\n/'i:tə/\r\n\r\n\r\n8\r\nΘ\r\nθ\r\ntheta\r\n西塔\r\n/'θi:tə/\r\n\r\n\r\n9\r\nΙ\r\nι\r\niota\r\n埃欧塔\r\n/aɪ'əʊtə/\r\n\r\n\r\n10\r\nΚ\r\nκ\r\nkappa\r\n堪帕\r\n/'kæpə/\r\n\r\n\r\n11\r\n∧\r\nλ\r\nlambda\r\n兰姆达\r\n/'læmdə/\r\n\r\n\r\n12\r\nΜ\r\nμ\r\nmu\r\n谬/穆\r\n/mju:/\r\n\r\n\r\n13\r\nΝ\r\nν\r\nnu\r\n拗/奴\r\n/nju:/\r\n\r\n\r\n14\r\nΞ\r\nξ\r\nxi\r\n克西\r\n/kˈsai/ 或 /ˈzaɪ/\r\n\r\n\r\n15\r\nΟ\r\nο\r\nomicron\r\n欧米可戎\r\n/əuˈmaikrən/或 /ˈɑmɪˌkrɑn/\r\n\r\n\r\n16\r\n∏\r\nπ\r\npi\r\n派\r\n/paɪ/\r\n\r\n\r\n17\r\nΡ\r\nρ\r\nrho\r\n若\r\n/rəʊ/\r\n\r\n\r\n18\r\n∑\r\nσ\r\nsigma\r\n西格马\r\n/'sɪɡmə/\r\n\r\n\r\n19\r\nΤ\r\nτ\r\ntau\r\n套\r\n/tɔ:/或 /taʊ/\r\n\r\n\r\n20\r\nΥ\r\nυ\r\nupsilon\r\n宇普西龙\r\n/ˈipsɪlon/或 /ˈʌpsɪlɒn/\r\n\r\n\r\n21\r\nΦ\r\nφ\r\nphi\r\n弗爱\r\n/faɪ/\r\n\r\n\r\n22\r\nΧ\r\nχ\r\nchi\r\n凯/柯义\r\n/kaɪ/\r\n\r\n\r\n23\r\nΨ\r\nψ\r\npsi\r\n普赛\r\n/psaɪ/\r\n\r\n\r\n24\r\nΩ\r\nω\r\nomega\r\n欧米嘎\r\n/'əʊmɪɡə/或 /oʊ'meɡə/\r\n\r\n\r\n\r\n","categories":["RegisteredStructure"],"tags":["一注结构专业","考试"]},{"title":"结构力学常用公式表大全","url":"/posts/2022/1VMAW6B.html","content":"本文主要收集了常用结构的力学公式，方便日常使用。\r\n\r\n常用截面几何与力学特征\r\n基本介绍\r\n\\(I\\)\r\n称为截面对主轴（形心轴）的截面惯性矩 ( \\(mm^4\\) )。基本计算公式如下： \\[\r\nI = \\int_A y^2 \\cdot dA\r\n\\] \\(W\\) 称为截面抵抗矩 ( \\(mm^3\\)\r\n)，它表示截面抵抗弯曲变形能力的大小，基本计算公式如下： \\[\r\nW = \\frac{I}{y_{max}}\r\n\\] \\(i\\) 称截面回转半径\r\n(mm)，其基本计算公式如下： \\[\r\ni = \\sqrt{\\frac{I}{A}}\r\n\\]\r\n\r\n\r\n上列各式中，\\(A\\) 为截面面积 (\r\n\\(mm^2\\) )，y\r\n为截面边缘到主轴（形心轴）的距离 (mm)，\\(I\\) 为对主轴（形心轴）的惯性矩。\r\n上列各项几何及力学特征，主要用于验算构件截面的承载力和刚度。\r\n\r\n\r\n常用公式\r\n\r\n\r\n常用截面几何与力学特征表\r\n\r\n单跨梁的内力及变形\r\n简支梁的反力、剪力、弯矩和挠度\r\n\r\n\r\n简支梁内力\r\n\r\n悬臂梁的反力、剪力、弯矩和挠度\r\n\r\n\r\n悬臂梁内力\r\n\r\n一端简支另一端固定梁的反力、剪力、弯矩和挠度\r\n\r\n\r\n一端简支另一端固定梁内力\r\n\r\n两端固定梁的反力、剪力、弯矩和挠度\r\n\r\n\r\n两端固定梁内力\r\n\r\n外伸梁的反力、剪力、弯矩和挠度\r\n\r\n\r\n外伸梁内力\r\n\r\n等截面连续梁的内力及变形表\r\n二跨等跨梁的内力和挠度系数\r\n\r\n\r\n二跨等跨梁的内力和挠度系数\r\n\r\n\r\n在均布荷载作用下：\r\n\\(M = 表中系数 \\times ql^2\\)；\\(V ＝ 表中系数 \\times ql\\)；$ w =表中系数\r\n$。\r\n在集中荷载作用下：\r\n\\(M ＝表中系数 \\times Fl\\)；\\(V ＝表中系数 \\times F\\)；\\(w =表中系数\\times\r\n\\frac{Fl^3}{100EI}\\)。\r\n\r\n不等跨连续梁的内力系数\r\n二不等跨梁的内力系数\r\n\r\n\r\n二不等跨梁的内力系数\r\n\r\n\r\n$ M＝表中系数 ql_1^2\\(；\\)\r\nV＝表中系数 ql_1$；\r\n\\(M_{max}\\)、\\(V_{max}\\)\r\n表示它为相应跨内的最大内力。\r\n\r\n三不等跨梁内力系数\r\n\r\n\r\n三不等跨梁内力系数\r\n\r\n\r\n$ M＝表中系数 ql_1^2\\(；\\)\r\nV＝表中系数 ql_1$；\r\n\\(M_{max}\\)、\\(V_{max}\\)\r\n为荷载在最不利布置时的最大内力。\r\n\r\n","categories":["RegisteredStructure"],"tags":["一注结构专业","考试"]},{"title":"markdown 中 LaTeX公式语法大全","url":"/posts/2022/1ERZT1V.html","content":"公式声明\r\n行内公式：\r\n$公式$\r\n多行公式\r\n$$\\begin公式\\end$$\r\n\r\n空格\r\n\r\n\r\n\r\n名称\r\n描述\r\n语法\r\n\r\n\r\n\r\n\r\n\\(a \\qquad b\\)\r\n两个 quad 空格：2 个 m 的宽度\r\n$a \\qquad b$\r\n\r\n\r\n\\(a \\quad b\\)\r\nquad空格：1 个 m 的宽度\r\n$a \\quad b$\r\n\r\n\r\n\\(a\\ b\\)\r\n大空格：1/3 个 m 的宽度\r\n$a\\ b$\r\n\r\n\r\n\\(a\\;b\\)\r\n中等空格：2/7 个 m 的宽度\r\n$a\\;b$\r\n\r\n\r\n\\(a\\,b\\)\r\n小空格：1/6 个 m 的宽度\r\n$a\\,b$\r\n\r\n\r\n\\(ab\\)\r\n正常\r\n$ab$\r\n\r\n\r\n\\(a\\!b\\)\r\n负空格\r\n$a\\!b$\r\n\r\n\r\n\r\n操作符\r\n\r\n\r\n\r\n名称\r\n语法\r\n\r\n\r\n\r\n\r\n+\r\n+\r\n\r\n\r\n-\r\n-\r\n\r\n\r\n\\(\\times\\)\r\n$\\times $\r\n\r\n\r\n\\(\\div\\)\r\n$\\div $\r\n\r\n\r\n\\(\\dfrac{x}{y}\\)\r\n$\\dfrac{x}{y} $\r\n\r\n\r\n\\(\\frac{x}{y}\\)\r\n$\\dfrac{x}{y} $\r\n\r\n\r\n$ $\r\n$\\sqrt[n]{x} $\r\n\r\n\r\n\\(x^y\\)\r\n$x^y $\r\n\r\n\r\n\\(\\cdot\\)\r\n$\\cdot $\r\n\r\n\r\n\r\n符号\r\n\r\n\r\n\r\n名称\r\n语法\r\n\r\n\r\n\r\n\r\n$ $\r\n$\\pi \\approx 3.14159 $\r\n\r\n\r\n$, 0.2 $\r\n$\\pm \\, 0.2$\r\n\r\n\r\n$ $\r\n$\\dfrac{0}{1} \\neq \\infty$\r\n\r\n\r\n$0 &lt; x &lt; 1 $\r\n$0 &lt; x &lt; 1$\r\n\r\n\r\n$0 x $\r\n$0 \\leq x \\leq 1$\r\n\r\n\r\n$x $\r\n$x \\geq 10$\r\n\r\n\r\n$, x (1,2) $\r\n$\\forall \\, x \\in (1,2)$\r\n\r\n\r\n$, x $\r\n$\\exists \\, x \\notin [0,1]$\r\n\r\n\r\n$A B $\r\n$A \\subset B$\r\n\r\n\r\n$A B $\r\n$A \\subseteq B$\r\n\r\n\r\n$A B $\r\n$A \\cup B$\r\n\r\n\r\n$A B $\r\n$A \\cap B$\r\n\r\n\r\n$X Y $\r\n$X \\implies Y$\r\n\r\n\r\n$X Y $\r\n$X \\impliedby Y$\r\n\r\n\r\n$a b $\r\n$a \\to b$\r\n\r\n\r\n$a b $\r\n$a \\longrightarrow b$\r\n\r\n\r\n$a b $\r\n$a \\Rightarrow b$\r\n\r\n\r\n$a b $\r\n$a \\Longrightarrow b$\r\n\r\n\r\n$a b $\r\n$a \\propto b $\r\n\r\n\r\n\r\n希腊字母\r\n参考\r\n\r\nMarkdown and\r\nLaTeX introduction\r\nlatex-project\r\nLaTeX\r\nWiki\r\nLearn\r\nLaTeX in 30 minutes\r\n\r\n","categories":["RegisteredStructure"],"tags":["markdown","LaTeX"]},{"title":"如何求最大弯矩","url":"/posts/2022/3SP0JGM.html","content":"在荷载进行作用组合时，往往需要先求内力，然后再进行组合。下方分享如何快速地求得最大弯矩。\r\n\r\n基本方程法\r\n通过弯矩方程来求最大弯矩。\r\n\r\n\r\nimage-20220321220445565\r\n\r\n如上图所示，由于荷载及支反力均对称于梁跨的中点，因此，两支反力（图a）相等，由平衡方程\r\n$ F_y = 0$，得：\r\n\\[\r\n\\begin{align}\r\nF_A=F_B=\\dfrac{ql}{2}\r\n\\end{align}\r\n\\] 取距左端（坐标原点）为 x\r\n的任意横截面（图a），则梁的剪力和弯矩方程为： \\[\r\n\\begin{align}\r\nF_s(x) = F_A-qx = \\dfrac{ql}{2}-qx \\qquad x\\in[0,l]\\\\\r\nM(x) = F_Ax-qx\\dfrac{x}{2}=\\frac{qlx}{2}-\\dfrac{qx^2}{2} \\qquad x\r\n\\in[0,l]\r\n\\end{align}\r\n\\]\r\n微分关系法\r\n通过弯矩、剪力与分布荷载集度间的微分关系来求解最大弯矩。 \\[\r\n\\begin{align}\r\n\\dfrac{dM(x)}{dx} = F_s(x) \\\\\r\n\\dfrac{d^2M(x)}{dx^2}=q(x)\r\n\\end{align}\r\n\\]\r\n\r\n剪力图上某点处的切线斜率等于该点处荷载集度的大小\r\n弯矩图的某点处的切线斜率等于该点处剪力的大小\r\n\r\n换言之，某点处截面的弯矩等于该点之前的\r\n剪力图的面积。\r\n从 1\r\n中的剪力图中，我们可以知道，弯矩最大点在跨中。该方法有个优点是将高次方程转为低次方程来计算，降低了复杂度，在手算时很方便。\r\n叠加原理法\r\n当所求参数（内力、应力或位移）与梁上荷载为线性关系时，由几项荷载共同作用时所引起的某一参数，就等于每项荷载单独作用时所引起的该参数值的叠加。\r\n\r\n\r\nimage-20220321223214213\r\n\r\n当该参数处于同一平面内同一方向\r\n时，叠加即为代数和。若处于不同平面或不同方向，则为几何和。\r\n参考\r\n\r\n材料力学\\(\\cdot\\)剪力图和弯矩图\r\n\r\n","categories":["RegisteredStructure"],"tags":["一注结构专业","考试"]},{"title":"桁架中零杆的判断","url":"/posts/2022/EBMGE2.html","content":"本文总结了桁架中零杆的判断方法，在分析桁架内力时，若能首先确定其中的零杆，可以简化后续杆件的分析。\r\n桁架中的零杆虽然不受力，但却是保持结构坚固性所必需的杆件。因为桁架中的荷载往往是变化的，在一种荷载工况下的零杆，在另一个工况下就有可能承受荷载。\r\n\r\n判断方法\r\n\r\n不在同一条直线上的两杆节点上若没有荷载作用，两杆均为零杆\r\n不共线的两杆结点，若荷载沿一杆作用，则另一杆为零杆\r\n无荷载作用的三杆节点，若两杆在一直线上，则第三杆为零杆\r\n对称桁架在对称荷载作用下，对称轴上的 K\r\n形结点若无荷载，则该结点上两根斜杆为零杆\r\n对称桁架在反对称荷载作用下，与对称轴重合或者垂直相交的杆件为零杆\r\n\r\n参考\r\n","categories":["RegisteredStructure"],"tags":["一注结构专业","考试"]},{"title":"求简支梁的绝对最大弯矩","url":"/posts/2022/2CGPR3T.html","content":"在设计承受移动荷载的结构时，须求出每一截 面内力的最大值\r\n(最大正值和最大负值)。连接各截面内力最大值的曲线称为内力包络图。包络图是结构设计中重要的工具，在吊车梁、楼盖的连续和桥梁的设计中应用很多。\r\n包络图表示各截面内力变化\r\n的极值，在设计中是十分重要的。弯矩包络图中最高的竖距称为绝对最大弯矩，它代表在一定移动荷载作用下梁内可能出现的弯矩最大值。\r\n需要特别注意，最大弯矩一般出现在\r\n跨中附近，但不一定是跨中。\r\n\r\n简支梁均布荷载作用的最大弯矩\r\n当全梁布满匀布荷载，其绝对最大变矩也就是匀布静荷载作用下的跨中最大弯矩:，其值为\r\n\\[\r\nM_{跨中} = \\frac{1}{8}ql^2\r\n\\]\r\n简支梁集中荷载组作用的最大弯矩\r\n如果简支梁上作用的是一组移动的集中荷载，求梁的绝对最大弯矩较难。\r\n有人认为，如果分别把梁的各截面的最大弯矩值求出，加以比较，取其中的最大值，不就可以确定绝对最大弯矩值了吗?\r\n这种想法是可行的，可实际涉及到计算并不容易，甚至是无法进行的。\r\n那么到底用什么方法可以计算其绝对最大弯矩呢？\r\n原理\r\n我们知道，荷载在任一位置时，梁的弯矩圆的顶点永远发生在集中荷载下面。因此，可以断定，绝对最大弯矩必定发生在某一集中荷载的作用点处。把这一集中荷载记为\r\n\\(P_k\\)。那么在一组移动的集中荷\r\n载中，哪一个会成为 \\(P_k\\) 呢?\r\n事实上，一般情况下，在一组移动的集中荷载\r\n中，使梁的跨中截面产生最大弯矩的荷载即是产生绝对最大弯矩的荷载\r\n\\(P_k\\)。\r\n确定了 \\(P_k\\)\r\n荷载后，我们即可遵照下面的方法\r\n来计算绝对最大弯矩了。下图表明，梁上所有荷载(包括 \\(P_k\\) 在内) 的合力 R 与 \\(P_k\\) 恰好位于梁的跨中截面 C\r\n两侧的对称位置时，\\(P_k\\)\r\n所在截面的弯矩最大。\r\n\r\n\r\nimage-20220324090538380\r\n\r\n此时简支梁的绝对最大弯矩为： \\[\r\n\\begin{align}\r\nM_{max} = \\frac{R}{4l}(l-a)^2-M_k \\tag{2-1}\r\n\\end{align}\r\n\\]\r\n\r\nl，跨长\r\nR，梁上实有荷载的合力\r\na，梁上实有荷载的合力 R 与 \\(P_k\\)\r\n荷载间的距离。当 \\(P_k\\) 荷载 在合力 R\r\n之左时，a 取正值；当 \\(P_k\\) 在 R\r\n之右时，a 取负值\r\n\\(M_k\\)，\\(P_k\\) 以左荷载对 \\(P_k\\) 点的力矩之和，是一常数\r\n\r\n求解步骤\r\n\r\n求出能使梁中点截面的弯矩发生最大值的临界荷载 \\(P_k\\)；\r\n计算梁上合力 R 及其与 \\(P_k\\)\r\n的距离 a；\r\n求解合力时，只需将力摘出来，利用静力平衡方程求解。\r\n移动荷载，使 R 与 \\(P_k\\)\r\n对称分布与中点两侧。若无荷载移出或移入梁，则用式（2-1）计算绝对最大弯矩；若有荷载移出或移入，则从第\r\n2 步重新计算。\r\n\r\n参考\r\n\r\n简支梁的绝对最大弯矩.pdf\r\n第五节\r\n简支梁的绝对最大弯矩 (5any.com)\r\n\r\n","categories":["RegisteredStructure"],"tags":["一注结构专业","考试"]},{"title":"电信光猫改桥接模式","url":"/posts/2021/11CAJEB.html","content":"原使用移动宽带，由于移动宽带无法申请动态公网IP，所以家里拟改用电信宽带。在电信师傅上门安装时，我告诉他我需要光猫桥接，然而师傅一脸为难地告诉我，电信无法改桥接。我一下秒懂了。\r\n\r\n本不想折腾，现在只能自己想办法改了。好在安装师傅人给力（诚挚感谢安装师傅！），向他要了光猫后台的超级管理员账号密码以及自己宽带的账号密码。好了，现在言归正传，正式开始。\r\n\r\n最重要的是要知道光猫的超级管理员密码才行\r\n\r\n登陆光猫后台\r\n为了能够登陆后台，路由器要改成DHCP模式，然后连接路由器的网络。当然，如果电脑有网口，直接接一根网线到光猫上也可以。\r\n在浏览器中输入：192.168.1.1\r\n\r\n查看 INTERNET 信息\r\n进入后台后，点击【网络】-&gt;【宽带设置】\r\n\r\n从图中可以看见，现在封装类型显示的IPoE(有的是PPPOE，这两个都是拨号模式），连接模式为路由，说明是在光猫端拨的号。\r\n在改桥接之前一定记住 VLAN ID 的值。\r\n改为桥接模式\r\n由于自己的连接模式可以修改，于是将连接模式改为桥接，点击保存就可以了。\r\n如何从光猫端中获取宽带密码\r\n\r\n致谢\r\n本文是对文章 光猫改桥接如此简单\r\n的实践，诚挚感谢作者！\r\n感谢电信安装师傅告知超管密码和宽带密码，减少了后期修改的麻烦，诚挚感谢！\r\n感谢电信的支持，打电信客服电话，有的客服也会帮忙找技术人员处理！\r\n感谢电信对公网IP的支持，这是选他家的唯一理由！\r\n","categories":["Tricks"],"tags":["宽带"]},{"title":"4条文件命名的黄金规则","url":"/posts/2021/2840RVF.html","content":"我一直在折腾自己的文件树命名规则，有时候按年划分，有时候按领域划分，有时候，又按类型划分。往往复复，最后，头炸了，文件也炸了，只能将以前的文件尽归于\r\nxx年之前 里。我开始思考，我这样分类的意义在哪儿？\r\n\r\n原来，我需要的是快速检索，能够第一时间直达它。\r\n这一切的改变都基于 everything，everything\r\n可以秒搜任何文件。所以，我通过规范自己的文件命名，利用 everything\r\n实现了文件直达的目的。\r\n1. Why?\r\n我们的逻辑一直是，先说「Why」，文件命名也是一样。\r\n上手先不要想这个文件的名字，\r\n而是先想想：如果我现在就立刻删除这个文件，为什么不可以删除？\r\n如果，我实在找不出理由，那就删了吧。\r\n如果，找的出理由，把理由写下来作为文件名即可，例如：\r\n「3月8日女王节素材」「李姐18号出差广州要用」「A公司X项目合同草稿等批准」……\r\n这类名称看似很随意，但是已经抓住了某类文件的核心问题：为什么存在？\r\n尤其针对：临时文件，这种命名已经足够了。\r\n多数文件最后都会有自己的最终归宿，要么被纸质归档，\r\n要么存在电子邮箱，要么进入XX\r\nERP系统，要么被扔到一个叫做「归档」的文件夹里。\r\n临时文件，占据了我们工作的相当大一部分，只要想清楚「存在的理由」不难命名，而这类文件最后的归宿都是「废纸篓」。\r\nWhen / Who / What\r\n对于上述以外的「非临时」文件，那么意味着有长久保存的必要，虽然可能也是从一份临时文件演变过来的。\r\n例如「合同草稿」最后变为「盖章合同扫描件」。\r\n长久要保存的文件，如果是类型固定的，数量又庞大的，就适合 When / Who /\r\nWhat 这个规则。\r\n我们还是以「合同」文件为例，\r\n如果有大量合同文件要归档，我们可以开一个文件夹，名叫「历史合同」，然后合同文件都扔进去，但要体现出每份合同的\r\n不同之处。最常见的区分维度是：\r\n\r\nWhen：合同日期（或到期日）\r\nWho：和谁签的合同\r\nWhat：关于什么事情的合同\r\n\r\n例如：「20190601.A公司.X项目1期合同.pdf」\r\n不仅局限于「合同」，常规的工作文件，几乎都适合这个套路，包括但不限于：周报，销售记录，统计表格，会议记录，协议备忘，申请表格\r\n……\r\n\r\n不同的信息用 . 分隔\r\n\r\n更多的「客观标签」\r\n如果 When / Who / What\r\n已经不能满足了，可以考虑添加一些固定的「标签」来描述。\r\n所谓「标签」就是一些经常会用到词眼。\r\n例如：如果我们的工作文件和地域\r\n有很强的关系，可以考虑「北京」「上海」「广州」……之类的标签。\r\n这种标签直接附加在文件标题后即可。\r\n例如：3月销售报告#广州.xls, 海外代理商名单#NY.pdf ……\r\n不仅仅是「地域」，任何一个对我们业务有帮助的客观属性，都可以作为一类「标签」的参考。\r\n但重点是对业务有帮助，不要为了分类而去分类，这是完全不可取的。\r\n之所以称之为「客观标签」那是因为，这个「标签」描述的是客观内容，无论谁都会得出相同的结论。好处就是，我这份文件的「接收方」绝不会对描述产生歧义。\r\n比方说，想找「北京」数据文件的人，只要看到了文件名就不会去找标着「广州」标签的文件，即使用\r\nEverything 搜索 也能精确的得到所需内容。\r\n\r\n标签用 # 开头表示\r\n\r\n适当的「状态标签」\r\n个人认为，这是4条规则中，含金量最高的标签。\r\n「状态标签」是什么意思呢？ 就是文件在「工作流」内的附加信息。\r\n例如：Office系统200条快捷键技巧#完成稿.pdf,\r\nA客户信息简介#高净值.ppt，XX项目计划书#已批准.docx，\r\n静态的文件并没有什么「状态」，\r\n而实际上很多工作文件由于牵涉到「工作流」，因而都是「动态」的。随着时间的推移，流程阶段会产生变化，业务的价值本身也会起伏，文件也会有生命周期，最后可能变得毫无价值。\r\n所以，如果这份文件要跟着流程「走」，最好加上「状态标签」，让使用它的人，清楚的知道这份文件的价值所在。\r\n参考文章\r\n我们实践总结的\r\n4条「文件命名」的黄金规则，文档/表格/邮件/幻灯 都适用\r\n","categories":["Tricks"],"tags":["文件命名"]},{"title":"摩智键盘蓝牙使用说明","url":"/posts/2022/1W9B310.html","content":"很久以前买了一个蓝牙键盘（Mozhi，摩智），当时闲充电麻烦，就一直用的有线，今天突然想改无线、切换下光效，却忘记了怎么配置，然后联系卖家，发现卖家厂家都已经倒闭了。最后通过回忆与尝试，摸索了出来，遂将其总结如下：\r\n\r\n蓝牙连接\r\n\r\n先打开蓝牙，在后侧有个开关，拨向数字键盘方向\r\n长按 Fn + Tab 键，直到 Esc\r\n闪烁，同时 scroll lock 也会亮起来\r\n通过电脑的蓝牙连接就可以了\r\n\r\n\r\n该键盘有3个蓝牙信道，按 Fn+1~3\r\n可以切换，不同的信道，可以连接不同的设备，方便切换。\r\n\r\n有线连接\r\n将键盘后侧的开关拨向 esc 键方向，然后连接有线即可。\r\n快捷键\r\n键盘的快捷键有：Fn+(F1~F11、↑↓、-=)\r\n修改灯光\r\nFn + insert 键循环切换灯光\r\nFn + -= 灯速调节\r\n","categories":["Tricks"],"tags":["蓝牙键盘"]},{"title":"深入原理学习汽车驾驶","url":"/posts/2022/1ZBGNQC.html","content":"本文从理论出发，深度剖析驾驶原理，从而从容面对各种复杂工况。\r\n\r\n说明\r\n本文章采用的汽车数据为（单位 mm）：\r\n\r\n\r\n\r\n车长\r\n车宽\r\n轴距\r\n前轮距\r\n后轮距\r\n轮胎\r\n\r\n\r\n\r\n\r\n4650\r\n1860\r\n2712\r\n1565\r\n1565\r\n225/60 R18\r\n\r\n\r\n\r\n车库尺寸为：5.8m x 3m\r\n汽车转弯\r\n转弯半径\r\n\r\n\r\nimage-20220427134427047\r\n\r\n汽车转弯时如上图所示，其中：\r\n\r\nL：车总长\r\na：前轴至车头距离\r\nl：轴距\r\nc：后轴至车尾距离\r\nb：车身宽度\r\nR：汽车转弯时最小外半径\r\nr：汽车转弯时最小内半径\r\nW：转弯时所需道路宽度\r\n\\(\\alpha\\)：汽车前内轮转角\r\n\\(\\beta\\)：汽车前外轮转角\r\n\r\n\\(\\alpha\\) 与 \\(\\beta\\) 的关系\r\n在转弯时，前面两个轮子的转弯角度是不一样的，因为汽车在行驶过程中(直线和转弯时候)，每个车轮的运动轨迹必须符合他的自然运动轨迹，从而保证轮胎与地面始终处于纯滚动状态。\r\n他们之间的关系为：\r\n \\[\r\ncot\\alpha - cot\\beta = K/L\r\n\\]\r\n\r\n\\(\\beta\\) - 汽车前外轮转角\r\n\\(\\alpha\\) - 汽车前内轮转角\r\nK - 两主销中心距\r\nL - 轴距（上图中）\r\n\r\n\r\n具体的原理可以参考阿克曼几何。\r\n\r\n最小内侧半径 r\r\n最小内侧半径为右后轮外侧处的半径，其公式如下： \\[\r\n\\begin{aligned}\r\ntan \\alpha = l/r \\\\\r\nr= l/tan\\alpha=l \\cdot ctan \\alpha\r\n\\end{aligned}\r\n\\]\r\n最大外侧半径 R\r\n最大外侧半径为左车头的半径，根据勾股定理有： \\[\r\n\\begin{aligned}\r\nR^2 &amp;=(l+a)^2+(b+r)^2 \\\\\r\nR^2 &amp;=(l+a)^2+(b+b.ctan\\alpha)^2 \\\\\r\n所以：R &amp;= \\sqrt{(l+a)^2+(b+b.ctan\\alpha)^2}\r\n\\end{aligned}\r\n\\] ### 转弯道路宽度\r\n\\[\r\n\\begin{aligned}\r\nW = R -r\r\n\\end{aligned}\r\n\\]\r\n内轮差\r\n在汽车行驶过程中，前内轮能过去的地方，后轮不一定能通过，所以需要使用内轮差来进行判断。即当障碍物垂直于内轮的距离大于内轮差时，后轮肯定也可以通过。\r\n内轮差的计算公式如下： \\[\r\nd_{内轮差} = r/cos \\alpha - r\r\n\\]\r\n汽车转弯时最大速度\r\n由物理学公式： \\[\r\n\\begin{aligned}\r\nF_{离心力} &amp;=m\\times a\\\\\r\na &amp;=\\omega ^2 \\cdot r = v^2/r \\\\\r\n\\end{aligned}\r\n\\]\r\n\r\nF-离心力\r\nm-汽车质量\r\n\\(\\omega\\)-角速度\r\n\\(v\\)-速度\r\nr-半径\r\n\r\n\\[\r\n\\begin{aligned}\r\n\\therefore v= \\sqrt{F_{离心力} \\cdot r/{m}}\r\n\\end{aligned}\r\n\\]\r\n汽车在转弯过程中，通过汽车与地面的摩擦力来克服汽车的离心力，所以有：\r\n\\[\r\n\\begin{aligned}\r\n\\because F_{摩擦} &amp;= \\mu \\cdot m \\cdot g \\\\\r\n\\therefore v &amp;= \\sqrt{\\mu \\cdot g \\cdot r}\r\n\\end{aligned}\r\n\\]\r\n\r\n\\(\\mu\\) -\r\n汽车与需的摩擦系数，不同类型的路面其值不同\r\ng- 重力加速度，可取 \\(9.8 \\\r\nm/s^2\\)\r\n\r\n常用数值表\r\n根据上述公式，计算了一些常用转向角对应的值，方便取用（单位：m）。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n内轮角 \\(\\theta\\) (单位：度)\r\nr \\((l \\cdot ctan \\alpha)\\)\r\n\\(d_{内轮差} \\ (r/cos \\alpha -\r\nr)\\)\r\nl = 2.712\r\n\r\n\r\n\r\n\r\n5\r\n11.4 l\r\n0.04 l\r\nr=31.0, d=0.1\r\n\r\n\r\n10\r\n5.7 l\r\n0.09 l\r\nr=15.4, d=0.2\r\n\r\n\r\n15\r\n3.7 l\r\n0.13 l\r\nr=10.1, d=0.4\r\n\r\n\r\n20\r\n2.7 l\r\n0.18 l\r\nr=7.5, d=0.5\r\n\r\n\r\n25\r\n2.1 l\r\n0.22 l\r\nr=5.8, d=0.6\r\n\r\n\r\n30\r\n1.7 l\r\n0.27 l\r\nr=4.7, d=0.7\r\n\r\n\r\n35\r\n1.4 l\r\n0.32 l\r\nr=3.9, d=0.9\r\n\r\n\r\n40\r\n1.2 l\r\n0.36 l\r\nr=3.2, d=1.0\r\n\r\n\r\n\r\n倒车入库轨迹\r\n\r\n\r\nimage-20220427214126353\r\n\r\n倒车入库如上图所示，参数说明如下：\r\n\r\nd: 倒车时车尾距离目标车库边界的距离\r\ne: 开始倒车时车侧边距离车库入库线距离\r\nf: 车库入库线距离圆心的竖向距离\r\ng: 车库宽度\r\n\r\n通过结合汽车转弯半径图示，d、e、f 值如下：\r\nd：\r\n由几何关系得 \\[\r\n\\begin{aligned}\r\nd &amp;= r-(g-b)/2\r\n\\end{aligned}\r\n\\] f：\r\n由勾股定理得 \\[\r\n\\begin{aligned}\r\nr^2 &amp;= d^2+f^2  \\\\\r\nf &amp;= \\sqrt{r^2-d^2} \\\\\r\n\\end{aligned}\r\n\\] f 按连分数法求解： $$\r\n\\[\\begin{aligned}\r\n当 \\ s &amp;= a^2+b \\ (a^2 &gt;= b) \\ 时 \\\\\r\n有 \\ \\sqrt{s} &amp;= a+ \\frac{b}{a+\\sqrt{s}} \\\\\r\n\r\n\\therefore f &amp;= r + \\frac{-d^2}{r+r+0}\r\n（按一层近似计算,f值会偏大）\\\\\r\nf &amp;= r + \\frac{-d^2}{2r}\r\n\\end{aligned}\\]\r\n$$\r\ne:\r\n由几何关系得 \\[\r\n\\begin{aligned}\r\ne = r-f\r\n\\end{aligned}\r\n\\] 在倒车入库时，一般关心的值是 d 和\r\ne，倒车时一般满打方向盘，所以 \\(\\theta\\) 取最大值（35度）。\r\n按《汽车库设计规范》JGJ100-98第4.1.4条规定：小型汽车与左右两侧墙面的最小距离应为0.6m，与前后墙面的最小距离应为0.5m。(g-b)/2\r\n按取常量 0.6m，从而可以计算得： $$\r\n\\[\\begin{aligned}\r\nd &amp;= 1.4l - 0.6 \\\\\r\n\r\nf &amp;= 0.7l +0.6 - \\frac{0.129}{l} \\\\\r\n\\because &amp; \\  \\frac{0.129}{l} \\ 太小，舍去 \\\\\r\n\\therefore f&amp;=0.7l+0.6 \\\\\r\ne &amp;= r-f = 0.7l-0.6\r\n\\end{aligned}\\]\r\n$$\r\n对于本文所使用的车型，可以得： \\[\r\n\\begin{aligned}\r\nf&amp;=0.7l+0.6 = 0.7*2.712+0.6 = 2.2272 \\\\\r\n\\end{aligned}\r\n\\] 由于在推导 f 过程中，使用连分数法时只计算到第一层，现在再用 f\r\n值迭代到第二层，于是有： \\[\r\n\\begin{aligned}\r\nf &amp;= r + \\frac{-d^2}{r+r+\\frac{-d^2}{r+\\sqrt{2.2272}}} \\\\\r\nr &amp;= 1.4l = 3.7968 \\\\\r\nd &amp;= 1.4l - 0.6 = 3.1968 \\\\\r\n\\\\\r\n\\therefore f&amp;= 1.991 \\\\\r\ne &amp;= r-f=1.8018\r\n\\end{aligned}\r\n\\] 结论：\r\n对于轴距为 2.7m 左右的车，其车轮后轴距车库边线距离至少应为\r\n3.1968m，侧边距离入库边线至少为 1.8018m。\r\n当起始位置非图示水平，且车辆位于水平位置左侧时，上述值会相应的减少。\r\n侧方停车轨迹\r\n\r\n\r\nimage-20220502130259206\r\n\r\n其中，蓝色线代表后轮轨迹，绿色线代表前轮轨迹。\r\n在进行右侧方位停车时，主要有以下步骤：\r\n\r\n自己的车与右侧库边线保持 30cm 距离\r\n在后轴越过目标车库边线时，开始向右满打方向盘\r\n待到车身与入库边线程 48度角（建议45~48度）时，反向打满方向盘\r\n即可一把倒车入库\r\n\r\n入库时车辆左侧道路最小宽度 \\(h\\)\r\n$$\r\n\\[\\begin{aligned}\r\nR_{界外} &amp;= r + 0.3 + b + h  \\\\\r\nR_{界外}^2 &amp;= (r+0.3+b)^2 + (l+a)^2 \\\\\r\n\r\n\\therefore R &amp;= \\sqrt{(r+0.3+b)^2 + (l+a)^2} \\\\\r\nh &amp;= \\sqrt{(r+0.3+b)^2 + (l+a)^2} - r -0.3 - b\r\n\\end{aligned}\\]\r\n$$\r\n对于不同的车型，可以代入上述公式，计算其左侧距离。\r\n本文中所用车型参数按卡式计算得，\\(h=1.22m\\)。\r\n一把出库时最小车前距 \\(L_2\\)\r\n\\[\r\nL2 = r \\times tan \\gamma\r\n\\]\r\n\r\n为什么 \\(\\gamma\\) 建议取 45~48\r\n度呢？\r\n可以通过公式证明，但是比较复杂，笔者就不再这里证明了。\r\n\r\n车距判断\r\n在行车过程中，在车内如何判断车头各部位的距离也非常重要。\r\n\r\n\r\nimage-20220502143520209\r\n\r\n\r\nL1- 驾驶员垂直于车头的距离\r\nL2 - 驾驶员垂直于车身的左侧距离\r\nL3- 驾驶员垂直于车身的右侧距离\r\nH1- 地面距车头右边界高度\r\nH2- 地面距车头左边界高度\r\nH3- 驾驶员眼睛距地面高度\r\n\r\n由上图可知，视野中，周围的障碍物在视野中必须低于前车的高度，才不会与自己的车剐蹭。在实际中，可以在车内寻找特征点判断车距。\r\n行车安全距离控制\r\n\r\n\r\n\r\n车速\r\n距离\r\n\r\n\r\n\r\n\r\n$v $100km/h\r\n\\(D \\ge 100m\\)\r\n\r\n\r\n\\(100km/h \\ge v \\ge 60 km/h\\)\r\n\\(D=v\\)\r\n\r\n\r\n\\(60km/h \\ge v \\ge 40\\)\r\n50m\r\n\r\n\r\n\\(v \\lt 40 km/h\\)\r\n30m\r\n\r\n\r\n\r\n上表中仅为正常行驶状态下的参考值，\r\n在实际行车中，最好按照反应时间来根据自身条件进行估算，其公式如下： \\[\r\nT = T_{反应时间} + T_{刹车时间}+T_{制动后与前车安全距离时间等效}\r\n\\] T 一般取 3 秒。\r\n参考\r\n了解阿克曼转向原理的作用\r\n标准车库尺寸是多少\r\n","categories":["Tricks"],"tags":["汽车驾驶"]},{"title":"使用草料二维码免费生成挪车码","url":"/posts/2024/2Z6NVCZ.html","content":"\r\n\r\nimage-20240222222605912\r\n\r\n一些车主为了方便挪车，往往会在车上留下自己的电话，方便其他人及时与自己取得联系。直接展示电话号码的形式，会使号码非常容易泄露，从而遭受广告骚扰。\r\n因此，可以将挪车信息转换成二维码的形式，避免电话号码直接曝光，从而保护隐私。\r\n\r\n读者使用 草料名片二维码生成器\r\n(cli.im) 来生成名片二维码，然后贴到前窗玻璃上，二维码效果如下：\r\n\r\n","categories":["Tricks"],"tags":["二维码","挪车码"]},{"title":"最全家庭关系称呼汇总","url":"/posts/2023/28RRCMN.html","content":"亲戚称呼是指以自己为中心所确定的亲属成员，是建立在血亲姻亲基础上的亲属之间相互称呼的名称、叫法。它是以本人为轴心的确定亲属与本人关系的标志。\r\n汉族的亲戚关系条理例分明尊卑有序：比自己长一辈的称呼有姨父叔伯姑舅，同辈的有兄弟姐妹嫂等等，下一辈有侄甥等等。中国人由于姻亲而产生的亲戚关系相当庞杂，本文将逐一梳理，既是解惑，亦是传承。\r\n\r\n关系计算器\r\n亲戚关系计算器手机版\r\n亲戚关系计算器电脑版\r\n参考\r\n本文参考以下文章，在此表示诚挚谢意！\r\n\r\n亲戚关系称呼\r\n中国人亲戚关系图表 在线家庭亲戚关系计算器 (fuhaoku.net)\r\n中国亲戚关系计算器\r\n亲戚称谓计算器 亲戚称呼大全 (passer-by.com)\r\ngithub.com/mumuy/relationship/\r\n\r\n","categories":["Tricks"],"tags":["Tricks"]},{"title":"同一个Model中多个相同的参考显示不同的层组合","url":"/posts/2019/159N1WD.html","content":"\r\n\r\n同参考显示不同图层1.png\r\n\r\n在进行二维出图的时候，我们通常会将几张图纸放到一个 Sheet\r\n中，那么，如何在不同的图纸显示不同的图层组合呢？\r\n\r\n问题描述\r\n假设 “图纸汇总\" Sheet 中有 3 张图纸，分别是 ”图A“、”图B“ 和 \"图C\"。\r\n这三张图参考同一个名为 ”直线Model“ 的 Model  ”直线“ Model 中有三条线，分别在\r\n\"Line1\"、”Line2“、”Line3“ 这三个图层中。  现在希望在 \"图纸汇总\" 中的 \"图A\" 中显示\r\n\"Line1\" 和 ”Line2“ 图层，在 ”图B“ 显示 ”Line2“ 和 ”Line3“ 图层，在 ”图C“\r\n中显示 \"Line1\" 和 ”Line3“ 图层。 如下图所示：\r\ngraph LR;0[图纸汇总]--包含--&gt;11[图A]0--包含--&gt;12[图B]0--包含--&gt;13[图C]11--参考--&gt;21(直线Model)12--参考--&gt;2113--参考--&gt;2121--包含--&gt;31[Line1图层]21--包含--&gt;32[Line2图层]21--包含--&gt;33[Line3图层]11-.显示参考模型中的.-&gt;3111-.显示参考模型中的.-&gt;3212-.显示参考模型中的.-&gt;3212-.显示参考模型中的.-&gt;3313-.显示参考模型中的.-&gt;3113-.显示参考模型中的.-&gt;33\r\n解决方案\r\n\r\n打开图纸的 sheet;\r\n选择需要修改的元素，长按右键，在弹出菜单中选择\r\nActive。这个功能的意思是在当前 Model 中激活参考，实现在当前 Model\r\n中对参考进行编辑。 \r\n打开图层显示管理器，根据需要，开关不同的图层。 \r\n长按右键，在弹出菜单中选择 DeActive\r\n取消激活，便完成了一张图纸的修改。\r\n如果有需要，可以采用上述 2-4\r\n步骤，对所有需要修改的图纸进行操作。\r\n\r\n效果展示\r\n\r\n\r\n同参考显示不同图层1.png\r\n\r\n声明\r\n本文首发于李有福呀，转载请注明出处。\r\n","categories":["Bentley","UseSkill"],"tags":["MS应用","MS","李有福呀"]},{"title":"如何制作 Bentley 软件的离线安装包","url":"/posts/2019/33DD0CG.html","content":"制作 Bentley\r\n产品的离线安装包\r\n打开命令行，进入到 安装文件.exe 所在目录，然后执行\r\n*.exe /layout 进行安装。\r\n\r\n以安装 OBD 为例，假设安装文件为 obdu9.exe，位于系统的\r\n下载目录中，则安装命令为：\r\ncd ~cd downloads./obdu9.exe /layout\r\n声明\r\n本文首发于李有福呀，转载请注明出处。\r\n","categories":["Bentley","UseSkill"],"tags":["MS应用","MS","李有福呀"]},{"title":"命名表达式可使用的函数汇总","url":"/posts/2020/1S5QGSS.html","content":"收集了 ms 中一些可用的命名表达式（Named Expression）方法。\r\n\r\nexpression_symbols\r\n","categories":["Bentley","UseSkill"],"tags":["ORD","NamedExpression"]},{"title":"打开系统隐藏的管理员功能","url":"/posts/2020/1DD84QT.html","content":"\r\n打开系统隐藏的管理员功能\r\n从 [ 快速访问工具栏 ]\r\n中选择管理时，将显示“管理”工作流选项卡。选项卡、工具组和工具按工作流从左到右排列。\r\n缺省情况下，仅当激活文件是由\r\nMS_GUIDGNLIBLIST、_USTN_SYSTEM_GUIDGNLIBLIST、MS_DGNLIBLIST 或\r\n_USTN_DGNLIBLIST_SYSTEM 配置变量指定的 DGN 库文件 (*.dgnlib) 时，“管理”\r\n工作流才可用。\r\n如果希望“管理”工作流始终可用，要将功能变量\r\n_USTN_CAPABILITY &lt; +CAPABILITY_UI_ALWAYSSHOWADMINWORKFLOW\r\n添加到 组织配置文件 (standards.cfg) 中。\r\n如果希望该工作流仅适用于特定的工作集，请将该功能变量添加到\r\n工作集配置文件 中。\r\n如果希望该工作流仅适用于特定的工作空间，请将该功能变量添加到\r\n工作空间配置文件 中。\r\n声明\r\n本文首发于李有福呀，转载请注明出处。\r\n","categories":["Bentley","UseSkill"],"tags":["MS应用","MS","李有福呀"]},{"title":"如何删除 ORD 中的工作空间","url":"/posts/2022/T3NMZE.html","content":"在日常使用中，我们可能会由于误操作，在公司定制的\r\nworkspace（工作空间）\r\n中创建了一个多余的工作空间，那么要如何删除它呢?\r\n\r\n假设需要删除的工作空间为 useless, 如下图所示：\r\n\r\n\r\nimage-20220314194931015\r\n\r\n找到工作空间存储的文件夹位置，下列中为\r\nC:\\sw_Bentley\\OpenRoads\\WorkSpaces， 删除其中的\r\nuseless 文件夹和 useless.cfg 配置文件。\r\n\r\n可以通过打开新建工作空间界面，来获取其保存的位置。\r\n\r\n\r\n\r\nimage-20220314194812625\r\n\r\n重启 ORD 即可完成对工作空间的删除。\r\n","categories":["Bentley","UseSkill"],"tags":["Bentley"]},{"title":"超级快捷键使用说明","url":"/posts/2021/192XQSC.html","content":"超级快捷键是一款可以让你在使用 Bentley 的产品时，拥有和 CAD\r\n一样的快捷键体验的插件。\r\n\r\n🌈演示\r\n\r\n\r\n\r\n😃优点\r\n\r\n命令直达\r\n所有操作皆可通过敲入一个快捷键来调用\r\n按字母顺序模糊匹配\r\n快捷键忽略大小写，同时会按顺序进行模糊匹配。比如定义了快捷键\r\nline，可以输入\r\nl、i、e、li、lin\r\nine 等共 10 种组合方式\r\n按使用频率排序\r\n由于每个快捷键会有多种匹配方式，会根据使用频率对结果进行排序，更懂你的想法\r\n中文状态可输入快捷键\r\n在中文状态下，也可以直接输入命令执行\r\n快捷键与 keyin 多对多\r\n一个快捷键可以执行多个 keyin，一个 keyin\r\n也可以设置多个快捷键\r\n\r\n🍅安装\r\n快速安装\r\n超级快捷键支持 PowerShell 脚本一键安装，打开\r\nPowerShell，然后复制以下命令，按 Enter 执行：\r\nirm https://gitee.com/galensgan/benltey-power-shortcuts/raw/master/install.ps1 | iex\r\n然后按提示输入选项即可一键安装。\r\n\r\n若提示需要手动配置快捷键，则按 手动配置空格弹出快捷键 进行操作\r\n\r\n视屏教程\r\n\r\n\r\n\r\n安装步骤\r\n\r\n点击 超级快捷键\r\n下载插件，并重命名为 PowerShortcut.dll\r\n在下载的时候，浏览器可能会提示需要信任：\r\n\r\n\r\nimage-20220318123634321\r\n\r\n点击信任即可。\r\n\r\n源代码：https://gitee.com/galensgan/benltey-power-shortcuts\r\n\r\n将 PowerShortcut.dll 拷贝至\r\nC:\\Program Files\\Bentley\\OpenRoads Designer CONNECT Edition\\OpenRoadsDesigner\\Mdlapps\r\n目录中。\r\n加载快捷键\r\n\r\n\r\nptBMTQSJZvqUjGa.png\r\n\r\n初始化超级快捷键\r\n请注意，初始化后，会覆盖原来的空格弹出功能。\r\n快捷键加载完成后，按 Enter 或者 F9 弹出 keyin 窗体，在里面输入\r\npower install，然后按 Enter 确认。\r\n\r\n如果提示\r\n未找到系统快捷键配置，请手动修改激活的快捷键，请按 手动配置空格弹出快捷键\r\n进行手动配置快捷键\r\n\r\n开始配置符合自己习惯的快捷键\r\n具体方式见 &gt; 增加快捷键\r\n\r\n手动配置空格弹出快捷键\r\n如果提示\r\n未找到系统快捷键配置，请手动修改激活的快捷键，需要按下图更改空格的响应\r\nkeyin 命令：\r\n\r\n如果没有手动修改配置空格的快捷键，需要重启软件才会生效。\r\n添加自定义快捷键\r\n按 Enter 或者 F9 弹出 keyin 窗体，在里面输入\r\npower openconfig，按空格确认，此时会打开快捷键定义文件，在里面进行快捷键定义，编辑完成后关闭文件，快捷键添加完成。\r\n&gt; 详细步骤-增加快捷键\r\n🥝使用\r\n\r\n单击空格，如果安装成功，会弹出快捷键输入窗体：\r\n\r\n在里面输入定义的快捷键，按 Enter 或者 空格 响应命令\r\n\r\n🍆内置 keyin\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n序号\r\nkeyin\r\n作用\r\n\r\n\r\n\r\n\r\n1\r\npower install\r\n超级快捷键安装，会覆盖原来空格键的弹出菜单\r\n\r\n\r\n2\r\npower openConfig\r\n打开快捷键定义文件，关闭编辑器会自动重载快捷键\r\n\r\n\r\n3\r\npower reloadConfig\r\n重新加载快捷键文件。如果直接修改快捷键文件后，需运行该命令重新加载后才可使用\r\n\r\n\r\n4\r\npower shortcut\r\n打开超级快捷键窗口\r\n\r\n\r\n5\r\npower setting\r\n对超级快捷键进行设置\r\n\r\n\r\n\r\n🥬内置快捷键\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n序号\r\nkeyin\r\n作用\r\n\r\n\r\n\r\n\r\n1\r\n空格\r\n激活快捷键输入窗体或者执行快捷键或者执行上一次的快捷键\r\n\r\n\r\n2\r\nEnter\r\n执行快捷键或者窗体输入为空时，执行上一次的快捷键\r\n\r\n\r\n3\r\nconfig\r\n打开快捷键定义文件\r\n\r\n\r\n4\r\nreload\r\n重新加载快捷键文件。当增加快捷键后，运行该命令重新加载后才可使用\r\n\r\n\r\n5\r\n上箭头\r\n查看上一个命令\r\n\r\n\r\n6\r\n下箭头\r\n查看下一个命令\r\n\r\n\r\n\r\n🌰快捷键定义\r\n单个快捷键定义\r\n&#123;    &quot;names&quot;:[&quot;d&quot;,&quot;delete&quot;], // 可以设置多个快捷键    &quot;keyin&quot;:&quot;delete element&quot;, // 快捷键对应的 keyin 命令,多个 keyin 用分号分隔，也可以使用 keyins 来配置    &quot;description&quot;:&quot;删除元素&quot; // 快捷键的描述&#125;, // 每一个定义都要以英文逗号结尾\r\n一个快捷键响应多个命令\r\n// 第一种方式&#123;    &quot;names&quot;:[&quot;mks&quot;,&quot;multipleKeyins&quot;],    &quot;keyin&quot;:&quot;keyin1;keyin2&quot;,    &quot;description&quot;:&quot;运行两个命令&quot;&#125;// 第二种方式&#123;    &quot;names&quot;:[&quot;mks&quot;,&quot;multipleKeyins&quot;],    &quot;keyins&quot;:[&quot;keyin1&quot;,&quot;keyin2&quot;],    &quot;description&quot;:&quot;运行两个命令&quot;&#125;\r\n模板\r\n&#123;    &quot;shortcuts&quot;:[        &#123;            &quot;names&quot;:[&quot;l&quot;],            &quot;keyin&quot;:&quot;place smartline&quot;,            &quot;description&quot;:&quot;绘制直线&quot;        &#125;,\t\t&#123;            &quot;names&quot;:[&quot;d&quot;,&quot;delete&quot;],            &quot;keyin&quot;:&quot;delete element&quot;,            &quot;description&quot;:&quot;删除元素&quot;        &#125;,\t\t&#123;            &quot;names&quot;:[&quot;c&quot;],            &quot;keyin&quot;:&quot;place circle icon&quot;,            &quot;description&quot;:&quot;绘制圆弧&quot;        &#125;,\t\t&#123;            &quot;names&quot;:[&quot;cc&quot;],            &quot;keyin&quot;:&quot;place circle center&quot;,            &quot;description&quot;:&quot;通过圆心绘制圆弧&quot;        &#125;,\t\t&#123;            &quot;names&quot;:[&quot;cd&quot;],            &quot;keyin&quot;:&quot;place circle diameter&quot;,            &quot;description&quot;:&quot;通过直径绘制圆弧&quot;        &#125;,\t\t&#123;            &quot;names&quot;:[&quot;m&quot;],            &quot;keyin&quot;:&quot;move icon&quot;,            &quot;description&quot;:&quot;移动&quot;        &#125;,\t\t&#123;            &quot;names&quot;:[&quot;co&quot;],            &quot;keyin&quot;:&quot;copy icon&quot;,            &quot;description&quot;:&quot;复制&quot;        &#125;,\t\t&#123;            &quot;names&quot;:[&quot;mi&quot;],            &quot;keyin&quot;:&quot;mirror icon&quot;,            &quot;description&quot;:&quot;镜像&quot;        &#125;,\t\t&#123;            &quot;names&quot;:[&quot;o&quot;],            &quot;keyin&quot;:&quot;MOVE PARALLEL OFFSET&quot;,            &quot;description&quot;:&quot;偏移&quot;        &#125;,\t\t&#123;            &quot;names&quot;:[&quot;tr&quot;],            &quot;keyin&quot;:&quot;trim multiple&quot;,            &quot;description&quot;:&quot;修剪&quot;        &#125;,\t\t&#123;            &quot;names&quot;:[&quot;te&quot;],            &quot;keyin&quot;:&quot;trim Extend&quot;,            &quot;description&quot;:&quot;延长&quot;        &#125;,\t\t&#123;            &quot;names&quot;:[&quot;b&quot;],            &quot;keyin&quot;:&quot;trim break&quot;,            &quot;description&quot;:&quot;打断&quot;        &#125;,\t\t&#123;            &quot;names&quot;:[&quot;ti&quot;],            &quot;keyin&quot;:&quot;trim tointersection&quot;,            &quot;description&quot;:&quot;剪切到交点&quot;        &#125;,\t\t&#123;            &quot;names&quot;:[&quot;reload&quot;],            &quot;keyin&quot;:&quot;power reloadConfig&quot;,            &quot;description&quot;:&quot;重新加载快捷键&quot;        &#125;,\t\t&#123;            &quot;names&quot;:[&quot;default&quot;],            &quot;keyin&quot;:&quot;model active default&quot;,            &quot;description&quot;:&quot;打开/关闭 default model&quot;        &#125;,\t\t&#123;            &quot;names&quot;:[&quot;modeltest&quot;],            &quot;keyin&quot;:&quot;model active ModelTest&quot;,            &quot;description&quot;:&quot;打开/关闭 ModelTest model&quot;        &#125;,\t\t&#123;            &quot;names&quot;:[&quot;model&quot;],            &quot;keyin&quot;:&quot;MDL KEYIN MODELMANAGER MODEL DIALOG TOGGLE&quot;,            &quot;description&quot;:&quot;打开/关闭 model 管理界面&quot;        &#125;,\t\t&#123;            &quot;names&quot;:[&quot;ref&quot;],            &quot;keyin&quot;:&quot;MDL KEYIN REF DIALOG REFERENCE TOGGLE&quot;,            &quot;description&quot;:&quot;打开 model 管理界面&quot;        &#125;,\t\t&#123;            &quot;names&quot;:[&quot;sw&quot;],            &quot;keyin&quot;:&quot;ribbon setworkflow swTools&quot;,            &quot;description&quot;:&quot;打开 swTools 界面&quot;        &#125;,\t\t&#123;            &quot;names&quot;:[&quot;drawing&quot;],            &quot;keyin&quot;:&quot;ribbon setworkflow drawing&quot;,            &quot;description&quot;:&quot;打开 drawing 界面&quot;        &#125;,\t\t&#123;            &quot;names&quot;:[&quot;skp&quot;],            &quot;keyin&quot;:&quot;snap keypoint&quot;,            &quot;description&quot;:&quot;捕捉关键点&quot;        &#125;,\t\t&#123;            &quot;names&quot;:[&quot;mref&quot;],            &quot;keyin&quot;:&quot;reference merge&quot;,            &quot;description&quot;:&quot;合并参考文件&quot;        &#125;,\t\t&#123;            &quot;names&quot;:[&quot;tk&quot;],            &quot;keyin&quot;:&quot;BOQAddin InsertDrawingBorder&quot;,            &quot;description&quot;:&quot;图框&quot;        &#125;,\t\t&#123;            &quot;names&quot;:[&quot;config&quot;],            &quot;keyin&quot;:&quot;power openConfig&quot;,            &quot;description&quot;:&quot;打开快捷键配置文件&quot;        &#125;,\t\t&#123;            &quot;names&quot;:[&quot;di&quot;],            &quot;keyin&quot;:&quot;measure distance&quot;,            &quot;description&quot;:&quot;测量距离&quot;        &#125;,\t\t&#123;            &quot;names&quot;:[&quot;acs&quot;],            &quot;keyin&quot;:&quot;MDL KEYIN BENTLEY.VIEWATTRIBUTESDIALOG,VAD VIEWATTRIBUTESDIALOG SETATTRIBUTE 0 ACSTriad True&quot;,            &quot;description&quot;:&quot;打开 ACS&quot;        &#125;,    ]&#125;\r\n快捷键定义文件位置\r\n快捷键默认保存到：C:\\Users\\%username%\\AppData\\Local\\Bentley\\PowerShortcut\\PowerShortcut.json\r\n好用的快捷键配置\r\n可直接复制到配置文件中使用。\r\n\r\n打开 ACS\r\n&#123;  &quot;names&quot;: [    &quot;acs&quot;  ],  &quot;keyins&quot;: [    &quot;MDL KEYIN BENTLEY.VIEWATTRIBUTESDIALOG,VAD VIEWATTRIBUTESDIALOG SETATTRIBUTE 0 ACSTriad True&quot;,    &quot;MDL KEYIN BENTLEY.VIEWATTRIBUTESDIALOG,VAD VIEWATTRIBUTESDIALOG SETATTRIBUTE 1 ACSTriad True&quot;  ],  &quot;description&quot;: &quot;打开 ACS&quot;&#125;,\r\n激活某个功能区\r\n&#123;  &quot;names&quot;: [    &quot;curves&quot;  ],  &quot;keyin&quot;: &quot;MDL KEYIN RibbonView RIBBON SETACTIVETAB Modeling\\\\Curves&quot;,  &quot;description&quot;: &quot;激活建模中的曲线功能区&quot;&#125;,\r\n初始化环境\r\n该快捷键主要做以下几个操作：\r\n\r\n关闭向后剪切\r\n打开 ACS\r\n将图形元素适应整个屏幕\r\n旋转到 ISO 视角\r\n光标重置为选择状态\r\n\r\n&#123;  &quot;names&quot;: [    &quot;init&quot;,    &quot;env&quot;  ],  &quot;keyins&quot;: [    &quot;MDL KEYIN BENTLEY.VIEWATTRIBUTESDIALOG,VAD VIEWATTRIBUTESDIALOG SETATTRIBUTE 0 ClipBack False&quot;,    &quot;MDL KEYIN BENTLEY.VIEWATTRIBUTESDIALOG,VAD VIEWATTRIBUTESDIALOG SETATTRIBUTE 0 ACSTriad True&quot;,    &quot;MDL KEYIN BENTLEY.VIEWATTRIBUTESDIALOG,VAD VIEWATTRIBUTESDIALOG SETATTRIBUTE 1 ACSTriad True&quot;,    &quot;fit view extended&quot;,    &quot;ROTATE ACTIVEVIEW ISO&quot;,    &quot;choose element&quot;  ],  &quot;description&quot;: &quot;环境初始化&quot;&#125;,\r\n打开/关闭 model 管理界面\r\n&#123;  &quot;names&quot;: [    &quot;model&quot;  ],  &quot;keyin&quot;: &quot;MDL KEYIN MODELMANAGER MODEL DIALOG TOGGLE&quot;,  &quot;description&quot;: &quot;打开/关闭 model 管理界面&quot;&#125;,\r\n打开参考管理界面\r\n&#123;  &quot;names&quot;: [    &quot;ref&quot;  ],  &quot;keyin&quot;: &quot;MDL KEYIN REF DIALOG REFERENCE TOGGLE&quot;,  &quot;description&quot;: &quot;打开参考管理界面&quot;&#125;,\r\n参考文件的操作\r\n&#123;  &quot;names&quot;: [    &quot;rc&quot;  ],  &quot;keyin&quot;: &quot;reference copy&quot;,  &quot;description&quot;: &quot;复制参考&quot;&#125;,&#123;  &quot;names&quot;: [    &quot;rm&quot;  ],  &quot;keyin&quot;: &quot;reference move&quot;,  &quot;description&quot;: &quot;移动参考&quot;&#125;,&#123;  &quot;names&quot;: [    &quot;rmi&quot;  ],  &quot;keyin&quot;: &quot;reference copy&quot;,  &quot;description&quot;: &quot;镜像参考&quot;&#125;,&#123;  &quot;names&quot;: [    &quot;rr&quot;  ],  &quot;keyin&quot;: &quot;reference rotate&quot;,  &quot;description&quot;: &quot;旋转参考&quot;&#125;,&#123;  &quot;names&quot;: [    &quot;rs&quot;  ],  &quot;keyin&quot;: &quot;reference scale&quot;,  &quot;description&quot;: &quot;缩放参考&quot;&#125;,&#123;  &quot;names&quot;: [    &quot;rmg&quot;,    &quot;merge&quot;  ],  &quot;keyin&quot;: &quot;reference merge&quot;,  &quot;description&quot;: &quot;合并参考到主文件&quot;&#125;,\r\n隔离与取消隔离\r\n&#123;  &quot;names&quot;: [    &quot;gl&quot;  ],  &quot;keyin&quot;: &quot;displayset set selection&quot;,  &quot;description&quot;: &quot;隔离选中元素&quot;&#125;,&#123;  &quot;names&quot;: [    &quot;ngl&quot;  ],  &quot;keyin&quot;: &quot;displayset clear&quot;,  &quot;description&quot;: &quot;取消隔离&quot;&#125;,\r\n功能区切换\r\n&#123;  &quot;names&quot;: [    &quot;curves&quot;  ],  &quot;keyin&quot;: &quot;MDL KEYIN RibbonView RIBBON SETACTIVETAB Modeling\\\\Curves&quot;,  &quot;description&quot;: &quot;激活建模中的曲线功能区&quot;&#125;,&#123;  &quot;names&quot;: [    &quot;solids&quot;  ],  &quot;keyin&quot;: &quot;MDL KEYIN RibbonView RIBBON SETACTIVETAB Modeling\\\\Solids&quot;,  &quot;description&quot;: &quot;激活建模中的实体功能区&quot;&#125;,&#123;  &quot;names&quot;: [    &quot;constraints&quot;  ],  &quot;keyin&quot;: &quot;MDL KEYIN RibbonView RIBBON SETACTIVETAB Modeling\\\\Constraints&quot;,  &quot;description&quot;: &quot;激活建模中的约束功能区&quot;&#125;,&#123;  &quot;names&quot;: [    &quot;home&quot;  ],  &quot;keyin&quot;: &quot;MDL KEYIN RibbonView RIBBON SETACTIVETAB Drawing\\\\Home&quot;,  &quot;description&quot;: &quot;激活绘图中的主页功能区&quot;&#125;,&#123;  &quot;names&quot;: [    &quot;rebar&quot;  ],  &quot;keyin&quot;: &quot;MDL KEYIN RibbonView RIBBON SETACTIVETAB swTools\\\\sw_Rebar&quot;,  &quot;description&quot;: &quot;激活swTools中的钢筋功能区&quot;&#125;,\r\n\r\n🍉匹配规则\r\n快捷键按下列优先级对匹配的快捷键进行排序：\r\n\r\n完整匹配\r\n部分匹配，按使用频率排序\r\n\r\n🍒增加快捷键\r\n按下列步骤新增快捷键：\r\n\r\n打开快捷键定义文件\r\n可以使用三种方式打开快捷键文件\r\n\r\n在快捷键窗口中输入 config\r\n在 keyin 窗口中输入 power openConfig\r\n在资源管理器中输入\r\nC:\\Users\\%username%\\AppData\\Local\\Bentley\\PowerShortcut\\PowerShortcut.json\r\n打开\r\n\r\n添加快捷键定义\r\n快捷键具体定义格式见 &gt;\r\n快捷键定义，特别注意，每个定义后面必须要有一个英文的逗号\r\n重新加载快捷键文件\r\n可以使用下列 3 个方式重新加载快捷键\r\n\r\n如果是通过 config 快捷键或者\r\npower openConfig keyin\r\n打开的快捷键编辑器，在其关闭时会自动重新加载\r\n在快捷键窗口中输入 reload\r\n在 keyin 窗口中输入 power reloadConfig\r\n\r\n\r\n在快捷键定义中，如何找到自己需要的 keyin 呢？\r\n点击视屏查看具体方法：\r\n\r\n\r\n\r\n","categories":["Bentley","UseSkill"]},{"title":"3dmax 文件如何导入到 dgn 中","url":"/posts/2022/29WK0R3.html","content":"如果需要将 3dmax 模型文件导入到 dgn 中，可以有以下方法：\r\n\r\n\r\n转为 fbx\r\n导出为 3ds 文件\r\n\r\n\r\na20b055e7096dbd2105bdd712558425\r\n\r\n在 3DMAX 中导出 3DS 格式，然后在 MS 中导入 3DS.\r\n\r\n","categories":["Bentley","UseSkill"],"tags":["Bentley","UseSkill"]},{"title":"ORD 及 swBentley 安装教程","url":"/posts/2022/3EFH36D.html","content":"本文介绍了 OpenRoads Designer（以下简称 ORD）的安装教程。本教程以 ORD\r\nu11 为例，其它版本的安装方法与该版本相同。\r\n\r\n\r\nimage-20230307213816049\r\n\r\n\r\n安装要求\r\n由于 ORD 软件默认安装在 C 盘，所以需要保证 C 盘有足够的空间大小，ORD\r\n最小所需安装空间约为：20G ！。\r\n\r\nORD 安装时支持自定义安装位置，可以选择安装在其它盘，减少 C 盘占用\r\n\r\n下载安装包\r\n安装包可以从 iEPC\r\n的知识管理中下载，也可以从同事处拷贝，由于网速原因，此处不再另外单独给下载链接。\r\n卸载原安装\r\n根据以下步骤进行依次卸载或者删除：\r\n卸载 ORD 程序\r\n打开程序和功能面板，卸载 ORD\r\n\r\n快捷打开方式： win+R，然后输入 appwiz.cpl\r\n，点击确定。\r\n\r\n卸载 Connection Client 程序\r\n\r\n\r\nimage-20230530095409381\r\n\r\n删除卸载残留\r\n\r\n删除残留为可选项，当安装失败时，需要先清除残留后再进行安装。\r\n\r\n\r\n删除安装目录\r\n默认为：\r\nC:\\Program Files\\Bentley\\OpenRoads Designer CE 10.11\\OpenRoadsDesigner\r\n删除程序配置目录\r\nC:\\ProgramData\\Bentley\\OpenRoads Designer CE 10.11\r\nC:\\ProgramData\\Bentley\\OpenRoadsDesigner\r\n删除用户配置目录\r\nC:\\Users\\%username%\\AppData\\Local\\Bentley\\OpenRoadsDesigner\r\n删除注册表\r\n以管理员身份运行 cmd 或者 posershell，按\r\nctrl+x 会弹出快捷菜单：\r\n\r\nwindows 10 选择 Windows Powershell 管理员(A)\r\nwindows 11 选择 终端管理员(A)\r\n\r\n可以快速打开 powershell。\r\n将以下代码拷贝到里面，按 Enter 即可：\r\n# 删除 ConnectClientreg delete HKCU/HKEY_CURRENT_USER/Software/Bentley/CONNECTIONClient /freg delete HKCU/HKEY_LOCAL_MACHINE/Software/Bentley/CONNECTIONClient /f# 删除 ORDreg delete HKCU/HKEY_CURRENT_USER/Software/Bentley/OpenRoadsDesigner /freg delete HKCU/HKEY_LOCAL_MACHINE/Software/Bentley/OpenRoadsDesigner /f# 删除 License 服务reg delete HKCU/HKEY_CURRENT_USER/Software/Bentley/LicenseService /freg delete HKCU/HKEY_LOCAL_MACHINE/Software/Bentley/LicenseService /f\r\n\r\n开始安装\r\n\r\n解压软件\r\n安装包下载完成后，解压文件，其中文件如下图所示：\r\n\r\n\r\nimg\r\n\r\n单击 Setup_OpenRoadsDesignerx64_10.09.00.091.exe\r\n进行安装\r\n配置安装路径\r\n点击 Configure 跳转到安装配置界面，如下图所示\r\n\r\n\r\n\r\nimage-20230307213816049\r\n\r\n配置完成后，勾选\r\nI accept the End User License Agreement，然后点击\r\nInstall 进行安装。\r\n现在不需要其它操作，静候程序自动安装完成即可!\r\n关闭 CONNECTION Client 自启动\r\n\r\n本步骤为可选项，根据需要选择\r\n\r\nCONNECTION Client\r\n安装完成后，会默认开机启动，既影响开机速度，又影响使用体验。关闭位置如下：\r\n\r\n在任务管理器的启动栏中，找到上述三个启动项，右键，关闭。\r\n\r\n登陆Bentley账号\r\n在打开 ORD 时，会要求登陆\r\nCONNECTION Client，其登陆界面如下：\r\n\r\n输入账号（账号是邮箱），点击\r\nNext，再输入密码进行登陆。\r\n注册账号\r\n如果没有账号，需要点击 立即注册 进行注册。也可以点击此处 快速跳转到注册界面。\r\n申请授权\r\n新注册账户需要管理员进行授权才能使用 ORD。将申请的账号发给\r\n管理员，在管理员授权以后，重新登陆\r\nCONNECTION Client ，即可正常使用 ORD。\r\n忘记密码？\r\n若忘记密码，请单击登陆界面的 忘记密码 进行找回。\r\n下载 SwSetup\r\n到目前为止，ORD 不具有任何企业定制化的设置在里面，此时需要通过\r\nSwSetup 安装 SwBentley，从而使 ORD\r\n可以开始应用于生产环境。\r\nSwSetup 可在 iEPC\r\n的知识管理中下载，此处没有直链。\r\n\r\n注意：\r\n下载时、解压时、使用时可能会被杀毒软件提示是病毒，从而不能被隔离。可以关闭杀毒软件再试，被报病毒是由于该软件需要用管理员权限启动，所以会被误报。\r\n\r\n激活 SwBentley\r\n注册必读：\r\n申请码与电脑硬件数量及类型相关，比如增减U\r\n盘、移动硬盘、软件狗等会使激活码变动（鼠标、键盘、显示器没有影响），因此在申请时，确保当前电脑处于常用的硬件安装状态。\r\n当打开 swSetup\r\n时，若未注册，则会弹出新用户注册界面，如下图所示：\r\n\r\n点击 获得注册码\r\n随后弹出注册申请界面，如下图所示：\r\n\r\n填入相关信息，单击发送。\r\n若申请通过，将会通过用户邮箱发送用户注册码。\r\n\r\n激活码可能会被邮箱识别成垃圾邮件，所以可以在垃圾箱中查看下是否有激活码接收。\r\n\r\n安装SwBentley\r\nswSetup 激活后，就可以进行更新了。\r\n在更新之前，需要先 关闭 ORD，然后再打开\r\nswSetup.exe，此时会出现下图所示界面：\r\n\r\n点击 更新，更新完成后，SwBentley\r\n也就安装完成了。\r\n\r\n额外补充：\r\nswSetup 的激活码与 SwBentley 是绑定的，只要激活了 swSetup，SwBentley\r\n也就激活了。\r\n\r\n","categories":["Bentley","UseSkill"],"tags":["NexT","Bentley","ORD使用"]},{"title":"管理 Microstation CE 版本的环境配置","url":"/posts/2019/7W71XB.html","content":"本文将解释如何构建和管理 MicroStation CONNECT Edition（以下简称 MS ）\r\n的环境配置\r\n\r\n概述\r\nMicrostation 通过配置变量（configuration\r\nvariables）来引导软件配置向正确的位置。\r\n配置变量 被组织成以 USTN 前缀开始的\r\n框架配置变量（Framework Configuration Variables）和以\r\nMS_ 为前缀开始的 操作配置变量（Operational Configuration\r\nVariables)。通常，框架配置变量用于设置基本路径，而操作配置变量用于指导\r\nMS\r\n内的程序流程。一些框架配置变量由MicroStation安装文件夹决定。其他框架配置变量默认设置为相对于安装文件夹的位置，但是可以在用户提供或编辑的配置文件中更改。\r\nMS 的\r\n配置文件处理可以看作是一个简单的程序，其中一部分由系统配置文件提供，不应该由用户修改，另一部分由用户可修改的配置文件提供。所有配置文件都是简单的文本文件，可以使用任何文本编辑器检查，修改。\r\n系统配置文件位于\r\nC:\\Program Files\\Bentley\\MicroStation CONNECT Edition\\MicroStation\\config\r\n文件夹,同时用户可以修改的配置文件位于安装目录或其他指定的目录。系统配置文件在适当的时候将用户可修改的配置文件包含到配置文件处理流中。\r\nMS 配置\r\nMS 默认配置目录\r\nMS 默认配置目录为\r\nC:\\Program Files\\Bentley\\MicroStation CONNECT Edition\\MicroStation\\Default\\\r\nMS 配置目录结构\r\ngraph LR0&#123;配置结构&#125;--&gt;1[Configuration];    1--&gt;11(Workspaces);        11--&gt;111(Example);            111--&gt;1111(Standards);                1111--&gt;11111(Cell);                1111--&gt;11112(DgnLib);                    11112--&gt;111121(GUI);            111--&gt;1112(WorkSets);                1112--&gt;11121(Building);                    11121--&gt;111211(Data);                    11121--&gt;111212(DGN);                    11121--&gt;111213(DWG);                    11121--&gt;111214(Out);                    11121--&gt;111215(Standars);                        111215--&gt;1112151(Cell);                        111215--&gt;1112152(DgnLib);                        111215--&gt;1112153(Seed);                        111215--&gt;1112154(Etc...);                1112--&gt;11122(Civil);                    11122--&gt;111221(Data);                    11122--&gt;111222(Etc...);                1112--&gt;11123(General);                    11123--&gt;111231(Data);                    11123--&gt;111232(Etc...);                1112--&gt;11124(Etc...);0--&gt;2[Organization];    2--&gt;21(Cell);    2--&gt;22(Data);    2--&gt;23(Dgn);    2--&gt;24(DgnLib);        24--&gt;241(ClashDetection);        24--&gt;242(DrawComp);        24--&gt;243(Etc...);    2--&gt;25(Macros);    2--&gt;26(Mareials);        26--&gt;261(Bump);        26--&gt;262(Pattern);    2--&gt;27(MdlApps);        27--&gt;271(InteInt)    2--&gt;28(Pltcfg);    2--&gt;29(Seed);    2--&gt;210(Spc);    2--&gt;211(Symb);    2--&gt;212(Tables);        212--&gt;2121(Dwg);        212--&gt;2122(PEN)    2--&gt;213(VBA);\r\n\r\n关于Configuration目录\r\n此处至少有两个文件夹和一个文件，如果是基于 MS\r\n平台的其它产品，还可能会有更多的文件夹及文件。\r\n\\Organization 文件夹是组织 CAD\r\n标准所在的位置。可以通过在配置文件中使用\r\n_USTN_ORGANIZATION（ORD 是\r\n_USTN_CUSTOM_CONFIGURATION）指向不同的位置。该配置在\r\nConfigurationSetup.cfg中。\r\n_USTN_CUSTOM_CONFIGURATION=C:\\MyOrganization\\或者：_USTN_CUSTOM_CONFIGURATION=你的服务器配置地址\\\r\nMicroStation CONNECT Edition 中的\r\n\\WorkSpaces\r\n文件夹是工作集、设计文件、标准文件和配置文件的容器。.cfg\r\n文件是一个配置文件，可以将MS 的环境配置重定向到服务器或其他位置上。\r\n关于Organization目录\r\n组织文件夹是存储自己的组织、单元格、dgnlib 和其他与 CAD\r\n标准相关的数据的地方。这些文件夹是空的，通过配置\r\nstandard .cfg\r\n文件告诉MicroStation在何处查找种子文件等特定项。\r\n配置变量定义及语法\r\n配置文件加载顺序\r\n配置文件处理从配置文件 mslocal.cfg 开始。它是启动\r\nMicroStation\r\n时打开的第一个文件，是一个简短的文件。mslocal.cfg 包含\r\nmsdir.cfg，msdir.cfg\r\n是在安装时生成的另一个小配置文件，它标识 MicroStation\r\n安装文件夹，然后包含 msconfig.cfg.cfg\r\n文件包含处理事件的大部分配置文件。\r\n永远不要修改 msconfig.cfg 本身(或 MicroStation\r\n程序文件夹中的任何其他配置文件)，也不要在这个位置添加自己的配置文件。msconfig.cfg\r\n中有许多已经定义好的，包含用户可修改的配置文件。在这些用户可修改的配置文件中，可以修改配置变量，以提供所有必要的灵活性，以满足组织对项目数据位置和\r\nCAD 标准的需求。\r\n当然，如果已经对配置文件理解得很透彻，则任何配置文件都可以修改。\r\nmsconfig.cfg 配置文件首先设置\r\n_USTN_BENTLEYROOT\r\n配置变量和一些框架配置变量，这些配置变量指向安装程序数据的目录。这些是程序操作所必需的，且不为任何用户数据或文件定义的位置。然后还包含MicroStation附带的系统和应用程序配置文件。\r\nmsconfig.cfg\r\n文件被完全重新组织，行内文档解释了它的作用。msconfig.cfg\r\n文件没有定义任何 MS_xxx(操作型)配置变量。\r\n下面是配置文件的加载顺序：\r\nmslocal.cfg--&gt;msdir.cfg--&gt;msconfig.cfg\r\n在 msconfig.cfg\r\n文件中，会按照顺序先后加载配置配置文件，配置文件的顺序按照出现在\r\nmsconfig.cfg\r\n中定义的先后顺序，注意不要修改其顺序，修改后可能导致系统出现意外的错误。加载顺序如下：\r\nall system cfg filesall appl cfg filesworkspacesetup.cfg filesall organization cfg filespersonal.ucf fileworkspace&lt;name&gt;.cfg fileall workspace cfg filesworkset&lt;name&gt;.cfg filesall workset cfg filesrole.cfg filedatabase cfg file\r\n\r\n参考资料\r\n\r\n[1] . Managing Configurations in\r\nMicroStation CONNECT Edition [2]. help\r\n","categories":["Bentley","Custom"],"tags":["Microstation"]},{"title":"修改文字大小","url":"/posts/2020/JJQETR.html","content":"在开发中，遇到这样一个问题，需要用某一文字样式创建文字，同时，还需要修改生成文字的大小，又不影响原来的文字样式。下面记录已知的两种方法。\r\n\r\n详细介绍\r\n\r\n采用 COM\r\n里面的API，用代码在原来样式的基础上生成新的样式，具体代码如下\r\n\r\nBentley.Internal.MstnPlatformNET.TextStyleLibCollection textStyles = new Bentley.Internal.MstnPlatformNET.TextStyleLibCollection(StyleIteratorMode.ActiveFileAndLibraries);DgnTextStyle targetStyle = textStyles.Where(item =&gt; item.Name == &quot;textStyleName&quot;).FirstOrDefault();if (targetStyle == null)&#123;    // 创建新的钢筋标注样式    string newTextStyleName = SwTextStyle.SW_25_SectionName.ToStringValue();//注意名字要确保是唯一的    string templateStyleName = SwTextStyle.SW_50_SectionName.ToStringValue();    Application msApp = Utilities.ComApp;    TextStyle templateStyle = msApp.ActiveDesignFile.TextStyles[templateStyleName];    msApp.ActiveDesignFile.TextStyles.Add(templateStyle, newTextStyleName);    TextStyle newTextStyle = msApp.ActiveDesignFile.TextStyles[newTextStyleName];    newTextStyle.Width = 0.0020;    //修改文本样式的属性    newTextStyle.Height = 0.0025;    targetStyle = textStyles.Where(item =&gt; item.Name ==   &quot;textStyleName&quot;).FirstOrDefault();&#125;// 使用TextBlock textBlock = new TextBlock(dgnTextStyle, DgnModel); ...\r\n\r\n直接修改文字样式，具体代码如下 Bentley.Internal.MstnPlatformNET.TextStyleLibCollection textStyles = new Bentley.Internal.MstnPlatformNET.TextStyleLibCollection(StyleIteratorMode.ActiveFileAndLibraries);DgnTextStyle targetStyle = textStyles.Where(item =&gt; item.Name == &quot;textStyleName&quot;).FirstOrDefault();targetStyle.SetProperty(TextStyleProperty.Width, 0.0020 * uor);targetStyle.SetProperty(TextStyleProperty.Height, 0.0025 * uor);// 使用TextBlock textBlock = new TextBlock(dgnTextStyle, DgnModel); ...\r\n\r\n上面这种用法也是不会修改原来文字样式。\r\n","categories":["Bentley","Develop"],"tags":["Bentley二次开发"]},{"title":"引线标注","url":"/posts/2020/1P955T2.html","content":"最近用 C# 对 ORD\r\n进行二次开发，做一个自动出图工具。其中必不可少的就是标注，被各种标注折腾得死去活来，特别是引线标注，坑特别多，特记录下来，供和大家学习交流，若有不正确之处，还请斧正。\r\n\r\n简介\r\n在 C# 中，引线标注采用的是 NoteCellHeaderElement\r\n这个类。具体代码如下：\r\n// 其中，arrowHeadPoint, arrowTailPnt, annotation, dgnModel 和 _dimensionCreateData 是传入的参数TextBlock textBlock = new TextBlock(_dimensionCreateData.GetTextStyle(), DgnModel);textBlock.AppendText(annotation);NoteCellHeaderElement header = new NoteCellHeaderElement(out Element leaderElement, textBlock, this._dimensionCreateData.GetDimensionStyle(), DgnModel, new DPoint3d[] &#123; arrowHeadPoint, arrowTailPnt &#125;);// 此步骤是为了设置引线文字的对齐方式为 0 (auto),它的主要作用是当第一个点在第二个点左侧时，文字在左方，否则文字是右方DimensionElement dim = leaderElement as DimensionElement;DimensionStyle ds = dim.GetDimensionStyle();ds.SetIntegerProp(0, DimStyleProp.MLNote_HorAttachment_INTEGER);         dim.ApplyDimensionStyle(ds, true);// 必须用这种方法添加引线标注到 model 中header.AddToModel(out dim,dgnModel);\r\n下面详细分析为了得出上面的几行代码，需要处理的技术问题。\r\n_dimensionCreateData\r\n怎么来的？\r\n_dimensionCreateData 是 DimensionCreateData\r\n的实例，查看 DimensionCreateData\r\n定义，我们可以看到，它是一个抽象类，不能实例化它，所以就想着，看在 ORD\r\n的程序集里面找一个实现它的类，可以查找无果，最后，从优先社区中得知，需要自己子类化一下它，代码如下（代码是项目中的一部分，没有简化，不能开箱即用，仅供参考）。\r\nusing Bentley.DgnPlatformNET;using Bentley.DgnPlatformNET.Elements;using Bentley.GeometryNET;using Bentley.MstnPlatformNET;using swOpenRoadsSDK;using SwTools.SimpleCAD.Enum.Extension;using System.Collections.Generic;namespace SwTools.RebarTools.SDK.Dimension&#123;    class SwDimesionCreateData : DimensionCreateData    &#123;        private static Dictionary&lt;SwDimensionStyle, DimensionStyle&gt; _dimensionStyleDic = new Dictionary&lt;SwDimensionStyle, DimensionStyle&gt;();        private static Dictionary&lt;SwTextStyle, DgnTextStyle&gt; _textStyleDic = new Dictionary&lt;SwTextStyle, DgnTextStyle&gt;();        private static Dictionary&lt;SwLevel, LevelId&gt; _levelDic = new Dictionary&lt;SwLevel, LevelId&gt;();        private readonly Symbology _symbology;        private readonly DirectionFormatter _directionFormatter;        public DimensionStyle DimensionStyle &#123; get; &#125;        public DgnTextStyle DgnTextStyle &#123; get; &#125;        public LevelId LevelId &#123; get; &#125;        public SwDimesionCreateData(DimensionStyle dimStyle, DgnTextStyle textStyle, Symbology symb, LevelId levelId, DirectionFormatter formatter)        &#123;            DimensionStyle = dimStyle;            DgnTextStyle = textStyle;                       LevelId = levelId;            _symbology = symb;            _directionFormatter = formatter;        &#125;        public SwDimesionCreateData(SwDimensionStyle swDimensionStyle,SwTextStyle swTextStyle,Symbology symb, SwLevel swLevel,DirectionFormatter formatter)        &#123;            if(_dimensionStyleDic.TryGetValue(swDimensionStyle,out DimensionStyle value1))            &#123;                DimensionStyle = value1;            &#125;            else            &#123;                DimensionStyle = DimensionHelper.GetDimensionStyle(swDimensionStyle.ToString());                _dimensionStyleDic.Add(swDimensionStyle, DimensionStyle);            &#125;            if(_textStyleDic.TryGetValue(swTextStyle,out DgnTextStyle value2))            &#123;                DgnTextStyle = value2;            &#125;            else            &#123;                DgnTextStyle = DrawingHelper.GetTextStyle(swTextStyle.ToStringValue());                _textStyleDic.Add(swTextStyle, DgnTextStyle);            &#125;            if(_levelDic.TryGetValue(swLevel,out LevelId value3))            &#123;                LevelId = value3;            &#125;            else            &#123;                LevelHandle levelByName = Session.Instance.GetActiveDgnFile().GetLevelCache().GetLevelByName(swLevel.ToString());                LevelId = levelByName.LevelId;                _levelDic.Add(swLevel, LevelId);            &#125;                     _symbology = symb;            _directionFormatter = formatter;        &#125;        public override DimensionStyle GetDimensionStyle()        &#123;            return DimensionStyle;        &#125;        public override DgnTextStyle GetTextStyle()        &#123;            return DgnTextStyle;        &#125;        public override Symbology GetSymbology()        &#123;            return _symbology;        &#125;        public override LevelId GetLevelId()        &#123;            return LevelId;        &#125;        public override int GetViewNumber()        &#123;            return 0;        &#125;        public override DMatrix3d GetDimensionRotation()        &#123;            return DMatrix3d.Identity;        &#125;        public override DMatrix3d GetViewRotation()        &#123;            return DMatrix3d.Identity;        &#125;        public override DirectionFormatter GetDirectionFormatter()        &#123;            return _directionFormatter;        &#125;        #region 静态方法        public static SwDimesionCreateData GetSwBridgeAnnotationCreateData()        &#123;            return new SwDimesionCreateData(SwDimensionStyle.SW_Bridge, SwTextStyle.CB_25, new Symbology(), SwLevel.sw_尺寸, null);        &#125;        public static DgnTextStyle GetDgnTextStyle(SwTextStyle swTextStyle)        &#123;            if (_textStyleDic.TryGetValue(swTextStyle, out DgnTextStyle style))            &#123;                return style;            &#125;            else            &#123;                DgnTextStyle styleNew = DrawingHelper.GetTextStyle(swTextStyle.ToStringValue());                _textStyleDic.Add(swTextStyle, styleNew);                return styleNew;            &#125;        &#125;        #endregion    &#125;&#125;\r\nnew\r\nNoteCellHeaderElement对象时，参数DPoint3d[] 中的点代表什么？\r\n它的第 1\r\n个点代表引线箭头的坐标，后面的点代表引线导线的关键点。一般传入两个点就可以了。\r\n怎么实现引线和文字关联？\r\n开始 new NoteCellHeaderElement 对象的时候，看到它 out 了一个\r\nelement, 便直接将它和 header 添加到了\r\nmodel。这时查看模型元素后，发现它们俩是分开的，拽文字引线不跟着动，很难受。后面在众多相似的方法中，在\r\nNoteCellHeaderElement 中找到一个\r\nAddToModel的重载，它是这样的：\r\npublic BentleyStatus AddToModel(out Element leaderElement, DgnModel dgnCache);\r\n从上面的定义里面，我们知道，它会 out\r\n一个元素出来，但是，这个其实就是个坑，一个大坑。这个参数真正的意思是要将从上文得到的\r\nleaderElement 传入进去，它里面会与 header 进行关联，并添加到 model\r\n中。\r\n所以，真正的用法应该是开篇示例代码那样。\r\n怎么让文字水平吸附为自动？\r\n\r\n如上图，如果不对参数进行设置，默认生成的引线标注是 1 和 2\r\n的样式，如果要得到 3 ，需要设置它的对齐方式。就是下面的代码：\r\nDimensionElement dim = leaderElement as DimensionElement;DimensionStyle ds = dim.GetDimensionStyle();ds.SetIntegerProp(0, DimStyleProp.MLNote_HorAttachment_INTEGER);         dim.ApplyDimensionStyle(ds, true);\r\n怎么知道要设置哪个属性值呢？\r\n上面是直接贴出了代码，可能就有人会问，为什么就知道是设置DimStyleProp.MLNote_HorAttachment_INTEGER\r\n这个属性呢？下面介绍一下怎么去解决这种类似的问题。这种问题，我称之为\r\n“操作代码化”\r\n问题，就是说用户可以使用软件手动操作生成出来，但是现在需要用程序来实现。\r\n这种问题的突破口就是要回归操作\r\n\r\n在应用程序中，手动放置需要生成的元素，然后通过 key-in\r\nanalyze element 这个命令去查看元素的详细信息。\r\n\r\n// 部分信息如下Element ID: 160542File Name: C:\\WorkSets\\codeTesting\\dgn\\柱测试.dgnModel Name: 桩_图纸Last Modified: 2020/08/27 00:52:41Type Specific Details:Dimension Type : IsAnnotation   : YesProxy Cell     : &lt;None&gt;Height         : 0.00000Point #0       : 0.50705, 0.26187Point #1       : 0.50178, 0.26847     ARotation       : | 1.0000000  0.0000000  0.0000000 |                 |-0.0000000  1.0000000  0.0000000 |                 | 0.0000000  0.0000000  1.0000000 |......\r\n\r\n画一个对照元素，也通过命令查看元素的详细信息\r\n将两个详细信息进行对比，差异的部分就是导致两个元素表征显示不一样的原因，然后在程序里面去找到相应的设置。\r\n\r\n那么现在又有一个问题了，程序里面的获得元素，都是 Element\r\n这个父类黑箱子，而要设置，就要进行拆箱，我们不知道究竟拆成什么类型？\r\n这个问题，可以在运行时，通过 .GetType()\r\n来获取类型，就知道应该转成什么类型了。\r\n","categories":["Bentley","Develop"],"tags":["Bentley二次开发"]},{"title":"将元素的颜色设置为 ByLevel","url":"/posts/2020/31H546G.html","content":"在给元素添加颜色的过程中，发现不能直接将颜色号设置成\r\n-1（ByLevel），经过在优先社区的查找，终于解决了，特此记录。\r\n\r\n简介\r\n设置元素的属性一般是创建一个\r\nElementPropertiesSetter，具体代码如下：\r\nElementPropertiesSetter setter = new ElementPropertiesSetter();setter.SetColor(ElementPropertyUint.COLOR_BYLEVEL);setter.SetWeight(1);setter.SetLevel(GetLevel(SwLevel.sw_2D_点划线));setter.SetLinestyle((int)ElementPropertyUint.STYLE_BYLEVEL,null);setter.Apply(ele);\r\n转到 SetColor 的定义我们可以看到，它是这样的：\r\npublic void SetColor(uint color);\r\n而在 ORD 中，我们可以得知，ColorByLevel 的值是\r\n-1，这就让我们很为难了。\r\n解决办法\r\n实际上，在 .NET 下的颜色，-1 并不代表 ColorByLevel, ColorByLevel\r\n真正的值是一个 uint, 不过它是16进制的，具体的定义如下：\r\npublic class ElementPropertyUint&#123;        // DgnPlatform.h 里面    public static uint COLOR_BYLEVEL = 0xffffffff;    public static uint COLOR_BYCELL = 0xfffffffe;    public static uint STYLE_BYLEVEL = 0x7fffffff;    public static uint STYLE_BYCELL = 0x7ffffffe;    public static uint WEIGHT_BYLEVEL = 0xffffffff;    public static uint WEIGHT_BYCELL = 0xfffffffe;    public static uint LEVEL_BYCELL = 64;&#125;\r\n致谢\r\n解决思路来自优先社区：\r\nhttps://communities.bentley.com/communities/other_communities/chinafirst/f/microstation-projectwise/175980/msce-c-element-bylevel?ReplySortBy=CreatedDate&amp;ReplySortOrder=Ascending\r\n","categories":["Bentley","Develop"],"tags":["Bentley二次开发"]},{"title":"ORD 环境变量汇总","url":"/posts/2020/2HMJJW9.html","content":"进行 Bentley\r\n系列产品修改化自定时，首先需要对环境变量进行配置，将特定的环境变量指向自定义的位置，所以在此处对\r\nORD 的环境变量进行系统的归纳。\r\n\r\n\r\nSystem Environment Category\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConfiguration Variable Name\r\nType\r\nShort Description\r\nRestart\r\nWorkSet\r\n\r\n\r\n\r\n\r\nMS_CONFIG\r\nFilename\r\nMain Configuration File\r\nYES\r\nNO\r\n\r\n\r\nRSC_COMP\r\nCommand Line\r\nResource Compiler Command Line\r\nNO\r\nNO\r\n\r\n\r\nMDL_COMP\r\nCommand Line\r\nMDL Compiler Command Line\r\nNO\r\nNO\r\n\r\n\r\nBMAKE_OPT\r\nCommand Line\r\nBMAKE Options\r\nNO\r\nNO\r\n\r\n\r\nMS_DEBUGMDLHEAP\r\nKeyword\r\nExtended Malloc\r\nNO\r\nNO\r\n\r\n\r\n\r\n\r\nConfiguration Category\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConfiguration Variable Name\r\nType\r\nShort Description\r\nRestart\r\nWorkSet\r\n\r\n\r\n\r\n\r\nMS_TEMPLATEEXTENDER_APPS\r\nFilelist\r\nElement Template Extender Applications\r\nYES\r\nNO\r\n\r\n\r\nMS_USERPREF_APPS\r\nFilelist\r\nUser Preference Applications\r\nYES\r\nNO\r\n\r\n\r\nMSDIR\r\nDirectory\r\n$[_USTN_PRODUCT_NAME] Dir\r\nYES\r\nNO\r\n\r\n\r\nMSLOCAL\r\nDirectory\r\n$[_USTN_PRODUCT_NAME] Dir (Local)\r\nYES\r\nNO\r\n\r\n\r\n_USTN_DEFUSERINTNAME\r\nDirectory\r\nDefault Interface Subdirectory\r\nYES\r\nNO\r\n\r\n\r\n_USTN_USERINTNAME\r\nDirectory\r\nInterface Subdirectory\r\nYES\r\nNO\r\n\r\n\r\n_USTN_USERINTROOT\r\nDirectory\r\nInterface Root Dir\r\nYES\r\nNO\r\n\r\n\r\n_USTN_USERINT\r\nDirectory\r\nInterface Base Data Dir\r\nYES\r\nNO\r\n\r\n\r\n_USTN_WORKSETNAME\r\nBase Name\r\nBase WorkSet Name\r\nYES\r\nNO\r\n\r\n\r\n_USTN_USERCFG\r\nFilename\r\nUser Configuration File\r\nYES\r\nNO\r\n\r\n\r\n_USTN_USERNAME\r\nBase Name\r\nBase User Name\r\nYES\r\nNO\r\n\r\n\r\n_USTN_USERDESCR\r\nKeyword\r\nUser Description\r\nNO\r\nNO\r\n\r\n\r\n_USTN_USER\r\nDirectory\r\nUser Configuration Files\r\nYES\r\nNO\r\n\r\n\r\n_USTN_WORKSETDGNWS\r\nSearch Path\r\nWorkSet full path\r\nNO\r\nYES\r\n\r\n\r\n_USTN_WORKSETSDGNWSROOT\r\nSearch Path\r\nWorkSets file root directory\r\nNO\r\nYES\r\n\r\n\r\n_USTN_TEMPLATEWORKSETNAME\r\nSearch Path\r\nWorkSpace template\r\nNO\r\nYES\r\n\r\n\r\n_USTN_TEMPLATEWORKSPACENAME\r\nSearch Path\r\nWorkSpace template\r\nNO\r\nYES\r\n\r\n\r\n_USTN_WORKSETDGNWSTEMPLATE\r\nSearch Path\r\nWorkSpace template\r\nNO\r\nYES\r\n\r\n\r\n_USTN_WORKSETTEMPLATE\r\nSearch Path\r\nWorkSet template\r\nNO\r\nYES\r\n\r\n\r\n_USTN_WORKSPACECFG\r\nSearch Path\r\nWorkSpace configuration\r\nNO\r\nYES\r\n\r\n\r\n_USTN_WORKSPACELABEL\r\nSearch Path\r\nWorkSpace label\r\nNO\r\nYES\r\n\r\n\r\n_USTN_WORKSPACENAME\r\nSearch Path\r\nWorkSpace name\r\nNO\r\nYES\r\n\r\n\r\n_USTN_WORKSPACEROOT\r\nSearch Path\r\nWorkSpace Root Directory\r\nNO\r\nYES\r\n\r\n\r\n_USTN_WORKSPACESROOT\r\nSearch Path\r\nWorkSpaces Root Directory\r\nNO\r\nYES\r\n\r\n\r\n_USTN_WORKSPACESTANDARDS\r\nSearch Path\r\nWorkSpaces standards\r\nNO\r\nYES\r\n\r\n\r\n_USTN_WORKSPACETEMPLATE\r\nSearch Path\r\nWorkSpace template file\r\nNO\r\nYES\r\n\r\n\r\n_USTN_WORKSETSTANDARDSDIRNAME\r\nSearch Path\r\nWorkSet Standards Files Directory Name\r\nNO\r\nYES\r\n\r\n\r\n_USTN_WORKSETSTANDARDS\r\nSearch Path\r\nWorkSet Standards Files\r\nNO\r\nYES\r\n\r\n\r\n_USTN_WORKSETDGNSDIRNAME\r\nSearch Path\r\nDesign Files Directory Name\r\nNO\r\nYES\r\n\r\n\r\n_USTN_WORKSETDGNS\r\nSearch Path\r\nDesign Files\r\nNO\r\nYES\r\n\r\n\r\n_USTN_WORKSETROOT\r\nDirectory\r\nWorkSet Root Directory\r\nYES\r\nNO\r\n\r\n\r\n_USTN_WORKSETSROOT\r\nDirectory\r\nWorkSets Root Directory\r\nYES\r\nNO\r\n\r\n\r\n_USTN_DATABASE\r\nDirectory\r\nDatabase Configuration Files\r\nYES\r\nNO\r\n\r\n\r\n_USTN_ORGANIZATION\r\nDirectory\r\nOrganization Configuration Files\r\nYES\r\nNO\r\n\r\n\r\n_USTN_APPL\r\nDirectory\r\nApplication Config Files\r\nYES\r\nNO\r\n\r\n\r\n_USTN_CONFIGURATION\r\nDirectory\r\nConfiguration Root Directory\r\nYES\r\nNO\r\n\r\n\r\n_USTN_SYSTEMROOT\r\nDirectory\r\nWorkspace System Directory\r\nYES\r\nNO\r\n\r\n\r\n_USTN_SYSTEM\r\nDirectory\r\nSystem Configuration Files\r\nYES\r\nNO\r\n\r\n\r\n_USTN_DATABASECFG\r\nFilename\r\nDatabase Configuration File\r\nYES\r\nNO\r\n\r\n\r\n_USTN_DATABASENAME\r\nBase Name\r\nDatabase Name\r\nYES\r\nNO\r\n\r\n\r\n_VERSION89\r\nKeyword\r\nVersion Number\r\nYES\r\nNO\r\n\r\n\r\n_PLATFORMNAME\r\nKeyword\r\nPlatform Name\r\nYES\r\nNO\r\n\r\n\r\n_WORKDIR\r\nDirectory\r\nWorking Directory\r\nYES\r\nNO\r\n\r\n\r\n_USTN_HOMEROOT\r\nDirectory\r\nLocal Product-specific Data Directory\r\nYES\r\nNO\r\n\r\n\r\n_USTN_HOMEPREFS\r\nDirectory\r\nLocal Preferences Directory\r\nYES\r\nNO\r\n\r\n\r\n_USTN_CAPABILITY_V7\r\nKeyword\r\nV7 Workmode Capabilities\r\nYES\r\nNO\r\n\r\n\r\n_USTN_CAPABILITY_DGN\r\nKeyword\r\nDGN Workmode Capabilities\r\nYES\r\nNO\r\n\r\n\r\n_USTN_CAPABILITY_DWG\r\nKeyword\r\nDWG Workmode Capabilities\r\nYES\r\nNO\r\n\r\n\r\n_USTN_CAPABILITY\r\nKeyword\r\n$[_USTN_PRODUCT_NAME] Capabilities\r\nYES\r\nNO\r\n\r\n\r\n_USTN_BENTLEYROOT\r\nDirectory\r\nBentley Root Directory\r\nYES\r\nNO\r\n\r\n\r\n_USTN_WORKSPACESTANDARDSUBDIRS\r\nFilelist\r\nWorkSpace Standard Subdirectories\r\nNO\r\nNO\r\n\r\n\r\n_USTN_WORKSETSTANDARDSUBDIRS\r\nFilelist\r\nWorkSet Standard Subdirectories\r\nNO\r\nNO\r\n\r\n\r\nMSDIR_INSTALLED\r\nDirectory\r\nExecutable Directory\r\nYES\r\nNO\r\n\r\n\r\n_ROOTDIR\r\nDirectory\r\nExecutable Directory\r\nYES\r\nNO\r\n\r\n\r\n_USTN_OUTDIRNAME\r\nDirectory\r\nOutput Base Directory Name\r\nNO\r\nNO\r\n\r\n\r\n_USTN_OUT\r\nDirectory\r\nOutput Base Directory\r\nNO\r\nNO\r\n\r\n\r\n_USTN_NEWDGNFILE\r\nFilelist\r\nMDL Apps Loaded on New Design File\r\nYES\r\nNO\r\n\r\n\r\n_USTN_FIRSTDGNFILE\r\nFilelist\r\nMDL Apps Loaded on First Design File\r\nYES\r\nNO\r\n\r\n\r\n_USTN_REQUIREDAPPS\r\nFilelist\r\nRequired MDL Applications\r\nYES\r\nNO\r\n\r\n\r\n_USTN_DISPLAYALLCFGVARS\r\nBoolean\r\nConfig Var Display Flag\r\nNO\r\nNO\r\n\r\n\r\n_ENGINENAME\r\nKeyword\r\nFoundation Product\r\nYES\r\nNO\r\n\r\n\r\n_USTN_CUSTOM_CONFIGURATION\r\nKeyword\r\nDefines the path of your custom Configuration directory\r\nYES\r\nNO\r\n\r\n\r\n$[_USTN_PRODUCT_CONFIGVARNAME]\r\nBoolean\r\nProduct\r\nYES\r\nNO\r\n\r\n\r\n_INTELNT\r\nBoolean\r\nOperating System\r\nYES\r\nNO\r\n\r\n\r\n_WINNT\r\nBoolean\r\nOperating System\r\nYES\r\nNO\r\n\r\n\r\n\r\n\r\nALL lists only\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConfiguration Variable Name\r\nType\r\nShort Description\r\nRestart\r\nWorkSet\r\n\r\n\r\n\r\n\r\nMS_NAMEDCOMMANDSLIST\r\nFilelist\r\nNamed Command Definitions XML File List\r\nNO\r\nYES\r\n\r\n\r\n_USTN_PRIMARY_RIBBONRSCLIST\r\nFilelist\r\nPrimary Ribbon Resource File List\r\nYES\r\nNO\r\n\r\n\r\nMS_DGNINDEXER_PORT\r\nKeyword\r\nDGN Indexer port\r\nYES\r\nYES\r\n\r\n\r\nMS_ANNOTATIONSCALEPROPAGATION\r\nKeyword\r\nModel Annotation Scale Propagation\r\nNO\r\nYES\r\n\r\n\r\nMS_AUTO_UPDATE_FIELDS\r\nKeyword\r\nAutomatically Update Fields in Active Model\r\nNO\r\nYES\r\n\r\n\r\nMS_NOTEAUTOUPDATE\r\nKeyword\r\nAutomatically update Note when saving Dimension Style\r\nNO\r\nYES\r\n\r\n\r\nMS_DIMLEGACYPOINTORDER\r\nKeyword\r\nUse Legacy Datapoint Order for Dimensions\r\nNO\r\nYES\r\n\r\n\r\nMS_SHEETDIR\r\nDirectory\r\nOutput directory for sheet files\r\nNO\r\nYES\r\n\r\n\r\nMS_DRAWINGDIR\r\nDirectory\r\nOutput directory for drawing files\r\nNO\r\nYES\r\n\r\n\r\n_USTN_SYSTEMTABLES\r\nDirectory\r\nTables Root Directory\r\nNO\r\nNO\r\n\r\n\r\n_USTN_RASTERTABLE\r\nDirectory\r\nRaster Table Directory\r\nNO\r\nNO\r\n\r\n\r\n_USTN_CUSTOMIZEBASEID\r\nKeyword\r\nBase Resource Identifier for user customizations\r\nNO\r\nNO\r\n\r\n\r\n_USTN_RMGR_MAXFILEPTRS\r\nKeyword\r\nResource File Pointers\r\nYES\r\nNO\r\n\r\n\r\nPZIP_OUT\r\nDirectory\r\nPackager Output Directory\r\nNO\r\nNO\r\n\r\n\r\nMS_SIGNATURE_DELETE_REQUIRES_PRIVATE_KEY\r\nBoolean\r\nMust own private key to delete signature?\r\nNO\r\nYES\r\n\r\n\r\nMS_SIGNATURE_SHOW_FULL_NAME\r\nBoolean\r\nDigital signature full name\r\nNO\r\nYES\r\n\r\n\r\nMS_SIGNATURE_DISPLAY_UNVERIFIED\r\nNONE\r\nDigital signature X\r\nYES\r\nYES\r\n\r\n\r\nMS_DATA\r\nDirectory\r\nData Files\r\nNO\r\nNO\r\n\r\n\r\nMS_OLDUSERLICENSE\r\nFilename\r\nOld User License\r\nNO\r\nNO\r\n\r\n\r\nMS_USERLICENSE\r\nFilename\r\nUser License\r\nNO\r\nNO\r\n\r\n\r\n_PACKAGEFILE\r\nFilename\r\nPackage File Name\r\nNO\r\nNO\r\n\r\n\r\n_EMBEDFILE\r\nFilename\r\nEmbedded File Name\r\nNO\r\nNO\r\n\r\n\r\n_DGNFILE\r\nFilename\r\nCurrent File Name\r\nNO\r\nNO\r\n\r\n\r\n_DGNDIR\r\nDirectory\r\nCurrent File Directory\r\nNO\r\nNO\r\n\r\n\r\n_USTN_HELPNAMESPACE\r\nKeyword\r\nHelp Namespace\r\nYES\r\nNO\r\n\r\n\r\nMS_HELPLOAD_TOPICPAGE\r\nKeyword\r\nHelp Topic Page Name Format\r\nYES\r\nNO\r\n\r\n\r\nMS_HELPLOAD_CONTENTSPAGE\r\nKeyword\r\nHelp Contents Page\r\nYES\r\nNO\r\n\r\n\r\nMS_HELPLOAD_USEBROWSER\r\nBoolean\r\nUse Browser for Help\r\nYES\r\nNO\r\n\r\n\r\nMS_WORKSETMISMATCH_ALERT_EXCLUDE_VARS_ALLLEVELS\r\nSearch Path\r\nExclusion list for WorkSet Mismatch(All levels)\r\nNO\r\nNO\r\n\r\n\r\nMS_WORKSETMISMATCH_ALERT_EXCLUDE_VARS_WORKSPACELEVEL\r\nSearch Path\r\nExclusion list for WorkSet Mismatch(WorkSpace Level and Above)\r\nNO\r\nNO\r\n\r\n\r\nMS_HELPLOAD_APPLICATION\r\nKeyword\r\nApplication Type that Loads Help\r\nYES\r\nNO\r\n\r\n\r\n_USTN_LOCALUSERTEMPPATH\r\nSearch Path\r\nHelp Path\r\nNO\r\nNO\r\n\r\n\r\n_USTN_USERAPPDATAPATH\r\nSearch Path\r\nHelp Path\r\nNO\r\nNO\r\n\r\n\r\n_USTN_LOCALUSERAPPDATAPATH\r\nSearch Path\r\nHelp Path\r\nNO\r\nNO\r\n\r\n\r\nMS_HELPPATH\r\nSearch Path\r\nHelp Path\r\nNO\r\nNO\r\n\r\n\r\nMS_RIGHTLOGICKB\r\nKeyword\r\nRight to Left Chars\r\nNO\r\nNO\r\n\r\n\r\nMS_INITAPPS\r\nFilelist\r\nInitial MDL Applications\r\nYES\r\nNO\r\n\r\n\r\nMS_RSRC\r\nFilename\r\nMain Resource\r\nYES\r\nNO\r\n\r\n\r\nMS_DGNOUT\r\nDirectory\r\nOutput Design Files\r\nNO\r\nYES\r\n\r\n\r\nMS_OPENDESIGNFILEFILTER\r\nKeyword\r\nOpen Design File Filter\r\nNO\r\nYES\r\n\r\n\r\nMS_SMARTSOLID\r\nDirectory\r\nSmartSolid Directory\r\nNO\r\nYES\r\n\r\n\r\nMS_SNAP_TANGENT_POINT_DEFAULT_MODE\r\nNONE\r\nPerp/Tan location\r\nNO\r\nYES\r\n\r\n\r\nMS_SNAPMODE_SOURCE\r\nNONE\r\nSnap mode source\r\nNO\r\nYES\r\n\r\n\r\nMS_VIEWATTRIBUTES_PLUGINASSEMBLIES\r\nNONE\r\nView Attributes Plugin Assemblies\r\nNO\r\nYES\r\n\r\n\r\nCONNECTUSER_FULLNAME\r\nNONE\r\nCONNECT User Full Name\r\nNO\r\nYES\r\n\r\n\r\nCONNECTUSER_LANGUAGE\r\nNONE\r\nCONNECT User Language\r\nNO\r\nYES\r\n\r\n\r\nCONNECTUSER_ORGANIZATION\r\nNONE\r\nCONNECT User Organization\r\nNO\r\nYES\r\n\r\n\r\nCONNECTUSER_COUNTRY\r\nNONE\r\nCONNECT User Country\r\nNO\r\nYES\r\n\r\n\r\nCONNECTUSER_NAME\r\nNONE\r\nCONNECT User Name\r\nNO\r\nYES\r\n\r\n\r\nCONNECTPROJECT_ASSETTYPE\r\nNONE\r\nCONNECT Project Asset Type\r\nNO\r\nYES\r\n\r\n\r\nCONNECTPROJECT_INDUSTRY\r\nNONE\r\nCONNECT Project Industry\r\nNO\r\nYES\r\n\r\n\r\nCONNECTPROJECT_LOCATION\r\nNONE\r\nCONNECT Project Location\r\nNO\r\nYES\r\n\r\n\r\nCONNECTPROJECT_STATUS\r\nNONE\r\nCONNECT Project Status\r\nNO\r\nYES\r\n\r\n\r\nCONNECTPROJECT_NUMBER\r\nNONE\r\nCONNECT Project Number\r\nNO\r\nYES\r\n\r\n\r\nCONNECTPROJECT_NAME\r\nNONE\r\nCONNECT Project Name\r\nNO\r\nYES\r\n\r\n\r\n\r\n\r\nPrimary Search Path Category\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConfiguration Variable Name\r\nType\r\nShort Description\r\nRestart\r\nWorkSet\r\n\r\n\r\n\r\n\r\nMS_DGNLIBLIST_DETAILINGSYMBOLSTYLES\r\nFilelist\r\nProcess the DGNLIBs for available DetailingSymbol Styles.\r\nNO\r\nYES\r\n\r\n\r\nMS_DGNLIBLIST_LINESTYLES\r\nFilelist\r\nProcess the DGNLIBs for available LineStyles.\r\nNO\r\nYES\r\n\r\n\r\nMS_DGNLIBLIST_DRAWINGSEEDS\r\nFilelist\r\nProcess the DGNLIBs for available DrawingSeeds.\r\nNO\r\nYES\r\n\r\n\r\nMS_DGNLIBLIST_DISPLAYSTYLES\r\nFilelist\r\nProcess the DGNLIBs for available Display Styles.\r\nNO\r\nYES\r\n\r\n\r\nMS_DGNLIBLIST_DIMENSIONSTYLES\r\nFilelist\r\nProcess the DGNLIBs for available Dimension Styles.\r\nNO\r\nYES\r\n\r\n\r\nMS_DGNLIBLIST_TEXTSTYLES\r\nFilelist\r\nProcess the DGNLIBs for available Text Styles.\r\nNO\r\nYES\r\n\r\n\r\nMS_DGNLIBLIST_TEXTFAVORITES\r\nFilelist\r\nProcess the DGNLIBs for available Text favorites.\r\nNO\r\nYES\r\n\r\n\r\nMS_SEED_LINKSET_PATH\r\nSearch Path\r\nLink Set Seed File Path\r\nNO\r\nYES\r\n\r\n\r\n_USTN_COMMONAPPDATAPATH\r\nFilelist\r\nDefines the full path to the file directory containing application\r\ndata for all users\r\nNO\r\nYES\r\n\r\n\r\nMS_ECFRAMEWORK_SCHEMAS\r\nFilelist\r\nECSchema Search Path\r\nNO\r\nYES\r\n\r\n\r\nMS_DGNLIBLIST_PRINTING\r\nFilelist\r\nDGN Library List for Print Styles.\r\nNO\r\nYES\r\n\r\n\r\nMS_DGNLIBLIST_LINKS\r\nFilelist\r\nDGN Library List for Link Set files.\r\nNO\r\nYES\r\n\r\n\r\nMS_DGNLIBLIST_RENDER\r\nFilelist\r\nDGN Library List for Rendering tasks.\r\nNO\r\nYES\r\n\r\n\r\nMS_DGNLIBLIST\r\nFilelist\r\nDGN Library List\r\nNO\r\nYES\r\n\r\n\r\nMS_DEF\r\nSearch Path\r\nDesign Files\r\nNO\r\nYES\r\n\r\n\r\nMS_RFDIR\r\nSearch Path\r\nReferences\r\nNO\r\nYES\r\n\r\n\r\nMS_MDLAPPS\r\nSearch Path\r\nVisible MDL Applications\r\nNO\r\nYES\r\n\r\n\r\nMS_MDL\r\nSearch Path\r\nMDL Applications\r\nNO\r\nYES\r\n\r\n\r\nMS_ADDINPATH\r\nSearch Path\r\nAddIns\r\nNO\r\nYES\r\n\r\n\r\nMS_ADDIN_DEPENDENCYPATH\r\nSearch Path\r\nAddIn Dependencies\r\nNO\r\nYES\r\n\r\n\r\nMS_RSRCPATH\r\nSearch Path\r\nResource Files\r\nNO\r\nYES\r\n\r\n\r\nMS_GUIDGNLIBLIST\r\nFilelist\r\nUser Interface DGN Library List\r\nNO\r\nYES\r\n\r\n\r\nMS_LIBRARY_PATH\r\nSearch Path\r\nLibrary Path\r\nNO\r\nYES\r\n\r\n\r\nRDL_DIR\r\nSearch Path\r\nRedline Location\r\nNO\r\nYES\r\n\r\n\r\nDWGRDL_DIR\r\nSearch Path\r\nDWG Redline Location\r\nNO\r\nYES\r\n\r\n\r\nMS_FILTER_LIB_DIR\r\nSearch Path\r\nFilter Library Path\r\nNO\r\nYES\r\n\r\n\r\nMS_LINFILELIST\r\nFilelist\r\nLIN File Path\r\nYES\r\nYES\r\n\r\n\r\nMS_ICONRSCLIST\r\nSearch Path\r\nIcon Resource File List\r\nYES\r\nNO\r\n\r\n\r\nMS_ICONLIBRARYLIST\r\nSearch Path\r\nIcon Library List\r\nYES\r\nNO\r\n\r\n\r\nMS_ICONPATH\r\nSearch Path\r\nIcon Path\r\nYES\r\nNO\r\n\r\n\r\nMS_PERSONALDGNLIB\r\nFilename\r\nUsers Personal DGNLIB\r\nYES\r\nYES\r\n\r\n\r\n\r\n\r\nPrinting Category\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConfiguration Variable Name\r\nType\r\nShort Description\r\nRestart\r\nWorkSet\r\n\r\n\r\n\r\n\r\nMS_PLTCFG_PATH\r\nSearch Path\r\nPrinter Driver Config Path\r\nNO\r\nYES\r\n\r\n\r\nMS_DEFAULT_PLTCFG_FILE\r\nFilename\r\nDefault Printer Configuration\r\nNO\r\nYES\r\n\r\n\r\nMS_PLT_PDF_PLTFILE\r\nFilename\r\nDefault PDF Printer Config\r\nNO\r\nYES\r\n\r\n\r\nMS_PLT_SYSPRT_PLTFILE\r\nFilename\r\nDefault Windows Printer Config\r\nNO\r\nYES\r\n\r\n\r\nMS_PLT_SYSPRT_DEFAULT_PRINTER\r\nKeyword\r\nDefault Windows Printer Name\r\nNO\r\nYES\r\n\r\n\r\nMS_PLT_SYSPRT_DEFAULT_FORM\r\nKeyword\r\nDefault Windows Form Name\r\nNO\r\nYES\r\n\r\n\r\nMS_PLT_SYSPRT_DEFAULT_TRAY\r\nKeyword\r\nDefault Windows Tray Name\r\nNO\r\nYES\r\n\r\n\r\nMS_PLTFILES\r\nDirectory\r\nPrint Output Directory\r\nNO\r\nYES\r\n\r\n\r\nMS_PRINTDEF_PATH\r\nSearch Path\r\nPrint Definition Search Path\r\nNO\r\nYES\r\n\r\n\r\nMS_PENTABLE\r\nSearch Path\r\nPen Table Search Path\r\nNO\r\nYES\r\n\r\n\r\nMS_DESIGNSCRIPT_PATH\r\nSearch Path\r\nDesign Script Search Path\r\nNO\r\nYES\r\n\r\n\r\nMS_PROPFILTER_PATH\r\nSearch Path\r\nProperty Filter Search Path\r\nNO\r\nYES\r\n\r\n\r\nMS_PLT_PREVIEW_USABLEAREACOLOR\r\nKeyword\r\nPreview Usable Area Color\r\nYES\r\nYES\r\n\r\n\r\nMS_PLT_PREVIEW_PLOTBOXCOLOR\r\nKeyword\r\nPreview Plot Rectangle Color\r\nYES\r\nYES\r\n\r\n\r\nMS_PLT_PREVIEW_PLOTFENCECOLOR\r\nKeyword\r\nPreview Plot Fence Color\r\nYES\r\nYES\r\n\r\n\r\nMS_PLTDLG_UNLOADONCLOSE\r\nKeyword\r\nUnload Print Dialog on Close\r\nNO\r\nYES\r\n\r\n\r\nMS_PLTDLG_CLOSE_AFTER_PLOT\r\nKeyword\r\nClose Print Dialog After Plot\r\nNO\r\nYES\r\n\r\n\r\nMS_PLT_ENABLE_SCALE_CLIPPING\r\nKeyword\r\nEnable Scale Clipping\r\nNO\r\nYES\r\n\r\n\r\nMS_PLT_ENABLE_PRESERVE_SCALE\r\nKeyword\r\nEnable Preserve Scale\r\nNO\r\nYES\r\n\r\n\r\nMS_PLT_ENABLE_AUTO_ROTATE\r\nKeyword\r\nEnable Automatic Rotation\r\nNO\r\nYES\r\n\r\n\r\nMS_PLT_ENABLE_AUTO_ORIENT\r\nKeyword\r\nEnable Automatic Orientation\r\nNO\r\nYES\r\n\r\n\r\nMS_PLTDLG_AREA_PRIORITY\r\nKeyword\r\nPrint Area Priority\r\nNO\r\nYES\r\n\r\n\r\nMS_PLT_FORM_SCALE_PRIORITY\r\nKeyword\r\nForm Scale Priority\r\nNO\r\nYES\r\n\r\n\r\nMS_PLT_SET_LAYOUT_FROM_SHEET\r\nKeyword\r\nHonor Sheet Layout Info\r\nNO\r\nYES\r\n\r\n\r\nMS_PLT_SET_PLOT_STYLE_TABLE_FROM_SHEET\r\nKeyword\r\nHonor Sheet Plot Style Table\r\nNO\r\nYES\r\n\r\n\r\nMS_PLT_MAX_ON_NEW_AREA\r\nKeyword\r\nMaximize on New Print Area\r\nNO\r\nYES\r\n\r\n\r\nMS_PLTDLG_AUTO_FIT_VIEW\r\nKeyword\r\nAutomatically Fit View\r\nNO\r\nYES\r\n\r\n\r\nMS_PLTDLG_SHOW_BASIC_LAYOUT_CONTROLS\r\nKeyword\r\nBasic Layout Controls\r\nNO\r\nYES\r\n\r\n\r\nMS_PLTDLG_ALLOW_FORM_SIZE_EDIT\r\nKeyword\r\nAllow Form Size Edits\r\nNO\r\nYES\r\n\r\n\r\nMS_PLTDLG_SHOW_PRINT_STATUS\r\nKeyword\r\nShow Print Status Dialog\r\nNO\r\nYES\r\n\r\n\r\nMS_PLTDLG_THUMBNAIL_PREVIEW_TIMEOUT\r\nKeyword\r\nThumbnail Preview Timeout\r\nNO\r\nYES\r\n\r\n\r\nMS_PLTDLG_SHOW_ACCURATE_PREVIEW_ROTATION\r\nKeyword\r\nPreview Accurate Rotation\r\nNO\r\nYES\r\n\r\n\r\nMS_PLTDLG_SET_UNITS_FROM_SHEET\r\nKeyword\r\nSet Units from Sheet\r\nNO\r\nYES\r\n\r\n\r\nMS_PLTDLG_KEEPVIEWFLAGSONFENCECHANGE\r\nBoolean\r\nKeep View Flags on New Fence\r\nNO\r\nYES\r\n\r\n\r\nMS_PLOTDLG_DEF_PENTABLE\r\nFilename\r\nDefault Pen Table\r\nNO\r\nYES\r\n\r\n\r\nMS_PLTDLG_ENABLE_SAVE_CONFIG\r\nKeyword\r\nEnable Save Configuration\r\nNO\r\nYES\r\n\r\n\r\nMS_PLTDLG_DISABLE_PREFERENCES_DIALOG\r\nKeyword\r\nDisable Plotdlg Preferences\r\nNO\r\nYES\r\n\r\n\r\nMS_PLT_SCALE_METHOD\r\nKeyword\r\nScale Method\r\nNO\r\nYES\r\n\r\n\r\nMS_PENTABLE_IMPORTEMPTYSECTIONS\r\nBoolean\r\nImport Empty Pen Table Sections\r\nNO\r\nYES\r\n\r\n\r\nMS_PENTABLE_DISABLECOLOR\r\nBoolean\r\nPen Table Disable Color\r\nNO\r\nYES\r\n\r\n\r\nMS_PENTABLE_SLOTNUM_MATCH_APPLIES_TO_CHILD\r\nKeyword\r\nPen Table Slot Number Match\r\nNO\r\nYES\r\n\r\n\r\nMS_PENTABLE_SEARCH_LEVEL_LIBRARIES\r\nKeyword\r\nPen Table Search Level Libs\r\nNO\r\nYES\r\n\r\n\r\nMS_PENTABLE_IMPORTCTB_NOPENMAP\r\nBoolean\r\nPen Table Import Pen Maps\r\nNO\r\nYES\r\n\r\n\r\nMS_PLTFILE_EDITOR\r\nFilename\r\nPrinter Configuration Editor\r\nNO\r\nYES\r\n\r\n\r\nMS_PENTABLE_EDITOR\r\nFilename\r\nPen Table Editor\r\nNO\r\nYES\r\n\r\n\r\nMS_DESIGNSCRIPT_EDITOR\r\nFilename\r\nDesign Script Editor\r\nNO\r\nYES\r\n\r\n\r\nMS_PLT_INVERT_WHITE_COLORS\r\nKeyword\r\nInvert White-to-Black Colors\r\nNO\r\nYES\r\n\r\n\r\nMS_PLT_ABBREVIATE_BORDER_FILENAME\r\nKeyword\r\nAbbreviate Border Filename\r\nNO\r\nYES\r\n\r\n\r\nMS_PLT_AUTOAREA_RESULT_LIMIT\r\nKeyword\r\nAutomatic Area Result Limit\r\nNO\r\nYES\r\n\r\n\r\nMS_PLT_AUTOAREA_SORT_MODE\r\nKeyword\r\nAutomatic Area Sort Order\r\nNO\r\nYES\r\n\r\n\r\nMS_PLT_ENGINE_CMDLINE_ARGS\r\nKeyword\r\nEngine Command-Line Arguments\r\nNO\r\nYES\r\n\r\n\r\nMS_PLT_ENABLE_VARIABLE_DEFINITION_MODE\r\nKeyword\r\nUse Variable Print Definitions\r\nNO\r\nYES\r\n\r\n\r\nMS_PRINTORGANIZER_OPEN_DGN_READWRITE\r\nKeyword\r\nOpen Designs Read-Write\r\nNO\r\nYES\r\n\r\n\r\nMS_PRINTERLIST_VISIBILITY\r\nKeyword\r\nPrinter List Visibility\r\nNO\r\nYES\r\n\r\n\r\nMS_PRINTERLIST_SYSPRINTERS\r\nKeyword\r\nPrinter List System Printers\r\nNO\r\nYES\r\n\r\n\r\nMS_PLT_ACCTVAR_ABBREV_LEN\r\nKeyword\r\nAccounting Var Abbrev Length\r\nNO\r\nYES\r\n\r\n\r\nMS_PLT_DEFAULT_PRINTDEF_NAME_EXPRESSION\r\nKeyword\r\nDefault print definition name expression\r\nNO\r\nYES\r\n\r\n\r\nMS_PLT_DEFAULT_OUTPUT_FILENAME_EXPRESSION\r\nKeyword\r\nDefault output file name expression\r\nNO\r\nYES\r\n\r\n\r\nMS_PLOT_VISEDGE_OVERRIDES\r\nNONE\r\nPlotting Visible Edge Overrides\r\nNO\r\nYES\r\n\r\n\r\n\r\n\r\nCell Category\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConfiguration Variable Name\r\nType\r\nShort Description\r\nRestart\r\nWorkSet\r\n\r\n\r\n\r\n\r\nMS_CELL\r\nSearch Path\r\nCell Library Directories\r\nNO\r\nYES\r\n\r\n\r\nMS_CELLLIST\r\nFilelist\r\nCell Library List\r\nNO\r\nYES\r\n\r\n\r\nMS_CELLSELECTORDIR\r\nDirectory\r\nCell Selector Directory\r\nNO\r\nYES\r\n\r\n\r\nMS_CELLSELECTOR\r\nFilename\r\nCell Selector File\r\nNO\r\nYES\r\n\r\n\r\nMS_CELLOUT\r\nDirectory\r\nOutput Cell Libraries\r\nNO\r\nYES\r\n\r\n\r\nMS_MENU\r\nFilename\r\nMenu Cells\r\nNO\r\nNO\r\n\r\n\r\nMS_RESOLVESCNAMECONFLICTS\r\nKeyword\r\nShared Cell Name Conflicts\r\nNO\r\nNO\r\n\r\n\r\n\r\n\r\nSeed Category\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConfiguration Variable Name\r\nType\r\nShort Description\r\nRestart\r\nWorkSet\r\n\r\n\r\n\r\n\r\nMS_SEED_LINKSET_NAME\r\nKeyword\r\nLink Set Name\r\nNO\r\nYES\r\n\r\n\r\nMS_SEED_LINKSET_FILE_NAME\r\nFilename\r\nLink Set Seed File\r\nNO\r\nYES\r\n\r\n\r\nMS_INPUT_CONFIGXMLSEED\r\nFilename\r\nTouch Gesture Assignments Seed File\r\nYES\r\nYES\r\n\r\n\r\nMS_BUTTONMENUSEED\r\nFilename\r\nButton Assignments Seed File\r\nYES\r\nYES\r\n\r\n\r\nMS_FKEYMNUSEED\r\nFilename\r\nFunction Key Assignments Seed File\r\nYES\r\nYES\r\n\r\n\r\nMS_KEYBOARDSHORTCUTSSEED\r\nFilename\r\nKeyboard Shortcuts Seed File\r\nYES\r\nYES\r\n\r\n\r\nMS_PERSONALDGNLIBSEED\r\nFilename\r\nPersonal DGNLIB Seed\r\nNO\r\nNO\r\n\r\n\r\nMS_VIEWGROUPSEED\r\nFilename\r\nView Group Seed File\r\nYES\r\nYES\r\n\r\n\r\nMS_VIEWGROUPSEEDNAME\r\nKeyword\r\nView Group Seed\r\nYES\r\nYES\r\n\r\n\r\nMS_DWGSEED\r\nFilename\r\nDWG Seed File\r\nNO\r\nYES\r\n\r\n\r\nMS_DWGSEED_OVERRIDE\r\nFilename\r\nDWG Seed File Override\r\nNO\r\nYES\r\n\r\n\r\nMS_SEEDFILES\r\nSearch Path\r\nSeed File Location\r\nNO\r\nYES\r\n\r\n\r\nMS_DESIGNSEED\r\nFilename\r\nDefault Design File Seed\r\nNO\r\nYES\r\n\r\n\r\nMS_TRANSEED\r\nFilename\r\nDefault Translation Seed\r\nNO\r\nYES\r\n\r\n\r\nMS_TRANSEED_OVERRIDE\r\nFilename\r\nTranslation Seed Override\r\nNO\r\nYES\r\n\r\n\r\nMS_CELL_SEEDFILE\r\nFilename\r\nCell Library Seed File\r\nNO\r\nYES\r\n\r\n\r\nMS_SHEETSEED\r\nFilename\r\nDrawing Sheet Seed File\r\nNO\r\nYES\r\n\r\n\r\nMS_GROUPPANELPREFSEED\r\nFilename\r\nGroup Panel Preference Seed\r\nYES\r\nNO\r\n\r\n\r\nMS_TASKDIALOGPREFSEED\r\nFilename\r\nTask Navigation Dialog Preference Seed\r\nYES\r\nNO\r\n\r\n\r\nMS_DOCKINGPREFSEED\r\nFilename\r\nDialog Docking Preference Seed\r\nYES\r\nNO\r\n\r\n\r\nMS_USERPREFSEED\r\nFilename\r\nUser Preference Seed\r\nYES\r\nNO\r\n\r\n\r\nMS_DRAWINGMODELSEED\r\nFilename\r\nDrawing Model Seed File\r\nYES\r\nYES\r\n\r\n\r\nMS_DRAWINGMODELSEEDNAME\r\nKeyword\r\nDrawing Model Seed\r\nYES\r\nYES\r\n\r\n\r\nMS_DESIGNMODELSEED\r\nFilename\r\nDesign Model Seed File\r\nYES\r\nYES\r\n\r\n\r\nMS_DESIGNMODELSEEDNAME\r\nKeyword\r\nDesign Model Seed\r\nYES\r\nYES\r\n\r\n\r\nMS_SHEETMODELSEED\r\nFilename\r\nSheet Model Seed File\r\nYES\r\nYES\r\n\r\n\r\nMS_SHEETMODELSEEDNAME\r\nKeyword\r\nSheet Model Seed\r\nYES\r\nYES\r\n\r\n\r\nMS_DWGSHEETMODELSEED\r\nFilename\r\nDWG Sheet Model Seed File\r\nYES\r\nYES\r\n\r\n\r\nMS_DWGSHEETMODELSEEDNAME\r\nKeyword\r\nDWG Sheet Model Seed\r\nYES\r\nYES\r\n\r\n\r\n\r\n\r\nTemp/Backup Category\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConfiguration Variable Name\r\nType\r\nShort Description\r\nRestart\r\nWorkSet\r\n\r\n\r\n\r\n\r\nDGNDBFILEIO_CACHE_MAX_FILES\r\nDirectory\r\nMaximum number of files in dgndb extraction cache.\r\nYES\r\nNO\r\n\r\n\r\nDGNDBFILEIO_CACHE_MAX_SIZE\r\nDirectory\r\nMaximum size of dgndb extraction cache in MB.\r\nYES\r\nNO\r\n\r\n\r\nMS_DWG_BACKUP\r\nDirectory\r\nDirectory for DWG backup files.\r\nNO\r\nNO\r\n\r\n\r\nMS_NO_DWG_BACKUP\r\nBoolean\r\nTurn off DWG .bak files\r\nNO\r\nNO\r\n\r\n\r\nMS_BACKUP\r\nDirectory\r\nBackup Files\r\nNO\r\nYES\r\n\r\n\r\nMS_TMP\r\nDirectory\r\nTemporary Files\r\nNO\r\nNO\r\n\r\n\r\nMS_SCR\r\nDirectory\r\nScratch Files\r\nNO\r\nNO\r\n\r\n\r\n\r\n\r\nColors Category\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConfiguration Variable Name\r\nType\r\nShort Description\r\nRestart\r\nWorkSet\r\n\r\n\r\n\r\n\r\nMS_DEFCTBL\r\nFilename\r\nDefault Color Table\r\nNO\r\nYES\r\n\r\n\r\nMS_RMENCTBL\r\nFilename\r\nRight Menu Color Table\r\nYES\r\nNO\r\n\r\n\r\nMS_LMENCTBL\r\nFilename\r\nLeft Menu Color Table\r\nYES\r\nNO\r\n\r\n\r\nMS_COLORBOOK_LIBRARIES\r\nFilelist\r\nColorbook Library List\r\nNO\r\nYES\r\n\r\n\r\nMS_SYSTEM_COLORBOOKS\r\nDirectory\r\nSystem Color Books Directory\r\nNO\r\nNO\r\n\r\n\r\n\r\n\r\nSymbology Category\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConfiguration Variable Name\r\nType\r\nShort Description\r\nRestart\r\nWorkSet\r\n\r\n\r\n\r\n\r\nMS_FONTCONFIGFILE\r\nSearch Path\r\nFont Configuration File Path\r\nNO\r\nYES\r\n\r\n\r\nMS_FONTPATH\r\nSearch Path\r\nFont Directories\r\nNO\r\nYES\r\n\r\n\r\nMS_SYMBRSRC\r\nFilelist\r\nSymbology Resources\r\nNO\r\nYES\r\n\r\n\r\n\r\n\r\nSystem Operation Category\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConfiguration Variable Name\r\nType\r\nShort Description\r\nRestart\r\nWorkSet\r\n\r\n\r\n\r\n\r\nMS_FAST_LEGACY_WIREFRAME\r\nBoolean\r\nDisable SmartSolid Silhouettes\r\nNO\r\nNO\r\n\r\n\r\nMS_COMPRESS_OPTIONS\r\nKeyword\r\nCompress Options Selections\r\nNO\r\nYES\r\n\r\n\r\nMS_KEYBOARDSHORTCUTSUSERORDER\r\nBoolean\r\nKeyboard Shortcuts User Order\r\nNO\r\nNO\r\n\r\n\r\nMS_KEYBOARDSHORTCUTSEXPAND\r\nBoolean\r\nKeyboard Shortcuts User Order\r\nNO\r\nNO\r\n\r\n\r\nMS_KEYBOARDSHORTCUTS\r\nFilename\r\nUser Keyboard Shortcuts\r\nYES\r\nYES\r\n\r\n\r\nMS_BUTTONMENU\r\nFilename\r\nButton Menu\r\nNO\r\nYES\r\n\r\n\r\nMS_FKEYMNU\r\nFilename\r\nFunction Key Menu\r\nNO\r\nYES\r\n\r\n\r\nMS_SAVEMENU\r\nFilename\r\nAttached Menus\r\nYES\r\nYES\r\n\r\n\r\nMS_APPMEN\r\nSearch Path\r\nApplication Menus\r\nNO\r\nYES\r\n\r\n\r\nMS_FILEHISTORY\r\nKeyword\r\nFile History\r\nYES\r\nNO\r\n\r\n\r\nMS_READONLY\r\nBoolean\r\nRead Only\r\nYES\r\nNO\r\n\r\n\r\nMS_WORKMODE\r\nKeyword\r\nWork Mode\r\nYES\r\nYES\r\n\r\n\r\nMS_OPENV7\r\nKeyword\r\nOpen V7 files\r\nNO\r\nNO\r\n\r\n\r\nMS_OPENDWGAEC\r\nKeyword\r\nOpen DWG AEC files\r\nNO\r\nNO\r\n\r\n\r\nMS_DISABLE_FILE_ICONS\r\nBoolean\r\nDisable File Open Icons\r\nNO\r\nNO\r\n\r\n\r\nMS_SOURCENAME_PROPERTY\r\nKeyword\r\nSave the SOURCE file property\r\nNO\r\nNO\r\n\r\n\r\nMS_IDLETIMEOUT\r\nKeyword\r\nExit $[_USTN_PRODUCT_NAME] when idle\r\nNO\r\nNO\r\n\r\n\r\nMS_POPUPDIALOGCLOSEDELAY\r\nKeyword\r\nPopup Dialog Close Delay\r\nNO\r\nNO\r\n\r\n\r\nMS_LEGACYTOOLMAPLIST\r\nFilelist\r\nPath to files that contain Tool Mapping data.\r\nNO\r\nNO\r\n\r\n\r\nMS_FULLPATHINTITLEBAR\r\nKeyword\r\nFull Path in Title Bar\r\nNO\r\nNO\r\n\r\n\r\nMS_NO_VIEW_ANIMATION\r\nKeyword\r\nDisable Tile/Cascade Animation\r\nNO\r\nNO\r\n\r\n\r\nMS_COMMONITEMDIALOG\r\nBoolean\r\nCommon Item Dialog from Microsoft\r\nNO\r\nNO\r\n\r\n\r\nMS_VIEWAUTORESIZE\r\nKeyword\r\nView Resize Behavior\r\nNO\r\nNO\r\n\r\n\r\nMS_GRAYGROUPHEADERBACKGROUND\r\nBoolean\r\nGray Color for Group Headers\r\nYES\r\nNO\r\n\r\n\r\nMS_UPDATESPLITBUTTONLABELTOSELECTED\r\nBoolean\r\nUpdate Split Button Label to Selected\r\nYES\r\nNO\r\n\r\n\r\nMS_GROUPPOPUPFADEKEYTIPS\r\nBoolean\r\nRibbon Group Popup Fade KeyTips\r\nYES\r\nNO\r\n\r\n\r\nMS_RIBBON_NUMEXPANDEDTASKGROUPS\r\nKeyword\r\nNumber of expanded ribbon groups on Active Task tab\r\nNO\r\nNO\r\n\r\n\r\nMS_RIBBON_MAXBUTTONLABELCHARS\r\nKeyword\r\nMaximum characters for a ribbon button label\r\nYES\r\nNO\r\n\r\n\r\nMS_CURSORPROMPT\r\nBoolean\r\nCursor Prompt\r\nYES\r\nNO\r\n\r\n\r\nMS_AUTOUPDATETEXTITEMSSLOWER\r\nBoolean\r\nAutoUpdate speed for Text items\r\nYES\r\nNO\r\n\r\n\r\nMS_AUTOUPDATETEXTITEMSSUPPORT\r\nBoolean\r\nAutoUpdate feature for Text items\r\nYES\r\nNO\r\n\r\n\r\nMS_TOOLSETTINGSIGNORETITLEFORWIDTH\r\nBoolean\r\nTool Settings Ignore Title when Determining Width\r\nYES\r\nNO\r\n\r\n\r\nMS_INPUT_CONFIGXML\r\nFilename\r\nDefault Touch Gesture Configuration\r\nNO\r\nNO\r\n\r\n\r\nMS_DEFAULT_MAINTASKPATH\r\nKeyword\r\nDefault Main Task\r\nYES\r\nNO\r\n\r\n\r\nMS_VIEWTOOLBOX3D\r\nKeyword\r\nView window toolbox for 3D\r\nYES\r\nNO\r\n\r\n\r\nMS_VIEWTOOLBOX2D\r\nKeyword\r\nView window toolbox for 2D\r\nYES\r\nNO\r\n\r\n\r\nMS_GROUPPOPUPFALLBACKWORKFLOW_3D\r\nKeyword\r\n3D Fall-back Workflow for pop-up group processing\r\nNO\r\nYES\r\n\r\n\r\nMS_GROUPPOPUPFALLBACKWORKFLOW_2D\r\nKeyword\r\n2D Fall-back Workflow for pop-up group processing\r\nNO\r\nYES\r\n\r\n\r\nMS_RIBBONCOMPONENTPROVIDERS\r\nFilelist\r\nRibbon Component Providers AddIn List\r\nYES\r\nYES\r\n\r\n\r\nMS_RIBBONXML\r\nFilelist\r\nRibbon XML File List\r\nNO\r\nYES\r\n\r\n\r\nMS_RIBBONPREFSSEED\r\nFilelist\r\nRibbon Preferences Seed File\r\nYES\r\nYES\r\n\r\n\r\nMS_RIBBONPREFS\r\nFilelist\r\nRibbon Preferences File\r\nYES\r\nYES\r\n\r\n\r\nMS_RIBBONRSCLIST\r\nFilelist\r\nRibbon Resource File List\r\nNO\r\nYES\r\n\r\n\r\nMS_RIBBONDIR\r\nSearch Path\r\nBase Path for Ribbon Definitions\r\nNO\r\nNO\r\n\r\n\r\nMS_VISEDGE_OVERRIDES\r\nNONE\r\nVisible Edge Overrides\r\nNO\r\nYES\r\n\r\n\r\nMS_VISEDGE_DEFAULTS\r\nNONE\r\nVisible Edge Overrides\r\nNO\r\nYES\r\n\r\n\r\n\r\n\r\nRendering/Image Category\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConfiguration Variable Name\r\nType\r\nShort Description\r\nRestart\r\nWorkSet\r\n\r\n\r\n\r\n\r\nMS_MATERIAL\r\nSearch Path\r\nMaterial Palettes\r\nNO\r\nYES\r\n\r\n\r\nMS_PATTERN\r\nSearch Path\r\nPattern Maps\r\nNO\r\nYES\r\n\r\n\r\nMS_BUMP\r\nSearch Path\r\nBump Maps\r\nNO\r\nYES\r\n\r\n\r\nMS_IMAGE\r\nSearch Path\r\nImages\r\nNO\r\nYES\r\n\r\n\r\nMS_IMAGEOUT\r\nDirectory\r\nImage Output\r\nNO\r\nYES\r\n\r\n\r\nMS_SHADOWMAP\r\nDirectory\r\nShadow Maps\r\nNO\r\nYES\r\n\r\n\r\nMS_LIGHTING\r\nSearch Path\r\nIES Lighting Files\r\nNO\r\nYES\r\n\r\n\r\nMS_LIGHTLIST\r\nFilelist\r\nPredefined Light Sources\r\nNO\r\nYES\r\n\r\n\r\nMS_IMAGE_EDITOR\r\nFilename\r\nImage Editor\r\nNO\r\nYES\r\n\r\n\r\nMS_MATERIAL_PREVIEW_BACKGROUND\r\nFilename\r\nMaterial Preview Background\r\nNO\r\nYES\r\n\r\n\r\nMS_FILTEREDCODECS\r\nFilename\r\nFiltered DirectShow Codecs\r\nNO\r\nYES\r\n\r\n\r\nMS_RENDERV7MATERIALS\r\nBoolean\r\nV7 Material Compatibility\r\nNO\r\nYES\r\n\r\n\r\nMS_DISABLE_RPCBROWSER\r\nBoolean\r\nDisable RPC Thumbnail Browser\r\nNO\r\nYES\r\n\r\n\r\nMS_RPCDIR\r\nDirectory\r\nRPC Search Path\r\nNO\r\nYES\r\n\r\n\r\n\r\n\r\nDatabase Category\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConfiguration Variable Name\r\nType\r\nShort Description\r\nRestart\r\nWorkSet\r\n\r\n\r\n\r\n\r\nMS_UDLDIR\r\nSearch Path\r\nUniversal Data Link directory\r\nNO\r\nYES\r\n\r\n\r\nMS_ORACLE_HOME\r\nSearch Path\r\nOracle Home\r\nNO\r\nYES\r\n\r\n\r\nMS_DBASE\r\nSearch Path\r\nDatabase Files\r\nNO\r\nYES\r\n\r\n\r\nMS_SERVER\r\nFilename\r\nServer Loader\r\nNO\r\nYES\r\n\r\n\r\nMS_DBEXT\r\nFilename\r\nDatabase Server\r\nNO\r\nYES\r\n\r\n\r\nMS_LINKTYPE\r\nKeyword\r\nDatabase Linkages\r\nNO\r\nYES\r\n\r\n\r\n\r\n\r\nData Files Category\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConfiguration Variable Name\r\nType\r\nShort Description\r\nRestart\r\nWorkSet\r\n\r\n\r\n\r\n\r\nMS_CUSTOMSHEETSIZEDEF\r\nFilename\r\nSheet Size Definitions\r\nNO\r\nYES\r\n\r\n\r\nMS_CUSTOMSCALEDEF\r\nFilename\r\nScales Definitions\r\nNO\r\nYES\r\n\r\n\r\nMS_CUSTOMUNITDEF\r\nFilename\r\nUnit Definitions for Upgrading to V8\r\nNO\r\nYES\r\n\r\n\r\nMS_HTMLDGNDIR\r\nDirectory\r\nHTML Template Directory\r\nNO\r\nYES\r\n\r\n\r\nMS_WMS_SERVERS_SEED\r\nFilename\r\nSeed file for MS_WMS_SERVERS file\r\nNO\r\nYES\r\n\r\n\r\nMS_WMS_SERVERS\r\nFilename\r\nWeb Map Service servers\r\nNO\r\nYES\r\n\r\n\r\nMS_DATETIMEFORMATS\r\nFilename\r\nStandard Date Time formats\r\nNO\r\nYES\r\n\r\n\r\nMS_SETTINGSOUTDIR\r\nDirectory\r\nSettings Output Directory\r\nNO\r\nYES\r\n\r\n\r\nMS_SETTINGSDIR\r\nDirectory\r\nSettings Directory\r\nNO\r\nYES\r\n\r\n\r\nMS_REMAP_CSVFILE\r\nFilename\r\nRemap CSV File\r\nNO\r\nYES\r\n\r\n\r\nMS_BSILOG_CONFIG_FILE\r\nFilename\r\nLogging config file\r\nYES\r\nYES\r\n\r\n\r\nMS_BSILOG_ENABLE\r\nBoolean\r\nEnable diagnostic logging\r\nYES\r\nYES\r\n\r\n\r\n\r\n\r\nQuickVision Category\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConfiguration Variable Name\r\nType\r\nShort Description\r\nRestart\r\nWorkSet\r\n\r\n\r\n\r\n\r\nQV_DISABLE_D3D11\r\nBoolean\r\nDisables Direct3D Version 11\r\nYES\r\nNO\r\n\r\n\r\nQV_DISABLE_HARDWARE\r\nBoolean\r\nDisables Graphics Hardware Acceleration\r\nYES\r\nNO\r\n\r\n\r\n\r\n\r\nDGNAPPS Category\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConfiguration Variable Name\r\nType\r\nShort Description\r\nRestart\r\nWorkSet\r\n\r\n\r\n\r\n\r\n_USTN_FIRSTDGNAPPS\r\nFilelist\r\nAllows you to add applications that load on MicroStation\r\nstartup\r\nNO\r\nYES\r\n\r\n\r\nMS_DGNAPPS\r\nFilelist\r\nDesign File Applications\r\nNO\r\nYES\r\n\r\n\r\n\r\n\r\nApplication Load Category\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConfiguration Variable Name\r\nType\r\nShort Description\r\nRestart\r\nWorkSet\r\n\r\n\r\n\r\n\r\nMS_MDLSTUB_LOAD\r\nFilelist\r\nMDL Application Stub-load\r\nYES\r\nNO\r\n\r\n\r\nMS_XCOMMAND_APPS\r\nFilelist\r\nXCommand Table Auto-load\r\nYES\r\nNO\r\n\r\n\r\nMS_CMDTABLE_LOAD\r\nFilelist\r\nKey-in Table Auto-load\r\nYES\r\nNO\r\n\r\n\r\n\r\n\r\nDWG/DXF Search Path\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConfiguration Variable Name\r\nType\r\nShort Description\r\nRestart\r\nWorkSet\r\n\r\n\r\n\r\n\r\nMS_DWG_COMMANDPREFIX\r\nKeyword\r\nDWG Command Prefix.\r\nNO\r\nNO\r\n\r\n\r\nMS_DWG_PGPFILE\r\nFilename\r\nPGP Command Alias file.\r\nNO\r\nNO\r\n\r\n\r\nMS_DWGSETTINGSFILE\r\nFilename\r\nDWG Settings File.\r\nNO\r\nYES\r\n\r\n\r\nMS_DWGSYSTEMDATA\r\nDirectory\r\nSystem DWG Data Directory.\r\nNO\r\nYES\r\n\r\n\r\nMS_DWGDATA\r\nDirectory\r\nDWG Data Directory.\r\nNO\r\nYES\r\n\r\n\r\nMS_BLOCKLIST\r\nFilelist\r\nAutoCAD Block List\r\nNO\r\nYES\r\n\r\n\r\nMS_DWGFONTPATH\r\nDirectory\r\nAutoCAD SHX Font Directory\r\nNO\r\nYES\r\n\r\n\r\nMS_ACADDIR\r\nDirectory\r\nAutoCAD Program Directory\r\nNO\r\nYES\r\n\r\n\r\nMS_DWG_FIELD_2005FORMATTING\r\nKeyword\r\nForce AutoCAD 2005 field format\r\nYES\r\nYES\r\n\r\n\r\n\r\n\r\nCGM-Translation Category\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConfiguration Variable Name\r\nType\r\nShort Description\r\nRestart\r\nWorkSet\r\n\r\n\r\n\r\n\r\nMS_CGMIN\r\nDirectory\r\nCGM Input Directory.\r\nNO\r\nYES\r\n\r\n\r\nMS_CGMOUT\r\nDirectory\r\nCGM Output Directory.\r\nNO\r\nYES\r\n\r\n\r\nMS_CGMLOG\r\nDirectory\r\nCGM Log Files.\r\nNO\r\nYES\r\n\r\n\r\nMS_CGMTABLES\r\nDirectory\r\nCGM Configuration Tables\r\nNO\r\nYES\r\n\r\n\r\nMS_CGMINSET\r\nFilename\r\nCGMIN Settings File.\r\nNO\r\nYES\r\n\r\n\r\nMS_CGMOUTSET\r\nFilename\r\nCGMOUT Settings File.\r\nNO\r\nYES\r\n\r\n\r\n\r\n\r\nIGES-Translation Category\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConfiguration Variable Name\r\nType\r\nShort Description\r\nRestart\r\nWorkSet\r\n\r\n\r\n\r\n\r\nMS_IGESIN\r\nDirectory\r\nIGES Input Directory.\r\nNO\r\nYES\r\n\r\n\r\nMS_IGESOUT\r\nDirectory\r\nIGES Output Directory.\r\nNO\r\nYES\r\n\r\n\r\nMS_IGESLOG\r\nDirectory\r\nIGES Log Files.\r\nNO\r\nYES\r\n\r\n\r\nMS_IGESINSET\r\nFilename\r\nIGESIN Settings File.\r\nNO\r\nYES\r\n\r\n\r\nMS_IGESOUTSET\r\nFilename\r\nIGESOUT Settings File.\r\nNO\r\nYES\r\n\r\n\r\n\r\n\r\nWorkspace Category\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConfiguration Variable Name\r\nType\r\nShort Description\r\nRestart\r\nWorkSet\r\n\r\n\r\n\r\n\r\n_USTN_WORKSETCFG\r\nFilename\r\nWorkSet Configuration\r\nNO\r\nNO\r\n\r\n\r\nMS_USERPREF\r\nFilename\r\nUser Preference Resource\r\nYES\r\nNO\r\n\r\n\r\n_USTN_UIPATH\r\nSearch Path\r\nUser Interface\r\nYES\r\nNO\r\n\r\n\r\n_USTN_DISALLOW_NOWORKSET\r\nSearch Path\r\nIf on, the No WorkSet option in the Work page will be hidden\r\nYES\r\nNO\r\n\r\n\r\n\r\n\r\nTags Category\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConfiguration Variable Name\r\nType\r\nShort Description\r\nRestart\r\nWorkSet\r\n\r\n\r\n\r\n\r\nMS_TAGOUTPUT\r\nDirectory\r\nTag Output\r\nNO\r\nYES\r\n\r\n\r\nMS_TAGREPORTS\r\nDirectory\r\nTag Reports\r\nNO\r\nYES\r\n\r\n\r\nMS_TAGTEMPLATES\r\nDirectory\r\nTag Templates\r\nNO\r\nYES\r\n\r\n\r\n\r\n\r\nOLE Server Category\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConfiguration Variable Name\r\nType\r\nShort Description\r\nRestart\r\nWorkSet\r\n\r\n\r\n\r\n\r\nMS_OLE_RETAIN_CONTROL_SIZE\r\nBoolean\r\nRetain display size of object\r\nNO\r\nNO\r\n\r\n\r\nMS_OLESERVE_EMBED_REFFILES\r\nKeyword\r\nEmbed References\r\nNO\r\nYES\r\n\r\n\r\n\r\n\r\nEngineering Links Category\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConfiguration Variable Name\r\nType\r\nShort Description\r\nRestart\r\nWorkSet\r\n\r\n\r\n\r\n\r\nMS_WEBLIB_HISTORY\r\nFilename\r\nWeblib history\r\nNO\r\nNO\r\n\r\n\r\nMS_BOOKMARKS_IMAGE\r\nFilename\r\nImage bookmarks\r\nNO\r\nNO\r\n\r\n\r\nMS_BOOKMARKS_RSC\r\nFilename\r\nResource bookmarks\r\nNO\r\nNO\r\n\r\n\r\nMS_BOOKMARKS_ARCHIVE\r\nFilename\r\nArchive bookmarks\r\nNO\r\nNO\r\n\r\n\r\nMS_BOOKMARKS_CELL\r\nFilename\r\nCell library bookmarks\r\nNO\r\nNO\r\n\r\n\r\nMS_BOOKMARKS_DGN\r\nFilename\r\nDGN bookmarks\r\nNO\r\nNO\r\n\r\n\r\nMS_WEBKIOSKMODE\r\nKeyword\r\nKiosk mode\r\nNO\r\nNO\r\n\r\n\r\nMS_WEBTYPESFILE\r\nFilename\r\nSpecial filetype handling\r\nNO\r\nNO\r\n\r\n\r\nMS_WEBFILES_DIR\r\nDirectory\r\nWeblib local storage\r\nNO\r\nNO\r\n\r\n\r\nMS_WEBDOWNLOADDIR\r\nDirectory\r\nDownload directory\r\nNO\r\nNO\r\n\r\n\r\nMS_BROWSERMAKECHILDWINDOW\r\nBoolean\r\nReparent Browser\r\nNO\r\nNO\r\n\r\n\r\nMS_USEEXTERNALBROWSER\r\nKeyword\r\nExternal browser name\r\nNO\r\nNO\r\n\r\n\r\n\r\n\r\nStep-Translation Category\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConfiguration Variable Name\r\nType\r\nShort Description\r\nRestart\r\nWorkSet\r\n\r\n\r\n\r\n\r\nMS_STEPOUT\r\nDirectory\r\nStep Output Directory.\r\nNO\r\nYES\r\n\r\n\r\nMS_STEPLOG\r\nDirectory\r\nStep Log Files.\r\nNO\r\nYES\r\n\r\n\r\nMS_ROSEDB\r\nDirectory\r\nRose database directory.\r\nNO\r\nYES\r\n\r\n\r\n\r\n\r\nSpelling Category\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConfiguration Variable Name\r\nType\r\nShort Description\r\nRestart\r\nWorkSet\r\n\r\n\r\n\r\n\r\nMS_SPELLINGUSERDICTIONARY\r\nFilename\r\nSpelling User Dictionary\r\nYES\r\nNO\r\n\r\n\r\nMS_SPELLINGDICTIONARYPATH\r\nDirectory\r\nSpelling Dictionaries\r\nYES\r\nNO\r\n\r\n\r\n\r\n\r\nLevels Category\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConfiguration Variable Name\r\nType\r\nShort Description\r\nRestart\r\nWorkSet\r\n\r\n\r\n\r\n\r\nMS_LEVEL_DO_NOT_OVERRIDE_DESIGN_LEVELS_IN_SHEET\r\nKeyword\r\nLevel Property Overrides in Sheet and Drawing Models\r\nNO\r\nNO\r\n\r\n\r\nMS_LEVEL_DISPLAY_FORMAT\r\nKeyword\r\nLevel Display Format\r\nNO\r\nYES\r\n\r\n\r\nMS_LEVEL_EDIT_NESTED_ATTACHMENT_LEVELS\r\nKeyword\r\nEdit Nested Attachment Levels\r\nNO\r\nYES\r\n\r\n\r\nMS_LEVEL_ALLOW_LIBRARY_LEVEL_EDIT\r\nKeyword\r\nEdit Unused Library Levels\r\nNO\r\nNO\r\n\r\n\r\nMS_LEVEL_LOAD_ATTACHMENT_FILTERS\r\nKeyword\r\nLoad Attachment Level Filters\r\nNO\r\nNO\r\n\r\n\r\nMS_LEVEL_EDIT_ATTRIBUTE_LIST\r\nKeyword\r\nControl Level Attributes Edit\r\nNO\r\nNO\r\n\r\n\r\nMS_LEVEL_SYNC_ATTRIBUTE_LIST\r\nKeyword\r\nControl Level Attributes Sync\r\nNO\r\nNO\r\n\r\n\r\nMS_LEVEL_AUTO_SYNC_ATTRIBUTE_LIST\r\nKeyword\r\nLevel Attribute Auto Synch.\r\nNO\r\nNO\r\n\r\n\r\nMS_LEVEL_SEED_LEVEL_NAME\r\nKeyword\r\nSeed Level Name\r\nNO\r\nNO\r\n\r\n\r\nMS_LEVEL_CREATE_FROM_SEED_ATTRIBUTE_LIST\r\nKeyword\r\nSeed Level Attributes to use\r\nNO\r\nNO\r\n\r\n\r\nMS_UPDATE_KEEP_UNUSED_LIBRARY_LEVELS\r\nKeyword\r\nKeep Unused Library Levels\r\nNO\r\nNO\r\n\r\n\r\nMS_LEVEL_PICKER_WIDTH\r\nKeyword\r\nAttributes Level Picker Width\r\nNO\r\nNO\r\n\r\n\r\nMS_LEVEL_SYNCH_BYLEVEL\r\nKeyword\r\nSynch Symbology to ByLevel on Level Change\r\nNO\r\nNO\r\n\r\n\r\nMS_LEVEL_LIB_DIR\r\nSearch Path\r\nLevel Library Path\r\nNO\r\nYES\r\n\r\n\r\nMS_V7TOV8_CSVNAME\r\nFilename\r\nV7 to V8 Level CSV File\r\nNO\r\nNO\r\n\r\n\r\nMS_V7_LEVEL_NAME_PREFIX\r\nKeyword\r\nV7 to V8 Level Name Prefix\r\nNO\r\nNO\r\n\r\n\r\nMS_V7TOV8_DELETE_UNUSED_LEVELS\r\nKeyword\r\nV7 to V8 Delete Unused Levels\r\nNO\r\nNO\r\n\r\n\r\n\r\n\r\nDesign History Category\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConfiguration Variable Name\r\nType\r\nShort Description\r\nRestart\r\nWorkSet\r\n\r\n\r\n\r\n\r\nMS_DESIGN_HISTORY_COMMIT_ON_SAVE\r\nBoolean\r\nCommit on save\r\nNO\r\nYES\r\n\r\n\r\nMS_DESIGN_HISTORY_COMMIT_ON_CLOSE\r\nNONE\r\nCommit before close\r\nNO\r\nYES\r\n\r\n\r\nMS_DESIGN_HISTORY_COMMIT_ON_MODEL_SWITCH\r\nBoolean\r\nCommit on model switch\r\nNO\r\nYES\r\n\r\n\r\nMS_DESIGN_HISTORY_OWNERSHIP_WARNING\r\nBoolean\r\nConfirm when taking ownership\r\nNO\r\nYES\r\n\r\n\r\nMS_DESIGN_HISTORY_COLORS\r\nNONE\r\nColors\r\nNO\r\nYES\r\n\r\n\r\nMS_DESIGN_HISTORY_REVISION_NUMBER_FORMAT\r\nKeyword\r\nRevision number display format\r\nNO\r\nNO\r\n\r\n\r\nMS_DESIGN_HISTORY\r\nKeyword\r\nDesign History capabilities\r\nNO\r\nNO\r\n\r\n\r\nMS_DESIGN_HISTORY_COMMIT_DOC_PROPERTIES\r\nBoolean\r\nInclude document properties in design history?\r\nNO\r\nYES\r\n\r\n\r\n\r\n\r\nProtection Category\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConfiguration Variable Name\r\nType\r\nShort Description\r\nRestart\r\nWorkSet\r\n\r\n\r\n\r\n\r\nMS_PROTECTION_ENABLE\r\nKeyword\r\nEnable file protection\r\nNO\r\nNO\r\n\r\n\r\nMS_PROTECTION_V8_COMPATIBILITY\r\nKeyword\r\nLimit encryption strength\r\nNO\r\nNO\r\n\r\n\r\nMS_PROTECTION_LICENSE_ENABLE\r\nKeyword\r\nControl license creation\r\nNO\r\nNO\r\n\r\n\r\nMS_PROTECTION_PASSWORD_MIXED\r\nKeyword\r\nPassword letters and numbers?\r\nNO\r\nNO\r\n\r\n\r\nMS_PROTECTION_PASSWORD_MINIMUM\r\nKeyword\r\nMinimum length of password\r\nNO\r\nNO\r\n\r\n\r\nMS_PROTECTION_NOENCRYPT_THUMBNAIL\r\nKeyword\r\nDo NOT encrypt file thumbnail?\r\nNO\r\nNO\r\n\r\n\r\nMS_PROTECTION_NOENCRYPT_PROPERTIES\r\nKeyword\r\nDo NOT encrypt file properties?\r\nNO\r\nNO\r\n\r\n\r\n\r\n\r\nSecurity Category\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConfiguration Variable Name\r\nType\r\nShort Description\r\nRestart\r\nWorkSet\r\n\r\n\r\n\r\n\r\nMS_SECURITY_LEVEL\r\nKeyword\r\nSecurity level\r\nNO\r\nNO\r\n\r\n\r\nMS_SECURITY_SPC\r\nKeyword\r\nSoftware Publishing Certs\r\nNO\r\nNO\r\n\r\n\r\n\r\n\r\nReference Category\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConfiguration Variable Name\r\nType\r\nShort Description\r\nRestart\r\nWorkSet\r\n\r\n\r\n\r\n\r\nMS_REF_MASTERFILELAST_SHEET\r\nKeyword\r\nSheet Model Update Sequence\r\nNO\r\nNO\r\n\r\n\r\nMS_REF_MASTERFILELAST_DRAWING\r\nKeyword\r\nDrawing Model Update Sequence\r\nNO\r\nNO\r\n\r\n\r\nMS_REF_MASTERFILELAST_DESIGN\r\nKeyword\r\nDesign Model Update Sequence\r\nNO\r\nNO\r\n\r\n\r\nMS_REF_MAXNESTDEPTH\r\nKeyword\r\nMaximum Reference Nesting Depth\r\nNO\r\nYES\r\n\r\n\r\nMS_REF_DEFAULTATTACHDIRECTORY\r\nDirectory\r\nDefault Attachment Directory\r\nNO\r\nYES\r\n\r\n\r\nMS_REF_DEFAULTSETTINGS\r\nKeyword\r\nDefault Attachment Settings\r\nNO\r\nYES\r\n\r\n\r\nMS_DISALLOWFULLREFPATH\r\nKeyword\r\nDisallow Full Ref Path\r\nNO\r\nYES\r\n\r\n\r\nMS_REF_NO_CVE_LOAD\r\nKeyword\r\nDisable loading of CVE references\r\nNO\r\nYES\r\n\r\n\r\nMS_REF_ENABLE_LEGACY_VISEDGES\r\nKeyword\r\nEnable Visible Edges \"Legacy\" Option\r\nNO\r\nYES\r\n\r\n\r\nMS_REF_NEWLEVELDISPLAY\r\nKeyword\r\nNew Level Display\r\nNO\r\nYES\r\n\r\n\r\nMS_NEST_COLORADJUSTMENT\r\nKeyword\r\nNested Reference Color Adjustment\r\nNO\r\nYES\r\n\r\n\r\nMS_REF_DONTHILITEFORMANIP\r\nKeyword\r\nHiliting References for Manipulation\r\nNO\r\nYES\r\n\r\n\r\nMS_REF_VISEDGE_ATTACH_STATE\r\nNONE\r\nReference Visible Edges default Attachment State\r\nNO\r\nYES\r\n\r\n\r\nMS_CVE_VISEDGE_OVERRIDES\r\nNONE\r\nCVE Visible Edge Overrides\r\nNO\r\nYES\r\n\r\n\r\n\r\n\r\nStandards Checker Category\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConfiguration Variable Name\r\nType\r\nShort Description\r\nRestart\r\nWorkSet\r\n\r\n\r\n\r\n\r\nMS_STANDARDSCHECKER_SETTINGSFILE\r\nFilename\r\nRequired Standards Checker Settings File\r\nNO\r\nYES\r\n\r\n\r\nMS_STANDARDSCHECKER_SETTINGSNAME\r\nNONE\r\nRequired Standards Checker Named Settings\r\nNO\r\nYES\r\n\r\n\r\nMS_STANDARDSCHECKER_OUT\r\nDirectory\r\nStandards Checker Report Directory\r\nNO\r\nYES\r\n\r\n\r\nMS_STANDARDSCHECKER_STYLESHEET\r\nFilename\r\nStandards Checker Style Sheet\r\nNO\r\nYES\r\n\r\n\r\nMS_STANDARDSCHECKER_APPS\r\nFilelist\r\nStandards Checker Applications\r\nNO\r\nYES\r\n\r\n\r\n\r\n\r\nFile Save Category\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConfiguration Variable Name\r\nType\r\nShort Description\r\nRestart\r\nWorkSet\r\n\r\n\r\n\r\n\r\nMS_DGNAUTOSAVE\r\nKeyword\r\nDesign File Auto-Save\r\nNO\r\nNO\r\n\r\n\r\nMS_V7AUTOSAVE\r\nKeyword\r\nV7 Design File Auto-Save\r\nNO\r\nNO\r\n\r\n\r\nMS_V7AUTOSAVE_NODIALOG\r\nKeyword\r\nV7 Auto-Save Dialog\r\nNO\r\nNO\r\n\r\n\r\nMS_V7BACKUPV8\r\nKeyword\r\nV7 create backup in V8 format\r\nNO\r\nNO\r\n\r\n\r\nMS_DWGAUTOSAVE\r\nKeyword\r\nDWG/DXF File Auto-Save\r\nNO\r\nNO\r\n\r\n\r\nMS_DWGAUTOSAVE_NODIALOG\r\nKeyword\r\nDWG/DXF Auto-Save Dialog\r\nNO\r\nNO\r\n\r\n\r\nMS_EVE_VISEDGE_OVERRIDES\r\nNONE\r\nExport Visible Edge Overrides\r\nNO\r\nYES\r\n\r\n\r\n\r\n\r\nRaster Category\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConfiguration Variable Name\r\nType\r\nShort Description\r\nRestart\r\nWorkSet\r\n\r\n\r\n\r\n\r\nMS_RASTER_IMG_STRETCH\r\nBoolean\r\nSet contrast stretch filtering for IMG file format\r\nNO\r\nYES\r\n\r\n\r\nMS_RASTER_IMG_CHANNELS\r\nNONE\r\nSet band to channel mapping for IMG file format\r\nNO\r\nYES\r\n\r\n\r\nMS_RASTER_DISABLE_IPPCONNECTION\r\nNONE\r\nDisable default server port\r\nNO\r\nYES\r\n\r\n\r\nMS_RASTER_VIEWSAVEASDWG\r\nNONE\r\nDefine view for DWG file\r\nNO\r\nYES\r\n\r\n\r\nMS_RASTER_COMMONGEOREFFILEFORMATS\r\nNONE\r\n'Common Geo Ref Raster Formats' File Filter\r\nNO\r\nYES\r\n\r\n\r\nMS_RASTER_COMMONFILEFORMATS\r\nNONE\r\n'Common Raster Formats' File Filter\r\nNO\r\nYES\r\n\r\n\r\nMS_RASTER_TIFFINVERT\r\nNONE\r\nInvert monochrome tiff\r\nNO\r\nYES\r\n\r\n\r\nMS_RASTER_NOSHARING\r\nNONE\r\nCreate .sharing.tmp files\r\nNO\r\nYES\r\n\r\n\r\nMS_RASTER_NO_DETACH_CONFIRM\r\nNONE\r\nDisplay alert dialog upon raster detach\r\nNO\r\nYES\r\n\r\n\r\nMS_RASTER_EPSGTABLE_PATH\r\nNONE\r\nSet path to EPSG table\r\nNO\r\nYES\r\n\r\n\r\nMS_RASTER_DEFAULTSISTER\r\nNONE\r\nSet default sister file\r\nNO\r\nYES\r\n\r\n\r\nMS_RASTER_DEFAULTSCALE\r\nNONE\r\nSet default scale\r\nNO\r\nYES\r\n\r\n\r\nMS_RASTER_1BIT_WORKMODE\r\nNONE\r\nHarmonize monochrome raster display\r\nNO\r\nYES\r\n\r\n\r\nMS_RASTER_DEFAULT_LEVEL\r\nNONE\r\nSet default display level\r\nNO\r\nYES\r\n\r\n\r\nMS_RASTER_TRANSPARENCY\r\nNONE\r\nSet transparency\r\nNO\r\nYES\r\n\r\n\r\n\r\n\r\nClash Detection Category\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConfiguration Variable Name\r\nType\r\nShort Description\r\nRestart\r\nWorkSet\r\n\r\n\r\n\r\n\r\nMS_INVALID_FIELD_INDICATOR_STRING\r\nKeyword\r\nDisplay \"null\" instead of \"####\"\r\nYES\r\nYES\r\n\r\n\r\n\r\n\r\nMarkup Category\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConfiguration Variable Name\r\nType\r\nShort Description\r\nRestart\r\nWorkSet\r\n\r\n\r\n\r\n\r\nMS_MARKUP_HIDE_AUDIT_COMMENTS\r\nBoolean\r\nHide Markup Audit Comments\r\nYES\r\nYES\r\n\r\n\r\nMS_MARKUPVIEWRESOLUTION\r\nNONE\r\nMarkup View Resolution\r\nYES\r\nYES\r\n\r\n\r\nMS_MARKUPSHEETSEEDNAME\r\nNONE\r\nMarkup Template Sheet\r\nNO\r\nYES\r\n\r\n\r\nMS_MARKUPSHEETSEED\r\nFilename\r\nMarkup Template File\r\nNO\r\nYES\r\n\r\n\r\nMS_MARKUPSETTINGS\r\nFilename\r\nMarkup Customization Settings\r\nNO\r\nYES\r\n\r\n\r\nMS_MARKUPPATH\r\nSearch Path\r\nMarkup Path\r\nNO\r\nYES\r\n\r\n\r\n\r\n\r\nMacro Recorder Category\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConfiguration Variable Name\r\nType\r\nShort Description\r\nRestart\r\nWorkSet\r\n\r\n\r\n\r\n\r\nMS_MACRONEWFILEDIRECTORY\r\nDirectory\r\nDirectory to create new BMR macros in\r\nNO\r\nNO\r\n\r\n\r\nMS_MACRO\r\nSearch Path\r\nSearch path for BMR macro files\r\nNO\r\nYES\r\n\r\n\r\nMS_VBASAVEONRUN\r\nKeyword\r\nAutomatically save VBA projects\r\nNO\r\nYES\r\n\r\n\r\nMS_VBAAUTOLOADPROJECTS\r\nFilename\r\nNames of standard projects\r\nNO\r\nYES\r\n\r\n\r\nMS_VBASEARCHDIRECTORIES\r\nSearch Path\r\nDirectories to search for VBA projects\r\nNO\r\nYES\r\n\r\n\r\nMS_VBANEWPROJECTDIRECTORY\r\nDirectory\r\nDirectory for new projects\r\nNO\r\nNO\r\n\r\n\r\n\r\n\r\nTables Category\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConfiguration Variable Name\r\nType\r\nShort Description\r\nRestart\r\nWorkSet\r\n\r\n\r\n\r\n\r\nMS_TABLE_INPUT\r\nDirectory\r\nTable Input\r\nNO\r\nYES\r\n\r\n\r\n\r\n\r\nReports Category\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConfiguration Variable Name\r\nType\r\nShort Description\r\nRestart\r\nWorkSet\r\n\r\n\r\n\r\n\r\nMS_REPORT_OUTPUT\r\nDirectory\r\nReport Output\r\nNO\r\nYES\r\n\r\n\r\n\r\n\r\nPoint Cloud Category\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConfiguration Variable Name\r\nType\r\nShort Description\r\nRestart\r\nWorkSet\r\n\r\n\r\n\r\n\r\nMS_POINTCLOUD_LAS_NBIT_COLOR\r\nNONE\r\nPoint Cloud LAS File Color Treatment\r\nNO\r\nYES\r\n\r\n\r\n\r\n\r\nGeographic Coordinate\r\nSystem Category\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConfiguration Variable Name\r\nType\r\nShort Description\r\nRestart\r\nWorkSet\r\n\r\n\r\n\r\n\r\nMS_GEOCOORDINATE_USERLIBRARIES\r\nFilelist\r\nUser-defined GCS Dictionaries\r\nNO\r\nYES\r\n\r\n\r\nMS_GEOCOORDINATE_REPROJECTIONSETTINGS\r\nDirectory\r\nReprojection Settings\r\nNO\r\nYES\r\n\r\n\r\nMS_GEOCOORDINATE_REFSETTINGS\r\nDirectory\r\nReference Reprojection Settings\r\nNO\r\nYES\r\n\r\n\r\nMS_GEOCOORDINATE_FAVORITESFILES\r\nFilename\r\nGCS Favorites File\r\nNO\r\nYES\r\n\r\n\r\nMS_GEOCOORDINATE_DATA\r\nDirectory\r\nGeoCoordinate Data Files\r\nNO\r\nYES\r\n\r\n\r\n\r\n","categories":["Bentley","Custom"],"tags":["ORD"]},{"title":"MS中曲线总结","url":"/posts/2020/37N8G1C.html","content":"MS\r\n二开中，可能会处理很多的曲线，比如对曲线进行偏移，求交点，延长等等。每一种曲线，有它的特点和相应的\r\nAPI，有时候要实现一个功能，可能需要将曲线在多种类型中进行相互转化，从而利用\r\nMS 中原生的 API 实现我们自己想要的功能。\r\n本文对常用的 ms 中的线条使用进行总结。\r\n\r\n","categories":["Bentley","Develop"],"tags":["Bentley二次开发"]},{"title":"MS中曲线总结","url":"/posts/2020/37N8G1C.html","content":"MS\r\n二开中，可能会处理很多的曲线，比如对曲线进行偏移，求交点，延长等等。每一种曲线，有它的特点和相应的\r\nAPI，有时候要实现一个功能，可能需要将曲线在多种类型中进行相互转化，从而利用\r\nMS 中原生的 API 实现我们自己想要的功能。\r\n本文对常用的 ms 中的线条使用进行总结。\r\n\r\n","categories":["Bentley","Develop"],"tags":["Bentley二次开发"]},{"title":"Bentley二开资料导航","url":"/posts/2022/C1SHZF.html","content":"本文收集 Bentley 开发相关资源链接，方便开发时查阅。\r\n\r\n开发文档及示例\r\nMicroStationAPI案例集\r\nMicroStation\r\nC# API 2022版 (yuque.com)\r\n社区问答\r\n二次开发\r\n- Bentley 中国优先社区\r\n技术资料库\r\n- Bentley 中国优先社区\r\n中国BDN社区-Wiki\r\nBentley 软件知识库 ·\r\n语雀 (yuque.com)\r\nDevelopers\r\nand Programming - Bentley Communities\r\nBentley\r\n相关产品的咖啡角\r\n官方教学\r\nBENTLEY软件-官方教学\r\n(bentley-learn.com)\r\nMS 开发\r\nORD 开发\r\nBentley 每周开发资讯\r\n\r\n普通，共享，参数化？单元类型怎么选\r\n当单元要求整体缩放，批量布置时，用共享单元\r\n当单元的多个变化量可以用变量表达，且需要进行不同变化时，用参数化单元\r\n当单元的变化没有规律时，只能使用普通单元\r\n视角不同，呈现不同\r\n—— Named Presentations功能介绍\r\n参数化约束（一）\r\n\r\n帮助文档\r\nMicroStation\r\n(bentley.com)\r\nDotNET 开发资源\r\njobbole/awesome-dotnet-cn:\r\nDotNet\r\n资源大全中文版，内容包括：编译器、压缩、应用框架、应用模板、加密、数据库、反编译、IDE、日志、风格指南等。\r\n(github.com)\r\nDotNetCodes:\r\n一些常用的功能性代码,可以减少许多开发时间,而且类与类之间没有什么依赖,每个类都可以单独拿出来使用\r\nquozd/awesome-dotnet: A\r\ncollection of awesome .NET libraries, tools, frameworks and software\r\n(github.com)\r\n其它个人博客\r\nScratchapixel 3.0,\r\nLearn Computer Graphics Programming\r\n致谢\r\n非常感谢以上文章所属作者的分享，在此表示诚挚谢意！\r\n","categories":["Bentley","Develop"],"tags":["Bentley"]},{"title":"Bentley 各个 DLL 库介绍","url":"/posts/2023/358VFAC.html","content":"Bentley 各个 DLL 作用介绍。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nDLL 名称\r\n作用\r\n\r\n\r\n\r\n\r\nBentley.GeometryNET\r\nManaged wrappers for native (element)\r\nimplementations. BsplineCurve, CurvePrimitive, etc.\r\n\r\n\r\nBentley.GeometryNET.Structs\r\nManaged wrappers for \"value\" data type structures.\r\nDPoint3d, DTransform3d, etc.\r\n\r\n\r\nBentley.GeomertyNET.Common\r\nInterfaces providing EC/XML bindings. e.g.\r\nIGeomerty, iLineSegment, etc.\r\n\r\n\r\n\r\n参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\n\r\nBentley.GeometryNET\r\n- MicroStation Programming - Wiki - MicroStation Programming - Bentley\r\nCommunities\r\n\r\n","categories":["Bentley","Develop"],"tags":["Bentley"]},{"title":"MS To Learn","url":"/posts/2023/1H5NPNF.html","content":"Bentley-learn里面全都有。都是以前公开课的视频。VBA、C#和C++的三套\r\n\r\n参考\r\nhttps://bentley-learn.com/page/1943206\r\n","categories":["Bentley","Develop"]},{"title":"ORD u9中无法编辑或者插入 Excel 表","url":"/posts/2021/31QX5RZ.html","content":"最近将 ORD 升级到了 u9，发现以前在 dgn\r\n中插入的表格无法打开编辑了。遇到这种情况，一般都是 ORD 的 OLE\r\n管理模块没有加载导致的。\r\n\r\n可以在程序中按 F9 或者 Enter 打开 Keyin\r\n窗体，在里面输入下列命令，手动加载模块即可解决。\r\nmdl load olecntr\r\n","categories":["Bentley","Problems"],"tags":["Bentley","Bentley问题处理"]},{"title":"Connect Client 提示无法安全地连接到此页面","url":"/posts/2021/3ZSEX8G.html","content":"\r\n\r\n企业微信截图_16377355973798.png\r\n\r\n\r\n当打开 Connect Client，如果提示 ”无法安全地连接到此页面”，并出现 “TLS\r\n安全设置未设置为默认设置” 等提示时（如上图），可以采用如下方法处理：\r\n打开 IE &gt; 设置 &gt; Internet 选项 &gt; 高级 &gt; 勾选 TLS1.0\r\n;TLS1.1 ;TLS1.2 &gt; 确定。\r\n","categories":["Bentley","Problems"],"tags":["Bentley","Bentley问题处理"]},{"title":"ORD安装完成一打开报错","url":"/posts/2021/WYBXRB.html","content":"在ORD安装完成后，一打开软件就弹出崩溃界面，在错误文件的\r\nManaged Call Stack: 处有如下错误：\r\nManaged Call Stack: 0: Boolean get_EnablePerformanceChanges() from Bentley.ECObjects.ECObjects in Bentley.ECObjects3, Version=1.0.0.0, Culture=neutral, PublicKeyToken=4bf6c96a266e58d4 1: Bentley.DgnPlatformNET.BentleyStatus Initialize() from Bentley.DgnPlatformNET.DgnPlatformLib in Bentley.DgnPlatformNET, Version=1.0.0.0, Culture=neutral, PublicKeyToken=4bf6c96a266e58d4 2: UInt32 wWinMainCRTStartup() 3: UInt32 wWinMainCRTStartup()\r\n\r\n然后查找 imodelSDKBinPath，其值如下：\r\nimodelSDKBinPath=G:\\PKPMV51\\EXPPWI\r\n所以猜想是 PKPM 软件导致了 Benetley 的 imodel 模块出现了问题。\r\n接着在【应用和功能】中找到 PMTolModel_GAC\r\n将其卸载。至此，ORD 终于可以正常打开了。\r\n","categories":["Bentley","Problems"],"tags":["Bentley","Bentley问题处理"]},{"title":"ORD打印图片是黑色","url":"/posts/2021/1P39N8S.html","content":"在 ORD\r\n中进行批量打印时，发现无法打印图片，图片范围全是黑色的，可以通过如下方式解决：\r\n\r\n\r\n企业微信截图_16366214984716.png\r\n\r\n将 Print raster images 勾选即可。\r\n","categories":["Bentley","Problems"],"tags":["Bentley","Bentley问题处理"]},{"title":"ORD 启动相关错误汇总","url":"/posts/2022/1XTXTE4.html","content":"本文汇总了 ORD\r\n在启动过程中可能遇到的问题，方便再次遇到问题时能够快速定位并处理。\r\n\r\nApplication use will be\r\nlimited\r\n错误如下：\r\n\r\n\r\nimage-20220509114902220\r\n\r\n解决方法：\r\n出现此问题的原因是由于没有登陆 CONNECTION Client\r\n导致的。打开 CONNECTION Client 后登陆自己的账号即可。\r\nPage Expired\r\n错误如下：\r\n\r\n\r\nimage-20220509115130920\r\n\r\n解决方法：\r\n出现上述问题是由于在登陆页面停留过久，导致页面过期了。\r\n可以通过下列任一方法来解决：\r\n\r\n右键，点击刷新，刷新页面\r\n关闭 CONNECTION Client，然后重新打开\r\n\r\nTrial Expired\r\n错误如下：\r\n\r\n\r\nimage-20220509115358653\r\n\r\n解决方法：\r\n出现上述错误的原因是 ORD\r\n试用过期且未能获取到用户的正式授权导致的。\r\n可以通过如下方式排查：\r\n\r\n是否登陆了 CONNECTION Client\r\n如果登陆了，问题依旧，则说明没有授权，可以找管理员开通授权\r\n\r\n连接问题\r\n错误如下：\r\n\r\n\r\nimage-20220509115801614\r\n\r\n解决方法：\r\n出现这个问题的的原因是无法与服务器通信导致的。可以通过以下方法解决：\r\n\r\n检查是否有杀毒软件禁止了 CONNECTION Client 联网\r\n如果网络正常，则关闭\r\nCONNECTION Client，重新打开。可以多试几次\r\n使用代理\r\n\r\n","categories":["Bentley","Problems"],"tags":["Bentley","Bentley问题处理"]},{"title":"VBA已拒绝OpenRoadsDesigner应用程序对象","url":"/posts/2022/2BJZWZD.html","content":"\r\n\r\nimage-20220509162253268\r\n\r\n\r\n正文\r\n当出现上图中的错误时，可能是 ORD 中的 OCX\r\n注册失败导致的，可以通过如下方式解决：\r\n\r\n用管理员打开 cmd\r\n进入到 ORD 安装目录：\r\ncd C:\\Program Files\\Bentley\\OpenRoads Designer CONNECT Edition\\OpenRoadsDesigner\r\n输入 openroadsdesigner /regserver 重新注册服务\r\n\r\n参考\r\nVBA\r\nrejected the OpenRoads Designer Application Object\r\n","categories":["Bentley","Problems"],"tags":["Bentley","Bentley问题处理"]},{"title":"ORD安装提示Failed copy payload xx的解决办法","url":"/posts/2023/304FHXE.html","content":"\r\n\r\n如果 ORD 在安装过程中出现 Failed to copy payload for xxx\r\n时，可能有几下几个原因：\r\n\r\n由于Connection Client的版本不匹配导致。\r\n由于.Net Framework 版本不匹配导致的。\r\n一些国产软件可能会影响安装并导致这个报错。\r\n可以在安装时暂时关闭杀毒软件和防火墙，或者重启电脑后再试。\r\n\r\n参考：\r\nMicroStation\r\nCE 安装报错 0x80070643\r\n","categories":["Bentley","Problems"],"tags":["Bentley","Bentley问题处理"]},{"title":"廊道高程获取异常解决方法","url":"/posts/2023/22EQ1WQ.html","content":"当模板导致生成的廊道高程获取异常时，可以使用如下方法解决。\r\n\r\n现象描述\r\n如下图所示：\r\n\r\n\r\n绿化带异常\r\n\r\n原因：一般是模板导致生成的 top mesh\r\n网格出现问题导致。\r\n可通过查看廊道TM查找模板具体哪里出问题，如下图所示，TM错误导致绿化带边线的纵断面异常：\r\n\r\n\r\nimage-20230403104858787\r\n\r\n\r\n\r\nimage-20230403104909416\r\n\r\n解决步骤\r\n\r\n更新模版，边坡，挡土墙等不参与 top mesh 生成，勾选 \"Exclude From\r\nTop/Bottom Mesh\"\r\n\r\n\r\nimage-20230403105047250\r\n\r\n更新完库模板后，点击绿化带异常所在的廊道Temple\r\nDrop,在悬停工具栏中点击同步库模板按钮\r\n\r\n\r\nimage-20230403105116225\r\n\r\n\r\n","categories":["Bentley","Problems"],"tags":["Problems"]},{"title":"多个数据的展开与压缩","url":"/posts/2023/2812PDV.html","content":"在开发中，遇到一个需求，需要将一组数据，将连续出现的部分压缩成 n*y\r\n的形式，比如：20 30 30 20 压缩后的结果应为\r\n20 2x30 20\r\n同时也要对压缩的数据进行解压还原。\r\n\r\n压缩数据算法实现：\r\n/** * 将数组数中相同的元素进行合并，表示成 数量*值 的形式，元素之间使用逗号分隔 * @param &#123;*&#125; arr * @return 返回的是数组 */export function compressArray(arr, productSign = &#x27;x&#x27;) &#123;  if (!Array.isArray(arr)) return arr  const result = []  let count = 1  for (let i = 0; i &lt; arr.length; i++) &#123;    // 如果是最后一个元素或者当前元素与下一个元素不同    if (i === arr.length - 1 || arr[i] !== arr[i + 1]) &#123;      // 如果连续出现的元素个数大于 1，则将其压缩为数量*值的形式      if (count &gt; 1) &#123;        result.push(count + productSign + arr[i])      &#125;      // 否则直接将当前元素加入结果数组中      else &#123;        result.push(arr[i])      &#125;      // 将计数器重置为 1      count = 1    &#125;    // 如果当前元素与下一个元素相同，则将计数器加 1    else &#123;      count++    &#125;  &#125;  return result&#125;// 测试compressArray([20,30,30,20]) // 结果：[20,&quot;2*30&quot;,20]\r\n解压数据算法实现：\r\n/** * 将字符串分隔符统一成逗号 * @param &#123;*&#125; str * @param &#123;*&#125; returnString 是否转换成字符串返回 * @param &#123;*&#125; separator * @returns */export function formatStringToArray(str, returnString = false, separator = &#x27;,&#x27;) &#123;  let results = []  if (typeof str !== &#x27;string&#x27;) results = [str]  else &#123;    // 先通过字符串进行分割    results = str.split(/,|:|;|\\s+|，|；|。|\\-|~|\\+/)  &#125;  // 判断每个元素是否包含 *、x、X, 如果包含，则进行展开  const newResults = []  const regex = /(\\d+)([xX*])(\\d+)/  results.forEach(item =&gt; &#123;    const match = item.match(regex)    if (match) &#123;      const count = parseInt(match[1], 10)      const value = parseInt(match[3], 10)      for (let i = 0; i &lt; count; i++) &#123;        newResults.push(value)      &#125;    &#125; else &#123;      newResults.push(item)    &#125;  &#125;)  if (returnString) return newResults.join(separator)  return newResults&#125;// 测试formatStringToArray(&quot;20 2*30 20&quot;) // 结果：[&#x27;20&#x27;,&#x27;30&#x27;,&#x27;30&#x27;,&#x27;20&#x27;]formatStringToArray(&quot;20 2*30 20&quot;,true) // 结果：&quot;20,30,30,20&quot;\r\n","categories":["Develop","Algorithm"],"tags":["Algorithm","数据处理"]},{"title":"数据库编码风格指南","url":"/posts/2022/3KBT6ZZ.html","content":"在面向数据读取时，建议按照以下约定进行开发。\r\n\r\n简介\r\n操作\r\n避免直接在具体功能代码中操作数据库，在数据库与具体功能代码之间，应增加一个中介来进行解耦。为未来数据变动提供统一的修改入口。\r\n","categories":["Develop","CodeStyleGuide"],"tags":["CodeStyle"]},{"title":"javalScript编码风格指南","url":"/posts/2022/FD5821.html","content":"简介\r\n参考\r\nGoogle\r\nJavaScript Style Guide\r\n","categories":["Develop","CodeStyleGuide"],"tags":["CodeStyle"]},{"title":"凸包问题的 5 种算法","url":"/posts/2020/15F3BA2.html","content":"前言\r\n首先，什么是凸包？\r\n假设平面上有p0~p12共13个点，过某些点作一个多边形，使这个多边形能把所有点都“包”起来。当这个多边形是凸多边形的时候，我们就叫它“凸包”。如下图：\r\n\r\n\r\n图片1\r\n\r\n\r\n然后，什么是凸包问题？\r\n我们把这些点放在二维坐标系里面，那么每个点都能用 (x,y) 来表示。\r\n现给出点的数目为13，和各个点的坐标。求构成凸包的点？\r\n解一：穷举法（蛮力法）\r\n时间复杂度：O(n³）。\r\n思路：两点确定一条直线，如果剩余的其它点都在这条直线的同一侧，则这两个点是凸包上的点，否则就不是。\r\n步骤：\r\n\r\n将点集里面的所有点两两配对，组成 n(n-1)/2 条直线。\r\n对于每条直线，再检查剩余的 (n-2)\r\n个点是否在直线的同一侧。\r\n\r\n如何判断一个点 p3 是在直线 p1p2\r\n的左边还是右边呢？（坐标：p1(x1,y1)，p2(x2,y2)，p3(x3,y3)）\r\n 当上式结果为正时，p3 在直线 p1p2\r\n的左侧；当结果为负时，p3 在直线 p1p2 的右边。\r\n或者采用向量法判断（叉乘）：\r\n向量 v12=p2-p1\r\n向量 v13=p3-p1\r\n如果 v12 x 13 的方向与 +Z相反，则在右侧，否则在左侧。\r\n解二：分治法\r\n时间复杂度：O(n㏒n)。\r\n思路：应用分治法思想，把一个大问题分成几个结构相同的子问题，把子问题再分成几个更小的子问题……。然后我们就能用递归的方法，分别求这些子问题的解。最后把每个子问题的解“组装”成原来大问题的解。\r\n步骤：\r\n\r\n把所有的点都放在二维坐标系里面。那么横坐标最小和最大的两个点 P1 和\r\nPn 一定是凸包上的点（为什么呢？用反证法很容易证明，这里不详讲）。直线\r\nP1Pn 把点集分成了两部分，即 X\r\n轴上面和下面两部分，分别叫做上包和下包。\r\n对上包：求距离直线 P1Pn 最远的点，即下图中的点 Pmax 。\r\n作直线 P1Pmax 、PnPmax，把直线 P1Pmax 左侧的点当成是上包，把直线\r\nPnPmax 右侧的点也当成是上包。\r\n重复步骤 2、3。\r\n对下包也作类似操作。\r\n\r\n\r\n\r\n这里写图片描述\r\n\r\n然而怎么求距离某直线最远的点呢？我们还是用到解一中的公式：  设有一个点 P3 和直线 P1P2\r\n。（坐标：p1(x1,y1)，p2(x2,y2)，p3(x3,y3)）\r\n对上式的结果取绝对值，绝对值越大，则距离直线越远。\r\n注意：在步骤一，如果横坐标最小的点不止一个，那么这几个点都是凸包上的点，此时上包和下包的划分就有点不同了，需要注意。\r\n解三：Jarvis步进法\r\n时间复杂度：O(nH)。（其中 n 是点的总个数，H 是凸包上的点的个数）\r\n思路：\r\n\r\n纵坐标最小的那个点一定是凸包上的点，例如图上的 P0。\r\n从 P0\r\n开始，按逆时针的方向，逐个找凸包上的点，每前进一步找到一个点，所以叫作步进法。\r\n怎么找下一个点呢？利用夹角。假设现在已经找到 {P0，P1，P2}\r\n了，要找下一个点：剩下的点分别和 P2\r\n组成向量，设这个向量与向量P1P2的夹角为 β 。当 β\r\n最小时就是所要求的下一个点了，此处为 P3 。\r\n\r\n\r\n\r\n这里写图片描述\r\n\r\n注意：\r\n\r\n找第二个点 P1 时，因为已经找到的只有 P0\r\n一个点，所以向量只能和水平线作夹角 α，当 α 最小时求得第二个点。\r\n共线情况：如果直线 P2P3 上还有一个点\r\nP4，即三个点共线，此时由向量P2P3 和向量P2P4 产生的两个 β\r\n是相同的。我们应该把 P3、P4 都当做凸包上的点，并且把距离 P2\r\n最远的那个点（即图中的P4）作为最后搜索到的点，继续找它的下一个连接点。\r\n\r\n解四：Graham扫描法\r\n时间复杂度：O(n㏒n) 思路：Graham 扫描的思想和 Jarris\r\n步进法类似，也是先找到凸包上的一个点，然后从那个点开始按逆时针方向逐个找凸包上的点，但它不是利用夹角。\r\n 步骤：\r\n\r\n把所有点放在二维坐标系中，则纵坐标最小的点一定是凸包上的点，如图中的P0。\r\n把所有点的坐标平移一下，使 P0 作为原点，如上图。\r\n计算各个点相对于 P0 的幅角 α ，按从小到大的顺序对各个点排序。当 α\r\n相同时，距离 P0 比较近的排在前面。例如上图得到的结果为\r\nP1，P2，P3，P4，P5，P6，P7，P8。我们由几何知识可以知道，结果中第一个点\r\nP1 和最后一个点 P8 一定是凸包上的点。\r\n\r\n（以上是准备步骤，以下开始求凸包）\r\n以上，我们已经知道了凸包上的第一个点 P0 和第二个点\r\nP1，我们把它们放在栈里面。现在从步骤3求得的那个结果里，把 P1\r\n后面的那个点拿出来做当前点，即 P2 。接下来开始找第三个点：\r\n连接P0和栈顶的那个点，得到直线 L 。看当前点是在直线 L\r\n的右边还是左边。如果在直线的右边就执行步骤5；如果在直线上，或者在直线的左边就执行步骤6。\r\n如果在右边，则栈顶的那个元素不是凸包上的点，把栈顶元素出栈。执行步骤4。\r\n当前点是凸包上的点，把它压入栈，执行步骤7。\r\n检查当前的点 P2\r\n是不是步骤3那个结果的最后一个元素。是最后一个元素的话就结束。如果不是的话就把\r\nP2 后面那个点做当前点，返回步骤4。\r\n\r\n最后，栈中的元素就是凸包上的点了。\r\n以下为用Graham扫描法动态求解的过程： \r\n解五：Melkman算法\r\n\r\n说真的，这个算法我也还没有看清。网上的资料也少的可怜，我暂且把网上的解释截个图在这里，往后搞懂以后再回来补上。\r\n或者有人看懂了的，希望不吝指教，不甚感激！\r\n扩展\r\n以上讨论的只是二维的凸包，如果延生为三维、多维的凸包问题呢？如何求解？\r\n不过首先，二维凸包可以用来解决围栏问题、城市规划问题、聚类分析等等。但是三维、多维的凸包可能的使用范畴有哪些？\r\n致谢\r\n原文链接：https://blog.csdn.net/Bone_ACE/article/details/46239187\r\n","categories":["Develop","Algorithm"],"tags":["Algorithm","凸包"]},{"title":"CSS中图片超过宽度自动缩放","url":"/posts/2022/2R0P0YJ.html","content":"在进行图片显示的时候，如何使图片宽度或高度超限时，让其自动缩放显示呢？\r\n\r\n可以给 image 添加如下样式：\r\nimage &#123;    max-width: 100%;    object-fix: &#x27;contain&#x27;;&#125;\r\n\r\n上述样式不仅针对 image，其它元素有类似需求时，也可以使用该方法\r\n\r\n","categories":["Develop","CSS"],"tags":["CSS"]},{"title":"编码风格指南说明","url":"/posts/2022/08TWEH.html","content":"在进行代码开发过程中，随着需求的不断变动，功能的不断增加，往往需要对代码进行优化或重构，而具有良好开发风格约束的代码，在处理这些问上更显得迎刃有余，从而达到事半功倍的效果。\r\n\r\n","categories":["Develop","CodeStyleGuide"],"tags":["编码风格"]},{"title":"CSS常用居中方式","url":"/posts/2022/9TBVZR.html","content":"本文主要总结在开发中用得比较多的几种居中方式，方便使用。\r\n\r\n水平居中\r\n内联元素水平居中\r\n利用 text-align: center\r\n可以实现在块级元素内部的内联元素水平居中。此方法对内联元素(inline)，内联块(inline-block)，内联表(inline-table)，inline-flex元素水平居中都有效。\r\n.center-text &#123;  text-align: center;&#125;\r\n块级元素水平居中\r\n通过把固定宽度块级元素的margin-left和margin-right设成auto，就可以使块级元素水平居中。\r\n.center-block &#123;  margin: 0 auto;&#125;\r\n多块级元素水平居中\r\n利用inline-block\r\n如果一行中有两个或两个以上的块级元素，通过设置块级元素的显示类型为inline-block和父容器的text-align属性从而使多块级元素水平居中。\r\n.container &#123;    text-align: center;&#125;.inline-block &#123;    display: inline-block;&#125;\r\n利用flex 布局\r\n利用弹性布局(flex)，实现水平居中，其中justify-content\r\n用于设置弹性盒子元素在主轴（横轴）方向上的对齐方式，本例中设置子元素水平居中显示。\r\n.flex-center &#123;    display: flex;    justify-content: center;&#125;\r\n垂直居中\r\n单行内联(inline-)元素垂直居中\r\n通过设置内联元素的高度(height)和行高(line-height)相等，从而使元素垂直居中。\r\n#v-box &#123;    height: 120px;    line-height: 120px;&#125;\r\n多行元素垂直居中\r\n利用 flex 布局\r\n利用 flex\r\n布局实现垂直居中，其中flex-direction: column定义主轴方向为纵向。因为\r\nflex 布局是 CSS3 中定义，在较老的浏览器存在兼容性问题。\r\n.center-flex &#123;    display: flex;    flex-direction: column;    justify-content: center;&#125;\r\n利用表布局（table）\r\n利用表布局的vertical-align: middle可以实现子元素的垂直居中。\r\n.center-table &#123;    display: table;&#125;.v-cell &#123;    display: table-cell;    vertical-align: middle;&#125;\r\n水平垂直居中\r\n利用 flex 布局\r\n利用flex布局，其中justify-content\r\n用于设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式；而align-items属性定义flex子项在flex容器的当前行的侧轴（纵轴）方向上的对齐方式。\r\n.parent &#123;    display: flex;    justify-content: center;    align-items: center;&#125;\r\n参考\r\n\r\n这15种CSS居中的方式，你都用过哪几种？\r\nFlex\r\n布局教程：语法篇 - 阮一峰的网络日志 (ruanyifeng.com)\r\nFlex\r\n布局教程：实例篇 - 阮一峰的网络日志 (ruanyifeng.com)\r\n\r\n","categories":["Develop","CSS"],"tags":["CSS"]},{"title":"CSS 5种经典布局","url":"/posts/2020/3GJ4VTC.html","content":"页面布局是样式开发的第一步，也是 CSS 最重要的功能之一。\r\n\r\n\r\nimg\r\n\r\n常用的页面布局，其实就那么几个。下面我会介绍5个经典布局，只要掌握了它们，就能应对绝大多数常规页面。\r\n这几个布局都是自适应的，自动适配桌面设备和移动设备。代码实现很简单，核心代码只有一行，有很大的学习价值，内容也很实用。\r\n\r\n我会用到 CSS 的 Flex\r\n语法和 Grid\r\n语法，不过只用到一点点，不熟悉的朋友可以先看看教程链接，熟悉一下基本概念。每一个布局都带有\r\nCodePen 示例，也可以到这个网页统一查看。\r\n\r\n本文是跟极客大学合作的前端学习讲座的一部分，详见文末说明。\r\n\r\n空间居中布局\r\n空间居中布局指的是，不管容器的大小，项目总是占据中心点。\r\n\r\n\r\nimg\r\n\r\nCSS 代码如下（CodePen 示例）。\r\n.container &#123;    display: grid;    place-items: center;&#125; \r\n上面代码需要写在容器上，指定为 Grid\r\n布局。核心代码是place-items属性那一行，它是一个简写形式。\r\nplace-items: &lt;align-items&gt; &lt;justify-items&gt;;\r\nalign-items属性控制垂直位置，justify-items属性控制水平位置。这两个属性的值一致时，就可以合并写成一个值。所以，place-items: center;等同于place-items: center center;。\r\n同理，左上角布局可以写成下面这样。\r\nplace-items: start;\r\n\r\n\r\nimg\r\n\r\n右下角布局。\r\nplace-items: end;\r\n\r\n\r\nimg\r\n\r\n并列式布局\r\n并列式布局就是多个项目并列。\r\n\r\n\r\nimg\r\n\r\n如果宽度不够，放不下的项目就自动折行。\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n它的实现也很简单。首先，容器设置成 Flex\r\n布局，内容居中（justify-content）可换行（flex-wrap）。\r\n.container &#123;    display: flex;    flex-wrap: wrap;    justify-content: center;&#125;\r\n然后，单个项上面只用一行flex属性就够了（CodePen 示例）。\r\n.item&#123;   flex: 0 1 150px;   margin: 5px;&#125;\r\nflex属性是flex-grow、flex-shrink、flex-basis这三个属性的简写形式。\r\nflex: &lt;flex-grow&gt; &lt;flex-shrink&gt; &lt;flex-basis&gt;;\r\n\r\nflex-basis：项目的初始宽度。\r\nflex-grow：指定如果有多余宽度，项目是否可以扩大。\r\nflex-shrink：指定如果宽度不足，项目是否可以缩小。\r\n\r\nflex: 0 1 150px;的意思就是，项目的初始宽度是150px，且不可以扩大，但是当容器宽度不足150px时，项目可以缩小。\r\n如果写成flex: 1 1 150px;，就表示项目始终会占满所有宽度。\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n两栏式布局\r\n两栏式布局就是一个边栏，一个主栏。\r\n\r\n\r\nimg\r\n\r\n下面的实现是，边栏始终存在，主栏根据设备宽度，变宽或者变窄。如果希望主栏自动换到下一行，可以参考上面的\"并列式布局\"。\r\n\r\n\r\nimg\r\n\r\n使用 Grid，实现很容易（CodePen 示例）。\r\n.container &#123;    display: grid;    grid-template-columns: minmax(150px, 25%) 1fr;&#125;\r\n上面代码中，grid-template-columns指定页面分成两列。第一列的宽度是minmax(150px, 25%)，即最小宽度为150px，最大宽度为总宽度的25%；第二列为1fr，即所有剩余宽度。\r\n三明治布局\r\n三明治布局指的是，页面在垂直方向上，分成三部分：页眉、内容区、页脚。\r\n\r\n\r\nimg\r\n\r\n这个布局会根据设备宽度，自动适应，并且不管内容区有多少内容，页脚始终在容器底部（粘性页脚）。也就是说，这个布局总是会占满整个页面高度。\r\n\r\n\r\nimg\r\n\r\nCSS 代码如下（CodePen\r\n示例）。\r\n.container &#123;    display: grid;    grid-template-rows: auto 1fr auto;&#125;\r\n上面代码写在容器上面，指定采用 Grid\r\n布局。核心代码是grid-template-rows那一行，指定垂直高度怎么划分，这里是从上到下分成三部分。第一部分（页眉）和第三部分（页脚）的高度都为auto，即本来的内容高度；第二部分（内容区）的高度为1fr，即剩余的所有高度，这可以保证页脚始终在容器的底部。\r\n圣杯布局\r\n圣杯布局是最常用的布局，所以被比喻为圣杯。它将页面分成五个部分，除了页眉和页脚，内容区分成左边栏、主栏、右边栏。\r\n\r\n\r\nimg\r\n\r\n这里的实现是，不管页面宽度，内容区始终分成三栏。如果宽度太窄，主栏和右边栏会看不到。如果想将这三栏改成小屏幕自动堆叠，可以参考并列式布局。\r\n\r\n\r\nimg\r\n\r\nHTML 代码如下。\r\n&lt;div class=&quot;container&quot;&gt;    &lt;header/&gt;    &lt;div/&gt;    &lt;main/&gt;    &lt;div/&gt;    &lt;footer/&gt;&lt;/div&gt;\r\nCSS 代码如下（CodePen\r\n示例）。\r\n.container &#123;    display: grid;    grid-template: auto 1fr auto / auto 1fr auto;&#125;\r\n上面代码要写在容器上面，指定采用 Grid\r\n布局。核心代码是grid-template属性那一行，它是两个属性grid-template-rows（垂直方向）和grid-template-columns（水平方向）的简写形式。\r\ngrid-template: &lt;grid-template-rows&gt; / &lt;grid-template-columns&gt;\r\ngrid-template-rows和grid-template-columns都是auto 1fr auto，就表示页面在垂直方向和水平方向上，都分成三个部分。第一部分（页眉和左边栏）和第三部分（页脚和右边栏）都是本来的内容高度（或宽度），第二部分（内容区和主栏）占满剩余的高度（或宽度）。\r\n参考链接\r\n\r\nTen modern layouts in\r\none line of CSS, Una Kravets\r\nFlex\r\n布局教程\r\nGrid\r\n布局教程\r\ngrid-template\r\n属性, MDN\r\n\r\n致谢\r\n本文摘抄至：阮一峰的网络日志——只要一行代码，实现五种\r\nCSS 经典布局\r\n","categories":["Develop","CSS"],"tags":["css","布局"]},{"title":"在弹性布局中内容溢出，滚动条失效的解决办法","url":"/posts/2020/2PX2VEN.html","content":"当在使用弹性布局时，我们希望头部、底部固定，中间 flex:1\r\n的部分实现滚动条显示，但是我们会发现，滚动条不会触发，直接超出弹性区域范围。\r\n\r\n解决方法是在设置 flex:1 的位置，将高度设置为 0：\r\nheight: 0px; // 为了能够有滚动条flex: 1px;\r\n","categories":["Develop","CSS"],"tags":["css","布局"]},{"title":"CSS 的值与单位","url":"/posts/2022/3JC8V28.html","content":"本文主要总结了 CSS 中的值和单位。\r\n\r\n值类型\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n数值类型\r\n描述\r\n\r\n\r\n\r\n\r\n&lt;integer&gt;\r\n&lt;integer&gt;是一个整数，比如1024或-55。\r\n\r\n\r\n&lt;number&gt;\r\n&lt;number&gt;表示一个小数——它可能有小数点后面的部分，也可能没有，例如0.255、128或-1.2。\r\n\r\n\r\n&lt;dimension&gt;\r\n&lt;dimension&gt;是一个&lt;number&gt;，它有一个附加的单位，例如45deg、5s或10px。&lt;dimension&gt;是一个伞形类别，包括&lt;length&gt;、&lt;angle&gt;、&lt;time&gt;和&lt;resolution&gt;类型。\r\n\r\n\r\n&lt;percentage&gt;\r\n&lt;percentage&gt;表示一些其他值的一部分，例如\r\n50%。百分比值总是相对于另一个量，例如，一个元素的长度相对于其父元素的长度。\r\n\r\n\r\n\r\n长度单位\r\n绝对长度单位\r\n\r\n\r\n\r\n单位\r\n名称\r\n等价换算\r\n\r\n\r\n\r\n\r\ncm\r\n厘米\r\n1cm = 96px/2.54\r\n\r\n\r\nmm\r\n毫米\r\n1mm = 1/10th of 1cm\r\n\r\n\r\nQ\r\n四分之一毫米\r\n1Q = 1/40th of 1cm\r\n\r\n\r\nin\r\n英寸\r\n1in = 2.54cm = 96px\r\n\r\n\r\npc\r\n十二点活字\r\n1pc = 1/16th of 1in\r\n\r\n\r\npt\r\n点\r\n1pt = 1/72th of 1in\r\n\r\n\r\npx\r\n像素\r\n1px = 1/96th of 1in\r\n\r\n\r\n\r\n相对长度单位\r\n相对长度单位相对于其他一些东西，比如父元素的字体大小，或者视图端口的大小。使用相对单位的好处是，经过一些仔细的规划，可以使文本或其他元素的大小与页面上的其他内容相对应。\r\n下表列出了web开发中一些最有用的单位。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n单位\r\n相对于\r\n\r\n\r\n\r\n\r\nem\r\n在 font-size\r\n中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如\r\nwidth\r\n\r\n\r\nex\r\n字符“x”的高度\r\n\r\n\r\nch\r\n数字“0”的宽度\r\n\r\n\r\nrem\r\n根元素的字体大小\r\n\r\n\r\nlh\r\n元素的line-height\r\n\r\n\r\nvw\r\n视窗宽度的1%\r\n\r\n\r\nvh\r\n视窗高度的1%\r\n\r\n\r\nvmin\r\n视窗较小尺寸的1%\r\n\r\n\r\nvmax\r\n视图大尺寸的1%\r\n\r\n\r\n\r\n参考\r\n\r\nCSS的值与单位\r\n\r\n","categories":["Develop","CSS"],"tags":["CSS"]},{"title":"从字意上理解 CSS 中的 justify 和 align","url":"/posts/2023/17Q11CW.html","content":"在进行 CSS 样式编写时，经常会遇到 align 和\r\njustify 这两个单词，比如：justify-content\r\n、justify-items、align-content、\r\nalign-items 等。\r\n在开发中，这个两个词意思相近，总是记不牢它们的用法，因此本文从其字面意思上梳理这两个单词的区别，方便记忆。\r\n\r\n利用百度进行翻译：\r\njustify:\r\n调整使全行排满;使每行排齐;使齐行\r\nalign:\r\n排列;校准;排整齐;(尤指)使成一条直线;使一致\r\n结合 css 中 flex 的用法，我们可以总结到如下结论：\r\n\r\njustify 是左右对齐\r\nalign 是上下对齐\r\n\r\n","categories":["Develop","CSS"],"tags":["[object Object]"]},{"title":"Vue 中的 CSS 样式编写要点","url":"/posts/2022/12DMY8D.html","content":"当 &lt;style&gt; 标签有 scoped 属性时，它的\r\nCSS 只作用于当前组件中的元素。这类似于 Shadow DOM\r\n中的样式封装。它有一些注意事项，但不需要任何 polyfill。\r\n\r\n它通过使用 PostCSS 来实现以下转换：\r\n&lt;style scoped&gt;.example &#123;  color: red;&#125;&lt;/style&gt;&lt;template&gt;  &lt;div class=&quot;example&quot;&gt;hi&lt;/div&gt;&lt;/template&gt;\r\n转换结果：\r\n&lt;style&gt;.example[data-v-f3f3eg9] &#123;  color: red;&#125;&lt;/style&gt;&lt;template&gt;  &lt;div class=&quot;example&quot; data-v-f3f3eg9&gt;hi&lt;/div&gt;&lt;/template&gt;\r\n混用本地和全局样式\r\n你可以在一个组件中同时使用有 scoped 和非 scoped 样式：\r\n&lt;style&gt;/* 全局样式 */&lt;/style&gt;&lt;style scoped&gt;/* 本地样式 */&lt;/style&gt;\r\n子组件的根元素\r\n使用 scoped\r\n后，父组件的样式将不会渗透到子组件中。不过一个子组件的根节点会同时受其父组件的\r\nscoped CSS 和子组件的 scoped CSS\r\n的影响。这样设计是为了让父组件可以从布局的角度出发，调整其子组件根元素的样式。\r\n深度作用选择器\r\n如果你希望 scoped\r\n样式中的一个选择器能够作用得“更深”，例如影响子组件，你可以使用\r\n&gt;&gt;&gt; 操作符：\r\n&lt;style scoped&gt;.a &gt;&gt;&gt; .b &#123; /* ... */ &#125;&lt;/style&gt;\r\n上述代码将会编译成：\r\n.a[data-v-f3f3eg9] .b &#123; /* ... */ &#125;\r\n有些像 Sass 之类的预处理器无法正确解析\r\n&gt;&gt;&gt;。这种情况下你可以使用 /deep/ 或\r\n::v-deep 操作符取而代之——两者都是 &gt;&gt;&gt;\r\n的别名，同样可以正常工作。\r\n动态生成的内容\r\n通过 v-html 创建的 DOM 内容不受 scoped\r\n样式影响，但是你仍然可以通过深度作用选择器来为他们设置样式。\r\n还有一些要留意\r\n\r\nScoped 样式中最好使用 class\r\n选择器。考虑到浏览器渲染各种 CSS 选择器的方式，当\r\np { color: red } 是 scoped 时 (即与特性选择器组合使用时)\r\n会慢很多倍。如果你使用 class 或者 id 取而代之，比如\r\n.example { color: red }，性能影响就会消除。\r\n在递归组件中小心使用后代选择器! 对选择器\r\n.a .b 中的 CSS 规则来说，如果匹配 .a\r\n的元素包含递归子组件，则所有的子组件中的 .b\r\n都将被这个规则匹配。\r\n\r\n参考\r\n\r\nScoped\r\nCSS | Vue Loader (vuejs.org)\r\n\r\n","categories":["Develop","CSS"],"tags":["CSS","Vue"]},{"title":"flex 布局中在 flex-grow 元素里显示滚动条","url":"/posts/2023/3FEED8Y.html","content":"\r\n\r\nimage-20230727230710866\r\n\r\n本文介绍了如何实现：\r\n容器的高度随内容增加而增高，且某个元素使用 flex:1\r\n占满剩余空间，当达到最大值时，若该元素溢出后则显示滚动条。\r\n\r\n思路\r\n\r\n使用 column 进行列布局\r\n对容器设置最大高度或者固定高度\r\n对需要占满剩余空间的元素设置 flex:1\r\n\r\n实现\r\nHTML：\r\n&lt;div id=&quot;app&quot;&gt;  &lt;div class=&quot;container&quot;&gt;        &lt;div class=&quot;item item-expand&quot;&gt;      &lt;div&gt;Item 1&lt;/div&gt;      &lt;div&gt;Item 1&lt;/div&gt;      &lt;div&gt;Item 1&lt;/div&gt;      &lt;div&gt;Item 1&lt;/div&gt;      &lt;div&gt;Item 1&lt;/div&gt;      &lt;div&gt;Item 1&lt;/div&gt;      &lt;div&gt;Item 1&lt;/div&gt;      &lt;div&gt;Item 1&lt;/div&gt;      &lt;div&gt;Item 1&lt;/div&gt;      &lt;div&gt;Item 1&lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;item&quot;&gt;Item 2&lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;\r\nCSS：\r\n.container &#123;  display: flex;  flex-direction: column;  max-height: 200px;  border: 1px solid #ccc;&#125;.item &#123;  padding: 10px;  border: 1px solid #ccc;&#125;.item-expand &#123;  flex: 1;  overflow: auto;&#125;\r\n演示\r\n单击查看演示：flex-grow\r\n中显示滚动条\r\n","categories":["Develop","CSS"],"tags":["CSS"]},{"title":"eggjs 单机热更新解决方案","url":"/posts/2023/QKCR7T.html","content":"后端采用 eggjs 作为框架，由于项目体量小，没有采用集群部署，而是将\r\nnginx 和\r\neggjs、前端都部署到了一台机器上，由于更新频繁，导致用户经常断线、响应错误，用户体验非常不好，造成程序不稳定的印象。\r\n\r\n用户内心\r\nOS：什么垃圾程序员，写的程序经常出问题，还强制退出，烦死了~\r\n\r\n因此，不论如何，为了尊严，一定得实现热更新！\r\n\r\n百度大法\r\n要解决问题，按照习俗，肯定是先问下百度。\r\n一通查找，发现官方建议使用\r\nSLB 来实现热更新，那我不具备这个条件咋办，然后又发现一个新的思路 eggjs\r\n的单机热部署，但作者已不再维护，因此根据 egg-deploy\r\n思路，自己进行一些优化实现了eggjs 的单机热更新。\r\n解决思路\r\n热更新的总体思路与集群热更新的方式一致，只不是实现方式不一样，核心思想是：\r\n在服务器上启动临时 eggjs 实例，然后通过 nginx 的 reload\r\n将流量切到临时实例后，更新主服务，再将 nginx 切换加主服务上。\r\n按思路，首先要考虑 2 个问题：\r\n\r\nschedule 任务可能在临时实例上执行\r\n在关闭服务时，可能还存在未完成的连接，导致用户端响应错误\r\n\r\n对于第 1 个问题，可以将 schedule\r\n单独用一个实例去承载。由于是一些定时任务，不会频繁地去更新，即使关闭重启，对用户的使用完全没有影响。\r\n对于第 2 个问题，据 官方回复，eggjs\r\n有做优雅退出，因此该问题不需要进行处理。\r\n完整方案\r\n独立 Schedule\r\nschedule 服务单独使用一个实例来承载。因此，在使用\r\negg-scripts start启动时，要向 eggjs\r\n传递启动参数，来区分实例的类型。可以通过下列两个方式来实现：\r\n\r\n如果是 eggjs3.x 的话，可以在启动时，传递一个 --env\r\n来指定环境变量，从而调用指定的配置文件来初始化\r\neggjs，这个时候就可以在指定的配置文件中增加配置来表明当前实例的类型\r\n在 eggjs2.x 中，则无法修改 --env，因此只能通过\r\nprocess.argv 的第 3 个参数来进行判断\r\n\r\n下面介绍一下在 eggjs2.x 的实例类型识别方法\r\n在 eggjs 实例中，process.argv[2] 是由 egg-scripts\r\n传递的参数，它是一个 json 字符串，我们可以通过其中的 title 或者 port\r\n来区分实例的类型，在 configWillLoad()\r\n钩子函数中将增加实例类型的配置。\r\n最后在定义 schedule 时，根据配置来判断是否启动该 schedule。\r\n代码如下：\r\n// app.jsconfigWillLoad() &#123;  // 此时 config 文件已经被读取并合并，但是还并未生效  // 这是应用层修改配置的最后时机  // 注意：此函数只支持同步调用  //   // 例如：参数中的密码是加密的，在此处进行解密  //   this.app.config.mysql.password = decrypt(this.app.config.mysql.password);  //   // 例如：插入一个中间件到框架的 coreMiddleware 之间  //   const statusIdx = this.app.config.coreMiddleware.indexOf(&#x27;status&#x27;);  //   this.app.config.coreMiddleware.splice(statusIdx + 1, 0, &#x27;limit&#x27;);  // 根据启动命令设置 deploy 环境  setStartupEnv(this.app.config)&#125;\r\n// setStartupEnv 定义function setStartupEnv(config) &#123;    const startupEnv = JSON.parse(process.argv[2])  // 不覆盖设置  if (config.deploy || config.env === &#x27;local&#x27;) return  if (startupEnv.port === 7010) &#123;    config.deploy = &#123;      env: &#x27;schedule&#x27;    &#125;  &#125;&#125;\r\n// shedule 定义// 如果不是采用这种方式的，可以参考思路&#x27;use strict&#x27;const &#123; schedule &#125; = require(&#x27;../utils/scheduleBase&#x27;)module.exports = app =&gt; &#123;  return &#123;    schedule: schedule(      &#123;        interval: &#x27;1s&#x27;, // 每天凌晨4点执行        type: &#x27;worker&#x27;, // 指定某一个 worker 执行        env: [&#x27;local&#x27;],        immediate: true, // 不开机启动        disable: true, // 不启动，只采用手动调用        running: false, // 是否正在运行        lastTime: 0 // 上次触发时间      &#125;,      app    ),    async task(ctx) &#123;      console.log(&#x27;testSchedule start()&#x27;)    &#125;  &#125;&#125;\r\n// scheduleBase.js/** * 包裹 schedule 设置定义 * @param &#123;*&#125; scheduleOptions * @param &#123;*&#125; app * @return */function schedule(scheduleOptions, app) &#123;  const enable = enableSchedule(app.config)  if (enable) return scheduleOptions  // 修改 disable 属性  scheduleOptions.disable = true  return scheduleOptions&#125;\r\n主服务热更新流程\r\nsequenceDiagramNginx -&gt;&gt; Eggjs—Instance1: 连接主服务Eggjs—Instance2 --&gt;&gt; Eggjs—Instance2: 启动临时服务Nginx --&gt;&gt; Eggjs—Instance2: 切换到临时服务Eggjs—Instance1 -&gt;&gt; Eggjs—Instance1: 重启主服务Nginx -&gt;&gt; Eggjs—Instance1: 切换到主服务Eggjs—Instance2 --&gt;&gt; Eggjs—Instance2: 关闭临时服务\r\nNginx 流量切换实现\r\nnginx 中使用 upstream 来进行流量切换。\r\nupstream backend_stream &#123;    // eggjs 主服务    server 127.0.0.1:7001;    // eggjs 临时服务    server 127.0.0.1:7002 down;&#125;server &#123;    listen 443;    server_name test.demo.com;    ssl_session_cache shared:SSL:1m;    ssl_session_timeout 5m;    ssl_ciphers HIGH:!aNULL:!MD5;    ssl_prefer_server_ciphers on;\t# 头信息    proxy_set_header X-Forwarded-Host $host;    proxy_set_header X-Forwarded-Server $host;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\t# location请求映射规则，/ 代表一切请求路径    location / &#123;        proxy_connect_timeout 600;        proxy_read_timeout 600;        proxy_set_header Upgrade $http_upgrade;        proxy_set_header Connection &quot;upgrade&quot;;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_set_header Host $host;        proxy_pass http://backend_stream;    &#125;&#125;\r\n通过修改 upstream 中的服务启用或关闭来进行流量切换，切换后，需要使用\r\nnginx -s reload 来重载配置。\r\n具体的实施代码可以参考：egg-deploy\r\n参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\neggjs生产环境可以热更新吗？\r\neggjs\r\n的单机热部署\r\negg-deploy\r\n大公司里怎样开发和部署前端代码？\r\n- 知乎 (zhihu.com)\r\n前端非覆盖式发布\r\n- 掘金 (juejin.cn)\r\neggjs优雅重启策略\r\n","categories":["Develop","Deploy"],"tags":["Vue","Deploy"]},{"title":"父元素仅设置max-height，子元素高度百分之100，溢出后如何显示滚动条","url":"/posts/2023/27DHP6N.html","content":"本文介绍了如何实现：\r\n父元素仅设置 max-height，子元素的高度为\r\n100%，跟随父元素高度的变化而变化，且当达到最大高度后，子元素显示滚动条。\r\n\r\n思路\r\n\r\n由于父元素没有设置 height 属性，因此子元素不能使用\r\nheight:100% 来跟随父元素的变化\r\n通过 flex 布局，将子元素设置成 flex:1\r\n来让其与父元素同高\r\n再设置子元素 overflow:auto;flext-wrap:nowrap;\r\n来显示滚动条\r\n\r\n实现\r\n&lt;div id=&quot;app&quot;&gt;  &lt;div class=&quot;container&quot;&gt;          &lt;div&gt;Item 1&lt;/div&gt;      &lt;div&gt;Item 1&lt;/div&gt;      &lt;div&gt;Item 1&lt;/div&gt;      &lt;div&gt;Item 1&lt;/div&gt;      &lt;div&gt;Item 1&lt;/div&gt;      &lt;div&gt;Item 1&lt;/div&gt;      &lt;div&gt;Item 1&lt;/div&gt;      &lt;div&gt;Item 1&lt;/div&gt;      &lt;div&gt;Item 1&lt;/div&gt;      &lt;div&gt;Item 1&lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;\r\n#app&#123;  display: flex;  max-height: 200px;&#125;.container &#123;  padding: 10px;  display: flex;  flex-direction: column;    border: 1px solid #ccc;  /* height: 100%; 此处不能使用这个属性，因为父类没有设置 height,因此无法计算高度*/  flex:1;  overflow: auto;  flex-wrap: nowrap;&#125;\r\n演示\r\n父元素设置max-height，子元素高度100%实现\r\n(runjs.work)\r\n","categories":["Develop","CSS"],"tags":["CSS"]},{"title":"类关系图简记","url":"/posts/2022/2AJRA04.html","content":"类关系记忆技巧总结如下表所示：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n分类\r\n箭头特征\r\n记忆技巧\r\n\r\n\r\n\r\n\r\n箭头方向\r\n从子类指向父类\r\n定义子类需要通过 extends\r\n关键字指定父类子类一定是知道父类定义的，但父类并不知道子类的定义只有知道对方信息时才能指向对方箭头的方向是从子类指向父类\r\n\r\n\r\n继承/实现\r\n用线条连接两个类； 空心三角箭头表示继承或实现\r\n实线表示继承，是is-a的关系，表示扩展，不虚，很结实\r\n\r\n\r\n虚线表示实现，虚线代表“虚”无实体\r\n\r\n\r\n\r\n\r\n关联/依赖\r\n用线条连接两个类； 普通箭头表示关联或依赖\r\n虚线表示依赖关系：临时用一下，若即若离，虚无缥缈，若有若无表示一种使用关系，一个类需要借助另一个类来实现功能一般一个类将另一个类作为参数使用，或作为返回值\r\n\r\n\r\n实线表示关联关系：关系稳定，实打实的关系，“铁哥们”表示一个类对象和另一个类对象有关联通常一个类中有另一个类对象作为属性\r\n\r\n\r\n\r\n\r\n组合/聚合\r\n用菱形表示：像一个盛东西的器皿（如盘子）\r\n聚合：空心菱形，代表空器皿里可以放很多相同的东西，聚集在一起（箭头方向所指的类）整体和局部的关系，两者有独立的生命周期，是\r\nhas-a 的关系弱关系，消极的词：弱-空\r\n\r\n\r\n组合：实心菱形，代表器皿里已经有实体结构的存在，生死与共整体与局部的关系，和聚合关系对比，关系更加强烈，两者具有相同的生命周期，contains-a\r\n的关系强关系，积极的词；强-满\r\n\r\n\r\n\r\n\r\n\r\n\r\n类图\r\n下图是对动物衍生关系描述的类图。这个图非常有技术含量也非常经典。\r\n\r\n\r\n类关系图\r\n\r\n依赖与关联的区别\r\n类与类之间由弱到强关系是: 没关系 &gt;依赖 &gt; 关联 &gt; 聚合 &gt;\r\n组合\r\n依赖\r\n可以简单的理解，就是一个 类A 使用到了另一个\r\n类B，而这种使用关系是具有偶然性的、临时性的、非常弱的，但是 B类\r\n的变化会影响到 A；\r\n比如某人要过河，需要借用一条船，此时人与船之间的关系就是依赖；\r\n表现在代码层面，为 类B 作为参数被 类A 在某个 method方 法中使用。\r\n用带虚线的箭头。\r\n关联\r\n他体现的是两个类、或者类与接口之间语义级别的一种强依赖关系，比如我和我的朋友；这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的，而且双方的关系一般是平等的、关联可以是单向、双向的；\r\n表现在代码层面，为被关联类B以类属性的形式出现在关联 类A\r\n中，也可能是关联 类A 引用了一个类型为被关联 类B 的全局变量；\r\n","categories":["Develop","DesignPattern"],"tags":["设计模式"]},{"title":"C# 优雅编程","url":"/posts/2022/54B652.html","content":"\r\n","categories":["Develop","DesignPattern"],"tags":["C#"]},{"title":"编程风格指南","url":"/posts/2022/1BXSKSD.html","content":"本文总结了 C# 中的编程风格，使编写的代码更加优雅。\r\n\r\n","categories":["Develop","DesignPattern"],"tags":["设计模式","C#"]},{"title":"关于时间的用法总结","url":"/posts/2020/2KKWR4A.html","content":"在工作中，经常使用 C# 和 JS\r\n混合编程，当两者时间混用的时候，如果不理解，会遇到各种坑，特此记录下对于时间的理解。\r\n\r\n什么是 UTC 时间？\r\n世界协调时间（Coordinated Universal\r\nTime）。\r\n生成时间\r\n原生js\r\nnew Date() 的参数如下：\r\nnew Date(&quot;month dd,yyyy hh:mm:ss&quot;);  new Date(&quot;month dd,yyyy&quot;);  new Date(&quot;yyyy/MM/dd hh:mm:ss&quot;);  new Date(&quot;yyyy/MM/dd&quot;);  new Date(yyyy,mth,dd,hh,mm,ss);  new Date(yyyy,mth,dd);  new Date(ms);\r\nmoment.js\r\nmoment.js\r\n里面的时间转换比较强大，具体可以参考：https://momentjs.com/docs/#/parsing/\r\nmoment 转原生 Date\r\nmoment.toDate()\r\n获取时间戳\r\n原生js\r\n// 1var timestamp = Date.parse(new Date());// 2var timestamp = (new Date()).valueOf();// 3var timestamp=new Date().getTime();\r\nmoment.js\r\nmoment().valueOf()\r\nCSharp\r\nnew DateTimeOffset(fileSystemInfo.LastWriteTimeUtc).ToUnixTimeMilliseconds();\r\n从时间戳中获取时间\r\n// 时间戳为msvar d = new Date(时间戳)var day = d.getDay()var month = d.getMonth() + 1var year = d.getFullYear()var hour = d.getHours()var minute = d.getMinutes()var second = d.getSeconds()var milliseconds = d.getMilliseconds()\r\n字符串转时间\r\nmoment: https://momentjs.com/docs\r\nmoment(string)\r\n","categories":["Develop","DateTime"],"tags":["android","cpp","c#"]},{"title":"前端好用工具","url":"/posts/2022/1QF32WJ.html","content":"本文主要收集一些好用的前端开发工具，方便在开发中使用。\r\n\r\n站酷：https://www.zcool.com.cn/search/folder/fix?word=%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F\r\nicon：https://remixicon.com/ 、https://iconic.app/aerial/ 、\r\nhttps://fontawesome.com/v5.15/icons?d=gallery&amp;p=2&amp;m=free\r\n调色板：https://arco.design/palette/list\r\n插画：https://undraw.co/illustrations 、\r\nhttps://icons8.cn/illustrations/style--pale\r\n动画库：vue版本https://motion.vueuse.org/\r\n、react版本https://motion.ant.design/language/transition-cn\r\n美工吧：https://www.meigong8.com/\r\ncss指南集合：https://tsejx.github.io/css-guidebook/concept/selector/\r\n、https://chokcoco.github.io/CSS-Inspiration/#/\r\n","categories":["Develop","FrontEnd"],"tags":["FrontEnd"]},{"title":"掌握设计原则，打磨编程基本功","url":"/posts/2024/3D3WTKJ.html","content":"随着开发经验的增加，总感觉自己的代码风格有些混乱，同时伴随着一些困惑，如：\r\n\r\n功能扩展性差，经常需要被重构\r\n编码时无法对设计模式进行灵活使用\r\n代码不够优雅\r\n\r\n虽然代码风格见人见智，但是好的代码，总会让人眼前一亮，低耦合、高内聚、高复用、易扩展、易维护，于己于人，都是一份优雅。\r\n作者从入门开始，就开始阅读设计模式，有系统地研读过，也有零零散散看过其他人的心得，但总是不能达到天人合一，运用自如的状态。今朝又心有所动，于是下定决心，稳扎稳打，以愚公移山之劲，重学设计模式，打磨编程基本功。\r\n\r\n概述\r\n面向对象开发，要主遵循七大设计原则，这七在原则，是编程的核心纲要，是编程的根基，因此必须滚瓜烂熟。\r\n这七大原则的核心目录其实就一个：封装变化。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n设计原则\r\n一句话归纳\r\n目的\r\n\r\n\r\n\r\n\r\n单一职责原则(Single Responsibility Principle，SRP)\r\n一个类只干一件事，实现类要单一\r\n便于理解，提高代码的可读性\r\n\r\n\r\n开闭原则(Open-Closed Principle，OCP)\r\n对扩展开放，对修改关闭\r\n降低维护带来的新风险\r\n\r\n\r\n里氏替换原则(Liskov Substitution Principle， LSP)\r\n派生类（子类）对象可以在程序中代替其基类（超类）对象。\r\n防止继承泛滥\r\n\r\n\r\n接口隔离原则(Interface Segregation Principle，ISP)\r\n一个接口只干一件事，接口职责要精简单一\r\n功能解耦，高聚合、低耦合\r\n\r\n\r\n依赖倒置原则(Dependence Inversion Principle，DIP)\r\n高层不应该依赖低层，应面向接口编程应依赖于抽象而不是一个实例\r\n更利于代码结构的升级扩展\r\n\r\n\r\n合成复用原则(Composite Reuse Principle，CRP)\r\n尽量使用组合或者聚合关系实现代码复用，少使用继承\r\n降低代码耦合\r\n\r\n\r\n迪米特法则(Law of Demeter，LoD)\r\n一个软件实体应当尽可能少地与其他实体发生相互作用，一个类应该保持对其它对象最少的了解，降低耦合度\r\n只和朋友交流，不和陌生人说话，减少代码臃肿\r\n\r\n\r\n\r\n\r\n上述可简记为：迪米特、开单里、接依合（迪米特 开 车到\r\n3（单谐音） 里 路外，去接 依 合）\r\n也可以简记为： SOLID CD（固体CD）\r\n\r\n单一职责原则(S)\r\n定义\r\n单一职责原则（Single Responsibility\r\nPrinciple，SRP）又称单一功能原则，由罗伯特·C.马丁（Robert C.\r\nMartin）于《敏捷软件开发：原则、模式和实践》一书中提出的。这里的职责是指类变化的原因，单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分（There\r\nshould never be more than one reason for a class to change）。\r\n该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：\r\n\r\n一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；\r\n当客户端仅需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。\r\n\r\n优点\r\n单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性。如果遵循单一职责原则将有以下优点。\r\n\r\n降低类的复杂度\r\n\r\n一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。\r\n\r\n提高类的可读性\r\n\r\n复杂性降低，自然其可读性会提高。\r\n\r\n提高系统的可维护性\r\n\r\n可读性提高，那自然更容易维护了。\r\n\r\n变更引起的风险降低\r\n\r\n变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。\r\n实现方法\r\n单一职责原则是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同的类或模块中。而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。\r\n\r\n不同的应用场景，对同一个类的职责是否单一的判定，是不一样的。我们需要具体场景具体分析\r\n一个类的设计可能已经满足单一职责原则了，但可能随着需求的迭代在未来的某个时候就不再满足单一职责原则了，此时我们没必要过于未雨绸缪，过度设计。可以先满足业务需求。随着业务的发展，如果类变得越来越庞大，代码越来越多，不再满足单一职责，这个时候，再把这个类持续进行重构拆分。\r\n\r\n不满足单一职责的坏味道\r\n随着开发经验的积累，我们是很容易嗅到一些不满足单一职责的坏味道的\r\n\r\n类的代码行数过多\r\n类依赖的其他类过多\r\n过长的方法\r\n私有方法过多\r\n不容易给类起名字，类名中包含两个或以上的名词\r\n\r\n开闭原则(O)\r\n定义\r\n开闭原则（Open Closed Principle，OCP）由勃兰特·梅耶（Bertrand\r\nMeyer）提出，他在 1988 年的著作《面向对象软件构造》（Object Oriented\r\nSoftware Construction）中提出：Software entities like classes,modules\r\nand functions should be open for extension but closed for\r\nmodifications，软件实体应当对扩展开放，对修改关闭。\r\n这里的软件实体包括以下几个部分：\r\n\r\n项目中划分出的模块\r\n类与接口\r\n方法\r\n\r\n实现方法\r\n需求总是变化的，\r\n可是对于软件设计者来说，如何才能做到不对原有系统修改的前提下，实现灵活的扩展，使其满足新的需求。\r\n在开发过程中，应面向相对稳定的类型编程，一般认为，以下类型都属于相对稳定的类型：\r\n\r\n接口\r\n抽象类\r\n功能类\r\n其它不变化的类\r\n\r\n因为抽象不包含具体实现，所以灵活性好，适应性广，只要抽象得合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。\r\n\r\n有的同学可能会有这样的疑惑：新派生一个类后，要如何初始化后应用到系统中？\r\n一般有以下方式：\r\n\r\n使用依赖注入框架。\r\n使用反射技术。将初始化的具体类型名称写入到配置文件，程序通过读取配置来初始化对应类\r\n\r\n\r\n作用\r\n开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。具体来说，其作用如下。\r\n\r\n对软件测试的影响\r\n软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。\r\n可以提高代码的可复用性\r\n粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。\r\n可以提高软件的可维护性\r\n遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。\r\n\r\n里氏替换原则(L)\r\n定义\r\n里氏替换原则（Liskov Substitution\r\nPrinciple，LSP）由麻省理工学院计算机科学实验室的里斯科夫（Liskov）女士在\r\n1987\r\n年的“面向对象技术的高峰会议”（OOPSLA）上发表的一篇文章《数据抽象和层次》（Data\r\nAbstraction and Hierarchy）里提出来的，她提出：Inheritance should ensure\r\nthat any property proved about supertype objects also holds for subtype\r\nobjects，继承必须确保超类所拥有的性质在子类中仍然成立。\r\n里氏替换原则主要阐述了有关继承的一些原则，是对多态应用的一种规范约束。\r\n规则\r\n\r\n子类方法不能违背父类方法对输入输出异常的约定\r\n\r\n前置条件（输入参数）更宽松\r\n后置条件（返回结果）更严格\r\n不能新增异常类型\r\n\r\n子类方法不能违背父类方法定义的功能\r\n子类必须完全实现父类的抽象方法\r\n\r\n作用\r\n里氏替换原则的主要作用如下。\r\n\r\n里氏替换原则是实现开闭原则的重要方式之一。\r\n它克服了继承中重写父类造成的可复用性变差的缺点。\r\n它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。\r\n加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。\r\n\r\n实现方法\r\n里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。\r\n根据上述理解，对里氏替换原则的定义可以总结如下：\r\n\r\n子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法\r\n子类中可以增加自己特有的方法\r\n当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松\r\n当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的的输出/返回值）要比父类的方法更严格或相等\r\n\r\n通过重写父类的方法来完成新的功能写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。\r\n接口隔离原则(I)\r\n定义\r\n接口隔离原则（Interface Segregation\r\nPrinciple，ISP）要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。\r\n2002 年罗伯特·C.马丁给“接口隔离原则”的定义是：Clients should not be\r\nforced to depend on methods they do not\r\nuse，即客户端不应该被迫依赖于它不使用的方法。该原则还有另外一个定义：The\r\ndependency of one class to another one should depend on the smallest\r\npossible interface，一个类对另一个类的依赖应该建立在最小的接口上。\r\n以上两个定义的含义是：要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。\r\n接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：\r\n\r\n单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。\r\n单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。\r\n\r\n优点\r\n接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下\r\n5 个优点。\r\n\r\n将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。\r\n接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。\r\n如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。\r\n使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。\r\n能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。\r\n\r\n实现方法\r\n在具体应用接口隔离原则时，应该根据以下几个规则来衡量。\r\n\r\n接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。\r\n为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。\r\n了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。\r\n提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。\r\n\r\n依赖倒置原则(D)\r\n定义\r\n依赖倒置原则（Dependence Inversion Principle，DIP）是 Object Mentor\r\n公司总裁罗伯特·马丁（Robert C.Martin）于 1996 年在 C++ Report 上发表的文章。\r\n依赖倒置原则的原始定义为：High level modules should not depend upon\r\nlow level modules. Both should depend upon abstractions. Abstractions\r\nshould not depend upon details. Details should depend upon\r\nabstractions，即高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。其核心思想是：要面向接口编程，不要面向实现编程。\r\n依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。\r\n由于在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。\r\n使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。\r\n作用\r\n依赖倒置原则的主要作用如下。\r\n\r\n降低类间的耦合性。\r\n提高系统的稳定性。\r\n减少并行开发引起的风险。\r\n提高代码的可读性和可维护性。\r\n\r\n实现方法\r\n依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以我们在实际编程中只要遵循以下\r\n4 点，就能在项目中满足这个规则。\r\n\r\n每个类尽量提供接口或抽象类，或者两者都具备。\r\n变量的声明类型尽量是接口或者是抽象类。\r\n任何类都不应该从具体类派生。\r\n使用继承时尽量遵循里氏替换原则。\r\n依赖注入：通过构造函数、方法参数或属性注入的方式，将低层模块的实例传递给高层模块\r\n\r\n合成复用原则(C)\r\n定义\r\n合成复用原则（Composite Reuse\r\nPrinciple，CRP）又叫组合/聚合复用原则（Composition/Aggregate Reuse\r\nPrinciple，CARP）。它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。\r\n如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。\r\n重要性\r\n通常类的复用分为 继承复用 和\r\n合成复用\r\n两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点。\r\n\r\n破坏了类的封装性。\r\n因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。\r\n子类与父类的耦合度高。\r\n父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。\r\n它限制了复用的灵活性。\r\n从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。\r\n\r\n采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点。\r\n\r\n它维持了类的封装性。\r\n因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。\r\n新旧类之间的耦合度低。\r\n这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。\r\n复用的灵活性高。\r\n这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。\r\n\r\n实现方法\r\n合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。\r\n迪米特法则(D)\r\n定义\r\n迪米特法则（Law of Demeter，LoD）又叫作最少知识原则（Least Knowledge\r\nPrinciple，LKP)，产生于 1987 年美国东北大学（Northeastern\r\nUniversity）的一个名为迪米特（Demeter）的研究项目，由伊恩·荷兰（Ian\r\nHolland）提出，被 UML\r\n创始者之一的布奇（Booch）普及，后来又因为在经典著作《程序员修炼之道》（The\r\nPragmatic Programmer）提及而广为人知。\r\n迪米特法则的定义是：只与你的直接朋友交谈，不跟“陌生人”说话（Talk only\r\nto your immediate friends and not to\r\nstrangers）。其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。\r\n迪米特法则中的“朋友”是指：\r\n\r\n当前对象本身\r\n当前对象的成员对象\r\n当前对象所创建的对象\r\n当前对象的方法参数等\r\n\r\n这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。\r\n\r\n也可以理解为只能使用一个 . 访问的资源。比如可以使用\r\nperson.age，但不能使用 person.Friend.age\r\n\r\n优点\r\n迪米特法则要求限制软件实体之间通信的宽度和深度，正确使用迪米特法则将有以下两个优点。\r\n\r\n降低了类之间的耦合度，提高了模块的相对独立性。\r\n由于亲合度降低，从而提高了类的可复用率和系统的扩展性。\r\n\r\n但是，过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。\r\n实现方法\r\n从迪米特法则的定义和特点可知，它强调以下两点：\r\n\r\n从依赖者的角度来说，只依赖应该依赖的对象。\r\n从被依赖者的角度说，只暴露应该暴露的方法。\r\n\r\n所以，在运用迪米特法则时要注意以下 6 点：\r\n\r\n在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。\r\n在类的结构设计上，尽量降低类成员的访问权限。\r\n在类的设计上，优先考虑将一个类设置成不变类。\r\n在对其他类的引用上，将引用其他对象的次数降到最低。\r\n不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。\r\n谨慎使用序列化（Serializable）功能。\r\n\r\n参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\nSOLID\r\n(面向对象设计) - 维基百科，自由的百科全书\r\n设计模式目录：22种设计模式\r\n","categories":["Develop","DesignPattern"],"tags":["设计模式"]},{"title":"Html 页面打印时无法自定义 Margin 修改边距","url":"/posts/2025/HCV0MC.html","content":"为了实现 HTML 页面打印成 PDF 的功能，在后端使用 Playwright\r\n调用浏览器进行打印，在开发中发现，不论怎么修改 margin\r\n参数，页面始终没有变化。\r\n经过一翻排查，发现是 @page css 规则限制了的原因。\r\n\r\n正文\r\n后端通过 python 微服务调用 playwright 打印模块，实现将 html 转换成\r\npdf，具体代码如下：\r\nasync def print_html_to_pdf_bytes(html_content, print_options: dict = &#123;&#125;) -&gt; bytes:    &quot;&quot;&quot;    将 HTML 内容渲染并返回 PDF 的二进制数据。    pdf_options 常用选项，参考 page.pdf 的参数    注意：page.pdf 仅在 Chromium 可用。    &quot;&quot;&quot;    async with await allocate_page() as page:        await page.set_content(html_content, wait_until=&quot;load&quot;)        try:            # 当不传递 path 参数时，page.pdf 会返回 PDF 的二进制数据            pdf_bytes = await page.pdf(                **&#123;                    **&#123;                        &quot;format&quot;: &quot;A4&quot;,                        &quot;print_background&quot;: True,                        &quot;display_header_footer&quot;: True,  # 必需：启用页眉/页脚占位符替换                    &#125;,                    **print_options,                &#125;            )        except Exception as e:            # 抛出更友好的提示（例如在非 Chromium 环境）            raise RuntimeError(                &quot;生成 PDF 时出错（注意：page.pdf 仅在 Chromium 中受支持）。原始错误: &quot;                + str(e)            )        finally:            pass        return pdf_bytes\r\n其中，print_options 的值为：\r\n&#123;  &quot;margin&quot;:&#123;    &quot;top&quot;: &quot;20mm&quot;,    &quot;right&quot;: &quot;10mm&quot;,    &quot;bottom&quot;: &quot;10mm&quot;,    &quot;left&quot;: &quot;10mm&quot;  &#125;&#125;\r\n这段代码在打印某个 html 页面时，始终无法修改打印后的边距，在网上搜索\r\nplaywright margin 相关的问题，github 上 issues 中显示这个 bug\r\n早已经修复了。\r\n最后，猜测可能是 html 本身有问题，打开 html 文件查看，发现 css\r\n中存在以下内容：\r\n@page &#123;      size: A4 portrait;      margin-left: 20mm;      margin-right: 10mm;      margin-top: 10mm;      margin-bottom: 10mm;      -webkit-print-color-adjust: exact;      print-color-adjust: exact;    &#125;\r\n原因终于明了了，@page 规则是一种 CSS\r\n规则，用于修改打印页面的不同方面。它的目标是修改页面的尺寸、方向和页边距。\r\n它的存在，会覆盖浏览器本身的 margin 打印设置，因此一直无法生效。\r\n参考\r\n\r\n[BUG]\r\nControlling margins when making a PDF using Playwright - Margins don't\r\nrespect CSS · Issue #3434 · microsoft/playwright\r\n@page - CSS：层叠样式表 |\r\nMDN\r\n\r\n","categories":["Develop","HTML"],"tags":["HTML","Playwright"]},{"title":"纯 css 实现 placehoder 效果","url":"/posts/2024/2YJ7VJZ.html","content":"如何使用 CSS 实现当内容为空时，显示 placeholder 呢？\r\n代码如下：\r\nhtml\r\n&lt;div id=&quot;css-placeholder&quot;&gt;  &lt;div class=&quot;editor&quot; contentEditable=&quot;true&quot; placeholder=&quot;请输入内容...&quot;&gt;  &lt;/div&gt;&lt;div&gt;\r\nscss\r\n#css-placeholder&#123;  [contentEditable=&#x27;true&#x27;]:empty:before &#123;    content: attr(placeholder);    color: black;  &#125;&#125;\r\n演示地址: css placeholder -\r\n码上掘金 (juejin.cn)\r\n","categories":["Develop","CSS"],"tags":["CSS"]},{"title":"Js 开发常用 npm 包合集","url":"/posts/2023/1KT0Y3S.html","content":"本文根据日常开发需求，通过对比现有各个包，总结出在个人认知范围内认为最为合适的\r\nnpm 包。方便在后续项目中应用。\r\n\r\nExcel\r\nexceljs\r\n参考：\r\n\r\nExceljs\r\n与 Sheetjs(xlsx.js)、 xlsx-populate.js\r\n解析xlsx表格的性能对比、耗时对比\r\n\r\n","categories":["Develop","Javascript"],"tags":["Javasript"]},{"title":"色彩搭配方法","url":"/posts/2022/2K21HCS.html","content":"\r\n\r\nimage-20220401215806742\r\n\r\n本文主要记录在平时使用中的一些配色技巧，方便使用。\r\n\r\n理解色彩\r\n色彩的构成\r\n什么是色彩\r\n印刷品设计：色彩就是可见光在物体颜料上除去被吸收的光后，散射出来的光的颜色，是一种「反射色」\r\n互联网设计：色彩就是白色光透过带颜色的电子屏幕后，表现出来的光的颜色，是一种「透过色」\r\n色彩的构成\r\n\r\n色相(Hue)：用于区分色彩的首要特征，比如红、黄、蓝等颜色\r\n纯度(Purity)：纯度用来表现色彩的鲜艳和深浅\r\n明度(Lightness)：明度是指色彩的亮度或明度\r\n\r\n十二色相环是由原色（primary hues），二次色（secondary\r\nhues）和三次色（tertiary\r\nhues）组合而成。\r\n\r\n色相环中的原色是红、黄、蓝色，彼此势均力敌，在环中形成一个等边三角形。\r\n二次色是橙、紫、绿色，处在三原色之间，形成另一个等边三角形。红橙、黄橙、黄绿、蓝绿、蓝紫和红紫六色为三次色。\r\n三次色是由原色和二次色混合而成。\r\n\r\n\r\n冷色与暖色\r\n色彩学上根据心理感受，把颜色分为 3 种色调。\r\n\r\n暖色调（红、橙、黄）\r\n冷色调（青、蓝）\r\n中性色调（紫、绿、黑、灰、白）\r\n\r\n色彩印象坐标\r\n\r\n\r\n配色印象评价\r\n\r\n\r\n\r\n\r\n象限\r\n说明\r\n常用颜色搭配\r\n\r\n\r\n\r\n\r\n1\r\n给人静态柔和的感觉\r\n通常是隐约柔和颜色之间的搭配\r\n\r\n\r\n2\r\n给人动态柔和的感觉\r\n通常是鲜亮颜色间的搭配\r\n\r\n\r\n3\r\n给人动态生硬的感觉\r\n通常是鲜亮和浑浊暗淡颜色之间的搭配\r\n\r\n\r\n4\r\n给人静态生硬的感觉\r\n通常是灰冷颜色之间的搭配\r\n\r\n\r\n\r\n在“配色印象空间”中，相距较远的颜色之间的印象会有较大的差异，而距离较近的颜色之间的印象会比较相近，也就是说颜色间的距离与印象的差异程度成正比关系。\r\n协调配色\r\n按色相一致配色\r\n\r\n\r\n色相一致\r\n\r\n主色和辅色都在同一个色相上。\r\n优点：这种配色方法往往会给人页面很一致化，容易营造出一种较为梦幻的感觉。\r\n缺点：但因较为朴素也就不容易引人注目，而且会给人一种单调的感觉。\r\n按明度一致配色\r\n明度一致的配色，即使是使用多种颜色也能让整体富有均衡的印象。\r\n\r\n\r\nsame-lightness\r\n\r\n明度即表示色彩的明亮程度。不管使用什么样的色调，只要色彩的明度相合就能表现出统一感。比起纯度以及色相，明度是让眼睛更容易感觉到变化的色彩要素。\r\n将明度统合，其意义等同于不在设计物上做出特别突显或醒目的部分。明度一致的设计，能使整体有均衡而平面的印象。\r\n蓝色和红色本来明度就偏低，而黄色原本就是明度高的颜色，正因为色彩本身即带有明度的特性，统合色彩明度的工作便格外困难。\r\n按纯度一致配色\r\n纯度，表示色彩的鲜艳程度。相比“明度”跟“色相”，纯度更容易对人的心理印象造成影响。\r\n其中，纯度越高，越是让人感到鲜艳刺激（图1）；纯度越低，越是让人感觉平静沉稳（图2）；而高低纯度混合的配色是难以统合的（图3）。\r\n\r\n\r\n颜色纯度\r\n\r\n强调配色\r\n按色相对比配色\r\n色相对比，是把不同色相的色彩组合在一起并借助颜色的不同来营造对比效果。\r\n按明度对比配色\r\n由于人的目光容易被鲜艳的色彩所吸引，所以可以使用高纯度的色彩来用作强调作品的某一部分。\r\n高纯度的色彩组合容易形成一种花哨的感觉，因此亮眼的作品需要在使用纯度高的颜色来凸显某一部分的同时压低周边元素的色彩纯度，然后还需考虑如何引导视线如何做排版。\r\n按纯度对比配色\r\n人的眼睛对明度差异的敏感度比其他任何一种对比都要高，所以明度间的对比很强烈。\r\n色彩搭配方式\r\n\r\n\r\n配色方式\r\n\r\n色相差形成的配色方式\r\n根据主色与辅色的色相差不同，可以分为以下各种类型：\r\n同色系配色\r\n色相环上相差 15 度左右。\r\n\r\n\r\n同系色配色\r\n\r\n邻近色配色\r\n色带上相邻近的颜色。\r\n\r\n\r\n邻近色配色\r\n\r\n类似色配色\r\n在色轮上90度角内相邻接的颜色。\r\n\r\n\r\n类似色\r\n\r\n中差色配色\r\n中差色对比是色相环上呈90度角的色彩组合。中差色对比相对突出，色彩对比明快，容易呈现饱和度高的色彩。但容易产生沉闷感。\r\n\r\n\r\n中差色配色\r\n\r\n对比色（互补色）配色\r\n在色相环中每一个颜色对面(180度对角)的颜色。\r\n\r\n\r\n对比色配色\r\n\r\n中性色配色\r\n用一些中性的色彩作为基调搭配，常应用在信息量大的网站，突出内容，不会受不必要的色彩干扰。这种过配色比较通用，非常经典。\r\n\r\n\r\n中性色配色\r\n\r\n多色搭配下的配色\r\n主色和其他搭配色之间的关系会更丰富，可能有类似色、中差色、对比色等搭配方式，但其中某种色彩会占主导。\r\n色调调和而形成的配色方式\r\n在纯色中加入统一的颜色，让整体的色调在视觉上达到统一。\r\n深色调和暗色调等类似色调搭配也可以形成同样的配色效果。即使出现多种色相，只要保持色调一致，画面也能呈现整体统一性。\r\n\r\n清澈的色调\r\n阴暗的色调\r\n明亮色调\r\n深暗色调\r\n雅白色调\r\n\r\n配色网站\r\n配色表 peisebiao.com\r\n其它教程\r\n\r\n红色篇：《设计师的读书笔记！带你重新全面认识色彩系列之红色篇》\r\n橙色篇：《深入浅出学配色！带你重新全面认识色彩系列之橙色篇》\r\n黄色篇：《深入浅出学配色！带你重新全面认识色彩系列之黄色篇》\r\n绿色篇：《深入浅出学配色！带你重新全面认识色彩系列之绿色篇》\r\n蓝色篇：《深入浅出学配色！带你重新全面认识色彩系列之蓝色篇》\r\n紫色篇：《深入浅出学配色！带你重新全面认识色彩系列之紫色篇》\r\n橙色进阶：《带你重新全面认识色彩系列之橙色进阶篇》\r\n蓝色+红色进阶：《超多案例！零基础学配色系列之红色+蓝色篇》\r\n\r\n参考\r\n\r\n《色彩设计原理》\r\n新手学配色，看这篇《色彩设计原理》读书笔记就够了（一）\r\n如何取得协调的配色\r\n配色不要慌！色彩搭配原理只有三条！\r\n\r\n","categories":["Develop","HTML"],"tags":["HTML","色彩搭配"]},{"title":"Color 颜色对照表","url":"/posts/2019/3QMZ3K8.html","content":"Color 颜色对照表。\r\n\r\n\r\n\r\n\r\n\r\nColor.AliceBlue\r\n\r\n\r\n240,248,255\r\n\r\n\r\nColor.LightSalmon\r\n\r\n\r\n255,160,122\r\n\r\n\r\n\r\n\r\nColor.AntiqueWhite\r\n\r\n\r\n250,235,215\r\n\r\n\r\nColor.LightSeaGreen\r\n\r\n\r\n32,178,170\r\n\r\n\r\n\r\n\r\nColor.Aqua\r\n\r\n\r\n0,255,255\r\n\r\n\r\nColor.LightSkyBlue\r\n\r\n\r\n135,206,250\r\n\r\n\r\n\r\n\r\nColor.Aquamarine\r\n\r\n\r\n127,255,212\r\n\r\n\r\nColor.LightSlateGray\r\n\r\n\r\n119,136,153\r\n\r\n\r\n\r\n\r\nColor.Azure\r\n\r\n\r\n240,255,255\r\n\r\n\r\nColor.LightSteelBlue\r\n\r\n\r\n176,196,222\r\n\r\n\r\n\r\n\r\nColor.Beige\r\n\r\n\r\n245,245,220\r\n\r\n\r\nColor.LightYellow\r\n\r\n\r\n255,255,224\r\n\r\n\r\n\r\n\r\nColor.Bisque\r\n\r\n\r\n255,228,196\r\n\r\n\r\nColor.Lime\r\n\r\n\r\n0,255,0\r\n\r\n\r\n\r\n\r\nColor.Black\r\n\r\n\r\n0,0,0\r\n\r\n\r\nColor.LimeGreen\r\n\r\n\r\n50,205,50\r\n\r\n\r\n\r\n\r\nColor.BlanchedAlmond\r\n\r\n\r\n255,255,205\r\n\r\n\r\nColor.Linen\r\n\r\n\r\n250,240,230\r\n\r\n\r\n\r\n\r\nColor.Blue\r\n\r\n\r\n0,0,255\r\n\r\n\r\nColor.Magenta\r\n\r\n\r\n255,0,255\r\n\r\n\r\n\r\n\r\nColor.BlueViolet\r\n\r\n\r\n138,43,226\r\n\r\n\r\nColor.Maroon\r\n\r\n\r\n128,0,0\r\n\r\n\r\n\r\n\r\nColor.Brown\r\n\r\n\r\n165,42,42\r\n\r\n\r\nColor.MediumAquamarine\r\n\r\n\r\n102,205,170\r\n\r\n\r\n\r\n\r\nColor.BurlyWood\r\n\r\n\r\n222,184,135\r\n\r\n\r\nColor.MediumBlue\r\n\r\n\r\n0,0,205\r\n\r\n\r\n\r\n\r\nColor.CadetBlue\r\n\r\n\r\n95,158,160\r\n\r\n\r\nColor.MediumOrchid\r\n\r\n\r\n186,85,211\r\n\r\n\r\n\r\n\r\nColor.Chartreuse\r\n\r\n\r\n127,255,0\r\n\r\n\r\nColor.MediumPurple\r\n\r\n\r\n147,112,219\r\n\r\n\r\n\r\n\r\nColor.Chocolate\r\n\r\n\r\n210,105,30\r\n\r\n\r\nColor.MediumSeaGreen\r\n\r\n\r\n60,179,113\r\n\r\n\r\n\r\n\r\nColor.Coral\r\n\r\n\r\n255,127,80\r\n\r\n\r\nColor.MediumSlateBlue\r\n\r\n\r\n123,104,238\r\n\r\n\r\n\r\n\r\nColor.CornflowerBlue\r\n\r\n\r\n100,149,237\r\n\r\n\r\nColor.MediumSpringGreen\r\n\r\n\r\n0,250,154\r\n\r\n\r\n\r\n\r\nColor.Cornsilk\r\n\r\n\r\n255,248,220\r\n\r\n\r\nColor.MediumTurquoise\r\n\r\n\r\n72,209,204\r\n\r\n\r\n\r\n\r\nColor.Crimson\r\n\r\n\r\n220,20,60\r\n\r\n\r\nColor.MediumVioletRed\r\n\r\n\r\n199,21,112\r\n\r\n\r\n\r\n\r\nColor.Cyan\r\n\r\n\r\n0,255,255\r\n\r\n\r\nColor.MidnightBlue\r\n\r\n\r\n25,25,112\r\n\r\n\r\n\r\n\r\nColor.DarkBlue\r\n\r\n\r\n0,0,139\r\n\r\n\r\nColor.MintCream\r\n\r\n\r\n245,255,250\r\n\r\n\r\n\r\n\r\nColor.DarkCyan\r\n\r\n\r\n0,139,139\r\n\r\n\r\nColor.MistyRose\r\n\r\n\r\n255,228,225\r\n\r\n\r\n\r\n\r\nColor.DarkGoldenrod\r\n\r\n\r\n184,134,11\r\n\r\n\r\nColor.Moccasin\r\n\r\n\r\n255,228,181\r\n\r\n\r\n\r\n\r\nColor.DarkGray\r\n\r\n\r\n169,169,169\r\n\r\n\r\nColor.NavajoWhite\r\n\r\n\r\n255,222,173\r\n\r\n\r\n\r\n\r\nColor.DarkGreen\r\n\r\n\r\n0,100,0\r\n\r\n\r\nColor.Navy\r\n\r\n\r\n0,0,128\r\n\r\n\r\n\r\n\r\nColor.DarkKhaki\r\n\r\n\r\n189,183,107\r\n\r\n\r\nColor.OldLace\r\n\r\n\r\n253,245,230\r\n\r\n\r\n\r\n\r\nColor.DarkMagena\r\n\r\n\r\n139,0,139\r\n\r\n\r\nColor.Olive\r\n\r\n\r\n128,128,0\r\n\r\n\r\n\r\n\r\nColor.DarkOliveGreen\r\n\r\n\r\n85,107,47\r\n\r\n\r\nColor.OliveDrab\r\n\r\n\r\n107,142,45\r\n\r\n\r\n\r\n\r\nColor.DarkOrange\r\n\r\n\r\n255,140,0\r\n\r\n\r\nColor.Orange\r\n\r\n\r\n255,165,0\r\n\r\n\r\n\r\n\r\nColor.DarkOrchid\r\n\r\n\r\n153,50,204\r\n\r\n\r\nColor.OrangeRed\r\n\r\n\r\n255,69,0\r\n\r\n\r\n\r\n\r\nColor.DarkRed\r\n\r\n\r\n139,0,0\r\n\r\n\r\nColor.Orchid\r\n\r\n\r\n218,112,214\r\n\r\n\r\n\r\n\r\nColor.DarkSalmon\r\n\r\n\r\n233,150,122\r\n\r\n\r\nColor.PaleGoldenrod\r\n\r\n\r\n238,232,170\r\n\r\n\r\n\r\n\r\nColor.DarkSeaGreen\r\n\r\n\r\n143,188,143\r\n\r\n\r\nColor.PaleGreen\r\n\r\n\r\n152,251,152\r\n\r\n\r\n\r\n\r\nColor.DarkSlateBlue\r\n\r\n\r\n72,61,139\r\n\r\n\r\nColor.PaleTurquoise\r\n\r\n\r\n175,238,238\r\n\r\n\r\n\r\n\r\nColor.DarkSlateGray\r\n\r\n\r\n40,79,79\r\n\r\n\r\nColor.PaleVioletRed\r\n\r\n\r\n219,112,147\r\n\r\n\r\n\r\n\r\nColor.DarkTurquoise\r\n\r\n\r\n0,206,209\r\n\r\n\r\nColor.PapayaWhip\r\n\r\n\r\n255,239,213\r\n\r\n\r\n\r\n\r\nColor.DarkViolet\r\n\r\n\r\n148,0,211\r\n\r\n\r\nColor.PeachPuff\r\n\r\n\r\n255,218,155\r\n\r\n\r\n\r\n\r\nColor.DeepPink\r\n\r\n\r\n255,20,147\r\n\r\n\r\nColor.Peru\r\n\r\n\r\n205,133,63\r\n\r\n\r\n\r\n\r\nColor.DeepSkyBlue\r\n\r\n\r\n0,191,255\r\n\r\n\r\nColor.Pink\r\n\r\n\r\n255,192,203\r\n\r\n\r\n\r\n\r\nColor.DimGray\r\n\r\n\r\n105,105,105\r\n\r\n\r\nColor.Plum\r\n\r\n\r\n221,160,221\r\n\r\n\r\n\r\n\r\nColor.DodgerBlue\r\n\r\n\r\n30,144,255\r\n\r\n\r\nColor.PowderBlue\r\n\r\n\r\n176,224,230\r\n\r\n\r\n\r\n\r\nColor.Firebrick\r\n\r\n\r\n178,34,34\r\n\r\n\r\nColor.Purple\r\n\r\n\r\n128,0,128\r\n\r\n\r\n\r\n\r\nColor.FloralWhite\r\n\r\n\r\n255,250,240\r\n\r\n\r\nColor.Red\r\n\r\n\r\n255,0,0\r\n\r\n\r\n\r\n\r\nColor.ForestGreen\r\n\r\n\r\n34,139,34\r\n\r\n\r\nColor.RosyBrown\r\n\r\n\r\n188,143,143\r\n\r\n\r\n\r\n\r\nColor.Fuschia\r\n\r\n\r\n255,0,255\r\n\r\n\r\nColor.RoyalBlue\r\n\r\n\r\n65,105,225\r\n\r\n\r\n\r\n\r\nColor.Gainsboro\r\n\r\n\r\n220,220,220\r\n\r\n\r\nColor.SaddleBrown\r\n\r\n\r\n139,69,19\r\n\r\n\r\n\r\n\r\nColor.GhostWhite\r\n\r\n\r\n248,248,255\r\n\r\n\r\nColor.Salmon\r\n\r\n\r\n250,128,114\r\n\r\n\r\n\r\n\r\nColor.Gold\r\n\r\n\r\n255,215,0\r\n\r\n\r\nColor.SandyBrown\r\n\r\n\r\n244,164,96\r\n\r\n\r\n\r\n\r\nColor.Goldenrod\r\n\r\n\r\n218,165,32\r\n\r\n\r\nColor.SeaGreen\r\n\r\n\r\n46,139,87\r\n\r\n\r\n\r\n\r\nColor.Gray\r\n\r\n\r\n128,128,128\r\n\r\n\r\nColor.Seashell\r\n\r\n\r\n255,245,238\r\n\r\n\r\n\r\n\r\nColor.Green\r\n\r\n\r\n0,128,0\r\n\r\n\r\nColor.Sienna\r\n\r\n\r\n160,82,45\r\n\r\n\r\n\r\n\r\nColor.GreenYellow\r\n\r\n\r\n173,255,47\r\n\r\n\r\nColor.Silver\r\n\r\n\r\n192,192,192\r\n\r\n\r\n\r\n\r\nColor.Honeydew\r\n\r\n\r\n240,255,240\r\n\r\n\r\nColor.SkyBlue\r\n\r\n\r\n135,206,235\r\n\r\n\r\n\r\n\r\nColor.HotPink\r\n\r\n\r\n255,105,180\r\n\r\n\r\nColor.SlateBlue\r\n\r\n\r\n106,90,205\r\n\r\n\r\n\r\n\r\nColor.IndianRed\r\n\r\n\r\n205,92,92\r\n\r\n\r\nColor.SlateGray\r\n\r\n\r\n112,128,144\r\n\r\n\r\n\r\n\r\nColor.Indigo\r\n\r\n\r\n75,0,130\r\n\r\n\r\nColor.Snow\r\n\r\n\r\n255,250,250\r\n\r\n\r\n\r\n\r\nColor.Ivory\r\n\r\n\r\n255,240,240\r\n\r\n\r\nColor.SpringGreen\r\n\r\n\r\n0,255,127\r\n\r\n\r\n\r\n\r\nColor.Khaki\r\n\r\n\r\n240,230,140\r\n\r\n\r\nColor.SteelBlue\r\n\r\n\r\n70,130,180\r\n\r\n\r\n\r\n\r\nColor.Lavender\r\n\r\n\r\n230,230,250\r\n\r\n\r\nColor.Tan\r\n\r\n\r\n210,180,140\r\n\r\n\r\n\r\n\r\nColor.LavenderBlush\r\n\r\n\r\n255,240,245\r\n\r\n\r\nColor.Teal\r\n\r\n\r\n0,128,128\r\n\r\n\r\n\r\n\r\nColor.LawnGreen\r\n\r\n\r\n124,252,0\r\n\r\n\r\nColor.Thistle\r\n\r\n\r\n216,191,216\r\n\r\n\r\n\r\n\r\nColor.LemonChiffon\r\n\r\n\r\n255,250,205\r\n\r\n\r\nColor.Tomato\r\n\r\n\r\n253,99,71\r\n\r\n\r\n\r\n\r\nColor.LightBlue\r\n\r\n\r\n173,216,230\r\n\r\n\r\nColor.Turquoise\r\n\r\n\r\n64,224,208\r\n\r\n\r\n\r\n\r\nColor.LightCoral\r\n\r\n\r\n240,128,128\r\n\r\n\r\nColor.Violet\r\n\r\n\r\n238,130,238\r\n\r\n\r\n\r\n\r\nColor.LightCyan\r\n\r\n\r\n224,255,255\r\n\r\n\r\nColor.Wheat\r\n\r\n\r\n245,222,179\r\n\r\n\r\n\r\n\r\nColor.LightGoldenrodYellow\r\n\r\n\r\n250,250,210\r\n\r\n\r\nColor.White\r\n\r\n\r\n255,255,255\r\n\r\n\r\n\r\n\r\nColor.LightGreen\r\n\r\n\r\n144,238,144\r\n\r\n\r\nColor.WhiteSmoke\r\n\r\n\r\n245,245,245\r\n\r\n\r\n\r\n\r\nColor.LightGray\r\n\r\n\r\n211,211,211\r\n\r\n\r\nColor.Yellow\r\n\r\n\r\n255,255,0\r\n\r\n\r\n\r\n\r\nColor.LightPink\r\n\r\n\r\n255,182,193\r\n\r\n\r\nColor.YellowGreen\r\n\r\n\r\n154,205,50\r\n\r\n\r\n\r\n\r\n","categories":["Develop","DotNET"],"tags":["C#",".NET"]},{"title":"在 Winform、WPF 中使用 Font Awesome","url":"/posts/2019/1TFVRP.html","content":"序\r\n今天在 github 上发现了一个可以在 Winform、WPF 中使用 Font Awesome\r\n的项目，本项目不需要自己安装 Font Awesome 字体，用起来很方便。\r\n\r\n项目地址：https://github.com/awesome-inc/FontAwesome.Sharp\r\n安装\r\n在包管理器中添加 nuget 安装包。\r\n\r\nInstall-Package FontAwesome.Sharp\r\n\r\n功能\r\n将 FontAwesome 图标生成图片和 Icon 图标\r\nWinform 上使用\r\n\r\n在 Winform 上可以使用下列类\r\n\r\nIconButton,\r\nIconToolStripButton,\r\nIconDropDownButton,\r\nIconMenuItem,\r\nIconPictureBox 或者\r\nIconSplitButton\r\n\r\n当然，如果你只想为 icon 生成\r\nbitmap，可以使用ToBitmap()/ToImageSource的扩展。如下：\r\n\r\nvar bitmap = IconChar.BatteryEmpty.ToBitmap(16, Color.Black); // Windows Formsvar image = IconChar.BatteryEmpty.ToImageSource(Brushes.Black, 16); // WPFvar customFontBitmap = MyCustomFont.ToBitmap(MyEnum.SomeIcon, 16, Color.Black); // Windows Forms, custom fontvar customFontImage = MyCustomFont.ToImageSource(MyEnum.SomeIcon, Brushes.Black, 16); // WPF, custom font\r\nWPF 上使用\r\n此处因为不需要，便暂时未做翻译，请直接参考：https://github.com/awesome-inc/FontAwesome.Sharp\r\n致谢\r\n\r\n本文来源于:https://github.com/awesome-inc/FontAwesome.Sharp\r\n图片来源于网络\r\n\r\n","categories":["Develop","DotNET"],"tags":["C#",".NET"]},{"title":"C# 中获取 Graphics 对象的方法","url":"/posts/2019/5JY0NS.html","content":"在做自定义控件时或者GDI+的时候经常会遇到获取Graphics实例的问题。一般有\r\n4 种获取方式。\r\n\r\n正文\r\n\r\n从Paint事件的参数中获取。\r\n窗体和许多控件都有一个Paint事件，有一个PaintEventArgs类型的参数e\r\nprivate void Form1_Paint(object sender,System.Windows.Forms.PaintEventArgs e)        &#123;           //获取Graphic对象           Graphics g = e.Graphics;         //书写绘图代码            g.DrawLine(new Point(0,0),new Point(1,1));            //释放Graphic对象占用的资源            g.Dispose();&#125;\r\n用CreateGraphics方法创建\r\n如果需要在Paint方法以外绘图，可以通过控件或窗体的CreateGraphics方法来获取Graphics对象\r\nusing(Graphics g=new Control().CreateGraphics())&#123;&#125;\r\n对Image对象调用Graphics.FromImage获取 //创建Image对象Bitmap image1 = new Bitmap(&quot;football.jpg&quot;);//窗体的绘图对象Graphics formE = e.Graphics;\r\n通过Graphics的FromHwnd函数 HandleRef NullHandleRef = new HandleRef(null, IntPtr.Zero);using (Graphics g = Graphics.FromHwnd(NullHandleRef.Handle))&#123;&#125;\r\n\r\n致谢\r\n本文转载于 https://www.bbsmax.com/A/Gkz1ony25R/\r\n","categories":["Develop","DotNET"],"tags":["C#",".NET"]},{"title":"C# 中获取 Graphics 对象的方法","url":"/posts/2020/5JY0NS.html","content":"在做自定义控件时或者GDI+的时候经常会遇到获取Graphics实例的问题。一般有\r\n4 种获取方式。\r\n\r\n正文\r\n\r\n从Paint事件的参数中获取。\r\n窗体和许多控件都有一个Paint事件，有一个PaintEventArgs类型的参数e\r\nprivate void Form1_Paint(object sender,System.Windows.Forms.PaintEventArgs e)        &#123;           //获取Graphic对象           Graphics g = e.Graphics;         //书写绘图代码            g.DrawLine(new Point(0,0),new Point(1,1));            //释放Graphic对象占用的资源            g.Dispose();&#125;\r\n用CreateGraphics方法创建\r\n如果需要在Paint方法以外绘图，可以通过控件或窗体的CreateGraphics方法来获取Graphics对象\r\nusing(Graphics g=new Control().CreateGraphics())&#123;&#125;\r\n对Image对象调用Graphics.FromImage获取 //创建Image对象Bitmap image1 = new Bitmap(&quot;football.jpg&quot;);//窗体的绘图对象Graphics formE = e.Graphics;\r\n通过Graphics的FromHwnd函数 HandleRef NullHandleRef = new HandleRef(null, IntPtr.Zero);using (Graphics g = Graphics.FromHwnd(NullHandleRef.Handle))&#123;&#125;\r\n\r\n致谢\r\n本文转载于 https://www.bbsmax.com/A/Gkz1ony25R/\r\n","categories":["Develop","DotNET"],"tags":["C#",".NET"]},{"title":"PropertyGrid 中实现动态的下拉选项","url":"/posts/2020/3GJFFVV.html","content":"在使用 PropertyGrid 控件中，有时候我们在属性的上面添加类型转换特性\r\n(TypeConverterAttribute) 来自定义下拉选项。\r\n这个时候，我们可能会有这样的要求，一个属性的改变会导致另一个属性的候选项发生改变，也就是说，我们需要为特定属性设置动态的下拉选项。\r\n\r\n此处以 StringConverter 为例。\r\npublic class RebarDiameterConverter:StringConverter&#123;    private List&lt;string&gt; _diameters = new List&lt;string&gt;() &#123; &quot;φ8&quot;,&quot;φ10&quot;,&quot;φ12&quot;, &quot;φ14&quot;, &quot;φ16&quot;, &quot;φ18&quot;, &#125;;    //true enable,false disable    public override bool GetStandardValuesSupported(ITypeDescriptorContext context)    &#123;        return true;    &#125;    public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)    &#123;        if(context!=null &amp;&amp; context.Instance is ISwRebarProperty rebar)        &#123;            _diameters = swOpenRoadsSDK.ParseSpecificationXml.Instance.GetSpecifications(rebar.FeatureName);        &#125;        return new StandardValuesCollection(_diameters.ToArray()); //编辑下拉框中的items    &#125;    //true: disable text editting.    false: enable text editting;    public override bool GetStandardValuesExclusive(ITypeDescriptorContext context)    &#123;        return true;    &#125;&#125;\r\n在 GetStandardValues 方法中，会传递下来一个 context, 而\r\ncontext.Instance\r\n就是调用该转换器的实例，所以，将它转换成相应的对象，然后利用对象里面的值来动态生成下拉选项。\r\n","categories":["Develop","DotNET"],"tags":["C#",".NET"]},{"title":"在可以调用 OLE 之前，必须将当前线程设置为单线程单元(STA)模式","url":"/posts/2020/16SCXPH.html","content":"用 C# 写了一个服务，为了能够方便调试，于是又写了一个 winform\r\n程序。当我在这个程序中打开一个文件对话框时，出现了如下错误。\r\n\r\n\r\nimg\r\n\r\n\r\n解决方案\r\n通过寻找相关资料，了解到了STA单元模式和COM对象，总的来说：winform中，很多控件是COM对象，这样的对象只能被sta模式中的线程所调用。\r\n解决办法有两种：\r\n\r\n第一种：在主方法上加上[STAThread]特性标签\r\n[STAThread]static void Main()&#123;  Application.EnableVisualStyles();  Application.SetCompatibleTextRenderingDefault(false);  Application.Run(new LogInForm());&#125;\r\n第二种：将线程的单元状态设置为单线程单元，thread.SetApartmentState(ApartmentState.STA)\r\nThread th = new Thread(()=&gt; new Form1().ShowDialog());th.SetApartmentState(ApartmentState.STA);th.Start();\r\n\r\n在代码里面，我的 Main 已经声明了 [STAThread]\r\n特性，但是依然报错，我想，可能是因为是服务的问题。最后采用了第二种方法解决了。\r\n特此记录，以免今后遗忘。\r\n致谢\r\n本文摘抄至：妄揽明月\r\n","categories":["Develop","DotNET"],"tags":["C#",".NET"]},{"title":"有价值文章汇总","url":"/posts/2022/1T9FB4F.html","content":"本文主要收集了 DotNET\r\n相关的一些有价值的网络文章，形成系统的知识网，供查询使用。\r\n\r\n内存\r\n\r\n可能会导致.NET内存泄露的8种行为\r\n\r\n效率\r\n1.C#\r\n快速高效率复制对象的方式\r\n","categories":["Develop","DotNET"],"tags":["开发","DotNET"]},{"title":"VS 中 C# 开发语法糖","url":"/posts/2021/BKEMB5.html","content":"在进行C#开发的过程中，有一些语法糖，可以提升开发体验和提高代码阅读性，特作此总结。\r\n\r\n弃用 out 值\r\n如果一个方法有多个 out 参数，当在使用时，不需要某些参数时，可以使用\r\nout _ 进行占位放弃。示例：\r\n// 定义public static bool IsRebar(Element ele,out string reason,out double diameter)&#123;    ...实现代码&#125;// 使用public static void Test()&#123;    Element ele;    // 第一个 reason 不需要，所以使用 out _ 来占位，表示弃用    If(IsRebar(ele,out _,out double diameter))    &#123;        ...    &#125;&#125;\r\n","categories":["Develop","DotNET"],"tags":["C#","开发技巧"]},{"title":"C#编写控制台程序最佳实践","url":"/posts/2023/2RY2W0D.html","content":"本文以自己的经验总结了在 C# 中编写控制台程序的最佳实践方法。\r\n\r\n在这之前，作者曾经使用过 CommandLineParser，最终选择了以下方案。\r\n程序集\r\n\r\n命令行解析\r\ndotnet/command-line-api:\r\nCommand line parsing, invocation, and rendering of terminal output.\r\n(github.com)\r\n进度条\r\nspectreconsole/spectre.console:\r\nA .NET library that makes it easier to create beautiful console\r\napplications. (github.com)\r\n\r\n实例\r\n通过上述技术，作者实现了一个具有插件功能的控制台工具，请跳转到查看效果。\r\nGalensGan/OneDo\r\n(github.com)\r\n参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\nSystem.CommandLine\r\n概述 | Microsoft Learn\r\n","categories":["Develop","DotNET"],"tags":["DotNET","Console"]},{"title":".NET Standard 项目单元测试时测试不运行","url":"/posts/2023/GDQD0X.html","content":"使用 .NET Standard 2.1\r\n编写了一个类库，运行单元测试后，在测试资源管理器中，所有的单元测试方法都显示未运行。\r\n\r\n\r\nimage-20230312143919494\r\n\r\n\r\n在测试函数处点击蓝色感叹号，选择“在测试资源管理器中显示”，左下角会提示:\r\n\"找不到所选测试。可能需要生成测试项目才能发现测试。\"\r\n\r\n\r\nimage-20230312144030008\r\n\r\n被这个问题困扰很久，google\r\n了很久，大家都提到，可能是程序无法正常运行导致的。当我准备重装\r\nMSTest.TestFramework 时，终于发现了问题所在。\r\n\r\n原来，是因为框架不支持导致的\r\n\r\n\r\n\r\nimage-20230312144608350\r\n\r\n从描述中，可以看到，它不支持 .net standard 2.1，由于通过\r\nVS\r\n自动创建的单元测试项目框架与目标库框架一致，因此导致测试项目的框架也为\r\n.net standard 2.1了。\r\n因此，只需要将框架改成 .NET Core 就可以了。\r\n\r\n","categories":["Develop","DotNET"],"tags":[".NET"]},{"title":"UzonMail(宇正群邮) 使用说明","url":"/posts/2020/2QMK677.html","content":"🥝简介\r\n\r\n\r\nuzon-mail-login-2\r\n\r\n本软件名为 “宇正群邮\r\n(UZonMail)\"，是一款开源免费的邮件群发软件。它具有非常强大的邮件正文定制能力，可快速实现\r\n\"千人千面\" 式地批量群发，使每一封邮件都让人觉得很温暖。\r\n原生多线程处理能力，极尽压榨每一核 CPU\r\n性能，让发件体验纵享丝滑，盏茶间，群发任务灰飞烟灭，独怅惘，无件可发何时休。\r\n常见的应用场景有：\r\n\r\n财务批量向员工发送每个人对应的工资条\r\n外贸批量群发营销邮件\r\n\r\n\r\n开源地址：UZonMail\r\n\r\n\r\n🍎特点\r\n\r\n\r\nimage-20240614121857800\r\n\r\n\r\n支持多个发件人同时发件\r\n可以添加多个不同的发件人，同时发件，提高发件效率。\r\n支持多个收件人批量收件\r\n可以添加多个收件人，实现批量发送\r\n支持邮件内容模板自定义\r\n模板完全可自定义，可根据需要定义自己所需的模板，并保存到模板库，实现模板的复用。\r\n模板板采用 html\r\n格式定义，程序也提供可视化界面进行编辑，对于新手和大神都很友好。\r\n支持无限变量，邮件封封不同\r\n可以在模板中引入变量，在发送的过程中，会自动将变量值替换成其真实的值进行发送，可以实现同一套模板，不同的收件人，接收的具体内容不同。\r\n多线程并发发送，日发可达 10 万+\r\n每个发件人采用单独的线程进行发送，当一个发件箱出问题之后并不会使发件停止，会由其它发件的所在线程继续发件。\r\n若有足够多的发件箱，日发 10 万不是问题。\r\n失败自动重发\r\n当有多个发件箱时，若 A 发件箱发件失败后，会转由 B\r\n发件箱继续进行发送。\r\n如果仅有一个发件箱，当发件失败后，会在其它邮件发送完成后，再次发送，可重发次数最大为5次。\r\n支持失败手动重发\r\n所有的发送过程都有记录，对于未发送成功的邮件，可以在发送任务完成后，手动进行重发。\r\n支持发件箱每日发件总量限制\r\n支持抄送、密送\r\n支持多封邮件抄送到特定邮箱或者不同邮件抄送到不同的邮箱。\r\n\r\n🍇环境要求\r\n\r\nWindows 7 及以上\r\n.NET Framework 4.6.2 及以上，下载地址：dotnet-framework\r\nWebview2 环境，下载地址：microsoft-edge/webview2/\r\nASP.NET Core 环境，下载地址：runtime-aspnetcore-8.0.6-windows-hosting-bundle-installer\r\n\r\n🌱Windows 安装使用\r\n环境安装\r\nWin7:\r\n\r\n.NET Framework 4.6.2\r\n及以上（这个一般都有，可以不用安装），下载地址：dotnet-framework\r\nWebview2 环境，下载地址：microsoft-edge/webview2/-腾讯微云\r\nASP.NET Core 环境，下载地址：runtime-aspnetcore-8.0.6-windows-hosting-bundle-installer\r\n\r\n\r\n温馨提示：\r\nwin7 与 win10 使用的 webview2 版本不一致\r\n\r\nWin10 及以上：\r\n\r\n.NET Framework 4.6.2 及以上，下载地址：dotnet-framework\r\nWebview2 环境，下载地址：microsoft-edge/webview2/\r\nASP.NET Core 环境，下载地址：runtime-aspnetcore-8.0.6-windows-hosting-bundle-installer\r\n\r\n网页版：\r\n\r\nASP.NET Core 环境，下载地址：runtime-aspnetcore-8.0.6-windows-hosting-bundle-installer\r\n\r\n直接下载安装包\r\nUZonMail-gitee\r\n或者加 QQ 群 877458612 在群文件下载 (更新速度更快)\r\n自己手动编译\r\n\r\n克隆仓库，切换到 master 分支；\r\n使用命令行进入到项目根目录，执行 ./build.ps1\r\n开始编译，编译结果在 build 目录中。\r\n编译成功截图：\r\n\r\n\r\nimage-20240616124656131\r\n\r\n\r\n\r\n手动编译时，会自动检测环境，若没有相关环境，请根据提示进行安装。\r\n\r\n使用\r\n本节只讲述通过安装包的使用方式。\r\n\r\n下载安装包\r\n安装对应方式所需要的环境\r\n\r\n直接使用：\r\n解压后，直接打开文件 UzonMailDesktop.exe\r\n即可开始使用\r\n网页端使用：\r\n\r\n首先启动服务：打开 UzonMailDesktop.exe 或\r\nservice/UZonMailService.exe 文件\r\n在浏览器中输入地址：http://localhost:22345\r\n打开网页\r\n\r\n🍒发件步骤\r\n\r\n添加发件箱（已添加请忽略）\r\n添加收件箱（已添加请忽略）\r\n导入所需模板（已添加请忽略）\r\n打开【新建发件】，输入主题 --&gt; 选择收件人 --&gt; 选择模板 --&gt;\r\n选择数据 --&gt;预览确认发件数量和模板正确性 --&gt; 退出预览\r\n--&gt;点击【发送】\r\n如果提示发送失败，转到【发件历史】，进行重发\r\n\r\n邮件经常进发件箱怎么办\r\n可以使用 Newsletters spam test\r\nby mail-tester.com 检查待发邮件的内容。\r\n\r\n\r\nimage-20220428140629151\r\n\r\n🥑功能介绍\r\n功能概览\r\n\r\n\r\nimage-20240614121857800\r\n\r\n软件主要由以下功能模块组成：\r\n\r\n首页\r\n数据统计展示\r\n邮箱管理\r\n管理发件箱、收件箱\r\n模板管理\r\n管理正文模板\r\n发件管理\r\n新建发件和历史发件查询\r\n系统设置\r\n\r\n用户管理\r\n增加其它使用用户\r\n基础设置\r\n发件相关的全局设置\r\n代理管理\r\n配置发件代理\r\n\r\n支持作者\r\n赞助页面\r\n使用说明\r\n帮助页\r\n\r\n下面开始按模块进行详细介绍。\r\n登陆界面\r\n\r\n\r\nuzon-mail-login-2\r\n\r\n默认用户名和密码为：admin/admin1234\r\n首页\r\n\r\n\r\nimage-20240614231957130\r\n\r\n首页主要展示的内容有：\r\n\r\n发件箱数量直方图\r\n收件箱数量直方图\r\n每月发件量折线图\r\n\r\n系统设置\r\n用户管理\r\n\r\n\r\nimage-20240612122713293\r\n\r\n系统默认的用户名为 admin，默认密码为\r\nadmin1234，这是一个管理员账号，该账号具有【管理用户】的权限。\r\n【用户管理】模块用于增加不同的用户。桌面版本的多用户功能仅限本机使用，若要多人同时使用，则需要使用服务器版本。\r\n服务器版本可联系作者获取。\r\n新增用户：\r\n\r\n\r\nimage-20240612123329057\r\n\r\n单击左上角的新增，即可新增用户。\r\n用户新增完成后，可对用户进行操作，比如重置密码，删除等\r\n重置后的密码为：uzonmail123，在重置时会有提示。\r\n\r\n\r\nimage-20240612123429178\r\n\r\n修改密码和头像：\r\n可以通过右上角的个人信息界面对头像和密码进行修改。\r\n\r\n\r\nimage-20240612125131168\r\n\r\n基础设置\r\n基础设置中，主要设置全局的发件间隔，最大发件量等。\r\n\r\n\r\nimage-20240612125859579\r\n\r\n\r\n单个邮箱每日最大发件量\r\n控制单个邮箱每日发件的总数，避免因发件数量超过每个邮件服务提供商规定的每日发件量，从而导致发件失败。\r\n为 0 时表示不限制\r\n单个发件箱最小(最大)发件间隔\r\n单位：秒\r\n为了避免因频繁发送邮件而导致被服务器认为是垃圾邮箱，所以，发送两封邮件之间需要有一定的时间间隔，为了使得发送时间间隔具有不规律性，用间隔范围来进行控制：\r\n实际发件间隔值 = 最小值 + （0，1）之间的随机数*（最大值-最小值）\r\n最大值小于等于最小值时，表示不限制\r\n合并发件最大数量\r\n当同时向多个收件箱发送相同内容时，可以将收件箱合并成一封邮件发送，这个参数即控制合并的最大数量。\r\n每个邮件服务商允许的最大数量不一样，最大数包含抄送和密送的数量\r\n为 0 时，表示不合并\r\n\r\n代理管理\r\n\r\n\r\nimage-20240612131312091\r\n\r\n代理管理模块主要针对使用国外邮箱的情况，允许针对某一类或者某个发件箱指定代理。\r\n该功能一般用于服务器部署的情况，本机使用时，可以打开全局代理。\r\n新增代理：\r\n\r\n\r\nimage-20240612130111084\r\n\r\n新增代理参数说明：\r\n\r\n名称\r\n必填项。在发件箱界面，可通过名称选择指定代理\r\n代理地址\r\n代理的地址、用户名和密码。格式为：协议:\\\\username:password@host，示例：\r\n\r\n完整格式：http:\\\\admin:admin1234@127.0.0.1:7890\r\n无密码格式: http:\\\\127.0.0.1:7890\r\n其它协议：socket5:\\\\127.0.0.1:7890\r\n\r\n目前支持的协议有：http、https、socks4、socks4a、socket5\r\n匹配规则\r\n若发件箱没有指定代理，则会从代理管理的列表中根据规则自动匹配，若匹配到，则使用。\r\n该规则的语法为正则表达式\r\n.* 表示所有的邮件都匹配\r\n优先级\r\n规则匹配的优先级\r\n是否共享\r\n共享后，系统内所有人都可使用这个代理\r\n\r\n\r\n代理安全提示\r\n代理是明文存储在服务器中的，因此管理员可以查看代理的信息，可能会造成代理泄露风险，请谨慎添加个人代理\r\n\r\n邮箱管理\r\n发件箱\r\n【发件箱】模块用于管理发件人信息。下面列出在使用中需要注意的功能进行说明：\r\n组管理：\r\n增加发件箱时，必须先建立发件组。\r\n\r\n\r\nimage-20240612131552355\r\n\r\n在 \"发件箱\" 上右键，可新增发件组。\r\n\r\n\r\nimage-20240612131711338\r\n\r\n新增时，\"序号\" 表示发件组的排序号，仅用于排序。\r\n当新建组完成后，可以在组名上右键，对组进行管理\r\n\r\n\r\nimage-20240612131916319\r\n\r\n新增发件箱：\r\n\r\n\r\nimage-20240612132056895\r\n\r\n本软件采用的是 SMTP 协议发件，因此发件时，需要将自己的邮箱开通 SMTP\r\n服务，可自行查阅资料。以下对一些重要参数说明：\r\n\r\n发件人名称\r\n若有，当发给对方后，不显示邮箱，而是显示名称\r\nsmtp 密码\r\n发件采用的 SMTP\r\n服务器，所以，它的密码并不是邮箱的密码，而是登陆邮箱后，自己申请的 SMTP\r\n密码。\r\n比如，163邮箱 SMTP\r\n密码获取方式如下：https://www.yisu.com/zixun/97973.html\r\nsmtp 地址\r\nsmtp 的地址，每种类型的地址不一样，可百度查找\r\nsmtp 端口\r\n该端口与是否【启用 SSL】有关，默认为 25，若启动 SSL，一般为\r\n465，需要自动查找确认。\r\n启用 SSL\r\n是在发件时，采用 SSL 加密，打开这个可以提升发件的安全性。\r\n代理\r\n若有需要，可以为其指定代理，可用代理候选项在【代理管理】中定义。\r\n\r\n\r\n密码安全提示\r\n服务器没有直接存储 smtp\r\n密码，而是存储了通过密钥加密后的密文，密钥由前端生成，当有需要时，由前端传递给后端解密。\r\n因此，即使数据库泄露了，也不会造成 smtp 的密码被盗的问题\r\n\r\n从EXCEL导入：\r\n通过【导入】功能可批量从 Excel 中导入发件箱。\r\n可以通过【模板】按钮下载导入模板。\r\n在使用批量添加发件人功能时，Excel 表中第一行为表头，必须包含\r\nsmtp邮箱、smtp密码、smtp地址、smtp端口\r\n列。\r\n\r\n\r\nimage-20240614123302248\r\n\r\n收件箱\r\n\r\n\r\nimage-20240614124814856\r\n\r\n该模块主要用于对收件箱的分组和管理，使用方式、注意要点与发件人一致。\r\n收件箱只需要姓名和邮箱即可，姓名是可选的。\r\n模板管理\r\n\r\n\r\nimage-20240614125056768\r\n\r\n在【正文模板】用于管理用户下的所有模板，它是 html 格式。\r\n新增模板\r\n使用两种方式进行添加：\r\n\r\n导入 HTML\r\n先在外面用 html\r\n定义好模板，然后通过上述中的【导入模板】功能将定义的模板导入到系统。对于自定义的\r\nhtml 模板，要求其中的 css 必须为行内 css。可以通过\r\nhttp://automattic.github.io/juice/ 自动将 html 文件中 css 转换成行内的\r\ncss。\r\n直接编辑\r\n通过单击【新增】按钮新增模板。\r\n\r\n\r\nimage-20240614125417120\r\n\r\n\r\n模板编辑\r\n通过单击模板名称或者在模板上右键，然后选择【编译】跳转到模板修改界面。\r\n\r\n\r\nimage-20240614125609679\r\n\r\n模板变量\r\n在模板的编写过程中，可以使用双花括号（&#123;&#123;变量名&#125;&#125;）来标记为变量，在发件的过程中，程序会在数据中查找该变量，如果查找到，就会使用实际的数据将变量替换掉。\r\n变量定义的格式是为：。\r\n\r\n在发件中，模板也可以因发件人而异，需要在数据中增加 templateId\r\n列来覆盖通用的模板。具体参考发件篇。\r\n\r\n发件管理\r\n新建发件\r\n\r\n\r\nimage-20240614125845479\r\n\r\n新建发件用于添加发件任务，通过不同的参数组合，它可以实现以下功能：\r\n\r\n一对一发件\r\n一个发件箱，一个收件箱\r\n一对多发件\r\n一个发件箱，多个收件箱\r\n多对多发件\r\n多个发件箱，多个收件箱\r\n主题变化、正文变化发件\r\n同时支持主题和正文根据收件人不同而变化\r\n\r\n主题\r\n发件的主题是必须的，主有两个作用：一是为邮件的主题，二是同一次发件将会归到一个发件历史记录中，该主题为历史记录组的名称。\r\n多个主题使用英文分号（;）或者换行进行分隔。\r\n\r\n\r\nimage-20240614130827129\r\n\r\n若有多个主题，系统在发件时，会随机使用一个主题（若在数据中指定了主题，则会固定使用数据的主题）。\r\n主题也支持变量声明，比如：-工资明细，日期\r\n即为定义的变量，在发送邮件时，它将被替换成 Excel 表中的实际数据。\r\n模板\r\n模板相当于是正文的一个草稿，它可以让你快速发送正文，而不需要每次都在正文处输入。\r\n\r\n\r\nimage-20240614131034812\r\n\r\n可以选择多个模板。若有多个模板时，系统将随机选择一个模板来发件（若在数据中指定了模板，则会固定使用数据中的模板）\r\n正文\r\n\r\n\r\nimage-20240614131326894\r\n\r\n\r\n\r\nimage-20240614225842011\r\n\r\n软件支持用户手动输入正文。\r\n若用户指定了正文，则不会使用模板作为邮件正文。\r\n正文的格式与模板一样，同样支持变量。\r\n发件人\r\n\r\n\r\nimage-20240614131606189\r\n\r\n单击发件人右侧的 + 号，选择发件人。\r\n发件人允许有多个，若有多个发件人，发件时，将会把邮件随机给其中一个发件人发件。\r\n在一次任务中，一封邮件只会被其中一个发件箱成功发送，不会多次发送。\r\n收件人\r\n\r\n\r\nimage-20240614131851665\r\n\r\n单击收件人右侧的 + 号，选择收件人。\r\n单次发件任务中，允许添加多个收件人，每个收件都会收到一款邮件。\r\n抄送人\r\n若选择抄送人，每一封邮件都会抄送到每一个抄送人处。\r\n附件\r\n\r\n\r\nimage-20240614214517919\r\n\r\n若邮件中需要添加附件，可以在此添加附件。\r\n允许添加多个附件，但是请注意，每封邮件都会携带相同的附件。\r\n数据\r\n支持数据发件功能是该软件的灵魂。通过导入数据，可以实现一次发件中，为不同的收件箱发送不同的内容。\r\n当将鼠标聚焦在数据栏，右侧会出现下载模板的图标，单击该图标即可下载模板。\r\n\r\n\r\nimage-20240614215520531\r\n\r\n数据格式大致如下：\r\n\r\n\r\nimage-20240614220243117\r\n\r\n数据的效果：\r\n模板内容:\r\n\r\n\r\nimage-20240614222544153\r\n\r\n模板赋予数据后的正文预览：\r\n\r\n\r\nimage-20240614222617857\r\n\r\n数据的作用：\r\n\r\n为模板提供变量\r\n快速实现精准的批量发送\r\n\r\n数据中系统保留变量：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n变量名\r\n必须\r\n描述\r\n\r\n\r\n\r\n\r\ninbox\r\n是\r\n指定收件邮箱。该字段必须存在，程序依靠该变量进行发件匹配。若为空，则该行数据无效。\r\n\r\n\r\ninboxName\r\n否\r\n设置收件人名称。\r\n\r\n\r\nsubject\r\n否\r\n指定主题。若指定，则会忽略界面中输入的主题。\r\n\r\n\r\noutbox\r\n否\r\n指定发件箱。若不指定，则使用用户在界面中选择的发件箱。该发件箱必须是在【邮箱管理/发件箱】中添加的邮箱地址。其它邮箱则视为无效。\r\n\r\n\r\noutboxName\r\n否\r\n设置发件箱名称。若不指定，则使用发件箱管理中的名称。\r\n\r\n\r\ncc\r\n否\r\n指定抄送人。多个抄送人使用逗号分隔。\r\n\r\n\r\ntemplateId\r\n否\r\n指定邮件的模板 Id。该模板 Id\r\n可在模板管理中查看，是一个数字。若不指定，则从用户选择的模板中随机取一个使用。\r\n\r\n\r\ntemplateName\r\n否\r\n指定邮件的模板名称。该名称可在模板管理中查看。templateName\r\n的优先级低于 templateId。当两者同时指定时，以 templateId\r\n为主。若不指定，则从用户选择的模板中随机取一个使用。\r\n\r\n\r\nbody\r\n否\r\n指定邮件的正文内容。该优先级大于 templateId 和 templateName。\r\n\r\n\r\n\r\n数据的优先级：\r\n\r\n主题\r\n【Excel数据/subject】 &gt; 【界面/主题】\r\n正文\r\n【Excel数据/body】 &gt; 【Excel数据/templateId】 &gt;\r\n【Excel数据/templateName】 &gt; 【界面/正文】 &gt;【 界面/模板\r\n】\r\n发件人\r\n【Excel数据/outbox 】&gt;【 界面/发件人】\r\n收件人\r\n【Excel数据/inbox 】&gt; 【界面/收件人】\r\n抄送人\r\n【Excel数据/cc】 &gt; 【界面/抄送人】\r\n附件\r\n附件目前无法通过数据指定\r\n\r\n发件历史\r\n发件历史显示历次所发的所有邮件记录，一次发送任务为一条历史。\r\n单击 ID 或者右键【详细】可查看具体发件项。\r\n\r\n\r\nimage-20240614225346191\r\n\r\n发件明细：\r\n\r\n\r\nimage-20240614231145776\r\n\r\n🪺技术栈\r\n本系统采用前后端分离的模式进行开发。\r\n前端：\r\ntypescript+vue3+quasar\r\n后端：\r\nC# + WPF +ASP.NET Core+webview2\r\n使用 ASP.NET Core 实现服务端，桌面端使用 WPF 开发\r\n🍄服务器部署\r\n简易版\r\n\r\n安装 ASP.NET Core 环境，下载地址：runtime-aspnetcore-8.0.6-windows-hosting-bundle-installer\r\n启动 service/UZonMailService.exe\r\n\r\n至此，即可通过 http://you-ip:22345 进行访问了\r\n前后端分离部署\r\n到这一步，我相信您已经具备专业的知识，可以自己处理安装，此处只简述下前后端各部分内容：\r\n\r\n后端位于 service 目录\r\n前端位于 service/wwwroot 目录\r\n\r\n您可以配置 nginx 进行反向代理，配置负载均衡\r\n前后端配置说明\r\n前端的配置位于 service/wwwroot/app.config.ts\r\n文件中，若是对外提供服务，则需要修改后端接口地址，即\r\nbaseUrl：\r\nexport default &#123;  // 默认配置  default: &#123;    baseUrl: &#x27;http://localhost:22345&#x27;,    api: &#x27;/api/v1&#x27;,    signalRHub: &#x27;/hubs/uzonMailHub&#x27;  &#125;,  // 生产配置  prod: &#123;&#125;,  // 开发配置  dev: &#123;&#125;&#125; as Record&lt;&#x27;default&#x27; | &#x27;prod&#x27; | &#x27;dev&#x27;, any&gt;\r\n后端的配置位于\r\nservice/wwwroot/appsettings.json，可以在这里配置：\r\n\r\n日志\r\n授权密钥\r\n系统参数\r\n接口 Http 参数\r\nWebsocket 参数\r\n数据库参数\r\n初始用户参数\r\n跨域\r\n文件存储\r\n定时任务\r\n\r\n请查看配置文件进行理解。\r\n🌵反馈与建议\r\n如果你在使用中发现了 bug,\r\n或者对该软件有任何建议，都欢迎联系我，让我们将这款软件一起变得更优秀吧！\r\nbug 反馈优先选择Github\r\nIssues，这样我能第一时间知道。\r\n如果有紧急问题，请通过邮件联系。\r\nQQ 和 QQ 群会不定时查看，所以不会很及时。\r\n🌶️联系方式\r\nQQ群：877458612\r\n邮箱：260827400@qq.com\r\nGitHub：GalensGan/UZonMail\r\n(github.com)\r\n个人主页：https://uyoufu.uzoncloud.com\r\n🍉致谢名单\r\n感谢老铁们对该软件的肯定，感谢大家的支持与鼓励！\r\n感谢 QQ 用户 来了来了、Me 协助管理 QQ\r\n群。\r\n感谢以下用户的赞助（按先后时间排序）：\r\n磊、鹏\r\n","categories":["Develop","MyIdeas"],"tags":["UzonMail","uyoufu"]},{"title":"developer-lazy-tool","url":"/posts/2021/3NEM1KV.html","content":"简介\r\n该工具出现的原因是这样的：\r\n每次发布前端版本到服务器，都需要经过编译，然后打开远程桌面，拷贝更新的文件到服务器这一过程。\r\n这一过程，虽然简单，但是一通操作下来，挺费时间的，有时间，复制还容易出错。\r\n所以，我就想，要是可以一句命令行来实现就好了~\r\n于是，develop-lazy-tool 就这样诞生了。\r\n\r\n安装\r\n手动\r\n下载安装包后，在安装包根目录打开命令行，运行 dlt install\r\n安装\r\nscoop\r\nscoop bucket add my-bucket https://gitee.com/noctiflorous/galens-bucket.gitscoop install developer-lazy-tool\r\n卸载\r\n手动\r\ndlt uninstall\r\n然后删除安装目录即可。\r\n定位\r\n不重复造轮子，只提供一个聚合方式，使得可以用一条命令完成所有任务。\r\n程序目录\r\n\r\ndata 存放用户数据\r\nconfig 存放系统配置\r\nsystem\r\n系统除配置外的文件\r\nscript 所有脚本\r\n\r\n功能\r\n安装(install)\r\n\r\n将程序添加到用户变量中\r\n\r\n卸载(uninstall)\r\n\r\n从用户变量中移除本程序\r\n提示删除安装目录\r\n\r\n打开配置(config)\r\n\r\n用户配置(--user || -u)\r\n系统配置(--system || -s)\r\n打开脚本目录(--scriptdir)\r\n打开安装目录(--setupdir)\r\n\r\nFTP上传(ftp)\r\n参数说明：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n参数名\r\n作用\r\n可选\r\n默认\r\n\r\n\r\n\r\n\r\n--name || -n\r\n指定后，上传 name 相应设置中的文件，不区分大小写。\r\n是\r\n是\r\n\r\n\r\n\r\n配置说明：\r\n&quot;ftps&quot;: [    &#123;      &quot;name&quot;: &quot;front-dist&quot;,      &quot;host&quot;: &quot;192.168.23.11&quot;,      &quot;port&quot;: 21,      &quot;username&quot;: &quot;test&quot;,      &quot;password&quot;: &quot;whfy8888&quot;,      &quot;localPath&quot;: &quot;E:\\\\galensShare\\\\Develop\\\\swToolsFrontEnd\\\\dist\\\\&quot;,      &quot;remotePath&quot;: &quot;/&quot;    &#125;  ]\r\n执行脚本(es)\r\n动词说明：\r\nes 是 execute script\r\n的缩写，该动词可以省略。假设配置中有名为\r\nzip-Dlt，则完整命令行：\r\ndlt es --name zip-Dlt\r\n简化的命令行：\r\ndlt zip-Dlt\r\n参数说明：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n参数名\r\n作用\r\n可选\r\n默认\r\n\r\n\r\n\r\n\r\n--name || -n\r\n指定后，执行 name 相应配置中的脚本，不区分大小写。\r\n否\r\n是\r\n\r\n\r\n\r\n配置说明：\r\n执行根目录默认在 script 目录，暂不支持修改.\r\n&quot;scripts&quot;: [    // 可以直接运行命令    // 使用 7z 打包 developer-lazy-tool    &#123;      &quot;name&quot;: &quot;zip-Dlt&quot;,      &quot;fileName&quot;: &quot;7z&quot;,      &quot;arguments&quot;: &quot;a -t7z E:/DeveloperLazyTool/bin/Release/developer-lazy-tool.7z E:/DeveloperLazyTool/bin/Release/*&quot;,      &quot;successFlag&quot;: &quot;Everything is Ok&quot;    &#125;,    // 也可以运行脚本文件    &#123;      &quot;name&quot;: &quot;cd-backend&quot;,      &quot;fileName&quot;: &quot;cd-backend.ahk&quot;,    &#125;      ],\r\n列出配置(list)\r\n参数说明：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n参数名\r\n作用\r\n可选\r\n默认\r\n\r\n\r\n\r\n\r\n--name || -n\r\n获取指定名称的配置，比如 dlt list scripts\r\n否\r\n是\r\n\r\n\r\n\r\n聚合\r\n聚合功能要求每项有 name\r\n属性，这样，才能给管道中每次成果命名，方便后面的管道使用。如果不设置\r\nname，则命名为空，不能指定参数名来引用。\r\nToDo\r\n\r\n安装 install\r\n卸载 uninstall\r\n打开配置文件\r\nftp上传 ftp\r\n执行脚本 es\r\n聚合 aggregate\r\n更新 update 更新自己\r\n\r\n","categories":["Develop","MyIdeas"]},{"title":"RESTful API 规范","url":"/posts/2020/K6BTSD.html","content":"HTTP状态码：\r\n摘抄至：\r\nhttp://www.ruanyifeng.com/blog/2014/05/restful_api.html\r\n","categories":["Develop","Web"],"tags":["Web","RESTful"]},{"title":"最全最详细 http 状态码介绍","url":"/posts/2020/25EQ87B.html","content":"HTTP 响应状态代码指示特定 HTTP\r\n请求是否已成功完成。响应分为五类：信息响应(100–199)，成功响应(200–299)，重定向(300–399)，客户端错误(400–499)和服务器错误\r\n(500–599)。状态代码由 section 10 of RFC\r\n2616定义\r\n\r\n信息响应\r\n\r\n100 Continue\r\n这个临时响应表明，迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它。\r\n101 Switching Protocol\r\n该代码是响应客户端的 Upgrade\r\n标头发送的，并且指示服务器也正在切换的协议。\r\n102 Processing\r\n(WebDAV)\r\n此代码表示服务器已收到并正在处理该请求，但没有响应可用。\r\n103 Early Hints\r\n此状态代码主要用于与Link\r\n链接头一起使用，以允许用户代理在服务器仍在准备响应时开始预加载资源。\r\n\r\n成功响应\r\n\r\n200 OK\r\n请求成功。成功的含义取决于HTTP方法：\r\n\r\nGET：资源已被提取并在消息正文中传输。\r\nHEAD：实体标头位于消息正文中。\r\nPOST：描述动作结果的资源在消息体中传输。\r\nTRACE：消息正文包含服务器收到的请求消息\r\n\r\n201 Created\r\n该请求已成功，并因此创建了一个新的资源。这通常是在POST请求，或是某些PUT请求之后返回的响应。\r\n202 Accepted\r\n请求已经接收到，但还未响应，没有结果。意味着不会有一个异步的响应去表明当前请求的结果，预期另外的进程和服务去处理请求，或者批处理。\r\n203 Non-Authoritative Information\r\n服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200\r\nOK的情况下才是合适的。\r\n204 No Content\r\n服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。\r\n205 Reset Content\r\n服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。\r\n206 Partial Content\r\n服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的\r\nHTTP\r\n下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。该请求必须包含\r\nRange 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range\r\n来作为请求条件。\r\n207 Multi-Status\r\n(WebDAV)\r\n由WebDAV(RFC\r\n2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。\r\n208 Already Reported\r\n(WebDAV)\r\n在 DAV 里面使用: propstat\r\n响应元素以避免重复枚举多个绑定的内部成员到同一个集合。\r\n226 IM Used\r\n(HTTP Delta\r\nencoding)\r\n服务器已经完成了对资源的 GET\r\n请求，并且响应是对当前实例应用的一个或多个实例操作结果的表示。\r\n\r\n重定向\r\n\r\n300 Multiple Choice\r\n被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。\r\n301 Moved Permanently\r\n被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个\r\nURI\r\n之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。\r\n302 Found\r\n请求的资源现在临时从不同的 URI\r\n响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。\r\n303 See Other\r\n对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET\r\n的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。\r\n304 Not Modified\r\n如果客户端发送了一个带条件的 GET\r\n请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304\r\n响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。\r\n305 Use Proxy\r\n被请求的资源必须通过指定的代理才能被访问。Location\r\n域中将给出指定的代理所在的 URI\r\n信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。\r\n306 unused\r\n在最新版的规范中，306 状态码已经不再被使用。\r\n307 Temporary Redirect\r\n请求的资源现在临时从不同的URI\r\n响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。\r\n308 Permanent Redirect\r\n这意味着资源现在永久位于由 Location: HTTP Response\r\n标头指定的另一个 URI。 这与 301 Moved Permanently HTTP\r\n响应代码具有相同的语义，但用户代理不能更改所使用的 HTTP\r\n方法：如果在第一个请求中使用 POST，则必须在第二个请求中使用\r\nPOST。\r\n\r\n客户端响应\r\n\r\n400 Bad Request\r\n1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。\r\n2、请求参数有误。\r\n401 Unauthorized\r\n当前请求需要用户验证。该响应必须包含一个适用于被请求资源的\r\nWWW-Authenticate\r\n信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization\r\n头信息的请求。如果当前请求已经包含了 Authorization\r\n证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。\r\n402 Payment Required\r\n此响应码保留以便将来使用，创造此响应码的最初目的是用于数字支付系统，然而现在并未使用。\r\n403 Forbidden\r\n服务器已经理解请求，但是拒绝执行它。与 401\r\n响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个\r\nHEAD\r\n请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个\r\n404 响应，假如它不希望让客户端获得任何信息。\r\n404 Not Found\r\n请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。\r\n405 Method Not Allowed\r\n请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow\r\n头信息用以表示出当前资源能够接受的请求方法的列表。 鉴于 PUT，DELETE\r\n方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。\r\n406 Not Acceptable\r\n请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。\r\n407 Proxy Authentication Required\r\n与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个\r\nProxy-Authenticate 用以进行身份询问。客户端可以返回一个\r\nProxy-Authorization 信息头用以验证。\r\n408 Request Timeout\r\n请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。\r\n409 Conflict\r\n由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。\r\n410 Gone\r\n被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用\r\n404 状态码。除非额外说明，否则这个响应是可缓存的。\r\n411 Length Required\r\n服务器拒绝在没有定义 Content-Length\r\n头的情况下接受请求。在添加了表明请求消息体长度的有效\r\nContent-Length 头之后，客户端可以再次提交该请求。\r\n412 Precondition Failed\r\n服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。\r\n413 Payload Too Large\r\n服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。如果这个状况是临时的，服务器应当返回一个\r\nRetry-After\r\n的响应头，以告知客户端可以在多少时间以后重新尝试。\r\n414 URI Too Long\r\n请求的URI\r\n长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括：本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query\r\nString）过长。\r\n415 Unsupported Media Type\r\n对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。\r\n416 Range Not Satisfiable\r\n如果请求中包含了 Range 请求头，并且 Range\r\n中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义\r\nIf-Range 请求头，那么服务器就应当返回416状态码。\r\n417 Expectation Failed\r\n此响应代码意味着服务器无法满足 Expect\r\n请求标头字段指示的期望值。\r\n418 I'm a teapot\r\n服务器拒绝尝试用 “茶壶冲泡咖啡”。\r\n421 Misdirected Request\r\n该请求针对的是无法产生响应的服务器。\r\n这可以由服务器发送，该服务器未配置为针对包含在请求 URI\r\n中的方案和权限的组合产生响应。\r\n422 Unprocessable Entity\r\n(WebDAV)\r\n请求格式良好，但由于语义错误而无法遵循。\r\n423 Locked\r\n(WebDAV)\r\n正在访问的资源被锁定。\r\n424 Failed Dependency\r\n(WebDAV)\r\n由于先前的请求失败，所以此次请求失败。\r\n425 Too Early\r\n服务器不愿意冒着风险去处理可能重播的请求。\r\n\r\n426 Upgrade Required\r\n服务器拒绝使用当前协议执行请求，但可能在客户机升级到其他协议后愿意这样做。\r\n服务器在 426 响应中发送 Upgrade\r\n头以指示所需的协议。\r\n428 Precondition Required\r\n原始服务器要求该请求是有条件的。\r\n旨在防止“丢失更新”问题，即客户端获取资源状态，修改该状态并将其返回服务器，同时第三方修改服务器上的状态，从而导致冲突。\r\n429 Too Many Requests\r\n用户在给定的时间内发送了太多请求（“限制请求速率”）。\r\n431 Request Header Fields Too Large\r\n服务器不愿意处理请求，因为它的 请求头字段太大（ Request Header Fields\r\nToo Large）。 请求可以在减小请求头字段的大小后重新提交。\r\n451 Unavailable For Legal Reasons\r\n用户请求非法资源，例如：由政府审查的网页。\r\n\r\n服务端响应\r\n\r\n500 Internal Server Error\r\n服务器遇到了不知道如何处理的情况。\r\n501 Not Implemented\r\n此请求方法不被服务器支持且无法被处理。只有GET和HEAD是要求服务器支持的，它们必定不会返回此错误代码。\r\n502 Bad Gateway\r\n此错误响应表明服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应。\r\n503 Service Unavailable\r\n服务器没有准备好处理请求。 常见原因是服务器因维护或重载而停机。\r\n请注意，与此响应一起，应发送解释问题的用户友好页面。\r\n这个响应应该用于临时条件和\r\nRetry-After：如果可能的话，HTTP头应该包含恢复服务之前的估计时间。\r\n网站管理员还必须注意与此响应一起发送的与缓存相关的标头，因为这些临时条件响应通常不应被缓存。\r\n504 Gateway Timeout\r\n当服务器作为网关，不能及时得到响应时返回此错误代码。\r\n505 HTTP Version Not Supported\r\n服务器不支持请求中所使用的HTTP协议版本。\r\n506 Variant Also Negotiates\r\n服务器有一个内部配置错误：对请求的透明内容协商导致循环引用。\r\n507 Insufficient Storage\r\n服务器有内部配置错误：所选的变体资源被配置为参与透明内容协商本身，因此不是协商过程中的适当端点。\r\n508 Loop Detected\r\n(WebDAV)\r\n服务器在处理请求时检测到无限循环。\r\n510 Not Extended\r\n客户端需要对请求进一步扩展，服务器才能实现它。服务器会回复客户端发出扩展请求所需的所有信息。\r\n511 Network Authentication Required\r\n511 状态码指示客户端需要进行身份验证才能获得网络访问权限。\r\n\r\n浏览器兼容性\r\nUpdate\r\ncompatibility data on GitHub\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nDesktop\r\nMobile\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nChrome\r\nEdge\r\nFirefox\r\nInternet Explorer\r\nOpera\r\nSafari\r\nAndroid webview\r\nChrome for Android\r\nFirefox for Android\r\nOpera for Android\r\nSafari on iOS\r\nSamsung Internet\r\n\r\n\r\n100\r\nFull supportYes\r\nFull support12\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\n\r\n\r\n200\r\nFull supportYes\r\nFull support12\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\n\r\n\r\n201\r\nFull supportYes\r\nFull support12\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\n\r\n\r\n204\r\nFull supportYes\r\nFull support12\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\n\r\n\r\n206\r\nFull supportYes\r\nFull support12\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\n\r\n\r\n301\r\nFull supportYes\r\nFull support12\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\n\r\n\r\n302\r\nFull supportYes\r\nFull support12\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\n\r\n\r\n303\r\nFull supportYes\r\nFull support12\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\n\r\n\r\n304\r\nFull supportYes\r\nFull support12\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\n\r\n\r\n307\r\nFull supportYes\r\nFull support12\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\n\r\n\r\n308\r\nFull supportYes\r\nFull support12\r\nFull supportYes\r\nFull supportYesNotes打开\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\n\r\n\r\n401\r\nFull supportYes\r\nFull support12\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\n\r\n\r\n403\r\nFull supportYes\r\nFull support12\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\n\r\n\r\n404\r\nFull supportYes\r\nFull support12\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\n\r\n\r\n406\r\nFull supportYes\r\nFull support12\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\n\r\n\r\n407\r\nFull supportYes\r\nFull support12\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\n\r\n\r\n409\r\nFull supportYes\r\nFull support12\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\n\r\n\r\n410\r\nFull supportYes\r\nFull support12\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\n\r\n\r\n412\r\nFull supportYes\r\nFull support12\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\n\r\n\r\n416\r\nFull supportYes\r\nFull support12\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\n\r\n\r\n418\r\nFull supportYes\r\nFull support12\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\n\r\n\r\n425\r\n?\r\n?\r\nFull support58\r\n?\r\n?\r\n?\r\n?\r\n?\r\nFull support58\r\n?\r\n?\r\n?\r\n\r\n\r\n451\r\nFull supportYes\r\nFull support12\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\n\r\n\r\n500\r\nFull supportYes\r\nFull support12\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\n\r\n\r\n501\r\nFull supportYes\r\nFull support12\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\n\r\n\r\n502\r\nFull supportYes\r\nFull support12\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\n\r\n\r\n503\r\nFull supportYes\r\nFull support12\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\n\r\n\r\n504\r\nFull supportYes\r\nFull support12\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\nFull supportYes\r\n\r\n\r\n\r\n致谢\r\n本文摘抄至：https://www.runoob.com/http/http-status-codes.html\r\n","categories":["Develop","Web"],"tags":["HTTP"]},{"title":"网络编程入门","url":"/posts/2020/WXDAQ3.html","content":"领导突然提出要将原来的 C/S 客户端转成 Web, 作为一个 web\r\n小白，只好使用百度和谷歌大法疯狂学习。\r\n在过程中遇到了很多疑惑，于是记录下来，以作分享：\r\n\r\n关于前后端如何协同\r\n根据公司的要求，今后可能会有更多的产品采用 web\r\n端，那么我不仅要完成自己负责这部分的改造，还要未未来的产品打下一个基础。首先，我就想到了前后端分离。\r\n但是前后端是怎么协同的工作呢？\r\n\r\n\r\n图片\r\n\r\n在网上找到了 云上丶无忧\r\n关于它的描述，通俗易懂。\r\n看完之后，有一种恍然大悟的感觉：\r\n原来前后端分离是要部署两套服务器的，当然也可以在一个服务器上，安装两个\r\nweb 服务。\r\n关于后端代码用什么语言\r\n我认为后端主要处理的是数据库和一些逻辑问题，对于界面展示基本等于无，所以，我认为用\r\nJaval, ASP.NET 区别不大。本人因为长期使用的是\r\nC#，所以自然的，后端就计划用 ASP.NET 了。\r\n前后端开发需要用到的技术\r\n前后端 API 管理\r\n前后端 API 管理采用 YApi, 它可以进行内网部署，很方便\r\n","categories":["Develop","Web"],"tags":["Web"]},{"title":"配置 HTTPS","url":"/posts/2021/2VVGDH0.html","content":"免费申请证书来配置 https。\r\n\r\nHTTPS,SSL,证书关系\r\n\r\nHTTPS 是通过 HTTP + SSL 组成\r\nSSL 的实现是通过安装数字证书来实现\r\nCA 签发数字证书\r\n数字证书包含了加解密的算法\r\n数字证书用于建立信任并且分发公钥\r\n\r\n软件\r\n\r\nopenssl\r\n用于生成密钥\r\ncerbot或者acme\r\n本文采用 win-acme 来获取证书\r\n\r\n\r\n上述两个软件均可用 scoop 安装\r\n\r\n通过openSSL制作证书\r\n在说明证书制作过程前，先说明制作证书时，用到的几类文件的作用： .key\r\n文件：私钥 .csr\r\n文件：证书签名请求文件，含有公钥信息，certificate signing request\r\n的缩 .crt 文件：用 .csr 生成的证书文件，certificate\r\n的缩写,这就是数字证书\r\n生成自签名根证书：就是模仿证书权威机构的作用，给用户提供一个权威机构的根证书。在真实场景中，根证书是CA认证中心给自己颁发的证书,是信任链的起始点。任何安装CA根证书的服务器都意味着对这个CA认证中心是信任的。\r\n\r\n生成CA 的私钥\r\nopenssl genrsa -out ca.key 2048\r\n生成CA 证书请求文件\r\nopenssl req -new -key ca.key -out ca.csr\r\n\r\n注意：\r\n\r\n如果要用 https，那么 common name\r\n那里应该是域名，否则会引起浏览器警告\r\n密码可以不输入\r\n\r\n\r\n设置密码后的影响\r\n我们在生成 RSA 私钥，即 ca.key\r\n时设置了密码，这样会导致在启动nginx服务时，每次需要输入密码。\r\n可能通过下列方式删除密码，生成一个没有密码的 RSA key：\r\nopenssl rsa -in ca.key -out ca_no_pass.key\r\n生成CA证书\r\nopenssl x509 -req -days 365 -in ca.csr -signkey ca_no_pass.key -out ca.crt\r\n\r\n用win-acme给\r\nwindows 服务器添加SSL（Let's Encrypt）证书\r\n见参考 2\r\n参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\n\r\nhttps://www.jianshu.com/p/449047437697\r\n用win-acme给windows服务器添加SSL（Let's\r\nEncrypt）证书\r\n\r\n","categories":["Develop","Web"],"tags":["HTTPS"]},{"title":"电脑无法更新Let'sEncrypt根证书的解决办法","url":"/posts/2021/G2SGMF.html","content":"网站使用了 Let's Encrypt 数字证书，随着 DST Root CA X3 根证书于\r\n2021年09月30日过期，有的电脑可能会无法将网站的根证书更新到新的根节点（ISRG\r\nRoot X1），导致在访问网站时提示网站不安全或者无法访问。\r\n\r\n如何判断出现是根证书问题\r\n在浏览器中打开【证书窗口】，切换到【证书路径】，查看证书路径中根节点的状态。如果没有更新的话，根节点为\r\nDST Root CA X3。\r\n手动更新根证书\r\n先在正常使用的电脑上面导出 ISRG Root X1\r\n证书，然后在有问题的电脑中导入即可。\r\n如果在 mmc 中导入证书无效时，可以通过 IE\r\n进行导入。具体导入方法见视频：https://youtu.be/scaPxbWy_2E\r\n导出证书\r\n\r\n","categories":["Develop","Web"],"tags":["let's encrypt"]},{"title":"Linux 中使用 acme.sh 申请泛域名证书","url":"/posts/2024/2TMXKG9.html","content":"本文将介绍如何在 Ubuntu 系统中使用 acme.sh 通过\r\ncloudflare 的 api 方式申请泛域名。\r\n\r\n为什么使用泛域名证书？\r\n泛域名证书和单域名证书的区别在于它们可以保护的域名范围不同。单域名证书只能保护一个具体的域名，而泛域名证书则可以保护一个域名下的所有子域名。\r\n举例来说，假设你有一个域名\r\nexample.com，单域名证书只能保护该域名，而泛域名证书可以保护 example.com\r\n及其所有子域名，例如 blog.example.com、shop.example.com 等。\r\n使用泛域名证书可以大大简化证书管理工作，特别是当你有多个子域名需要保护时。使用单域名证书需要为每个子域名分别申请和维护证书，而泛域名证书可以一次申请并保护所有子域名。\r\n因此推荐使用泛域名证书。\r\n安装 acme.sh\r\n安装很简单, 一个命令:\r\ncurl https://get.acme.sh | sh -s email=my@example.com\r\n生成 SSL\r\n创建 Token\r\n根据官方 CloudFlare\r\nOption 介绍，推荐使用限制权限的 Token，申请地址为：cloudflare api\r\ntoken\r\n\r\ncloudflare 右上角可以切换成中文\r\n\r\n依次选择【创建令牌】/ 编辑区域 DNS【使用模板】，如图所示：\r\n\r\n\r\nimage-20240409222129668\r\n\r\n其中，该 Token 需要有 DNS 的【编辑】权限。\r\n单击后，生成的 token 是一个长度为 40 的字符串，示例如下：\r\nY_jpG9AnfQmuX5Ss9M_qaNab6SQwme3HWXNDzRWs\r\n开始生成\r\n在 shell 中执行下列命令\r\n# 设置环境变量export CF_Token=&quot;Y_jpG9AnfQmuX5Ss9M_qaNab6SQwme3HWXNDzRWs&quot;# 如果是单个 DNS 区域，需要设置区域 id, 该 id 可以进入到具体的 DNS 配置中右则查找export CF_Zone_ID=&quot;763eac4f1bcebd8b5c95e9fc50d010b4&quot;# 如果是多个 DNS 区域，需要设置账户 id 方便 acme.sh 识别，区域 ID 可不设置# 账户 id 可以在登陆后，跳转到主页 https://dash.cloudflare.com/，最后一级即为 id# 例如：https://dash.cloudflare.com/763eac4f1bcebd8b5c95e9fc50d010b4export CF_Account_ID=&quot;763eac4f1bcebd8b5c95e9fc50d010b4&quot;# 进入到 .acme.sh 目录cd ~/.acme.sh# 生成证书./acme.sh --issue --dns dns_cf -d example.com -d &#x27;*.example.com&#x27;# 安装证书acme.sh --install-cert -d example.com \\--key-file       /path/to/keyfile/in/nginx/key.pem  \\--fullchain-file /path/to/fullchain/nginx/cert.pem \\--reloadcmd     &quot;service nginx reload&quot;\r\n参考\r\n\r\n说明 ·\r\nacmesh-official/acme.sh Wiki (github.com)\r\ndnsapi ·\r\nacmesh-official/acme.sh Wiki (github.com)\r\n\r\n","categories":["Develop","Web"],"tags":["acme","SSL","Let's Encrypt"]},{"title":"使用 win-acme 申请泛域名证书","url":"/posts/2023/1ZNRJSW.html","content":"win-acme 是一个可以在 Windows\r\n系统上运行的免费、开源的证书申请工具，支持申请 Let's Encrypt 签发的\r\nSSL/TLS 证书，包括泛域名证书。\r\n本文详细讲解如何在 Windows 系统中使用 win-acme，基于 Cloudflare\r\n申请泛域名证书。\r\n\r\n为什么使用泛域名证书？\r\n泛域名证书和单域名证书的区别在于它们可以保护的域名范围不同。单域名证书只能保护一个具体的域名，而泛域名证书则可以保护一个域名下的所有子域名。\r\n举例来说，假设你有一个域名\r\nexample.com，单域名证书只能保护该域名，而泛域名证书可以保护 example.com\r\n及其所有子域名，例如 blog.example.com、shop.example.com 等。\r\n使用泛域名证书可以大大简化证书管理工作，特别是当你有多个子域名需要保护时。使用单域名证书需要为每个子域名分别申请和维护证书，而泛域名证书可以一次申请并保护所有子域名。\r\n因此推荐使用泛域名证书。\r\nwin-acme 下载安装\r\n\r\n本文使用的 win-acme 版本为：win-acme.v2.2.6.1571.x64.pluggable\r\n\r\n\r\n下载 win-acme\r\n可以从 win-acme\r\n官网（https://www.win-acme.com/）下载最新版本的工具，下载完成后解压到某个目录下。\r\n特别注意，由于要使用 cloudflare 插件，因此一定要下载\r\npluggable 版本。\r\ngithub 上最新版本地址：github\r\nrelease latest\r\n\r\n\r\nimage-20231007093040579\r\n\r\n下载 plugin.validation.dns.cloudflare\r\n该插件用于在申请证书时，使用 cloudflare API 进行证书验证。\r\n\r\n\r\nimage-20231007093245979\r\n\r\n\r\n创建 Cloudflare DNS\r\n在 Cloudflare\r\nDNS 中添加域名解析。\r\n如果域名解析服务是阿里、华为等服务商，需要将域名的解析切换到\r\nCloudflare，具体方法可以在网上搜索下，此处不赘述。\r\n生成 Cloudflare API Token\r\n从 我的个人资料\r\n里创建 API 令牌。\r\n\r\n\r\nimage-20231007112322249\r\n\r\n开始生成证书\r\n\r\n使用 wacs --verbose 启动 win-acme\r\n使用 --verbose 启动时，可以查看 cloudflare\r\n插件是否加载成功。\r\n\r\n\r\nimage-20231007111038989\r\n\r\n选择创建方式\r\n输入 m 使用完整选项的方式来创建。\r\n\r\n\r\nimage-20231007111152620\r\n\r\n选择指定域名的方式\r\n输入 2 来手动输入\r\n\r\n\r\nimage-20231007111515006\r\n\r\n手动输入泛域名\r\n泛域名的格式为\r\n*.domain，例如：*.uamazing.cn\r\n\r\n\r\nimage-20231007111638681\r\n\r\n选择证书保存的方式\r\n输入 1 来将同一个域名保存到同一个文件中\r\n\r\n\r\nimage-20231007111826853\r\n\r\n选择 DNS 验证方式\r\n输入 6 使用 Cloudflare DNS 验证，然后会让你输入\r\nCloudflare DNS API Token。将上方中生成的 Token 复制到命令行中即可。\r\n\r\n\r\nimage-20231007112020384\r\n\r\n选择加密方式和保存位置\r\n\r\n\r\nimage-20231007112456225\r\n\r\n设置密码和其它保存位置\r\n都选择无\r\n\r\n\r\nimage-20231007112603424\r\n\r\n选择是否执行其它操作\r\n输入 3，表示不进行操作\r\n\r\n\r\nimage-20231007112825338\r\n\r\n这一步输入完成后，就会在指定的目录里自动生成相应的证书。\r\n添加任务计划定时自动更新证书\r\n若要添加任务计划自动更新证书，需要使用管理员身份启动命令行，否则会报如下错误：\r\n\r\n\r\nimage-20231007123855656\r\n\r\n\r\n参考\r\n\r\ncloudflare\r\nvalidation\r\n\r\n","categories":["Develop","Web"],"tags":["SSL","Let's Encrypt","win-acme"]},{"title":"你好！2020","url":"/posts/2019/3MYBQJA.html","content":" ## 你好，新年；你好，2020\r\n\r\n新年的钟声已经敲响\r\n时光的车轮又留下一道深深的印痕\r\n伴随着冬日里温暖的阳光\r\n2020年如约而至\r\n\r\n一元开始，万象呈新\r\n元旦\r\n新年的第一天\r\n在万声的祝福中正一步一步地走着\r\n走向我们\r\n\r\n新年\r\n有她美好的样子\r\n有她美好的憧憬\r\n\r\n新年\r\n就像春天一样\r\n万物复苏之前\r\n让我们重新开始\r\n\r\n新年\r\n就像小孩一样\r\n无忧无虑玩耍\r\n让我们重回最初\r\n\r\n新年\r\n就像老人一样\r\n如期而至的到来\r\n让我们重新感受\r\n\r\n新年\r\n就是这么一个喜庆的日子\r\n就是这么一个特殊的日子\r\n我将所有美好的祝福与心愿\r\n写在2020年的扉页\r\n\r\n让我们在新的一年里\r\n把祝福传给祖国\r\n愿祖国更加繁荣昌盛\r\n\r\n让我们在新的一年里\r\n把祝福传给亲人\r\n祝愿亲人们身体安康\r\n岁岁平安\r\n\r\n让我们在新的一年里\r\n把祝福传遍所有的朋友\r\n祝愿朋友们\r\n不忘初心，各自安好\r\n\r\n让我们在新的一年里\r\n让自己更快乐\r\n用最好的状态\r\n迎接新年的到来\r\n\r\n新的一年\r\n新的开始\r\n新的祝福\r\n新的起点\r\n\r\n让我们拥抱阳光\r\n开启幸福的2020\r\n\r\n祝大家元旦快乐，新年快乐\r\n","categories":["Essay","2019年"],"tags":["散文"]},{"title":"关于《挑山夫另解》","url":"/posts/2013/1F4T3C2.html","content":"走路之间，偶有灵感，突然回忆起《挑山夫》一文中的挑山工，突然发现，他的做法从能量角度来讲，是不可取的。\r\n\r\n很多人都很疑惑，为什么呢？不是重力做功与路径无关吗？这个思想我们从初中一直到现在，都是这样认为的，也是这样做的。很多人都有疑惑，其实，重力做功与去确实与路径无关。\r\n而对于人，对于生物，我们不仅仅只受重力，还受到各方面的力，宏观到地对脚的摩擦力，微观到地球磁场对身体分子，而对于自己消耗能量从而获得动能的生物来说，我们处处受力，处处需要能量，只要动（宏观上的运动和抽象的思考），一切，都需要能量来维系。\r\n所以，挑山工的行动是需要能量的，他在上山的过程中的心灵思考，各种停留，也是要消耗能量的\r\n。一方面，假如他沿着阶梯的梯度往上走，虽然过程比较累，但是这只是因为他的身体产能跟不上消耗的结果，但是，这样，他所消耗的时间变短了，节省了他水平移动时候的能量消耗。另一方面，一个人的思维，也是需要能量的，当他上山时间越长，心灵就会越疲惫，用于控制身体的思维就会发散，也可能导致能量多损耗。\r\n就像骑自行车，你遇到一个上坡，当你调档到费力的时候，你的速度起来了，通过相同路程的时间变短了，你的能量消耗假设为Q；那么当你调档到省力的时候，你所花的时间延长了，在这个延长的时间里，你的积累消耗能量用于通过路程的也为Q，但是，在△t内，时间效应（在△t时间内的附加能量消耗）会消耗能量q，所以，后者消耗能量更多。\r\n综上，我觉得小学课文中的《挑山夫》挑山夫的做法从能量角度看，不可取。\r\n","categories":["Essay","2016年及以前"],"tags":["生活感悟"]},{"title":"自然守恒论","url":"/posts/2015/R4FXSA.html","content":"理论假设\r\n首先，假设如下理论，即对称理论：\r\n我们生活的空间由两个世界组成，一个是显化在物质界的真实世界，称为三元宇宙，另一个是显化在精神世界的精神世界，称之为虚无界。真实的世界和虚无的世界呈函数映射关系，其具有一一对应的关系。当真实世界产生的那一刻起，虚拟界也跟着生成。\r\n\r\n能量守恒\r\n物质界的能量守恒的定义：\r\n能量可以从一个物体传递给另一个物体，而且能量的形式也可以互相转换，但能量永远不会消失。\r\n虚拟界的元能守恒：\r\n元能的定义：在虚拟的精神世界，有这么一种精神能量，叫做元能。它就像物质界的能量一样，永远不会消散，只能够相互转移。\r\n元能守恒：\r\n元能可以从物质界的一个所有者转移到另一个所有者，而且元能可以相互吸收和转化，但永远不会消失。\r\n虚拟界\r\n虚拟界可以假想成一个倒的金字塔形状。从最底端到最高端，有无数个能量等级，而每一个能量等级就有一个无穷大的空家供该等级的元能反应。\r\n低等级的元能可以通过吸收其他元能从而成长，跳跃到高等级。而物质界的任何一件事情，任何一个行为，任何一个有能量的物质体，都对应着虚拟界的一份自己的元能机器，这个机器有初始元能，初始元能通过借用这个机器（或者说通过它本身的特性）完成对其他元能的作用。每个初始元能的性质不一样，等级不一样。\r\n元能之间的作用称之为共鸣。\r\n实例\r\n用对称的能量守恒来解释：杀人者最后被人杀，杀猪者则不会被猪所杀\r\n智慧的人的初始元能等级相对较高，假设位于“倒金字塔”的 30\r\n层，人一出生就有很多的权利，因为你的能量等级是\r\n30，可以在同等级和低等级的范围内活动而不会引起其他元能的负效应。\r\n一个人由小到大，通过沐浴阳光，吃饭喝水，学习工作等，现实中的每一个行动，虚拟界中，自己的初始元能机器也相应的吸收转化其他元能，然后不断升级。然而有的人在现实生活中因为各种“原因”，走上犯罪的道路，在虚拟界的映射就是在转化这些“原因”的元能的时候，元能机因为某些原因未能够完全转化，导致虚拟界对应自己的那份初始元能不能够很好的协调运转，积少成多（假设这时他的元能等级为\r\n100），当这份等级为 100 的能在 100\r\n以及以下的虚拟界移动时，对其他的元能产生负效应，最后引发杀人动机，杀了人。\r\n杀人之后，除了钱财什么的，更重要的是他的元能机吸收了该遇害者的初始元能，这将为自己的元能机埋下更大的隐患，最后元能机要么自己不能工作（崩溃自杀），要么被其他元能机感应到（被发现排斥），要么被更强大的元能机吞掉（他杀）。\r\n然而，一个人杀个猪并不会怎么样，为什么呢？\r\n因为你的初始元能等级比猪高，所以吸收了猪的初始元能，能够顺利的转化。保持自身元能机器的正常运转。\r\n可以用这个解释很多东西。虚拟界的元能模式在我们现实世界来说，就是冥冥中的因果关系。\r\n如果一个人（虚拟界的元能机）可以完美吸收其他元能（吸收元能你不能改变它的性质，只能吸收它，融合它，通过其他途径转化它），只要连续不断的去吸收，那么，在物质界的你，也一定能够达到自己的目标（对应着，在虚拟界的你，将有更广阔的空间让元能机去“走动”。\r\n总结\r\n守恒，是所有世界的通用法则，得并不应定失，不断努力，方可不断得。\r\n","categories":["Essay","2016年及以前"],"tags":["生活感悟"]},{"title":"人当有梦","url":"/posts/2016/2YSA5Z7.html","content":"一杆老笔，一个人，两个默默地在纸上疾书，但思绪却飘出窗外，飘到阳光下，飘到明天的以后，直到很远，很远......\r\n\r\n一个模糊的影子，住在方方正正的屋子里，好像计算机的无限循环，在上下班之间不断加一。对了，过年过节，会陪着亲人，玩着，乐着，偶尔遇见老同学，会去喝几杯，聊聊天，谈谈工作，家庭，孩子，然后又继续回归到每天的上班，下班......\r\n很久很久之后，这个影子终于慢慢的清晰了，突然一惊，它竟然是我自己。\r\n时光慢慢倒回，回到中学的教室，回到小学的方块字，回到我的第一个呼吸，是无奈，是惊醒，是冲动...我的前半生，竟然都只是在做一件事情，为了养活自己，十几年的学习，最后是为了找份工作，养活自己，养活家人，然后慢慢的老去，化为一抔黄土，随风消散，无人相思，更无人相忆。\r\n不禁让人思考，自己的一生究竟该怎么度过？\r\n学习为了什么，\r\n工作为了什么，\r\n娶妻生子为了什么，\r\n那人活着，是为了什么，\r\n.....\r\n活完就是一生，生与死是上天赋予每个生灵的最大使命，而不同的人用不同的方式把它走完，在这段旅程中，怎么过，唯心乐则是最好的活法。\r\n善者好施，是以为乐，\r\n恶者行凶，是以为乐，\r\n豪者嗜酒，是以为乐，\r\n侠者仗义，是以为乐，\r\n而我以众人乐，为乐！\r\n怎么活，只是个人的爱好和梦想。只要自己在人生路上的时候，抬头看路，低头做事，怎么活，都很精彩！\r\n","categories":["Essay","2016年及以前"],"tags":["生活感悟"]},{"title":"爱得不够深沉","url":"/posts/2016/3VN0XNQ.html","content":"我为什么我的眼里常含泪水，因为我对这片土地爱得深沉——艾青\r\n时间把这暖暖的阳光分成了两半，一半留在上午，另一半，正在懒懒的洒向大地。思绪把我也分成了两半，一半留在自习室，另一半，正在深情的慨叹。\r\n\r\n我在思考，为什么在文人的眼里，我们的起居之所何以被如此赞扬，山河，江山，社稷，国......而这些大气磅礴的词语，被文人们用出来，却是那么的贴切，自然。羡慕他们，羡慕他们总能够一步一景，一步一喟叹。不论是小桥的流水，还是残破的老屋，亦或是凋零的花草，这些文人们，总能感受到它们的磁场，与之共鸣，然后又把自己留在那儿。\r\n这不禁让我想起了自己的一位好友，他的风格我很喜欢，文字细腻而平淡，读他的文章，你会分外的宁静，然后由着他把你带进他的世界，再安安静静的送你出来，不食烟火，但回味无穷。他笔下的每一个地方，在他那里都有着满满的故事。我很喜欢这种感觉，走一个地方，就是一个故事。\r\n我在思考，为什么自己外出游玩，总是万般风景旧曾谙，最后留下的，只是给记忆多点流逝的内容。这个问题困惑了我很久，脑袋一直不开窍，想不通，想不明白。今天突然看到艾青的这句诗，突然顿悟了：因为我对这个世界爱得还不够深沉。\r\n是啊，屈原发出”路漫漫其修远兮，吾将上下而求索”的感叹，是因为他对他的国爱得炽热，李白潇洒挥墨”飞流直下三千尺，疑是银河落九天”，是因为他对这片景爱得深沉，徐志摩感叹”只求在最美的年华里，遇到你”,是因为他对你早已爱得痴迷。读着这些诗，每个文字，都承载着诗人浓浓的感情。情是船，文字是船夫，一船，一人，静静的在时间的河流上驶着，我想，时间尽了，它也不会停下。\r\n只要爱得深沉，任它天穹星月轮转，任它大地沧海桑田，你的江山，就是你的国，闭眼，睁眼，刹那也是芳华。\r\n","categories":["Essay","2016年及以前"],"tags":["生活感悟"]},{"title":"君子之道","url":"/posts/2016/2H6KWG8.html","content":"天行健，君子以自强不息，地势坤，君子以厚德载物。古之圣人，俯仰天地，早已道出何以为君子，历代大文豪对此也不吝赞美，沿着历史，我们可以看到，总有一大批人在寻求君子之道，以致圣人之境。\r\n\r\n春天的阳光好像有一种神秘的力量，今天出门的那一瞬，阳光仿佛空灵的仙气，扑面而来，随之而至的，是我顿悟了。悟出了一种为人之道——人之立世，当拾一颗君子之心。\r\n是的，立世，当为君子。心中坦荡，为人诚于心，为事而无所怠，自然正气浩荡，鬼神莫敢欺。但是人总会有属于自己的私心，这种大爱天下的境界让我们求之不得，但前赴后继。\r\n生活在当代这个大熔炉之中，如何臻至这无上之境呢？一个词语就足矣，问心无愧。\r\n培养浩然之气，不在乎邪，不在乎正，而在乎心。每个人为人处世，心中自有一杆秤，即使这杆秤在别人看来是违反秩序的，但是与己，那就是自己行事的准则，该做不做，不该做而为之，都会使你违背心中的那杆秤，从而产生心魔，埋藏于心，好比在心中制造了一个小小的黑暗地带，吞噬心中正气。但是如果你能事事顺心，那么便无心魔滋生，心之世界一片朗朗乾坤，浩然之气聚集，由内至外，使自己心无所畏惧，坚韧不拔，一言一行，大开大合，心旷神怡，做事自然事半功倍。\r\n顿悟真的很美妙，在那一瞬间，你的心突然就开阔了，就像北冥之鱼，突然化身鲲鹏，扶摇九天之上的那种感觉，又若醍醐灌顶，从此进入一种大自在的世界，从此看红尘，可为大千，亦可为尘埃，在这转换之间，直透本心，明了为与不为。\r\n当为君子，纳存粹之心，感念周遭万物。\r\n","categories":["Essay","2016年及以前"],"tags":["生活感悟"]},{"title":"人的终点在何处","url":"/posts/2016/3FADRYM.html","content":"每一个晚上我都会进入另一个世界。这个世界有好人，也有坏人，有善良，也有丑恶，但是这个世界中的我才是最真实的。这个世界是梦。\r\n我有这一个疑惑：如果我们每晚做的梦是连续的，那么现实与梦境了，哪一个才是真实存在的，这就像庄周梦蝶，是现实入到梦里还是梦里梦见了现实呢？\r\n\r\n春秋二十多年，梦就像另一份经历一样，时常在记忆中荡起涟漪，又归于平静。以前都是从别人那儿知道日有所思，夜有所梦，亦或是神经衰弱等等之类的，但是有时候自己做的梦，天方夜谭，有些名词，有些场景却是自己想象不出来的，这不禁让我产生了思考，什么是梦，什么是现实，什么为真？\r\n几年前看过一部电影《盗梦空间》\r\n，讲述了一个梦中梦的精彩故事，而我们或多或少的也有过梦中梦的经历，那么，我们可以推论，现实的我们可以做梦，在梦中的我们也可以做梦，无限循环，反过来讲，在梦中梦醒来是梦，在梦中醒来时现实，那在现实醒来是什么？我称之为超现实。如下图：\r\n\r\n\r\nimg\r\n\r\n\r\n\r\nimg\r\n\r\n因为我们是以一重梦境中的自己为变量，所以，纵轴x代表自己的本质能量。\r\n现实世界的函数y==1，不论自身本质如何强大，这个世界的丰富和精彩程度不会因为你一个人的意志而发生特别大的波动，总会在y=1的附近保持平衡，或者说，你的精彩是你的，对我的影响不会非常大。因为我们生活在由万事万物共同组成的社会里面，一个人不可能有掌控所有事物的能力，也就是他不会有打破现实世界平衡的能力。\r\n一重梦境的函数为y=x，一重梦境世界丰富程度与本质能量成正比，所以，一个人见多识广，他的本质能量越大，离现实世界y=1就越远，说明一重梦境世界越丰富，则所梦见的东西也可能会更离奇。\r\n二重梦境世界的函数y=x2，如第一重梦境世界一样，但是变化更大，就是说即使一个人的本质能量比较小，他的二重梦境也可能会很丰富。\r\n超现实的函数为y=x-1，是一反比例函数，就是说，如果一个人本质能量越大，则超现实世界的丰富程度就越低，最后会低于现实世界。我想可以这样理解，超现实世界因为种种原因，环境发生大改变，不适合人类交流活动，只能通过一个游戏头盔进入到了现实世界进行交互。而从他们那一批人开始之后的现实世界每个出生的孩子，都是现实世界原生的数据。\r\n当现实世界的人的本质能量强大到一定程度之后，会逐渐遗忘回到超现实世界的这个念头。就像我们在梦里一样，开心的时候不会想起来自己是在做梦。\r\n每个人本质能量和起所处的每个世界的丰富程度有上面的函数关系，如果我们对每个函数进行积分：，表示自身本质能量与各个世界的关联程度之间的关系。 \r\n函数图像如下： \r\n由图像我们可知：\r\n本质能量越大，你和现实世界，一重梦境世界，二重梦境世界的关联就越强。一个本质能量较弱的人，他与他的这三个世界的联系都不是很大，所以，对于这个世界来说，他是没有什么存在感的，做梦的时候，也大多是以第三人称的方式出现的，而本质能量强的人，他所做的梦，大多是自己在主导，可以称之为本能，我称之为本质能量够强大。\r\n对于超现实世界，一个人的本质能量越强大，他的超现实世界的关联程度的绝对值就越小，就是说，梦里开心，不会想到现实世界，现实世界有成就感，也不会想到超现实世界，自然，对另一个世界的关联程度就低了。\r\n但是，当人到老年，生命流逝的时候，我们的本质能量归为0了，这个时候，和超现实世界的本质联系就是无穷大。所以，我想，一个人的终点不是灭亡，而是梦醒，回到永远到不了的另一个世界，超现实世界，然后在那个世界回忆自己这一生的点点滴滴，然后开始又不一样的人生。\r\n一梦一世界，一叶一菩提。梦什么，在哪个世界，都不重要，重要的是，每一个世界都是你自己。做一个本质能量强大的人，在每个世界都精彩地静待梦醒。\r\n","categories":["Essay","2016年及以前"],"tags":["生活感悟"]},{"title":"最殇别离,记湘江一桥","url":"/posts/2016/201Z6G7.html","content":"\r\n\r\nimg\r\n\r\n众里寻他千百度，蓦然回首，那人却在灯火阑珊处。四年一蓦然，四年才回首，那烟火绚烂处的湘江一桥竟然已经陪了我四个春秋。\r\n\r\n近来天气总有一种雨恨云愁的味道，偶尔拾得放晴时光，约几好友，游于湘江堤上，更别有一番味道：\r\n白鸟芳草引画桡，垂杨影里见一桥，欲寻往事已魂销\r\n遥指洲头潇湘路，断鸿无数水迢迢，离愁分付湘江潮\r\n离别的人最是伤感，一彳一亍，皆有万般情愫。我就那么静静一立，仿佛立在了时间的河里。伟人一幕幕，涓涓的淌在心里。毛泽东少年豪情，问苍茫大地，谁主沉浮；美景不胜收，看万山红遍，层林尽染，我循着北去的湘江，望穿千年，湘江竟然一直与岳麓学府相伴。\r\n颔首，长桥卧波。湘江一桥以其优美的双曲拱线条，优雅的展示着她的魅力。她的美，是属于奇迹，她的美，羞了长沙几代的少女，美人早已易逝去，而惟她不老。\r\n第一次与她邂逅，是四年前。那年，懵懂的我在校车里，极目远眺，眼里装着橘子洲，装着湘江水，装着若隐若现的湖南大学，余光里，也有她的影子。\r\n再次相遇不知期已几何，唯有洲头烟花一万重。她在漫天的花火中若隐若现，披着夜色，把这观火人秒秒分分的时光都记在了日记本里。当时的情景已经模糊了，我只记得眼中全是炫丽的烟花，对于一桥，好像她只是在该出现的时候出现，自自然然。\r\n就这样，两年，半烟半雨洲头桥边，我和她重了又逢，离了又别......\r\n大三，偶然发现课本里夹了一张她的老照片，有点泛黄，应该是上个世纪70年代拍的，看着看着，竟然迷了一节课。晚些时候，一个人，带着心情，来到了桥上。感受着她的呼吸，感受着风拂过她的脸颊，她在颤抖，在抑制不住的颤动，我静默的体会着，那一瞬间，我懂了。那是心跳的节奏，是久逢知己的酣畅，是终得一人心的喜悦。这一刻，我眼中的湘江一桥，古朴，厚重而又伟大。她化作孤独，横越一个世纪的距离，呵护着每个往来的旅人；她优雅而美丽，绽放着桥梁的魅力。\r\n四载匆匆，湘江一桥，那完美的双曲线拱桥，那完美得是奇迹的美，依然惊艳，而我，无奈岁月，只手道离别，即将离开这陪伴了我一个大学的一桥，不舍别离，又殇别离。\r\n阅尽天涯离别苦，离人最是人间留不住。桥梁，湖大，湘江一桥，不忍别，别了盼相聚。\r\n","categories":["Essay","2016年及以前"],"tags":["生活感悟"]},{"title":"游沅江有感","url":"/posts/2017/HPBWTD.html","content":"今天是2017年4月15日。\r\n本周轮到我值夜班，今天早早的就起来了，也没有了平时的睡意。我记得睁开眼大约是8:30\r\n分左右，懒了一会儿床，起来就9点了。本想着做一篇西安的攻略，可是想想，好像时间还蛮多，应该出去走走。在益阳的半年里，很多地方都已经去了，漫无目的在网上浏览者，在地图上惊鸿一瞥，发现沅江是个好地方。洗漱完，想做个攻略再走，但是担心时间不够，所以直接拎着包和相机就出门了。\r\n\r\n到达车站之前，我都不知道车票是多少，后来一买票才知道，只需要10块。心里还是蛮高兴，走对了，应该不远，一天来来回回够了。\r\n约3刻钟的样子，就到了沅江。初识的沅江给人印象并不是很好，车站很破，楼房全部散布着暮年的气息，慵懒的在街边立着。沅江的交通我最是不喜欢，公交不会报站，特别是在网上查不到公交的信息，对于我一个陌生人来讲，这是比较麻烦的事。\r\n但沅江有她自己的魅力。每一块土地拥抱着湖泊，每一个湖泊躺在一块土地上。多水的沅江，尽是柔柔的美。这儿的人过得很惬意，面里总是带着欢快，在他们的身上看不到生活的压力，舒缓的节奏，那么自然。\r\n后记：\r\n这篇游记并未完成，但是却反应了才毕业不久的自己不甘工地的平淡生活，从时间缝里去拥抱世界的精神，这也为后来的辞职作下了铺垫。\r\n同时，这种精神，都值得现在的自己学习：心有抱负，积极阳光。\r\n","categories":["Essay","2017年"],"tags":["散文"]},{"title":"老卓的礼物","url":"/posts/2017/05KG8X.html","content":"一个来自银城益阳，一个则来自山城重庆；一个沉默寡言，一个却活泼开朗，50岁的电梯操作手老卓与24岁的技术员小甘于中交二航局益阳大桥项目部入职半年也相识了半年，性格迥异的二人谈笑间在旁人看来关系密切的很。春节前，二人约定在节后复工后互相送给对方一份新年礼物。\r\n\r\n节后二人相遇几句嘘寒问暖后，均立马投身到了紧张的岗位工作中，并把玩笑似的约定抛在了脑后。小甘负责10号主塔虽已封顶，可下塔柱还有一些后期工作需完善，每天仍有许多施工人员在塔上作业。而老卓的主要工作便是通过操纵施工电梯，把包括甘明昔在内的建设者们安全送达目的地。\r\n老卓言语不多，他的工作责任心也如此，如他人有意让其违规操作，也是不必多言。根据项目规定，益阳大桥施工电梯限载九人，硕大的“九”字贴在电梯狭小的空间内，是老卓始终的坚守。这天天色已晚，本想着站完最后一班岗就可以换班回宿舍休息，速去速回是最好了，小甘就带领着包括他在内的一行10人进入了电梯门。\r\n“老卓，上去吧！”说完甘明昔已经关上了电梯门。\r\n心存侥幸的一行人沉默了足有两分多钟，电梯依然不见启动。其实谁都知道这班电梯也许是开不了了，但有老卓的好友小甘在也许会不一样。众人期盼中小甘终于开了口：“老卓啊，你让大家早点做完早点下班，就多一个，不要紧的，走吧！”\r\n友情在原则面前并无一丝作用-电梯仍无任何声响。小甘心中顿生不悦，正当他准备找老卓理论时，不擅言辞的老卓却挤出一句话来：“限载九人你们看不到吗？多一个人我都不会载你们上去，你们自己下去一个，等下我再跑一趟。”言语朴实又坚定，众人还未听完便开始商量着谁先下去，因为他们知道面对这种情况老卓自然是不会让步一寸的。\r\n还未等大家商议出来，小甘自己打开电梯门走了出去。包括老卓在内，大家都认为小甘肯定是怒不可竭，要去告他老卓的状了。而众人也不愿意多猜测，还是赶紧上去做好手头的事情当作什么也没发生为上策。\r\n事情就这样过去了，老卓后来的几天工作虽照常，但谁都看得出来是有心事。最后他鼓起勇气拿着自己从老家带来特产趁着下班时间敲开了小甘的房门：“这不是答应了过年来给你一份新年礼物吗？你瞧，我拿来了，那天的事情你知道我嘴笨......”\r\n还没等老卓说完，小甘哭笑不得，“老卓，你并没有做错什么，错的是我咧！”\r\n原来那天老卓说出口的话并没有让小甘生气，而是震惊了许久。面对着眼前的老卓，小甘继续补充到：“做人做事要有原则、有底线，施工安全更是如此，任何时候都不能动摇，感谢你通过这样的一句话教会我了这个道理，这个新年礼物来的比什么都要珍贵哩！”\r\n","categories":["Essay","2017年"],"tags":["散文"]},{"title":"向心而行","url":"/posts/2017/218KCWH.html","content":"从益阳到武昌，再次踏上了去武汉的旅途，这是六月份第二次奔赴武汉。\r\n\r\n清晰的记得6月1号，我瞒着所有人，包里塞着一套西装，就登上了去武汉的列车。这是工作以后买的第一张硬座，仿佛又回到了读书的时候，天南海北的人挤在一个车厢里，三连座的位置总会留一个屁股给陌生人，列车员说着麻利的顺口溜，宣传着自己的产品，一切那么的熟悉。车厢里的我，工作已经快一年了，但对于面试，依旧紧张和青涩。我心底是迷茫的，不知道面试自己的公司是什么样的，我要选择什么样的公司，我想，我只是为了证明，自己有实力可以进设计院。\r\n在武汉呆了10多个小时，匆匆的去，匆匆的回，面试完之后，没有期待，暗暗告诉自己，这次你终于任性了一把，随性而为，释放了内心的想法，现在心愿已了，可以回去踏踏实实工作了。\r\n现在又一次奔赴武汉，心情很平静，迈出这一步，我知道今后的生活会很艰辛。从今以后，得考虑柴米油盐这些问题，打的会心疼，吃肯德基会心疼，过节会心疼，再也没有足够的资金支撑自己旅游的愿望了。自己又将从一个小虾米开始奋斗，将职业生涯用橡皮擦擦掉，一切，又从头开始。\r\n这样做，我不清楚究竟好或不好，但是我知道，一旦选择，将再无退路，今后不论如何艰辛，我也必须咬牙扛过去，选择了就不后悔，我愿用十倍的努力，弥补这一年的青春。\r\n曾经看过一部电影，七月与安生。七月活成了安生，安生却成了七月。我想，我就那个七月，内心向往着自由豪放的生活，期待着激情似火的世界，爱好充满无限可能和挑战的生活，但是环境影响，我把它们都埋在了心底。\r\n这应该就是自己选择更换工作的原因。寻着心的呼唤，努力走好每一步。\r\n","categories":["Essay","2017年"],"tags":["散文"]},{"title":"一次思想的旅行","url":"/posts/2017/3T2T8EN.html","content":"这个梦发生在今天下午，因为周日，下午无事，便睡了个饱觉，于是，诞生了一个神奇的梦，我称之为思想的旅行。\r\n\r\n睡了一会儿，醒了，便起床去洗把脸，发现脸是麻木的，有一种不真实的感觉，不论怎么用水洗都是这样，瞬间觉得不对，反应过来，应该这是一个梦，我应该还没醒。然后就挣扎着起来，换了个睡觉的姿势，奋力直腰，最后终于起了，当洗脸的时候，脸还是麻木，我知道，这是又没起来…挣扎了很多次，每次都没能真正的醒，每次都在重复相同的事情，然后再挣扎着。渐渐的，没了起床的心思，睡熟了。\r\n这次做了另一个梦，和朋友趁着周末，来到了伦敦。我们出现的地方是泰晤士河旁边，朋友说：“这条河好熟悉啊！”我立马回答了一句：“这是莱茵河”。\r\n游着游着，朋友觉得有些困，便提前回去休息了，我趁着夕阳西下的时光，欣赏着两侧的风景。第一印象便是这儿有一座桥，没看到叫什么名字，是一座拱桥，拱座外面贴了灰色的瓷砖，瓷砖与瓷砖之间的缝隙刚刚好，错落有致，仔细看，每一块砖的砌筑，不多一寸，不偏一分，这才代表工匠的水平。还有一个印象是，这儿的景观布局也很精致，柳条垂落，不论从哪个角度看，都那么整齐，赏心悦目。\r\n朋友有一个好友，叫做Toms ---\r\nTimy,中间还有一个字，记不清了。在我给这个桥拍照的时候，他找到了我，然后还用中文和我交流，我当时想，至少得用英文问一下名字，然后脑袋就在搜索“请问怎么称呼”用英文怎么讲呢，思考无果，只得讲中文，有点尴尬。他给我讲，这条河叫做泰晤士河，然后领着我在旁边走了走。\r\n这儿的建筑也是很精致，充满着历史感和独特的人文气息。每一栋房子，虽然有着浓浓的历史痕迹，但仔细一看，每一个细节，都那么吸引人，其中的工艺更是不得不让人佩服，我随手用手机量了下，每一块板的厚度都完全一样，让人觉得不可思议，让人震撼，让人佩服。\r\n游着游着，天色渐晚，夕阳缓缓西下，此时另有一番风景，夕阳的光线很柔，逆光更是美到极致。难得的景致，我拿出手机，横着屏幕拍下了这美好的一瞬。\r\n\r\n\r\n图片来自网络\r\n\r\n（光和图片类似，但是当时太阳更低）\r\n接下来的事情便是几经波折，回到酒店休息，结束了这美好的一天。\r\n梦到这儿就结束了，醒来之后，一切历历在目，无比清晰，翻了下手机相册，略有失望。\r\n我在思考，旅行，究竟是为了什么，答案应该是去一个美好的地方，放松自己的心灵，这个梦，让思想进行了一次旅行。\r\n身在闹市，不为车马喧，我们自己的世界，应由自己来丰富。\r\n","categories":["Essay","2017年"],"tags":["生活感悟"]},{"title":"因为匆匆","url":"/posts/2017/3C2G7GH.html","content":"又是一次天色渐晚，吃过晚饭，听着音乐，打发闲着的时间，只有在这一刻，我才感觉到，光阴是在身边流淌。工作的时候，时间逝得很快，快得都分不出来是时间超过了我们，还是我们越过了时间。\r\n我想，大概是我们走得太快，时间也跟不上了。\r\n\r\n走得太快，便错过了路上的风景。昨天出门没有看天气预报，便没有带伞，出了门，回家的时候，天突然下起了淅淅沥沥的小雨，淋着雨，一路跑了回来，换了身衣服，略有后悔，要是早一点回来，就不会淋湿了。今天回想起来，昨日的自己却是错了一场浪漫的雨。\r\n从前的自己，很喜欢下雨。让雨落在头发上，打在湿了的衣服上，脚踩在路边的小水洼里，然后溅起一滩泥水，随性而为的放松，让人痴迷。现在因为匆匆的自己，下了雨，却没了感受的心，遗憾的错了雨的一厢情愿。\r\n不知道这是不是很多人的感觉，当阳光透过窗子，照在你的桌子上，你用笔尖在阳光下写着承载着自己思想的文字，这一刻，世界是那么安静，一刻好似永恒。而现在，因为匆匆，已经有很长一段时间没有见过黄昏了。家里的玻璃，成了冰冷的窗户，窗帘，埋葬了如诗的生活。\r\n庆幸自己偶然慢了下来，可以让思想驰骋去更广阔的世界。\r\n听着舒缓的音乐，闭着眼睛，细细品味着每个音符的跳动，一切的烦恼和压力，随之消散，此时的声音，便是最好的天籁。走得慢了，也就走进心里去了。这让我想起了一个朋友曾经讲过的一句话，“真不敢相信自己是在西安旅游，感觉就是在家旁边逛了一个古镇”。是的，走心的生活，一行一亍，都是美好，空间里没了时间。\r\n天快黑了，夜晚开始慢慢苏醒，天上稀稀落落的星慢慢探出头来，他们来到地球，是走得快还是慢呢？\r\n\r\n\r\n图片\r\n\r\n","categories":["Essay","2017年"],"tags":["生活感悟"]},{"title":"五分钟的世界","url":"/posts/2017/3Y49VDP.html","content":"不久前，搬来了新的住处，离公司比较近，便喜欢在午饭之后，回家小憩。于是中午定了一个\r\n13:45\r\n的闹钟，但这个时间却是有点尴尬，上班的时候，如果运气好，楼下可以找到“小黄车”，那么就会准时到达公司，但如果不被眷顾，就只能跑着去了，生怕来不及，只有到达公司楼下的时候，忐忑的心才能放下。当然，被眷顾的概率极低，通常我都是在做跑步运动。\r\n\r\n有时候，不禁好奇，这些人都是什么时候去上班的呢，为什么回来的时候那么多“小黄”，而走的时候却一辆也没了，难道他们都不用午休吗？我带着纳闷，保持着几乎每天跑步上班的节奏，“坚持”了快一个月，直到今天。\r\n今天很惊喜，比闹钟早醒了5分钟，下楼之后，门口居然惊现一辆“小橙”，赶快扫码，心情瞬间大好。走了几步，左边一辆，右边还有一辆。心里有点莫名，今天发生了什么，居然还有这么多空车。因为早了5分钟，上班也不用急着赶，慢悠悠的踩着脚踏板，沐着阳光，把心灵放空虚，听着风语，思考今天的安排，编织着放假的精彩，不用狂野的奔跑，不用担心迟到，一切很惬意。而路上行人或匆匆，或焦虑，或笑逐言开，走着的有，小跑着的亦有，千姿百态，红尘人生，这好像就是从前的自己。\r\n这种感觉甚是奇妙，他们是自己，又不是自己，站在他们的角度折射生活，站在自己的角度思考未来。仔细一琢磨，每个人都在自己的圈子忙碌着，这个圈子只有那么几个名字，只有那么几件东西，有的人，一直在这个圈子往返，直到生命消散，有的人，知道何处是远方，往返皆是精彩。\r\n惊奇的发现，自己与所好奇的人的世界，只是隔了5分钟的距离。因为这5分钟，便是一册不一样的人生，两个迥异的世界。拥有它的人，从容而淡定，睿智而优雅，失去它的人，无奈和落寞。但即便是这么短的距离，我亦靠着偶然堪破。\r\n这个事实让我醍醐灌顶，或许我们离所追求的人生也只有一个5分钟，走上巅峰，只是需要比现在多努力那么一点。\r\n5分钟的差距，星星与星空的格局。\r\n","categories":["Essay","2017年"],"tags":["生活感悟"]},{"title":"三世","url":"/posts/2017/BPMA7E.html","content":"期望有轮回，却一直在轮回。\r\n\r\n1 前世\r\n前世，他出生在偏僻的小山村。只有一条泥泞的小路，穿过小河，然后从这个村子旁边经过，在他的记忆中，这条路，承载了整个村子的故事，塞满了他的童年。村落中的人家，如果算上脚趾头，那就是屈指可数了，村子里也没什么文物之类的，上了年纪的，除了老人，就是屋顶一片片的青瓦了，还有在山里头老李家的牛。\r\n他的年纪小，脑袋里放不住记忆，每天似乎过得很平淡，但也似乎很快乐，那个时候没有时间的概念，连年龄都是爸爸妈妈帮着保管。他每天有一个任务，就是把家里的小牛牵到草长得好的山坡上，让它饱饱的，好好的吃一顿，这头牛很挑剔，但是很喜欢和他在一起。有时候，他会想，这牛一点也不好养，草老了不吃，树叶也不吃，要是养只羊该多好，什么都吃，有时候也很喜欢，因为可以把它丢到山上，等到时间差不多了，就“哞～哞…”的学着叫几声，带着起伏，它就自己回来了。牛也很有脾气，一般不让人骑，他想到一个好法子，出门的时候，憋一泡尿，等走的时候撒在草地上，牛会吃得很开心，恨不得把泥土也吃进去，这时候，他的愿望就实现了。不过，快到家了，还是得下来，被人看到了回去肯定要挨一顿家长的狠揍。\r\n就这样过了几年，村里迎来了第一台电视机，是黑白的，电视机很古老，调频没有遥控器，需要手去拧上面的按钮。跟着电视机一起到来的，是孙悟空，是腾云驾雾，是肝胆相照，是外面精彩的世界。每天晚上，是他最期待的时间，因为可以去电视的主人家那儿看电视。如果去得晚了，就倚在门边，从大人们之间的空隙去发现外面的故事。他觉得生命真是渺小，拍一部电视剧有那么多人死亡和受伤。\r\n那时候的他，很认真，很单纯，没有人告诉他们电视里的真假，不过这都不打紧，因为它开始向往外面的世界了。大人告诉他，只要努力读书，就会一步步的走出去的。在村里读小学，在镇里念初中，在城里上高中，然后到市里读大学，他想不到然后要到哪儿去，要去干什么了。所以，他就一直走一直走，越走越远，越走越远，走过了一生。\r\n2 今生\r\n今生，他穿越成一个毕业的小伙子。彷徨的在没有家的地方沉浮，好像是生于这个世界，但又融不进任何一个地方。他的第一份工作是在建设的前线。到公司报到之后，有一个为期七天的培训，这七天过得很充实，有讲座，有素质拓展，还有各种丰富的活动，他以为这便是工作。培训到最后一天，团委书记很怜惜的对他和新同事讲，你们要好好珍惜此时此刻，这可能将会是你们今后唯一一次参与这样的活动了。当时的他满怀着一腔热血，不怕苦，不怕难。\r\n工作中的人，有的可爱，有的又是可恨，有的紧着小家，但却失了大家。工作环境的复杂，不是外部，而是人心。老张是施工队的负责人，在他的眼中，大多数时候只有利益。在需要别人的时候，卑躬屈膝，当找他帮忙时，便笑里藏刀，表面答应得好好的，可是转身就抛之脑后。这是最为可恶的行径了，忍不住让人感叹。老张时常在嗟叹，生活之不易，可是却忘了，大家的生活都是不易的，他只顾着自己了，从没想过，在人生的路上，相互扶持，是他的无奈呢，还是他本无心。\r\n他，耐不了人与人之间的这些不真诚，便悄悄地决定走了，每天做着浪费生命的毫无意义的人际交往，这本也不是他期待的生活。其他人都说，搞工程四海为家，而他却觉得那个只是宿舍。换了新工作，他看到了希望，同时又出现了新的绝望。现在住的地方不叫宿舍了，但也不叫家，对于他来说那只是落脚点。他时常一个人发着呆，不胜感慨，诺大的城市，容得下他的，只有几个平米。没有经历过，便都是向往，以前的他，只知隔行如隔山，可是却不懂得，每座山中都有虎。生活的无奈，已经不是无病呻吟的句子，而是赤裸裸的现实。他也不知剩下的光阴是或喜，只是一步一步，走下去。\r\n3 来世 若是有来世，他希望，一切都好。\r\n","categories":["Essay","2017年"],"tags":["散文"]},{"title":"想念挚友","url":"/posts/2017/1AJP2Y0.html","content":"三毛说：“最好的爱情就是相处不累”。我觉得这句话也可以用来形容友谊，最好的友情也便是相处不累。\r\n\r\n去年夏末的时候，我和他相识。他初给我的印象是很阳光，脸上的轮廓略显刚毅，戴着一副黑框眼镜，又显得很斯文。他说话时带着一点甘肃的口音，总是把”yun”读作“yong”，当时听到这个口音的时候，很是亲切，大约是大学有一个好友，也是甘肃的缘故吧。\r\n和他第一次见面是在施工现场的办公室，我不认识他，他也不认识我，虽然见了面，好像也没打招呼。就这样呆了一两个月，慢慢地变得熟悉，熟悉彼此的性格，熟悉彼此的价值观，熟悉对方有没有女朋友，然后就成为了好朋友。\r\n有句话说得很对，只有当失去了，你才会懂得珍惜。我离开之后，才发现那段青葱的岁月，如此值得怀念。自换了工作已有两月余，面对新环境，我战战兢兢的生活和工作着，一个人，一座城，默默地打拼。每天拼命的学习，认识了另外的人，做另外的事，一切，都很累。静下来的时候，总会很想念以前的日子。\r\n我和他的床是对着的，中间隔了一张桌子，是少强留下的，后来又有一张，好像是李伟的。我俩把它们拼在了一起，我在上面放了个简易书架，还养了一盆“小家碧玉”。有时候我会给它拍拍照，他会浇浇水，虽然是我买的，好像更是他的宝贝。\r\n夏天的时候，外面很热，他去买水的时候，总会捎上我的一份，有时候桌上的纸巾用完了，他会多拿出一卷，一卷放在他那儿，一卷放在我这边。上次出去把妹，他还和我商量着暗号，要是钱不够了，打个电话给他，他立马给我想办法，在电话里就问，拆迁怎么样了，拆了一栋就是一千，两栋就是两千，免得被姑娘听见自己借钱，很窘迫，我笑他，我这是举朋友之力追妹子啊。我知道，要是我真这样给他打电话，他肯定会马上帮我解决的。我们的交情不需要在意金钱，只是彼此肝胆相照。\r\n大学就很喜欢吃鱼，有一次，拽着他去了工艺美大旁边吃了那儿的纸包鱼，很鲜嫩，这是第一次吃纸包鱼，后来在其他地方也吃过，可是没那味道，好像从那时候起，他也迷上吃鱼了。有一天，咱俩就约着，把益阳的鱼尝个遍。为了吃一次鱼，我俩先是转了一趟公交，然后打了快半个小时的车，才到城院的小吃街那边，鱼店很多，觅着一家烤鱼店就窜进去了，那儿的鱼也很好吃。\r\n已经离开益阳有一段时间了，有一天晚上，微信振动，是他发来的消息，有一个定位，然后来了句想你了。初听这话，以为他是开玩笑的，居然写得那么肉麻，然后点开定位，突然发现，那是我们第一次吃鱼的位置，他在那边喝酒，应该是喝了有几分了，此时，虽然和他隔了一个省的距离，但仍能感受到那如浓酒般的思愁。我也非常怀念彼此共同度过的岁月，真挚而又轻松，快乐而又写意。人生又哪能轻易找到几个这样的知心朋友呢？\r\n等他来到我的地方，等我去到他的城市，等和他在远方遇见，不醉不归。\r\n","categories":["Essay","2017年"],"tags":["散文"]},{"title":"无邪","url":"/posts/2017/331FR19.html","content":"\r\n\r\n图片\r\n\r\n我痴痴的，寻寻觅觅，那扰人心弦的美。那种美，是一日不见，如三秋兮的思念，是力拔山兮气盖世的豪迈，是谈笑间，樯橹灰飞烟灭的壮阔，是一种，可以让心铭记的画面。\r\n\r\n生命中，见过很多的美，但总是昙花一现，让人抓不住，留不下，又念不起。夕阳西下时分，一对老人相互依偎着，身后的影子，随着斜阳，拖得老长老长，却始终形影不离，这是岁月的美；自习室里，女孩安静的写着作业，风乱了发，男孩瞧见了，便宠溺的将女孩的发丝揽回耳畔，这是青春的美；三两岁的小孩，得到一颗糖就可以开心很久，笑的时候无拘无束，哭的时候撕心裂肺，这是天真的美.…..美无形无相，它可以是感动，可以是伤情，可以是一幅画，也可以是一阵风。\r\n以前，见到美的物或人，便是心旷神怡，然后感叹一句“好美啊”，随后就丢在了记忆的角落里。闲下来的时候，就思考着，究竟什么是美？周末的时候，云儿在天上睡着了，丝丝缕缕阳光便遛了下来，于是决定到昙华林走走。很幸运，遇到了两份让人难忘的美好，瞬间明白了美的真谛。\r\n路过一个小店门前，一只灰色的小猫正匍在地上，头快耷拉到了地板，心情很低落，一点也不搭理路过的人。一位女生从店里准备离开，看到了它，便蹲下身，用手抚摸着猫的脑袋，宽慰这只小猫，似乎感受到了猫的心情，她的神情带着淡淡的忧伤。过了一会儿，小猫扭过头来，心情好了很多，女生收回手，小猫静静地看着她，她也温柔看着小猫，最后，小猫耐不住羞，喵了一声，把头撇了过去，女孩忍俊不禁，扑哧一下笑出来了声。这弯笑容，穿过午后的空气，涤荡在我的心头，至今萦绕在脑海中，不曾消散。我想，这便是一份美，一份善良的美。\r\n女孩后来和同伴消失在了人海，我缓缓的踏着步子，认真的呼吸着每一口空气，收拾着刚刚的好心情，惬意地静静地享受着此刻的时光。走着走着，一家小店吸引了我，不是因为它的名字，而是店的门边栓了一直可爱的小狗。一身金黄色的卷卷的毛，搭着深灰色的流行款式，两只炯炯有神的眼眸，好奇的看着往来的行人，也不知它心里在想着些什么。这时，一个小孩看到了小狗，她手里拎着一小袋零食，准备和小狗分享。可是离得远，于是她想踏上台阶再递给小狗。虽然台阶不高，但对于才学会走路的她来说，很有难度，只能用两只手，平衡摇摇晃晃的身体。小狗见着了，露出期待，小女孩上了两级阶梯，可以够着了，但她想走到平坦的地方，专注的迈着最后一步。这时，小狗的脑袋有点转不动，呆呆的扭过头看着女孩，思考着，她为什么还不停下呢？这画面，虽然简简单单的，却觉得是另一番说不出的美。\r\n\r\n\r\n图片\r\n\r\n女生的眼中，只有猫的失落，她便留下来宽慰；女孩的世界，有台阶和小狗，她便先忘了小狗，小心仔细地踏着步子。美，大约就是如此，简单而专注，不参杂丝毫的杂质，天真无邪。\r\n","categories":["Essay","2017年"],"tags":["生活感悟"]},{"title":"缘起西塘","url":"/posts/2017/3DKZM8Z.html","content":"3年前，初听到西塘这个名字的时候，便烙在了灵魂里，虽从未与她邂逅，但从那个时候开始，就已经喜欢上了西塘。印象中的西塘，应是庭院深深深几许的宁静，是夜船吹笛雨潇潇的惆怅，是巧笑倩兮，美目盼兮的温婉。三年间，去了很多的古镇，只为寻找心中的西塘。到过最大的古镇便是乌镇了，乌镇很美，但是却牵不起一丝记忆的涟漪，自那以后，每看一个古镇，便失望一分，天下的古镇好像都是那般，禁不住深情。\r\n\r\n这个国庆，因为行程改到了上海，便顺道去了西塘，对于古镇，已经近乎失望成绝望，我想，三年前因西塘两字缘起古镇，此刻便从西塘结束吧。尽管烟雨朦胧，风细柳斜，但已心观赏，幸得朋友的陪伴和宽慰，也就不那么在意了。\r\n票是请青旅老板买的，便宜了很多，在老板的带领下，我们走进了西塘，步入古巷的那一瞬间，仿佛空间穿过了时间，回到了千年前的江南。小桥流水人家，古道白墙灰瓦，夕阳西下，佳人腮凝桃花，这才是心中的那个古镇，以前对西塘的误会瞬间释然了，一直误会了西塘这个美丽的地方，误会了西塘这么美的名字。\r\n西塘的美，不似乌镇的雕栏画栋，是一种天然去修饰的朴素。西塘的美，一个人赏，两个人赏，或者一群人，不管你是南方，还是来自北方，都是适宜的。西塘，完全满足了我对古镇的幻想，静若处子，动若脱兔。\r\n落住的的青旅很别致，入口处散落着很多盆栽，高的矮的，有的开着小花，有的松松懒懒的扶在墙上，好像是老板疏于打理，又像是盆栽自己任性，显得那么自由和轻松。推开暗红的大门，便是这间店的大厅，大厅右边一角是登记入住的柜台，不过更像是一个吧台，啤酒，白酒，红酒俱全，精致的玻璃杯，还有几支高脚凳，让人有一种坐上去，和朋友一醉方休，向老板谈天说地的冲动。挨着吧台不远处，摆放着一套茶具，如果喜欢，以茶会友，亦有一样风情。扭过头来，墙上挂着大大的屏幕，放着王者荣耀的比赛，惊险的对战，激情的解说，玩或不玩，都会立足几分钟，细细的感受那份青春的激情。还有一角，立着两个书柜，上面放着当下盛销的书籍。看到这个布局，让人惊讶和兴奋，相互矛盾的东西，在这儿自然的融为一体了。在这家深藏巷子里的店里，你可以自由自在的放纵自己，也可以安静的捧着书卷，心是怎样，就活成怎样，真是一种别样的享受。\r\n西塘的昼，小桥流水，轻舟翩翩，宛如散落在人间的桃源，又如豆蔻的少女，羞红了脸。而夜晚的西塘，性感而奔放，最著名的便是酒吧一条街，各富特色的酒吧挤满了一巷子。踏上这条街的瞬间，一股活力四射的狂野铺面而来，街道两侧，灯光妖娆，烟雾缭绕，音乐在巷子里肆意的宣泄，你可以喝着啤酒，装成失意的少年，搭讪身边的美女，你可以站在舞台上，酣畅的摇摆，你也可以染着爆炸头，穿着拖鞋，在大厅里嚎叫。此时此刻，你便是自己心中的，心底深处的自己。这条街会在晚上十一点准时关门，是想告诉往来的旅人，疯狂之后，及时回家。这便是这条街的魅力。\r\n绕过酒吧一条街，世界又一下子安静了，灯笼红彤彤的，静静的挂在长廊上，很多精致的小店傍水而卧，可以打尖，可以住店。有家店叫做“奶奶家客栈”，以前这位奶奶常被邻居欺负，于是倾尽毕生积蓄，开了这家店，有了生意，生活慢慢变好了，也少了人欺负。还有一家店叫做“西塘记忆”，店里面人很多，但一点也不喧闹，大家静静的听着歌，暖暖的感受着此刻宁静的心情。还有很多店，很多的名字，五姑娘客栈，猫的魔法城堡，声声慢……每一个名字，都有一个让人感动故事。此时，你可以觅一处石凳，静静的坐着，慢慢的品味西塘的夜，让时光随着灯光，留在西塘。\r\n西塘，宁静而淡雅，美好得似一幅泼墨的山水画，舒展在江南的烟雨里。她用一个名字，便醉了一世游人。\r\n","categories":["Essay","2017年"],"tags":["生活感悟"]},{"title":"两个人的上海","url":"/posts/2017/3B8ZFDY.html","content":"\r\n本文仅作纪念\r\n\r\n有一种旅行，不为跋涉千里的向往，只为漫无目的的闲逛，不为人山人海的名胜，只为怡然自乐的街景。或走，或停，都是美丽的心情，这就是我喜欢的旅行。\r\n\r\n国庆之前，计划着去黄山，然后就问同行的伙伴的意愿，她是深圳的，祖国的南方了，我问她，咱们先去合肥，然后去黄山吧，她想都没想，就说：“好”，她当时都不知道合肥会有多远，她可能也不是很喜欢爬山，但就是那么干脆的答应了，我想，她也喜欢这样的旅行，不是走路，而是走心。后来，黄山的票没了，便改了行程，去了上海。\r\n到一个地方，总会想去看看最出名的学校，所以，我们的第一站，就是交大。步入交大，一种学府的厚重气息瞬间扑面而来，里面“康白渡式”的建筑风格处处透露着学府的严谨，散发着求知的精神，虽然它历史源远，但是又让人觉着亲切。只是，我和她对这个没一点研究，就是觉得想去看看交大，即使去看一眼校门，即使留下一个脚印在那片土地上，也是满足的。进了校园以后，她就是觉得好看，我也不问，问了怕她形容不出来，问了怕坏了景致，而我就是乱按一通快门，因为觉得每个角度，都是一幅画，直到后来，她惊讶的说，这是体育馆，你也拍？我就拍得没那么放肆了。现在想想，我当时脑袋应该是短路了，我怎么不拍啊，又不是像湖大，旁边还有一个厕所。不知道她当时为什么惊讶，难道是和我一样，想到了湖大的体育馆？\r\n就这样，两个人，四个脚印，从交大的一头到了另一头。现在的记忆，大部分已经落在了照片里，剩下的，只是一段蜿蜒的路，两个背着包的身影，还有那段静谧的时光。\r\n我和她去的第二个地方，算得上是偶遇吧。乘地铁到人民路站下车，她问我，要怎么走，我说，我也不清楚，那随便选一个吧，她欣然接受了，彼此都不在乎景点在哪儿，因为觉得行过的地方，就是最舒适的风景。出乎意料，我们的选择是一份惊喜，那个出口记录着大上海曾经的故事，拉黄包车的师傅，卖栀子花的小姑娘，还有很多，记不住了…让人如痴如醉。经过一个民国时期的火车站台时，她带着好奇，天真的看着泛着光晕的穹顶，那画面让人感动，我静静地站着，呼吸缓缓的，生怕残了那幅唯美的画，她的景，是那些光，而我的景，是她和光。\r\n穿过人民广场的时候，阳光还是浅浅的，斜着透过大厦，铺到地面，给人干净清新的感觉，看一眼，就着迷了，同行的她瞬间被感染，脚步无拘无束，时而欢快，时而袅袅，仿佛误入了仙境的公主，剩下的只有快乐。我端着相机，她就负责把快乐放在风景里。两个人，玩着玩着便忘了时间，忘了下一站是哪儿，等惊醒的时候，两人会心一笑，背着包，又消失在人海。\r\n后面还去了很多地方，\r\n到了外滩，看了万国建筑，还有东方明珠塔。每个景点都游得很浅，但我们不在乎，她饿了，就陪着她去吃饭，我想看夜景，她便耐心的同行，这已经就是旅行了。\r\n国庆的上海，风景和人各占了一半，而我们眼中的上海，就只有两个人。\r\n","categories":["Essay","2017年"],"tags":["散文"]},{"title":"七月与安生","url":"/posts/2017/2P24YP8.html","content":"有一对闺蜜，一个叫七月，另一个是安生，七月安静，在大人面前表现得很乖，安生开朗，七月妈妈说她什么都好，只是缺了点运气。安生没考上大学，出去闯荡，换了很多男朋友，最后找了个老实人结了婚，过上了相夫教子的幸福生活，七月和男友同一所大学，毕业后谈婚论嫁，所有人都认为他们是最合适的一对，会很幸福，但是他不够爱她，在结婚的时候离去，七月终于找到借口出去闯荡。\r\n\r\n七月过成了安生，安生活成了七月。\r\n恰好，我也有两个朋友，一个叫七月，另一个是安生，他俩是基友。七月成绩一直优秀，初中出去上通宵，第二天考试拿了年级第一，高中走路都在看小说，成绩也还不错，大学成绩差点保研，在所有人眼中他会很有出息；安生浪荡，也很贪玩儿，初中留了级，高中辍学出去潇洒，大学挂科，他有自己的想法，没毕业，自己赚钱买了一辆车。\r\n安生给七月打电话。\r\n“七月，工作怎么样？”\r\n“工作很累，没有休息的时间，感觉整天都在工作，不是我想要的生活。”\r\n“工资怎么样？”\r\n“不怎么样，有点低……”七月心里其实还有一点自豪，因为他的很多朋友工资没他高\r\n“确实有点低啊。我在学校旁边和人开了一个点，每天能赚个2000左右吧。”\r\n七月第一年工作回去和安生见了一面，是安生开车来接的他，安生的车技很好，放的歌不像七月听的那样安静，很激昂。安生很忙，他们吃了一碗面就分开了，安生给七月带去了震撼，七月也想要一辆车，想要安生的潇洒生活。\r\n安生活成了七月想的那样。\r\n七月想去环游世界，想有一辆车，一幢房子，想给父母好的生活......\r\n七月在挣脱。\r\n","categories":["Essay","2017年"],"tags":["散文"]},{"title":"兰州","url":"/posts/2018/202BKMX.html","content":"未见得兰州，便已入了迷。单是念着这个名字，脑中便不自觉的浮现出她的身影，仿佛一位慧质兰心的女子，一袭碎花长裙，恬静地立在黄河边上。兰州，是和大理一样浪漫的地方，未识得时想念，遇见了眷念，离开后又是挂念。大理的浪漫是邂逅和放纵，多是妖娆。兰州的浪漫，则是细水源长，缠缠绵绵，秀气而清纯。\r\n\r\n喜欢兰州，就像爱一个人，不是因为她美得惊艳，而是她懂你的心，她的味道是你喜欢的，她的样子是你喜欢的，她的性格也是你喜欢的。初到兰州时，天灰蒙蒙的，她就像伊斯兰教的女子，用头巾掩了自己的美丽，不想让人瞧见了。想到这儿，我不禁婉尔一笑，看来只能自己慢慢去体会了。\r\n第一个接触的是兰州拉面。拉面馆就餐的流程和南方不大一样。你需要先在前台为自己的食物埋单，然后服务员会根据你点的东西给你相应的小票，凭借小票到相应的区域领取食物。做拉面一般有三个伙计，一个揉面，一个拉面，最后一个负责煮面。揉面是一个体力活，有的伙计比较瘦小，便将面团放在案板上，左手按着面团，右手盖于左手，然后猛的跳起，借着落地的动能加成，将面团揉匀。拉面的师傅技术高超，往往一团面上手，一拉一折，面条就已经成形了，侧身便把它投入沸水中。煮面师傅估摸着时间捞面，然后两勺面汤，一把葱花，一撮牛肉，三勺辣椒油，一碗地地道道的兰州牛肉拉面便成了。\r\n在冬天里吃一碗牛肉面是最幸福的事情了。用筷子挑起几丝面条，还没送到嘴里，你的所有细胞便已被牛肉面的香味征服了。此时，也顾不得谦谦君子，窈窕淑女了，只想一口接一口地吃下去，末了，还得喝下去半碗汤才感觉到知足。兰州牛肉面就这样牵走了每一个陌生人的心。\r\n兰州的美食，大多为清蒸，这样的烹饪方法，保证了食材最天然的味道，清香又自然。手抓羊肉便是另一道美食，羊肉不加任何佐料，只是放了盐，但是却没有羊肉的膻味，惊叹兰州人可以把烹饪简化得如此极致。吃手抓肉也是有讲究的，剥一瓣生大蒜，挑一大块肉，一起放进嘴里，蒜去了羊肉的腻，羊肉则缓了蒜的辛辣，但又都保留着彼此的原汁原味，实在是一番美妙的体验。兰州的美食，不像南方总是藏在深巷子里，你只需找一家清蒸餐厅，便可揽尽大部分美食了。羊膝盖泡饭、凉拌小葱、牛奶煮鸡蛋、还有脏脏梨（这是一个朋友这样叫的，原名叫软儿梨）都让人回味无穷。\r\n谈到兰州，除了吃，一定少不了的就是中山桥了。对于桥，我总是有一份特别的感情，走在桥上时候，仿佛可以感受到它跨过一个又一个岁月的艰辛和倔强。长江上的大桥，冷得让人难以亲近，而中山桥，虽然是用冷冰冰的钢铁建成，但是它却用那厚重的历史，压住了钢桥的凌厉，一眼望去，便是它的浪漫和故事。明朝开始，人们便在这儿建起浮桥，把船码成一排连好，在上面钉上木板，方便人们的出行，在当时称为镇远浮桥。1907年，由陕甘总督升允牵头，美国人设计，德国人制造材料，中国人建造，历时三年，耗费三十万六千两白银终于建成了当时黄河上真正意义上的现代桥梁，素有“天下黄河第一桥”的美称。\r\n中山桥从风雨飘摇的晚清走到了现在，他亲眼见证了泱泱大清的坠落，和苦难的中国人民一起经历着漫长的销烟和战火，看着一个又一个熟悉的人辞世，剩下了他一个人失落和寂寞，我想，今后再也没人能够绘声绘色地讲中山桥的故事了。一座桥，走过苍桑的岁月，一座桥，跨越百年的历史，当你缓缓地走在上面，手指轻轻拂过一颗颗螺钉，仿佛时光倒转，你能够切切真真地感受到已经翻过去的一页页历史。\r\n兰州另一个让人忘不掉的地方要数五泉山了，五泉山全部由黄土堆积而成，但却呈山之宏伟之势，绵延起伏，雄伟壮阔。未亲至，是很难想象得出它的震撼。五泉山因有五口山泉而得名，五泉之中，数摸子泉最为有趣。摸子泉位于摸子洞中，洞深14米，两侧石壁上凿有佛龛，到洞最里面之后，再下5级台阶，就到了泉边。泉为方形，水深约半米。以前寺内僧人在泉中置石子和瓦片，求子者摸到石子生男，摸到瓦片生女。常有信男善女钻进洞中，用手在泉水中摸索，刘尔炘曾在洞门口书一对联，嘲讽这种迷信行为是“糊糊涂涂将佛脚抱来，求为父母；明明白白把石头拿去，说是儿孙。”\r\n五泉山的建筑多为佛教古建筑，层楼叠阁，采用歇山式屋顶，建筑斗拱飞檐，雕梁画栋，结构精巧，气势庄严。楼阁依山而建，错落有致地立在黄土坡上。每一处都是一幅精美的画，初见时，总会想挑最好的先看了，但又觉得每一处都有各自和妙处，舍不得落下任何一个角落。\r\n兰州，最让作为南方人的我欢喜的便是在太阳高挂的时候，还可以看到厚厚的冰了。有的冰很薄，你可以一边沐着阳光，一边踩着冰，一脚下去，冰便伴着呲呲的声音，脆裂开来，此时心中所有的思绪都跟着冰的破裂化了，纯净又无拘无束，真想一直就这样挥洒着烂漫的时光。\r\n去到兰州，一定要感受一次西北的烈酒，一口下去，那种粗犷豪放的味道，拔动你的灵魂，你心中只剩下一个念头，喝不过我还吐不过吗。一方水土养一方人，这句话一点也没错，才到兰州两天，我就已经迷恋上了大口吃肉，大口喝酒的畅快了。到主人家做客时，动筷之前，热情的主人会用一个盘子，盛好6杯烈酒，端至你面前，表达他们对客人欢迎和祝福。如果席间恰好有兰州姑娘在，她们便会打着节拍，用兰州话唱着简单的调子，为客人助兴，宜杯呀宜杯…量杯呀量杯…\r\n三杯呀三杯……盛情难却，只好一杯接一本杯，不负主人家的热情。\r\n兰州的魅力，在山里，在水里，在可爱的文化里。轻轻至兰州，浅浅地邂逅，魂牵梦萦\r\n。\r\n","categories":["Essay","2018年"],"tags":["生活感悟"]},{"title":"一生一世相依","url":"/posts/2018/36GBYZE.html","content":"哐铛哐铛……绿皮火车缓缓地往北驶去。我和老伯坐在小板凳上，静静地听他回忆着自家大壮和妞妞的故事，渐渐地入了迷。\r\n\r\n\r\n图片\r\n\r\n那年初夏，春刚走，还未来得及带走绵绵的细雨，他正欲拢上窗子时，两只鸽子扑腾着翅膀从眼前掠过，匆匆地赶到了对面的飘窗下避着雨。一只鸽子的体型稍小，雪白的羽毛，应该是雌鸽，另一只是雄鸽，体型很壮，羽毛也很漂亮。雄鸽落地后，警惕地左右张望着，等确认安全了才放松下来，它往雌鸽边上挪了几步，雌鸽也向它的身边紧了紧。雌鸽的羽毛被雨扰得有些乱了，它便用嘴给雌鸽梳理羽毛，雌鸽会偶尔抖抖身子，然后又亲昵地蹭蹭雄鸽的脖子。\r\n\r\n他以为雨停了，这两只鸽子便会离开。可是不久后，两只鸽子却叼来树枝和小草，开始筑巢。筑巢安家是很辛苦的，但它们还是很开心，累了便依在一起，靠着自己的小窝，幸福地期待着。过了些日子，他突然发现鸽子夫妇俩已经开始孵窝了，这说明它们已经结下了爱情的种子，白天鸽爸爸留在巢里孵卵，让鸽妈妈出去觅食，天快黑的时候，鸽妈妈便来替它。\r\n这样的日子平平淡淡，但是也洋溢着幸福。这天，鸽爸爸如往常一样，一边细心地呵护着宝宝，一边期待着妻子归来，太阳已经完全落下了，鸽妈妈的身影还是未出现，鸽爸爸等着等着，便着急了。夜里，他只听见振翅声无数次焦急地划破夜空，还有归巢后的哽咽。第二天起床打开窗户看去，鸽爸爸已然憔悴了，身上的羽毛乱乱的，早已经无心打理，只是呆呆地孵着它们共同的宝宝，眼里满是神伤，鸽妈妈应该是遇难了。它偶尔会出去觅食，但几分钟便又回来了。\r\n他是爱鸽人，也养鸽，看着这对野生的鸽子夫妇，原本美满的生活就这样支离破碎，凄凄惨惨，他不禁惋伤。有时候打开窗子，一看就是几个小时。这天他如往常一样，走到窗前准备打开窗子，鸽爸爸见到他出现后，扑腾一下，落在了他家的窗子前，看着他，然后扭过头去看看自己的宝宝，又对着他咕咕两声，便飞回巢去了。一会儿，鸽爸爸起身，好像是去觅食，但才飞到半空，盘旋着又飞了回来，看了一眼未出生的宝宝，又朝着他看了一眼，然后一声凄鸣，冲天而去，再也没回来。\r\n听到这儿，我很是震惊，原来鸽子的爱情是这么坚贞。回过神来，我问到：“那大壮和妞妞是它们俩的名字吗？”\r\n“大壮和妞妞啊，不是。大壮是它们俩的孩子，妞妞是大壮的伴侣”。我知道故事还有很长，便听着他断续讲下去。\r\n那天他见鸽爸爸久久没回来，大概也猜到了，可能它是再也不回来了。他想，毕竟看着这俩孩子在这儿成家立业，一起度过了那么久的时光，也是有些感情，鸽爸爸也算是临终遗孤，便去对面邻居家，把那两个鸽蛋取了回来，让自家的鸽子帮着孵化。\r\n几天之后，一个蛋的壳破裂了，那对鸽子夫妇的生命终于得到了延续。而另一个蛋则再也没有动静，大约已经见到它的父母了。他见到这个小家伙出生，很是欣喜，给它取了个名字，叫大壮，希望它能够健康地长大。\r\n大壮是个好孩子，一个月之后就可以在天空飞翔了。他给大壮做了一个名字的二维码，系在它的脚踝上，养鸽子的一般都会这么做，只是别的鸽子的二维码信息都备注有父母是谁，而大壮却是没有。大壮很争气，它对于新技能总是能很快的掌握，从熟悉巢房到信号辨识，从掌握飞翔到识别方向归巢，它总能很快地学会。令他印象深刻的是，还未满一周岁，它已经能够从300公里之外自行回家了。\r\n鸽子能够飞300公里，说明血统很优秀了，于是他寻思着是给它找个优秀的伴侣，便把妞妞介绍给了大壮，他把它们放在一个鸽舍里，促进彼此交流。大壮和妞妞第一次见面，便一见钟情，但彼此都很羞涩，呆立在笼中一动不动，谁也不先搭理对方。这时，他想到一个好办法，分别在他们俩身上洒上一些水，大壮和妞妞觉得身上不舒服，都梳理着自己的羽毛，我抬头看看你，你抬头看看我，两只鸽子看着对方的举动，都觉得对方对自己有意思，然后这就成了。\r\n从此，他们成双成对，形影不离。闲的时候，彼此拾掇着羽毛，调皮的妞妞会偶尔啄一下大壮的头，等大壮正要怒时，又把整个身体凑过去，给一个安慰的拥抱。大壮在放飞训练中，总会照顾着妞妞，总是一直跟着妞妞，怕它找不到回家的方向。放飞时间，是它们最浪漫的旅行。在那段时光里，大壮和妞妞是鸽群中最幸福的一对了。\r\n我打断他的话问到：“你养了那么多鸽子，他们不会去找别的鸽子相好吗？”\r\n“鸽子和我们一样，也是一夫一妻制的。”说完他继续回忆着。\r\n他家在山东，一次受朋友之邀去重庆的时候，他便把大壮和妞妞带在身边，到了重庆，就让它们各自飞回家。等他回到家时，只有妞妞一只鸽在鸽笼里神情郁郁，含泪伤心。过了一个月，再也没见到大壮的影子，他知道，大壮是在途中遇难了。而此时的妞妞，连叫唤也不会了，身体也越来越虚弱，不久，它便满足地离开了这个世界。\r\n至此，他的故事讲完了，随着火车的哐铛声，缓缓睡去，而我则久久地沉默了。它们没有法律的约束，没有道德的谴责，却忠诚着爱情，一生一世，至死不渝。\r\n","categories":["Essay","2018年"],"tags":["生活感悟","鸽子的爱情"]},{"title":"即使再微末，也要幸福的活着","url":"/posts/2018/38WXA9N.html","content":"蝼蚁尚且偷生，可偷来的生命有何意义，只是活着吗？\r\n俯仰天地，大地和星空一样寂静。车如流，来来往往，从归处去，便又从去处归；人若蜉蝣，纷纷扰扰，用百年光阴，在历史中苦苦争渡；苍生无力，沧海桑田，只任大势起起落落。太多的活着，最后都是轻轻地走了。\r\n\r\n我有些恐惧了，恐惧平凡而没有思想地活着。假如时光可以跳跃，我希望去我离开的那天，问问自己：“这一生，是否溅起了生命的涟漪”。\r\n春节回家时，遇到了两件事，仿佛晴天霹雳，霹散了心中一直的迷惑，让我明白，生命的意义不在于活得重，而是活得幸福。\r\n一个文静的女孩，扎着精致的马尾，独自拖着不大不小的行李箱，走到一家周黑鸭的店前停了下来，服务员微笑着问道：“您好！请问需要什么？”女孩点了下头，没有接话，而是扫了一眼柜台，发现一张清单台卡，径直地走过去认真地看了几秒钟。见服务员等着自己，她便用手指着两个名称，示意她的需求。服务员会意，把东西打包好之后，礼貌地递给女孩，然后露出询问的表情说到“一共44块，支付宝还是微信？”，女孩失了听力，不能听见，但是很郑重地点了下头，好像在说“好的，我知道了”。接着掏出手机，扫了码之后，又让服务员输入金额，顺利地完成了这次购物。\r\n我从未敢想，一个失聪的女孩可以如此独立和坚强。她眼眸中的那份宁静，浸人心扉，让人有一种感觉，仿佛在她的心里，有她自己的一方国。那个国度，纯净，安宁，幸福。\r\n在排队取票时，又一幕画面扣动了我的心弦。一位清洁工老爷爷，正在收拾栏杆旁边的垃圾，他大约6旬有余了，胡渣和头发都有些花白，岁月在他身上留下了深深地痕迹。这时一位老奶奶，蹒跚着向着他走去，老奶奶一只脚以前受过伤，左脚偏低，走路有些吃力。他抬头间不经意看到了她，于是放下手里的活儿，一手扶着扫把，立在那儿一直看着她，眼神中是柔情，又是担心。\r\n老奶奶走到跟前，从衣兜里掏出一瓶酸奶递给他，他推脱不肯要，她就佯装不悦，他一下没法了，笑了笑，只好把它放进衣兜里，她见了，一下子笑逐颜开，又跛着脚去忙了。等我取完票，见他正坐在旁边的凳子上，喝着酸奶，静静地看着她离开的方向，嘴角偶尔勾起一弯会心的微笑。\r\n他们虽然干着脏乱的工作，拿着微末的工资，过着紧巴巴日子，但是他们相互温暖、相互给予、相濡以沫，又相守一生。\r\n以前觉得幸福是在天上，站高了才够得着，现在发现幸福其实就在身边。即使再微末，活得认真了，便是幸福。读一本书是幸福，行一里路是幸福，发一阵呆也是幸福……\r\n我想，假如我是一只蝼蚁，我也会想要活着。\r\n","categories":["Essay","2018年"],"tags":["生活感悟"]},{"title":"触及灵魂的旅行","url":"/posts/2018/39BM7K7.html","content":"\r\n\r\n图片\r\n\r\n元旦之前和朋友定好去宏村，因朋友有事，便不能同行，自己期待的元旦计划就这样搁浅了。大约自己是一个执拗的人吧，说好的出行，如果不去做，便如哽在喉，念头不通。于是便决定一个人去登泰山，体验“岱宗夫如何？齐鲁青未了”的雄浑壮阔。\r\n\r\n就这样，一人，一个念头，一张票，便随着火车的哐当声，在墨色的夜里缓缓地朝着北国而去。先是去济南，坐火车大约要14个小时，因为是临时起意，只有站票了。上车的时候，车里挤满了人，费了老力，才上得了车，虽然过道里很挤，挤得只能容下两只脚，但大家的脸上却洋溢着幸福和满足，因为坐上车就代表着离自己期待的地方越来越近。我想，自己能够有一张票，也很幸运了。\r\n毕业之后，就很少坐K开头的车了，却是不知不觉的，学生时候的乐趣也慢慢隐去了。读书那会儿，只能买得起普通火车，遇上节日时候，不好买票，只得站着去学校，一次就是10多个小时，当时也不觉着难受，毕竟咱都是从艰苦环境下磨砺出来的孩子。工作后，反而更喜欢普通火车了，高铁什么的反而觉着无趣。在火车上，最幸福的事便是遇见，遇见天南海北的人，遇见不同的故事，遇见一段美好的回忆。\r\n火车上有趣的事情可多着呢，要是周围同龄人较多，则大家相互邀请一下，凑一桌便开始玩游戏，我是很期待遇到很多人，这样就可以玩狼人杀，这游戏让人入迷，往往是旅途结束之时，意犹未尽。如果全是伯伯婶婶，那也是美好的一次经历，可以感受他们经历岁月沉淀之后的人格魅力，有人若泰山稳重，有人似鲲鹏洒脱，有人又如烈火炙热。在火车上，我是你的路人，你是我的过客，每位旅客，便如人之初生，与周遭无因无果，但每一个人，又从心底里散发着善良，见着站票的，大家会挤挤，空出一个位置，实在不能挤了，有人会在中途起身活动活动，让个位置给需要的人休息，这种在艰苦环境下体现出来的人性，便是旅途中最美的风景。\r\n途中和一位伯伯一见如故，和他聊了大半宿，相聊甚欢。他从少年聊到中年，从山东聊到益阳，从烧瓷聊到养鸽，听着他娓娓道来的经历，自己好似淌在他的时光里，感受了另一番生活的精彩。旅行不在乎终点，当你踏上远方的路时，旅行就已经开始了。\r\n到济南的第一个景点，是趵突泉。趵突泉，是藏在记忆中的美，在小学时，便已初闻其名，现在记忆已经模糊了，若平时不经人提及，断然没有它的印象。但当你与之邂逅时，那尘封的记忆仿佛破茧化蝶，悉数涌来，“一溪活水，清浅，鲜洁，由南向北的流着”，老舍笔下的趵突泉印象在这一刻和现实完美地契合了。它的美，就像它的泉水，秀气中带着婉约，走得稍急，便会与它擦肩而过。\r\n趵突泉于我来说，景致未有多么惊艳，只是如愿以偿吧。但是到大明湖一游，让我一下就满足了。湖岸垂柳依依，仿佛纤纤女子，微风轻拂，便摇曳着身姿，清扬婉兮。柳隙间，亭台楼阁若隐若现，走近细看，却是红柱青瓦，雕梁画栋，古朴而典雅。置身其中，好似时空错乱，让人觉得是在江南的画里。放眼望去，碧波浩淼，别有一番味道。大明湖不似西湖的水，柔情，又不像天池的水，超然，而是带着一种皇家的贵气。\r\n痴迷于眼前的如诗如画，心中念着“大明湖”这几个字，总觉得似曾相识，直至湖畔，才应景而出一句“皇上，您还记得十八年前大明湖畔的夏雨荷么”，恍然大悟，原来这便就是那个大明湖啊。夏雨荷在这儿邂逅了她的爱情，但这爱情却让她等了一辈子，恨了一辈子，怨了一辈子，想了一辈子，可她依然感激上苍，因为有这个可等、可恨、可怨、可想的人，让生命不再是一口枯井，不再了无生趣。大明湖的爱情，让人不觉得凄凉，更多的是感动。\r\n太阳渐渐落下，温暖的金黄洒满了整个湖面，然后夹着波光，挤满了每位游人的眼。我看过去的时候，夕阳正停在柳梢，配着冬日淡淡的青，颇有一种村廓斜阳醉晚归的味道。我沿着湖堤，悠然地迈着步子。时而思绪飘远，鱼跃为鲲，翱翔九天，有一种吾身非本身的超脱；时而眷恋红尘，一木一草，行人纷纷，移步是景，如此是随意，是惬意。\r\n一个人旅行时，时间完全是自己的，可以恣意地懒床，可以被风吹得潇潇洒洒，可以过得像吟游诗人一样，天大地大，海阔天空，自由自在而不拘一格。\r\n到泰山山脚时，已经上午11点了。泰山之途，不似华山险峻，十八盘是泰山最险的一条山路，共有石阶1600余级，两山崖壁如削，陡峭的盘路镶嵌其中，远远望去，恰似天门云梯，蔚为壮观。登顶泰山之后，首先经过南天门，然后是天街，最后上至玉皇顶，登泰山，就如凡人修仙，达至南天门便为修成正果，然后每再往上一处，视野和体验又不一样，但每一个地方，都浸染着浓厚的道教文化。玉皇顶是泰山最高处，耸入天际，顶上建了一个院落，中间置着一个香炉，据说在此祭拜，可直达天听。\r\n有人问我，年末是最冷的时候，你为什么要选择去爬山，不怕冷吗？我说，在最冷的时候，登上周围最高的地方，感受着刺骨的寒冷，这是一种体验，也是精神的升华。是的，迎难而上，战而胜之，这是最美好的事情。\r\n太阳快下山时，泰山上的温度骤降，但是我们依然留在观月台，陪着2017年最后一个夕阳缓缓落下，然后对着它大喊，太阳再见，2017再见！登最有名的山，喝最寒冷的风，观最珍贵的日落，这一切是如此的美好。\r\n夏丐尊先生在《生活的艺术》中写道：在弘一法师的世界里，百衲衣，破毛席，毛巾一样好；青菜，萝卜，白开水同样好。旅行于我来说，亦如是，不观景，只过心。\r\n","categories":["Essay","2018年"],"tags":["生活感悟"]},{"title":"黄山游记","url":"/posts/2018/2TJN1ZF.html","content":"\r\n\r\n图片\r\n\r\n薄海内外，无如徽之黄山，登黄山天下无山，观止矣！\r\n去年国庆之时，便心心念念地想一揽黄山美景，今清明时节，终如愿以偿。未至黄山，便被诗人的描述掳了所有的心思，峰峰寒列簇芙蕖，静想嵩阳秀不如。清明多雨，天公好似为了应景，举国降温。一下车，便是一股寒气扑面而来，透过衣裳，冷了每一寸肌肤。如此天气，有些让人失望，心想，虽然明天的黄山之旅可能无所收获了，但既来之，则安之，若不去走走，又空留遗憾。\r\n\r\n睡得早，起得也早。6：00左右就出发去了换乘中心，排了一小会儿队，买了票便乘大巴前往景区大门口。黄山上山有两条主流的路线，一是前山路线，另一条是后山路线。因为一个人，所以基本没有做攻略，只有一份不完全的地图，但人大胆子粗，任它天大地大，我亦仗剑天涯，稍一考量，就往后山奔去了。\r\n因为山大而时间紧，所以我选择索道上山，步行下山。刚下索道，所有风景便若大江决堤，奔腾汹涌而至。那一刻，我才真正体会到，黄山的美，不是清秀，不是婉约，而是波澜壮阔。下索道的第一个地方是白鹅岭，站在它的观光台向下远眺整个黄山，只见巨峰与天穹对峙，虽各有高低，但无一不巍峨雄伟，峰峰拔地而起，顶天立地。云雾穿梭缭绕，雾借山势，山依雾浑，风起而雾涌，只一眼，心中便顿生万丈豪情，人生纵是千磨万难，我当以一力破之。\r\n感谢路人朋友这么好的技术\r\n到的第一个著名景点是石笋是一个动人心魄的地方。石笋矼在黄山始信峰与仙人峰之间。矼上怪石参差，犹如雨后春笋。石笋缸的观景台削峰而成，上下皆虚空，不知几千丈。正当我惊叹于大自然的鬼斧神工之时，突然生起一阵狂风，风势比山势更险，转瞬之间，谷底云雾上涌，无边无际，于上观景，真是飘飘然如遗世独立，羽化而登仙。\r\n[图片](http://a3.qpic.cn/psb?/V118G3dh0IatwX/YK3fQrxUz9oOaG1SuMXpo*zIz4VuD2JhzZdA6OQhSHw!/b/dCIBAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=gAc4BAAAAAAREJw!&amp;t=5&amp;tl=3&amp;su=0144353185&amp;tm=1566104400&amp;sce=0-12-12&amp;rf=2-9\r\n“石笋缸云雾汹涌”）\r\n从石笋缸往前走一小段，便是著名的始信峰。入画境，似幻而真，凸起于绝壑之上“”\r\n黄山另一处胜景是西海大峡谷。峡谷步道多是在险峻的崖壁上人工挑梁，然后铺以面板而成。其险可比华山，但又不让人生惧，你可以坦坦然行立，施施然观景。在谷中放眼四顾，只见山依山、山套山，层次分明、壮阔奇特，令人叹为观止。初至此地，初见此景时，心中不禁万分欢喜，风景太美了，刚揽一处胜景，又迫不及待地期待前面的惊喜，一不留神便从山顶走到了谷底，最后只能一步一步从谷底爬回到山顶。\r\n[图片](http://a3.qpic.cn/psb?/V118G3dh0IatwX/vnTQhNNiNr4hkLQcW2dtORfN2W4a9qwcNEgfwsjRDjw!/b/dCIBAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=VAY4BAAAAAAREEk!&amp;t=5&amp;tl=3&amp;su=0228506593&amp;tm=1566104400&amp;sce=0-12-12&amp;rf=2-9\r\n“西海大峡谷”）\r\n到黄山，飞来石是必须要去的地方。女娲补天，红楼梦，天外之石，一个个尘封的记忆便瞬间喷涌而出，时空倒转，本是虚幻，却又那么真实，你与它千载轮回修得。倚于飞来石，俯仰之间，不禁相叹，人力有尽，造化无穷绝。\r\n黄山另一特色便是它的水。山间清泉叮咚，山伴水的温柔，水染山的苍翠，移步间，或是清泉侧畔，或是潺潺声绕耳，即便是人工开凿的小道旁，也会偶尔拾得一泓泉水。要是渴了，便掬几捧山泉，痛饮而下，它是那么地甘甜，清冽，夹着自然的清新。游黄山，便当是这样，身与心与之交融，这比任何纪念品都有意义，让人永远地记住了它的味道。\r\n每登一座山，便是一个故事。登徵之黄山，若红尘入仙境，洗涤心灵，又好似在那泼墨的山水画中惊世一梦，如梦幻泡影，美得流连忘返。\r\n","categories":["Essay","2018年"],"tags":["生活感悟","黄山"]},{"title":"悟道武当","url":"/posts/2018/2HSM119.html","content":"争渡凡尘三千丈，悟道武当尽斜阳。\r\n武当之美，隐于不秀，不奇，不险，乍看之下，除去青葱，放眼尽是平凡。若是匆匆归去，大多是无所得，无所感。至武当，心中需是无涟无漪\r\n，心与身融，身与山合，细细地品味它承载的精神。正如道德经中所述，常无欲，以观其妙，常有欲，以观其徼。\r\n\r\n\r\n闻道，是从很小的时候开始的。父亲有一方道印，是爷爷传下来的，上面刻了一道符咒灵符，每当亲人远行之时，便会在印堂之处盖上一方，说是用以镇压气运，驱吉避凶。爷爷是一名道医，他还在世的时候，经常出门云游四方，途中遇上人家有人生病，有婚丧嫁娶的，都会请他去帮忙，或是治病，或是作法，亦或是算算黄道吉日。有时一去便是好几个月，孤身万里游，问路白云头，好不逍遥自在。\r\n虽未入道门，却早有一颗道心。踏在武当山的大地上，一步一步，无思无想，慢慢地自己就进入了一种奇妙的境界。仿佛一下子踏过了红尘，无尘无垢，无忧无虑，心思登至处,目极仰苍穹。此时你会发现，自己的心已然入道，仿佛任它无尽岁月磨砺，依旧是亘古唯一，而周遭的纷杂，不再扰人，不在忧心，都是合乎道的美。有人抢座，也有人让座；有人骄横，也有人谦逊；善人行恶，恶人至孝，一张一驰，阴阳相济。当所有好的，不好的画面淌过你空明的心里，你会觉得这都是美好，是一份可遇不可求的生命印记。\r\n\r\n武当山，不知不觉便让人的心灵返璞归真。恰至逍遥谷，只见一溪活水，清澈如带，于山间叮咚而来。溪水浅浅，漫在大大小小的鹅卵石上，时急时缓。溪中小鱼数十,皆若空游无所依，日光下澈，影布石上，佁然不动；俶尔远逝，往来翕忽，似与游者相乐\r\n。\r\n邂逅此情此景，心中不胜欢喜。脱下鞋子，将裤角卷至小腿肚，无拘无束地淌着溪水。把脚丫埋进水中的细沙里，犁出两条长长地印记，静静地感受着沙子挤进趾间，然后又从脚背滑过，心底尘封的记忆一下喷涌而出，恍然大悟，这便是童年的味道。这个时候，几个小孩赤着脚丫来到水里，玩得不亦乐乎。有个小男孩，拿着一个空瓶在那儿专注地捉鱼，他把鱼赶到浅水边，然后用瓶口对着鱼儿，希望鱼儿自己主动钻进去，可是小鱼儿根本不理他，自顾地游了一会儿，便从旁边溜走了。小男孩见了，又去把它赶回来，一会儿，鱼儿又溜走了……鱼儿和男孩俩就这样，你来我往，乐此不彼。\r\n平常人顿悟只是刹那，心中波澜一动，便又跌落凡尘，念三餐一宿，忧生老病死。我不禁忧思，余下人生漫漫，是否家人安康，是否事业有成，是否不负韶华？当在金顶看到朝阳冲破黎明的那一刻，我对于人生的恐惧一下释然了。破晓时分，天边渐渐发白，然后一道红霞倏忽出现，横跃于天际，一会儿功夫，整个东方便弥满了朝霞。太阳在此时睁开了眼，它出现的那瞬间，天下褪尽黑暗，它要有光，于是便有了光。\r\n\r\n我要人生无憾，于是便无憾。\r\n","categories":["Essay","2018年"],"tags":["生活感悟","武当"]},{"title":"假如即将死去","url":"/posts/2018/27Y513A.html","content":"刚好凌晨，往窗外一瞥，在玻璃里便遇见了思考的自己。我和他安安静静地对视着，他模仿的我表情，我复制他的动作，在这无尽的黑夜里，倒也是有趣。\r\n\r\n他对我说，他在思考，假如现在即将死去，那生前的经历，是否足以瞑目？\r\n\r\n我也在沉思这个问题，并努力地回想前二十几年的记忆，恍惚间，忽然发现我就像一名演员，一直在一个剧本中兜兜转转，吃饭，喝水，学习，工作，过着浅薄，空虚和充满麻烦的生活，本色地出演着红尘这部大戏。直至死亡时，可能自己都认为这就是人生。\r\n越细想越觉得甚是恐怖，如果我们维度以外还有第四维的生物，那么我们存在的作用就像是在绘制一幅画卷而已。在四维生物的眼中，若把空间当作时间的因变量，那么每个人便仿佛一枝画笔，他的人生，只是一条弯弯扭扭，来回曲折的线条，出生是线条的起点，死亡是线条的终点，一个人，一条线，线的结束，于他们来说，只是画卷的一笔，对我们来说，却是人生的终止。\r\n但又有线条不一样，同为线条，有的是五颜六色，引导着其他线条的走向，有的则是平平淡淡，碌碌无为，只能化为笔墨下的点缀。生命只有那么长，有的生命逝去了，就像他不留恋这世间一样，世间也渐渐抹去了他的痕迹；有的生命虽然消逝，但是他的印记却耐住了时间的磨炼，恒远流长。\r\n究竟是什么造就了这么大的差异？是思想，是境界，是精神。\r\n一代诗人屈原，虽然死在了几千年前，但却永远的活在了人们的心里，他的死亡，只是肉体的消散。而那个时代更多的人，死亡了，便就永远不在了。这就是自身精神境界的不一样，屈原的思想在肉体存在的时候，便可通透万古，最后化为千古绝叹，留传世间。想起一个朋友曾经说过，每个人的精神应该要一直在远行，我觉得这很有道理，人除了在现实生活中存在，还应该构建自己的精神国度，在精神国度中活着。虽然我们是一条线，身不由己，但是我们可以选择在自己的精神国度灿烂。\r\n这让我想起一件往事：有一次和同事一起回家，路上偶然抬头看了一眼天空，只见晚霞和白云一齐落在天际，我不禁欢喜，掏出手机，拍了一张。同事问我“你很喜欢拍照啊？”。我当时镇了一下，他为什么问我这个问题，而不是被这个美景所感动呢？现在我大约明白了，一个人若是只跟着原始意识生活，而少了了精神上的生活，即便是置之美也浑然不知。相反，有精神生活的人，生活的艰难也难以在他的身上刻下烙印。\r\n阅读则可以丰富我们的精神生活，读万卷书犹如行万里路，生命短暂，没有什么是比阅读更快的交通工具了，在有限的生命里，我们用阅读来延伸生命，用思考给精神提供远行的动力，让思想行过时间，行过空间，最后抵达永恒。\r\n假如即将死去，我该要含恨了。庆幸的是，人生距离终点还很远，我可以好好走下去。\r\n","categories":["Essay","2018年"],"tags":["生活感悟"]},{"title":"张家界游记","url":"/posts/2018/DRBTMR.html","content":"2017\r\n年的年假还没过完，便买了车票奔向项目部，因为年初的原因，直达的票很难买，我便取了个折中的办法，从黔江坐汽车，经过秀山，再途径张家界，最后坐火车到项目部。\r\n\r\n自从毕业之后，就没有正正经经的出去玩过，趁着假期，到心心念念的张家界看看。为了这个心愿，特意买了一个单反，然后就坐着车抵达了。初五的下午抵达张家界，安顿好到之后，便一个人出去觅食，打了个的士，在地图上很近，但是居然要我10块钱，有一点不愿，但是想想，自己是出来玩儿的，为嘛那么斤斤计较，开心就好，便很高兴的上车了。\r\n来到步行街，走了一大圈，居然都没有发现一个比较平民的能填饱肚子的地方。最后地儿是找到了，但是真的贼贵，一个茄子要10块，这导致我今天的晚餐就是一个茄子。\r\n最后去超市买了一堆零食，然后看看时间还挺早的，就去网吧呆到11点的样子，玩儿了一会儿天刀，玩儿了几把英雄联盟，唯一的感受就是，卡蜜儿有时候厉害，有时候又是弱鸡。\r\n回到住的地方已经12点了，折腾折腾wifi，看看电视剧，居然已经到3点了。心想，明天还要去天门山呢？这个状态怎么能够醒得来啊！简直了，然后设了两个闹钟，一个6:45的，一个7:10的，可是后面的一个闹钟没响，导致睡到了9点，起床洗漱，然后准备出发天门山。\r\n来到售票大厅，我的天，那么长的队，得到天黑啊……干脆算了，去报个团，明天游一天吧，今天就回去上网好了。来到旅行社一了解，得知张家界森林公园这一个地方，于是又坐车到张家界森林公园。这儿的风景确实不错，一张门票可以使用四天，可是当我看到地图的时候，四天哪能够游完啊！沿着台阶，慢慢的登顶。因为天气冷，又下雨，地很滑，走得很慢，沿途的风景很美，山也很壮观。来到黄石寨顶的时候，眼前豁然开朗，有一种千里冰封，万里雪飘的爽飒和壮阔，有一种白装素裹的妖娆，有一种海阔天空的舒畅。\r\n下山坐了一次索道，这是我人生中第一次坐索道，感觉很好，不是很怕，但是天气原因，雾气太重，看不清下面的风景，我想，夏天应该会很好。\r\n晚上回到住处，发现没什么事儿干，去网吧happy到00:00，可是钱没用完，但也得走了，否则明天肯定起不来了，回去还是看看电视剧，又到3点了。起来得很晚，不过睡得还不错，第二天入口都已经14:00了，随便看看就回去吧，地图害了我，本来觉得一会儿就到的地方，要走很久，买的是18:16的票，最后几经周折，终于赶上火车，完美的结束了张家界之行。\r\n","categories":["Essay","2018年"],"tags":["散文"]},{"title":"表演","url":"/posts/2018/2E319BV.html","content":"刚好凌晨，往窗外一瞥，在玻璃里便遇见了思考的自己。我和他安安静静地对视着，他模仿的我表情，我复制他的动作，在这无尽的黑夜里，倒也是有趣。\r\n他对我说，他在思考，假如现在即将死去，那生前的经历，是否足以瞑目？\r\n\r\n我也在沉思这个问题，并努力地回想前二十几年的记忆，恍惚间，忽然发现我就像一名演员，一直在一个剧本中兜兜转转，吃饭，喝水，学习，工作，过着浅薄，空虚和充满麻烦的生活，本色地出演着红尘这部大戏。直至死亡时，可能自己都认为这就是人生。\r\n越细想越觉得甚是恐怖，如果我们维度以外还有第四维的生物，那么我们存在的作用就像是在绘制一幅画卷而已。在四维生物的眼中，若把空间当作时间的因变量，那么每个人便仿佛一枝画笔，他的人生，只是一条弯弯扭扭，来回曲折的线条，出生是线条的起点，死亡是线条的终点，一个人，一条线，线的结束，于他们来说，只是画卷的一笔，对我们来说，却是人生的终止。\r\n但又有线条不一样，同为线条，有的是五颜六色，引导着其他线条的走向，有的则是平平淡淡，碌碌无为，只能化为笔墨下的点缀。生命只有那么长，有的生命逝去了，就像他不留恋这世间一样，世间也渐渐抹去了他的痕迹；有的生命虽然消逝，但是他的印记却耐住了时间的磨炼，恒远流长。\r\n究竟是什么造就了这么大的差异？是思想，是境界，是精神。\r\n一代诗人屈原，虽然死在了几千年前，但却永远的活在了人们的心里，他的死亡，只是肉体的消散。而那个时代更多的人，死亡了，便就永远不在了。这就是自身精神境界的不一样，屈原的思想在肉体存在的时候，便可通透万古，最后化为千古绝叹，留传世间。\r\n想起一个朋友曾经说过，每个人的精神应该要一直在远行，我觉得这很有道理，人除了在现实生活中存在，还应该构建自己的精神国度，在精神国度中活着。虽然我们是一条线，身不由己，但是我们可以选择在精神的国度灿烂。\r\n这让我想起一件往事：有一次和同事一起回家，路上偶然抬头看了一眼天空，当时晚霞和白云齐放，让我不禁欢喜，掏出手机，便拍了一张。同事问我“你很喜欢拍照啊？”。我当时镇了一下，他为什么对这么美的景致视而不见呢？现在我大约明白了，一个人要是只跟着原始意识生活，而少了了精神上的生活，即便是置之美也浑然不知。相反，有精神生活的人，生活的艰难也难以在他的身上刻下烙印。\r\n阅读是精神生活的一部分，读万卷书犹如行万里路，生命短暂，没有什么是比阅读更快的交通工具了，在有限的生命里，我们用阅读来延伸生命，用思考给精神提供远行的动力，让行过时间，行过空间，最后抵达永恒。\r\n假如我现在逝去，只能含恨了，原来只是个演员。\r\n渡过今晚，便要重活一世。\r\n","categories":["Essay","2018年"],"tags":["散文"]},{"title":"被一颗无垢之心净化","url":"/posts/2018/1GY6GF5.html","content":"在这一期的极限挑战里，读到了候媛丽小朋友写的一篇未完成的文章：一天晚上近处的花园里，传来了淡淡的青草香味。我寻着清香走到一块偏僻的角落，哎呀，这不是我最爱的百合花吗？看！它们波浪的花瓣，一片一片优雅的伸着。我贪婪地望着那一朵朵百合花，眼里充满了清香，它们纯洁优雅，不像牡丹那样爱夸耀自己，向来平平静静地看着人世……\r\n\r\n虽仅百余字，但却极为传神，你会情不自禁地走进她笔下的夜晚，去发现那美极了的百合花。我初次看到这篇文章时，真是不胜感慨，备受触动，字里行间中，感受到的，是小女孩最真挚的情感流露，若清水出芙蓉，洁净无瑕，未沾染一丝岁月的无病呻吟。读罢，自己心灵深处好似有一颗种子，忽然间挣破混沌，吐出了新芽。这种感觉，就像是一身污垢生活了很久，突然有一天，变得清清爽爽，这时，你会觉得，满世界的味道，都那么让人满足，充满希望。\r\n未完...\r\n","categories":["Essay","2018年"],"tags":["散文"]},{"title":"倾心音乐","url":"/posts/2018/268TABM.html","content":"许久未听音乐了，今天一时兴起，带上耳机，当音乐响起的那瞬间，整颗心一下子被那久违的旋律掳了去，沉浸在音乐的世界里无法自拔，忽然有种喜极而泣的感动，那种感觉，就像吃了很久的清水煮白菜，突然吃到一次柠檬酸汤鱼，幸福感扑面而来。\r\n\r\n我喜欢音乐，对于喜欢的歌曲，一首就可以听到手机换代，可是说来也奇怪，听了几十上百遍的歌曲，记不住歌词，记不得旋律，就连歌名也只是有个模糊的印象。后来仔细想了想这个问题，发现自己听歌的时候，心思根本不在它上面，而是思绪到处飘啊飘，天马行空，悠哉游哉。\r\n音乐，有这么一种魔力，让我在纷纷挠挠的世界里，觅得一片自由自在。每当音乐响起时，周遭的一切在悠悠扬扬的旋律中，便渐行渐远，灵魂缓缓地从身体中剥离出来，穿过厚厚的混凝土墙壁，在大自然中无拘无束地徜徉。身于一隅，心无羁绊，这便是音乐的魅力，它为心灵构筑了一片纯净而自由的世界。\r\n音乐于我，就像酒于诗人般，让人灵感迸发。诗人们喜欢饮酒作诗，大概是酒醉人心，让人再无余力旁念，遂得灵感吧。音乐的作用，和酒有异曲同工之妙，音乐一起，本是躁动的心便渐渐安静了下来，被杂念染了的思绪，如墨入宣，慢慢晕散开来，散而不乱，反倒是更兼神韵。此时的心，空灵纯净，一念一感，或是忧国忧民，或是文思泉涌，又或是壮志凌云，大有执一凡心，兼济天下的豪情。因为心净，是以对周围的物与景，有更真切的感受，思考更为发散，同时也兼备了一定的创造性。大家都不喜欢夏天，可是当我听着音乐，走在盛夏正午的太阳下时，却是另一番感受，不由得喜欢上了夏天。\r\n音乐，一般代表着吵闹，但在我看来，音乐却是安静的，它让身边的本是喧嚣的世界，如流水般涓涓流淌，结庐在人境，而无车马喧。音乐的静，浸人心扉，让人察觉不出时间的流逝。\r\n记忆比较深的是，去年元旦从泰山返汉在列车上的感受。从泰安到武汉，大约要16个小时，坐这么久的车，很多人可能会觉得无聊无趣，受不了这种长途跋涉，但我却很享受这种时光。上车的时候是凌晨，醒来时，天已渐亮，便找了个靠窗的位置，带上耳机，让音乐相伴，看着窗外的蒙眬的景致掠过，仿佛自己成了一辆奔驰的列车，从黎明到下一个黎明，从一片田野到另一片田野，从一个城市到下一个城市。\r\n列车一直哐铛哐铛地驶向人们心中的方向，我在音乐的浸染下，念头不断蔓延，时而化作青山，被绿水萦绕，时而躺在田野，饱饱地沐浴阳光，到站台时，又挤进人群，感受人们的依依惜别与近乡情切。是音乐，给了我如此无拘无束的洒脱，让我第一次感受到，他人笔下描述的旅途。等到下车时，突然发现，时间过得很快，居然不知不觉过去了16个小时，有些意犹未尽之感。\r\n不同的人对音乐，大概是不同的诠释，但有音乐相伴，定是美好的，我想，音乐也是这样想。\r\n","categories":["Essay","2018年"],"tags":["生活感悟"]},{"title":"转角恋上夏天","url":"/posts/2018/JW1J07.html","content":"这个城市里的夏天，没有“人散后，一钩淡月天如水”的夜色，也没有“绿树阴浓夏日长，楼台倒影入池塘”的夏景，更没有“落落疏帘邀月影，嘈嘈虚枕纳溪声”的闲适，有的，是铺天盖地的热和南方那如溺水般的闷。\r\n\r\n盛夏是最热的时候，阳光肆意地从穹顶洒下来，夹着暴躁的热，摊铺到整个大地上。空气中混合着的水汽和热，把光扰得露了身影，远远朝着沥青路面看去，气浪层层叠叠，若隐若现。只一眼，便热去了一身的精气神，恰似古人之言，“天地一大窑，阳炭烹六月”。\r\n如果从物理的角度来体验夏天，确实如炉火那般，热得实实在在，但你若是怀着一颗欣赏的心，慢慢地契合夏天的韵律，一定会情不自禁地爱上这个季节。\r\n感受夏天的狂野，在炙热的中午是最好的。喝上一两升水，收拾好心情，就可以出门了。踏出小区的瞬间，强烈的阳光从四面八方蜂拥而至，每颗阳光的活力直透每一寸肌肤，让人觉得仿佛置身于圣洁的海洋，心中的负面能量犹如光明遇上黑暗，无处藏匿，消散一空。在你还未来得及感受内心的变化的时候，那无穷无尽的热浪便如龙卷风般，疯狂向你奔袭而来，一下侵袭了你的意识。此时，你只需深深地呼吸一口这原始的空气，细细地去口味，便一下子就喜欢上它的味道了。\r\n夏天的空气，在高温和紫外线的照射下，空气中掺杂的其它成分被过滤，留下了最自然的味道，草地旁，空气是青草味的，田野里，空气是稻香味的，湖泊旁，空气又是清新的味道。品一口夏天的空气，如掇一口碳火温过的酒，裹着醇醇的芳香，暖暖入心脾。\r\n行走在盛夏里，也是一番别样的感受，仿佛大厨烹小鲜，以天地为器，以人为材，选用最好的阳光，辅以热而不烫的火候，让每颗体表细胞都充分吸收日光的活力。你能够清晰地感受到，出门前喝下去的水，仿佛在身体里游走，焕发出勃勃生机。只需在日光下一小会儿，毛孔便开始舒张开来，身体里的水分顺着毛细孔，漫在体表，在阳光的照射下，晶莹剔透，此时的状态，就如打开了奇经八脉那般，通体舒畅。\r\n夏是一个有生命力的季节。“接天莲叶无穷碧，映日荷花别样红”是莲在绽放自己的风采；“漠漠水田飞白鹭，阴阴夏木啭黄鹂”是飞鸟在展示自己的魅力；“梅子留酸软齿牙，芭蕉分绿与窗纱”是自然在表达夏季的到来。在夏天，我们也应当做一件有生命力的事情，可以在最热的时候，吃一顿最辣的火锅，跑一次最长的步，又或者喝一次最烈的酒，如此才不枉这大好的时节。\r\n走进夏天，方觉迷上夏天。\r\n","categories":["Essay","2018年"],"tags":["生活感悟"]},{"title":"活得更努力一点","url":"/posts/2018/29ZPVW.html","content":" 又是一年，又是新的困惑。\r\n已经毕业两年了，却是变化不大，只不过是从不想学习，变成了不想工作。上班的时候工作，下班的时候加班，放假的时候就赶紧逃离熟悉的地方，在陌生的地方，加载一份新鲜的记忆，然后又是工作，如此的单调，如此的重复着。在这兜兜转转的生活中，我发现自己迷茫了，不知前路是遥向何方，但心里一直有个声音，活着不应止于此的简单。\r\n\r\n每当旅行结束之余，总觉得心里有些空虚，像是疲惫，又像茫然。我在想，三两年之后，此次旅行的记忆定是会模糊到我曾经去过的程度了，那在途中的所历所闻，又有何意义呢？这个问题一直搁在心里，久久未能落下。\r\n前几天到兰州考试，便顺道去了西宁，在旅行中，结识了一位出差借周末时间而旅行的伙伴。她是一个爱好旅行的人，去了很多的地方，长白山天池有她的倩影，三亚也有她的足迹，对于成都，更是如数家珍。她去过了很多地方，从她身上，看不到我遇到的迷茫，反倒是，她让我感受到了对生活热爱，她的每次旅行，都变成了她生活中精致的点缀。\r\n途中聊天时，我开口问她：每一次旅行，所到过的每一个地方，最后总会沦为记忆，越来越模糊，你觉得旅行，对你的意义是什么呢？\r\n她想了想，回答我道：“我觉得，旅行对于我的意义，更多的是调剂生活吧。”\r\n紧接着她回忆到：毕业的这几年，我每年都在考注会，但是工作特别忙，还经常加班，所以为了准备考试，加完班一回到家便开始看书，一看就是到晚上12点，平时也没有任何的业余活动，超过半个小时的活动，我一般都拒绝参加。工作学习累了，就利用假期去旅行，把它当作给自己努力的鼓励，就这样连续几年，一边工作，一边看书，今年终于通过了所有考试。对于目的地，我不是很在意它的风景，行得轻松，住得干净就够了，因为我觉得可以在紧张的工作学习中出来散心，用心感受不同地方的味道，这就是最美好的旅行了，所以，我每到一个地方，都很开心。就是这样，工作的时候努力工作，然后一有空就拼命看书，压力太大的时候就出去走走，这么多年就这样挺过来了…”\r\n听着她把自己的经历娓娓道来，心底那颗激情的种子开始迸发了绿芽，我终于明白，这种破釜沉舟的努力才是自己渴望的，也明白，为何每次出行之后会感到空虚，因为自己的生活，一直浮于表面，从没有认真的坚持过，工作中自以为的很努力，禁不起一丝认真，没有必须完成的目标，也没有日日夜夜地挑灯夜读，甚至连早起都很少做到，一切，努力得那么的无力。\r\n想起十点读书里面提到的一个观点，每个人都当给自己“生一个孩子”，它可以是一本书，可以是一个梦想，又或者是一份坚持，这样，你的精神就有了寄托，生活也就变得丰富，便也少了恐惧远方的迷茫。但我想，光就生孩子这件事，也是很困难的，起码需得十月怀胎，所以“生孩子”不是一天两天的事，而是长长久久的坚持与呵护。\r\n新的一年，还可以更努力一点。每天一步一步地前行，扛着艰难困苦，终有一天，会抵达诗和远方。\r\n","categories":["Essay","2018年"],"tags":["生活感悟"]},{"title":"静夜随笔","url":"/posts/2020/2RT0R7Q.html","content":"今夜，雨又清清凉凉地落了下来。我躺在阳台上的椅子上，全身空灵，用每一颗细胞去细细地感受着这雨中的世界。\r\n\r\n抬头，目光从布满铁栏杆的阳台穿过，直抵那无边无际的天空，灵魂随之出窍，在雨的夜空里自由地翱翔，在电闪雷鸣的乌云里随意翻腾，深深吸一口，湿润的空气里，还有浅浅的超脱味道。\r\n多么自由的气息啊，无拘无束，无因无果，潇潇洒洒，仿佛又回到了曾经那个仗剑天涯的少年状态。\r\n这份感受好久都没有过了，记忆中似曾相似的感觉，不知不觉已经过去了一年多。\r\n此刻，突然惊醒，自己正慢慢地陷入滚滚红尘里，迷醉在忙忙碌碌地的“生活”里。我生活的影子，越来越像剧本那样，规规矩矩，没有期待，也没有回忆，也成了大家喜闻乐见的活在当下。\r\n简单的生活，只用肉体就能很好地生活了，我渐渐地，悄无声息地将内心给尘封在角落，不再让它去参与生活，不再去感觉春夏秋冬，不再去感受阴晴雨雪。\r\n","categories":["Essay","2020年"],"tags":["散文"]},{"title":"个人经验总结","url":"/posts/2020/3905HA6.html","content":"\n  0813600775e6fdeda6d3c9905e8745039ee48aad99a9c510ed2d1061115ee38ad780143ed5fe4bd81954c497d5c6be4ce0dbd6513b052c0698de7293571f26db4c96d49e425c0579ba0837091e0bdf03e5bcf75548b7d4b4698ab3bc4aa56f976aae1b07f4a65bffe8a49a6ea232292dfa5ec0c4f8a0ea0a7188b1888550dc356b41854e3ccfee0f56b75b3e97f2342f6468af738a8f69d026d2a72b21d26eff28a2f8035bab83bdbca1175c37fd99b7776a86eabf31aa62ac69ee6da834e9902e9f50c4d3fbaa684854e6ac118d147a0f2c069934cf02b8ba043878149ae5879c4989c9834a783688268ca9e7585cd4b03aa80e159c35b2e767b9c2a63e56f116df42741adaa5fd7e5d1a88e1aba3cc21ba0329a959905b39fb17aa206e2dd9a7092cc860070d8bb095594e597c25f58baa46a92f97cc8b86ceb57372081358bf3c4a02194e2271fc5e6fc4b6de7e1bbfb64356fe0ada9984f4fd5328de01ce289a20f3b7812beff1c50ce7c1b8675a1c6d7b469cdadeaf3c46e2817351feaac585cba255443cea6fa3677baefb4c0fe11c6a7808a5d99503ae2f4e23889e41c2fb5fb9d8bee7c2a767961f32a02939cf9eb15a15a7dce9f15e552017de0799\n  \n    \n      \n      \n        当前文档已加密，请输入密码查看\n      \n      \n        \n        \n      \n    \n  \n\n","categories":["Essay","2020年"],"tags":["日志","加密"]},{"title":"孙少安的人格魅力","url":"/posts/2020/QQM15G.html","content":"合上《平凡的世界》，书中的一幕幕仍在脑海中回荡。\r\n\r\n故事发生在陕西北部，旧时代的西北地区，荒蛮的贫瘠缓缓蔓延在每一寸广袤的土地上，贫穷，给无数的普通人民灌溉起生活的磨难。而这份厌人的磨难下，也生长起许多鲜活动人的生命。每一个平凡的人，都得为自己存在的世界而战斗,看似平静的世界在普通民众的生活里不断的掀起惊涛骇浪。这种大时代的贫穷，让人们负重前行，绽放出极致而纯净的美好品德。\r\n责任担当\r\n六岁之前，小少安的生活虽然贫穷，但是充满着无限的欢乐。春天，当桃花盛开时，他和润叶一起到阳土坡上刨刚刚发芽的“蛮蛮草”根；夏天，一入三伏，他和村里的小娃娃便成天泡在东拉河里耍水；秋天，他又和一群小孩子去野外找吃的，常常把肚皮撑得饱饱的；而冬天，他又去寻找打碎的瓷器片，作为自己的玩具。\r\n一年年过去，快乐的时光在六岁的时候突然没了，小少安开始慢慢承担起家庭的责任。他父亲给他起了一把小镢头，然后还给他盘了一根小绳，让他和他一起去砍柴，分担家里的劳动。\r\n随着自己年龄的长大，这一天终是到来了，他也知道，自己家家穷业薄，就父亲一人拉扯一家子，很不容易，便每天为家里干一些活。\r\n在他读小学期间，成绩一直很优异，升入高小的考试中，他位列全公社第一，可是上完两年的高小后，他家再也供不上他上中学了。他主动向父亲提出，要回家劳动。然后他说：“我想进一回初中的考场，我想证明，我不上中学，不是因为我考不上”。\r\n当我读到这一部分时，那个场景仿佛活了过来般，我变成了孙少安，说着这热血激昂的话，我又变成了孙少安的父亲，心中无限愧疚，却又无能为力。\r\n我有些哽咽，少安为了这个家，他牺牲得太多了。长兄为父，身为长子，他自然而然的接受和担负着家庭的责任，为了这个光景“一烂包”家庭，为了弟弟和妹妹能够走得更远，可以上中学，上大学，他只能选择将自己的骄傲和志气埋藏在心底，从此在农村踏踏实实劳动，帮着父亲，维持着这个风雨飘摇的家庭，仿佛一叶扁舟，在那个惨烈而贫穷的年代里，摇曳前行。\r\n吃苦耐劳\r\n书中有一段是这样说的：”由于他的精明强悍和可怕的吃苦精神，在十八岁那年，一队的队员就一致推选他当了队长“。我们可以想象，他真正参加劳动的时候，是\r\n13 岁，才劳动 5\r\n年，就能在一群几十岁的老庄稼汉中间，获得认可，那他吃的苦，到了多么可怕的程度。\r\n他的吃苦耐劳，除了在队里身先士卒外，还表现在对家里的事的操心上面。他要趁队里人休息的时候，经营自留地，种上夏土豆、西红柿、黄瓜，将来卖零钱用。队里、家里完了，还要帮一个人种地的姐姐，一年到头，忙里忙外，真是辛苦。\r\n孙少安为改变生活，到县城拉砖的那一幕，也让我记忆犹新。他住的地方是一个没门没窗的烂窑洞，还不如一个狗窝。天不明的时候，他就开始去拉砖。在上坡的时候，他就使出浑身的劲拼命拉车，两只手都快要趴在地上了；牲口和他都大汗淋漓，气喘得像两只风箱。\r\n一个男人为了家庭，默默受苦受累的精神让我敬佩不已。\r\n孙少安吃的苦太多太多了，但是从字里行间里，我们却找不到他身在苦中而畏苦的描写，他的形象永远像一头勤劳踏实的老牛，一步一步地，稳健地耕耘着他那份土地。\r\n勇于革新\r\n年轻人身上，总不缺少激情。但是孙少安身上，不仅有激情，还有改革创新的智慧和勇气。\r\n为什么这样说呢？\r\n十八岁成为双水村最年轻最有能力的生产队队长，生产一队在他的带领下，生产量年年稳居第一。孙少安在拉砖的时候，他留意到当时到处在搞建设，砖瓦是紧缺材料，因此他拿着准备置办新窑洞的钱，开办了一个砖窑。而当乡公社砖厂面临倒闭时，他深思熟虑后，毅然承包过来，大刀阔斧的改革后，终于转亏为盈，事业更上一层楼。\r\n他从小生活在农村，小学毕业，发家之前到过最远的地方就是当地的县城，而在这样环境中，它却干了一件又一件大事。我想，这就是因为他身上有一种其他农民所没有的品质，持续思考，并付诸勇气和实践，最后才能冲破环境的约束，走向成功。\r\n善良仁爱\r\n他很早熟，上面我们也提到，本来学习成绩很好的他，“不用父亲说，也知道家中供不起，不能再读书了”，他知道，他和父亲两个人劳动，一定要把少平和兰香的书供成”，这时，他才十三岁。\r\n单是想想，就觉得不可思议，13\r\n岁的小孩主动做出牺牲。归根到底，我认为这是一种心灵的仁爱，对父亲，对弟妹，对整个家庭。\r\n书中例子很多。但最好的一个，是看着乡亲们没地方赚钱买化肥，就给大家提供工作。不幸砖厂倒闭，付不起工钱，被村民们逼迫要钱，他一边承担着压力，一边想着怎么才能付给乡亲们，让他们有钱买化肥。\r\n后来幸运砖厂重开，当时逼迫要钱的人又来找工作，“秀莲（妻子）在感情上转不过弯，坚决不同意......但少安是个软心肠，他知道这些要来干活的村民，实在是没有办法才又求他。他不能见死不救”。他很善良，也不计较。\r\n他平凡的地方\r\n当然，他到底还是一个平凡的人。他身上有许多缺点，也不是说，有缺点不好。相反，孙少安的缺点，让这个平凡的人更真实，也更可爱，更加成为我们日常生活中能经常遇到的人。或者，他的这些缺点，就在我们身上存在，本来就是平凡的人难以避免的缺点。\r\n孙少安面对爱情拿不起、放不下，畏惧挑战，不算好男儿。读孙少安的故事，最憋屈的就是他和田润叶的爱情了。\r\n他和润叶青梅竹马一起长大，由于家庭条件限制，他初中后没去上高中。田润叶高中毕业在县城当了小学老师。他在双水村当一队队长。他们经常联系。田润叶喜欢孙少安，孙少安也喜欢田润叶。\r\n田润叶几次叫人捎信，叫他来商良大事，他都假装不明白。田润叶直接写信“少安哥，我愿意一辈子和你好”。\r\n他就站在马路上，呆住了！田润叶不见他回复，又来找他。他却疯狂而贪婪地干一天活，不见面。田润叶没办法坐汽车回去了，他却嘴里喃喃地说“对不起你，润叶，我对不起你”。\r\n人家这么主动，他却唯唯诺诺，一点不像个大男人，要是我，克服千难万难也要接受了。他却没有，为了逃避，干脆到外地找了个人当老婆。\r\n不顾一切的爱情，那是理想主义者，是超人，是小说家写精彩的情节来骗人的，少安终究是平凡的人，我们也终究是平凡的人。我们不想看到这样的结果，但这就是平凡人的世界。\r\n总结\r\n读《平凡的世界》，自己仿佛身临其境般，真真切切地地体会到了 70\r\n年代时，农村的贫苦生活，也让我感受到人性的美好和纯真。书中有角色很多，很多人过得很苦，但是不论环境怎么样，他们和孙少安一样，都保持着自己善良仁爱，热爱劳动，爱护家庭，友爱邻居。\r\n作为一个平凡的人，读平凡的故事更容易引起共鸣，如果将心灵鸡汤比作快餐，那《平凡的世界》就像烹饪精致的美食，让人念念不忘。他带给我的是一种信念，一种在平凡的生活坚持下去，脚踏实地，努力拼搏的信念。\r\n最后，也希望大家将《平凡世界》中的艰苦奋斗精神融化在自己的信念里，踏踏实实，一步步走出自己的天涯。\r\n","categories":["Essay","2020年"],"tags":["散文"]},{"title":"浮沉喧嚣不惊觉，一朝醒来入凡心","url":"/posts/2023/1N11HYC.html","content":"很长一段时间没有提笔了，今日突然心有所感，借此机会便将脑中那飘渺的灵感记录下来，摘一段时光，以供未来思忆。\r\n\r\n新冠疫情终于渐渐淡化，笼罩在心头的无尽的阴霾也慢慢散去，这个周末，春光正好，于是和老婆小孩一起，到东湖赏梅散心。\r\n我们是开车去的，快到东湖入口时，便已经堵着走不动了，我便留意起从旁边经过的行人，他们之中有的是情侣，有的是一家人，有的是大学生，三五成群，或是步行，或是骑着自行车，有说有笑，朝着东湖前行。\r\n我面无表情地坐在车里，感受着他们的喜悦，脑海深处仿佛有一股躁动正在挣脱束缚，想要喷涌而出。我循着这似曾相识的场景渐渐回忆，霎那间，仿佛大江决堤，山崩地裂，那股躁动终于奔腾而出，熟悉的感觉重回身体，我心中突然明悟了：曾经的自己也和他们一样，生命在热烈地绽放，曾几何时，我却丢掉了它们。\r\n以前，自己也和他们一样，喜欢用脚丈量大地，喜欢微风轻拂面颊，喜欢享受旅途风景，喜欢用真诚去体悟生命。\r\n曾经的自己，可以一念起，横空数千公里，南下丽江赏秋雪；可以心意动，恕爬十几小时，登顶峨嵋观云海；可以兴致至，跨越千万山水，西行茶卡照天镜。\r\n然而，随着新冠的出现，连续几年的抗疫，再加 2022\r\n年底防疫的彻底放开，全家感染，自己渐渐疲于奔命，迷失在了忙忙碌碌地的生活里，虽然每天依然吃饭喝水、上班下班、买菜做饭，但总感觉少了些什么。直到今天，我突然明悟过来，是少了一缕光，一缕绽放生命的光。\r\n真是浮沉喧嚣不惊觉，一朝醒来入凡心，好在重拾初心志犹在，上揽苍穹下关月。\r\n","categories":["Essay","2023年"],"tags":["散文","心有所感"]},{"title":"让心驰骋在木兰草原之上","url":"/posts/2021/8Z3TAG.html","content":"2021年11月27日，设计四所、BIM中心和经营部在木兰草原联合举办了具有草原风情的团建活动。滑草、骑马、射箭，不论老少，玩得不亦乐乎。\r\n合照\r\n一进入木兰草原，一股厚重的苍茫感就迎面扑来，它挟着初冬的一丝凛冽，将春夏的苍翠，华作漫天枯黄。走在小道上，呼吸着微风中淡淡的青草味，看着远山上朦朦胧胧的牛马食草，感受着四周无边无际的草原，木兰草原在这一刻，仿佛有了生命，一下子将我们拉进了\r\n“天似穹庐，笼盖四野”\r\n的壮阔草原里，置身此情此景，我们不禁惊叹住了，这正是我们想象中的草原的样子：“天苍苍，野茫茫，风吹草低见牛羊”\r\n写大家释放激情\r\n写大家放松与交流\r\n本次活动，似湖面上溅起的一缕涟漪，荡漾起了大家内心深处的激情澎湃；又如冬日里绽放的暖阳，治愈了每个人精神上的紧绷与疲惫；也像大地上溪流汇成的江河，消融了彼此间的陌生，增进了彼此的感情，在未来，我们将携手同行，扬帆大海。\r\n","categories":["Essay","2021年"],"tags":["散文","团建"]},{"title":"为她守护一束桅子花开","url":"/posts/2023/21AX3JT.html","content":"\r\n\r\nimage-20230717000711448\r\n\r\n今天是周五，如往常一样，是徒步回家的一天。出发的时候，几滴小雨已经开始孤零零地落着，我没理会它们，循着回家的路，就在小道上“噔噔噔”地小跑起来。\r\n跑出几公里后，在一个路口处，刚好遇到了红灯，就停了下来，霎那间，我觉自己仿佛一台过载地的发动机，从内到外都是如火地滚烫，不断地吭哧吭哧地向外冒着热气，空气一吸进肺里，就变得焦灼起来。突然间，一阵花香飘来，香气中带有一丝齁甜，浓郁而沁人心脾。\r\n\r\n这种味道让我回忆起了中学的时候，每当春夏之际，路边总会有许许多多的游商，担着一个担子，担子两端分别系着一竹篓，里面盛着一满满篓筐的桅子花，当他们走过的时候，整条街都萦绕香甜的味道。那个时候，很想去买，但又没多少零钱，因此通常就只会饱饱地吸几口，然后就走了。长大后，有时又遇到卖桅子花的，还是小时候的味道，但是也不会去买，因为买了，也没有承载这份美好和欢喜的人。\r\n但是，今天终于可以买一束桅子花了，我想将这束带着美好回忆的，象征着守候和坚持的花朵，送给如花香般甜蜜的爱情，送给亲爱的老婆。\r\n这束花，只有几朵绽放得热烈，其它的都是含苞待放，我将它们拿在手里，小心地呵护着。因为还要继续小跑回家，便将花举到胸前，跑步的时候，就一直稳稳地端着。闻着阵阵的花香，我的嘴角不由地浮现出一窝浅笑，一弯幸福的笑。\r\n我脑中开始萦绕出一幅幅深动的画面，老婆抱着小宝宝，望着回家的方向，正盼着自己回来，我将花藏在身后，出现在他们面前，故作神秘地道：“是不是发现有一种好闻的香味，嘿嘿~”，然后借着老婆转移注意力的时候，将花送到她面前，我想，她一定会非常开心，高兴得手舞足蹈，像个大小孩。然后我就抱着娃，一起看着她自己忙忙碌碌地倒腾着心爱的花花。\r\n想着想着，不知不觉就跑了几公里，所过之处，尽皆残留着淡淡的桅子花香，每一阵花香，都是一段美好的记忆。\r\n接近半程时，雨渐渐变得密集起来，一小会儿的功夫，就开始转为狂风暴雨。这雨转换得太突然，完全找不到避雨的地方，我只好一只手将T恤的领口撑开，另一只手将花从下向上放进衣服里护着，避免被大风大雨给打落了花瓣。就这样，我在瓢泼大雨中缓缓地前行着，有好几次想将花儿给拿出来，因为这样走路会轻松些，可以早点回家，但当闻到从领口传出来的花香，想到被风吹得光凸凸的花枝，就又放弃了这个念头，爱是需要被呵护的。\r\n我护着这束桅子花，终于走到了小区门口。突然发现有两朵新花正在盛情绽放，花瓣亭亭玉立，香味浓郁幽长。看着这两朵惊艳的花，我会心地笑了，这一路走来，很值，我想她一定会很喜欢！\r\n","categories":["Essay","2023年"],"tags":["散文","生活"]},{"title":"家庭服务器被网络攻击后, 日均下载流量 2T","url":"/posts/2024/HPDBE7.html","content":"近日，发现家里网络非常慢，但是测速时，速度又很正常，于是进后台看看看，一看不要紧，看了后吓一跳，好家伙，网络被攻击了，最近几天日均下载量高达\r\n2T。\r\n不禁生起一阵感慨，裸奔的网络太凶险了！\r\n大致的原因是这样的，在此做一个记录，与大家共警！\r\n\r\n家里的服务器由二级路由管理，家庭的设备接入都在一级路由分配的网段里，所以为了方便自己连接服务器上的代理，于是将二级路由上的代理端口\r\n7890 暴露给了一级路由。\r\n由于一级路由是一个传统的路由器，没有防火墙，因此同时相当于将服务器的\r\n7890 端口暴露在公网上了。\r\n就这样，悲剧开始发生了。\r\n应该是被网络攻击请求嗅探到了这是一个代理，连续几天都使用它进行高负载地代理操作，由于家里是千兆网络，因此每日的下载流量达到了\r\n2 T。\r\n\r\n\r\nimage-20241104163332882\r\n\r\n\r\n\r\nimage-20241104163351362\r\n\r\n\r\n\r\nimage-20241104163411312\r\n\r\n当发现是代理端口问题后，使用火绒的网络监控进行排查，发现请求的 IP\r\n来自各个国家，有美国、立陶宛等国家。\r\n通过分析流量请求频率，发现一般是夜间在请求。\r\n\r\n\r\n流量异常\r\n\r\n在这之前，网络攻击都只存在于防火墙的拦截报告里，没想到自己真切地体验了一把，所幸及时发现问题，没造成什么影响。\r\n经此一事，深感网络世界的凶险，对于暴露在公网下的服务，都要慎之又慎！\r\n","categories":["Essay","2024年"]},{"title":"梦之阴阳相望","url":"/posts/2017/BSTRJW.html","content":"2017-2-7 晚\r\n昨晚做了这样一个神奇的梦：\r\n梦里我有两个妹妹，一个是现在的妹妹，一个是难产出生的妹妹。这个妹妹很特殊，妈妈说，生她的时候难产，身体损坏了，医生把她的灵魂渡入到一个\r\niPad\r\n里面。家里人很喜欢这个小家伙的出生，虽然不幸，但是很开心她能够陪伴在我们身边。\r\n\r\n父亲每天对着平板聊天，呵护小孩子一样，我们也会时不时的去逗几句。有一天，我看到父亲在平板上写字，我问他在干嘛，他说他在教女儿写字。因为妹妹的特殊性，她其实是生活在阴间，但是可以通过这个\r\npad\r\n沟通阳间，我就问她，你在那边生活得怎么样？她说，她和爹爹生活在一起，起码有亲人陪伴，还有爷爷奶奶们也都在。我当时想，原来人逝去时候也会在一起的。\r\n然后我问，给你烧的钱你那儿能用吗？因为现实中自己经济拮据，我希望这个妹妹在另一个地方不用为经济而烦恼，我想多给她烧一些纸钱。她说，她生活的地方和我们住的地方一样，纸钱可以用，但是阳间是什么样子，阴间也就是什么样子！\r\n我当时感觉好内疚，作为大哥，不能给弟弟妹妹们好的生活，去了之后还因为自己的原因而住的那么破旧。很难受，为了改变阳间，阴间的生活，我必须得加油奋斗了！\r\n","categories":["Essay","梦"],"tags":["梦"]},{"title":"战胜梦境","url":"/posts/2018/1945B98.html","content":"藏匿在心底深处的东西，只有在意识薄弱的时候才会伺机而动，所以，当一个人意志低迷或者处于睡梦中的时候，心灵深处的本质便会暴露。此时，平时自己压制的一些缺点会被放大，害怕变成恐惧；踌躇变成退缩；小恶变成大恶。仔细一想，这确实是一件恐怖的事情，虽然我们努力成为一个正能量的人，但是可能在心底深处的本质依然没有改变。\r\n\r\n昨晚做了一个梦，一个特殊的梦。\r\n\r\n以前在梦里，总会处于劣势，要么被追杀，要么若蝼蚁，要么绝望而无助，然后每次醒来，总有些懊恼，恼在自己的梦里却如此憋屈，同时心里也期待，下次再遇到类似的梦，我一定要奋起反抗，大不了醒来又是一条好汉。可是，在梦里总是身不由。反复多次之后，我意识到，在梦里是不会带入自己的意志的，能进去的，只有自己心灵最本质的东西。\r\n昨晚的这个梦，让我真正感受到了心灵力量的强大。\r\n天色渐晚，夕阳未落，月华却已洒向人间。我背着包，有些着急的找着住宿的地方。沿途的街道到处在施工，人们只能在施工搭设的防护下面走着，外面是机器的轰鸣，里面是人们三三两两的谈笑，人群熙熙攘攘，整个环境显得嘈杂。匆匆一瞥之间，看到一家理发店，这家店门前约2米的地方直接被立了一堵墙，墙已经老旧得有些发黄，应该是有一段时间了，而理发店也关着门，但是在靠着墙的位置，一位中年男子正在为一位老爷爷理发，我看过去地时候，他正仔细地半蹲着身子，小心地给老爷爷刮着胡须。这一刻，心里很是触动，生活太不容易。\r\n终于找到下榻地地方了，远远的望去，这家店除了大门前面是一条道路以外，其他地方要么是荒草漫野，要么是楼房拆除后剩下的断壁残垣，在这寂静的夜色中，它独自摇曳着昏黄的灯光。走进才发现，这家店是用青砖垒砌的三层小楼，呈四合院的形式分布，每层楼上零零散散的挂着各色的小旗子，但大部分颜色已经褪去，分不清了。院子里的灯显得很昏暗，朦朦胧胧的，中间有一口老井，应该是许久没用了，都爬满了苔痕。\r\n散去一身疲倦，渐渐入睡。快至黎明，便被外面的尖叫声吵醒了，打开窗子一看，目之所及，全是铺天盖地的幽灵在肆虐。这些幽灵像极了昙华林卖的小铃铛，有一个圆圆的头，一个没有手脚的躯体，和女士们的婚纱形状类似，不过有些虚无，仿佛淡淡的烟，它们的头上只有两个眼眶孤零零的嵌着，眼眶中闪着猩红的光芒，欲择人而食。\r\n我特别害怕，赶紧关了窗，打开朝向院子方向的门，准备去找别人求助。哪知刚一打开，一头幽灵便盯上了我，瞬间飘来，然后从我身体穿过，我只觉得一阵虚弱，回头一看，这家伙又飘过来了。在刹那间，我突然想起了曾经去武当山的一个画面，武当山南岩有一宫殿，名叫玄帝殿，当时我登上殿前一高台，对着苍天一拜，那一瞬间，我好似悟得道之真谛，心灵无穷极，心之所往，便可镇压一切魑魅魍魉。我默默地坚定自己地心神，相信心灵是有力量的，但仍旧很害怕，幽灵转瞬即至，又将夺体而过，在这千钧一发之际，我的体表一下迸发出微弱的金光，阻挡着幽灵穿体而过，这让我信心大增，试着挥出一拳，没想到直接把幽灵吓走了。\r\n危险解除了，紧接着我又开始挣扎，想着是否冲进漫天的幽灵海中，帮助大家解决这次灾难，我心里完全没有底，不知自己能否抗住这么多的攻击，而且每个幽灵都自带恐惧效果，让人心底自然而然的畏惧，让人忍不住要退缩。回忆过去的一幕幕，想到自己在泰山顶时候的感受，当我立于山巅时，真是会当凌绝顶，一览纵山小，豪情万丈，当时的我觉得任世间千磨万难，我自当勇往直前，踏平一切困难险阻。于是，我毅然的跳入了幽灵海，跳下的瞬间，幽灵们仿佛洪水决堤，从四面八方向我涌来，铺天盖地，除了幽灵们红彤彤的眼睛，便是自己无边无际的恐惧，当时自己的豪迈全没了，就是害怕，还有倔强，不能放弃。我努力告诉自己，力量源自内心，心有多强大，能力就有多强。开始只能够堪堪的抵挡幽灵们穿体而过，后来，大约是破罐子破摔了，直接暴走，把幽灵们全部夷灭了。\r\n后来天也亮了，便悠悠转醒，回到现实，整个人都很开心，因为自己终于战胜了梦境，梦中，从此我是主宰。\r\n仔细思考，也弄不明白究竟是什么影响着梦里的自己，我想，大概就是每个人的心灵本质吧。\r\n","categories":["Essay","梦"],"tags":["生活感悟","梦"]},{"title":"岁月静好，便是幸福","url":"/posts/2018/WHDN7Q.html","content":"今天看到一个朋友在朋友圈中分享这样一个故事:妈妈说外公的手机里连表姐的电话号码都没存，就存了我的。他这两天在练习打电话，非要给我打。虽然讲话还很混乱，还是很努力地和我讲，最后还对我说，要过好日子。\r\n\r\n读完这条分享的时候，虽未亲身感受，但却也觉得特别温馨，感动欲浸透心房。短短几语，便勾勒出了祖孙深深地感情，长者慈，幼者孝，和谐美满。我在想，她当时是怎样的心情呢，是幸福，是感动，还是未能陪伴的憾然？\r\n幸福是怎样的？这位朋友定很幸福，有人惦记，有人关心，也刚刚好，她发现了这份幸福。芸芸众生中，有的人，一生幸福，也有的人，却半生凄苦半生难，而有的人，身于福中而觉苦。何谓幸福，幸福，是心的一种感觉，各人各不相同的理解。\r\n幸福很小，有时候是暖暖地一杯水，有时候是脉脉的一回眸，有时候是浅浅地一声叮咛，幸福也很大，它是勇往直前地奋斗，是百折不挠地坚持，是一生一世地呵护。\r\n7月初，挚友林结婚，便借此机会，与相知10多年的好友，好好聚了一番。当时天色已晚，乌云摭住了月光，夜色掩了乌云下的雨，我们从中学便相识相知的几个挚友，择了一清吧，点一壶铁观音，伴着缕缕茶香，共诉衷肠。有些老友，好几载未得相遇，有些老友，平日间从未互通安好，只一面，便依然如中学那般，情谊浓长。大家毕业后，去向了不同的岗位，承担着不一样的责任，有了不同的发展，再聚首，你依然是你，我还是我，彼此，还是熟悉的那个人。得一知己，共同走过漫长的岁月，是一种幸福。\r\n一次中午回家，在一家清蒸餐厅吃饭时，见几个工人正在这家店吃饭。他们的工服沾满了建筑涂料，发丛中藏着缕缕白发，虽上了年纪，但很是硬朗。他们各自点了一大碗面，三三两两地坐在一起，也不讲话，就那么安安静静的大口吃着。做工程甚是辛苦，淋最大的雨，晒最烈的太阳，受着最冷的风，呼吸着糟糕的空气，还有永无休止的力气活。他们许是累了，但眼睛却炯炯有神，充满着执着和希冀。我想，他们心底是幸福的，有挂念的人，有人挂念，为家人努力着，岁月漫长，却有一个值得相守的希望。\r\n上个夏天，在光谷等公交时，偶然收获了一份幸福的画面。一位母亲正带着她大约两岁的小孩在等车，母亲正在玩手机，此时，一只苍蝇停在了母亲的鞋上，孩子见到后，便蹲下去，一直守在母亲的脚边，苍蝇一过来，就被他赶走了，这位母亲直到上车也没发现她的孩子在帮她驱赶苍蝇。幸福很小，小到被忽略。\r\n如果我外公仍在世，可能也开始学用手机了，会不会打一通电话，从一个省到另一个省，然后在我的耳边喃喃，嘱咐别委屈了自己。\r\n岁月静好，珍惜拥有，拥有的便是幸福。\r\n","categories":["Essay","2018年"],"tags":["生活感悟"]},{"title":"一腔热血夜雪山，奇灵怪异退堂鼓","url":"/posts/2023/2BPZ3DJ.html","content":"\r\n\r\nimage-20230717005034407\r\n\r\n一条小溪从茂密的山林里窜了出来，缓缓地流向远方，直到在那无尽的远处，消失不见，佛淌进了九幽的黑暗里。在小溪的尽头，一条上泛着灰白的硬水泥路蜿蜒曲折而至，时而与小溪相向而行，时而又隐匿在群山之中，它不断逆流而上，爬上了附近的最高峰，快到山顶时，戛然而止，好似用尽了全身的力气，再也不能向上分毫。\r\n\r\n这座山便是我们一行人的目标，我们计划夜宿山顶，欣赏第二天的日出。到山脚下时，天色已近晚，我顺着水泥路的方向，向山顶看了过去，只见半山腰上三两人家炊烟袅袅，他们的房子制式很统一，采用传统的木结构，大门向南开，左右两侧分别是厢房，但有一点很奇怪，大家都在房子的右侧整整齐齐地备好了一堆木头当材火。\r\n我们沿着公路开始向山顶出发，在公路的尽头，是一条幽长狭窄的小路，直达山顶。快到山顶时，天空就已经被黑暗笼罩，扭头向山腰看去，几家灯火明灭不定，但炊烟依旧袅袅。\r\n突然一户人家窗子突然打开了，打开的瞬间，窗子里绽放出了灿烂的金光，这金光不刺眼，且异常温和，在这夜色里，让人有一种亲近和温暖的感觉。正在感叹之际，从窗户时探出一老者，两鬓斑白，应该已年近古稀，他朝着山顶的方向招呼，就像呼唤孩子回家一样，就在这时，整座山刮起了大风，窗户里的光也被吹得摇曳不定，老人便关上了窗户。\r\n看到这，我们也没多想，继续朝着目标营地出发。没一会儿，天空就开始飘起了碎碎的雪花，随后不到一盏茶的时间，山顶又开始狂风乱作，飘起了鹅毛大雪。肉眼可见地，整片山脉慢慢地亮了起来，全部化作了白茫茫地一片。待到积雪有半尺左右的时候，雪又骤然停了，此时再向山下看去，几户人家已经被淹没在了雪地里。\r\n此时我们一队人围在一起，面面相觑，这阵雪来得有些诡异。突然地气温下降，打了大家一个措不及防，随身所带的衣服也很单薄，无法在这样的环境下保暖，今晚将注定是煎熬的一夜。我突然回想起刚上山顶的场景，想到老者的呼唤，顿时觉得这坐山可能有问题，于是想借着雪停了空当，下山去。\r\n我向大家表达了下山想法，有的表示想在原地静观其变，等天亮了再做打算，有的想继续前行，一鼓作气地走到目的地。就这样，大家就此分道扬镳，我开始向山下走去。\r\n走着走着，发现下山的路已经变得不再熟悉，此时，一座破烂的车站映入眼帘，和公交车站类似，有一个遮雨棚和一块站牌，片子上写着一个站字，其它的字已经被锈蚀，完全看不出来是什么了。\r\n我走近站台，发现站台上已经有一位队友到了，看他的样子，像是在候车。我正准备走过去和他搭话，突然心里咯噔一下，因为这位队友是继续爬山的队友之一，此时的他，已然换了一身干净的素色长袍，登山的工具包也不在背上，他手里拿着一张车票，就在那看着山顶的方向。我的心里突然生出了一种不好的预感，我静静地立在原地，轻微地呼吸着，一动也不动地观察着。\r\n过了一阵，一辆大巴车莫名地从山顶的方向缓缓驶来，破破烂烂地，车牌是诡异的红色。虽然已有很深的积雪，但是车轮轧过后，却没有留下一丝痕迹。大巴在站台处停了下来，那个队友便拿着车票准备上车，在登上车门口的时候，他扭头看了一眼山下，我从侧面看过去，他的眼里是深深不舍与留恋。随后，大巴启动，朝着山下驶去，直到消失在茫茫地雪地里。\r\n虽然没有车痕，但我记着小车驶过的路线，于是沿着它的路径，不停地走着走着，不知过了多久，突然感觉脚下的质地不一样了，是踩在马路上的感觉，再继续向前走几步，突然周围变得漆黑一片，我定睛一看，此时所在的地方，正是上山时马路的尽头，山腰上的人家依然亮着灯火，只是在这诡异的夜里，仿佛风中残烛，摇曳不定。\r\n我转身再看向山上，整座山脉充斥着空无和寂静，那漫天的大雪好似从未出现过一样，心底生出一阵恐惧和后怕。\r\n我心底默默回忆着刚上山时那灯火温暖的感觉，缓缓地向着人家的方向走去......\r\n\r\n梦于 2023-07-09\r\n\r\n","categories":["Essay","梦"],"tags":["生活感悟","梦"]},{"title":"《非暴力沟通》读书笔记","url":"/posts/2023/3KQXHMP.html","content":"\r\n读完《非暴力沟通》，略有所得，于是整理其中的阅读心得，以便在日常使用。\r\n\r\n总结\r\n通读全书，其核心思想是：\r\n不论什么场景（交流、愤怒、被别人感激等），我们都应该通过非暴力沟通的思想，先客观观察、接着体悟此时的感受、然后明确需要，最后根据需要提出请求。\r\n通过非暴力沟通的 4\r\n个步骤，使我们与人沟通时对事不对人，直指任务核心，提高沟通效率、降低情绪对自己的影响。\r\n\r\n重要的步骤再次重复一遍：\r\n\r\n客观观察\r\n表达感受\r\n明确需要\r\n提出请求\r\n\r\n\r\n第一章 让爱融入生活\r\n\r\n转变谈话和岭听的方式，改用非暴力沟通\r\n既诚实、清晰地表达自己，又尊重与倾听他人\r\n\r\n非暴力沟通过程：\r\n\r\n先客观观察\r\n接着表达感受\r\n然后明确需要\r\n最后提出请求\r\n\r\n第二章 什么蒙蔽了爱?\r\n本章主要讲是什么让我们忽略了他人的感受，不知不觉地与他人在进行暴力沟通。\r\n主要原因有：\r\n\r\n用并道德标准去评判别人\r\n与其它案例进行比较，达不到自己的期望\r\n为了回避责任而失去理性\r\n强人所难\r\n\r\n总结上述几条原因，可以归结为，我们习惯站在自己的角度看到问题，当他人未能达到自己的预期时，就会使自己容易失去理智，不自觉地产生暴力沟通。\r\n第三章 区分观察和评论\r\n观察：客观地对既有现象进行陈述\r\n评论：带有主观意志地发表看法\r\n以下面的一句话为例：\r\n哥哥昨天无缘无故对我发脾气。\r\n“无缘无故＂是评论。此外，我认为说哥哥发脾气了也是评论。他也可能是感到害怕、悲伤或别的。\r\n以下例句描述了观察结果而不含任何评论：哥哥告诉我他生气了。\r\n第四章 体会和表达感受\r\n可以换位思考，细心地去体会对方的情绪，然后准确地表达自己的感受。\r\n感受与想法不一样，要注意区分：\r\n感受：描述自身客观的状态\r\n例：作为吉他手，我有些失落。\r\n想法：通过主观加工后的表达\r\n例：我觉得我吉他弹得不好。\r\n为了能够清楚表达自己的感受，可以借鉴以下词汇：\r\n\r\n需要得到时满足时的感受：\r\n\r\n兴奋、喜悦、欣喜、甜蜜、精力充沛、兴高采烈、感激、感动、乐观、自信、振作、振奋、开心、高兴、快乐、愉快、幸福、陶醉、满足、欣慰、心旷神怡、喜出望外、平静、自在、舒适、放松、踏实、安全、温暖、放心、无忧无虑\r\n\r\n需要没有得到满足时的感受：\r\n\r\n害怕、担心、焦虑、忧虑、着急、紧张、心神不宁、心烦意乱、忧伤、沮丧、灰心、气馁、泄气、绝望、伤感、凄凉、悲伤、恼怒、愤怒、烦恼、苦恼、生气、厌烦、不满、不快、不耐烦、不高兴、震惊、失望、困惑、茫然、寂寞、孤独、郁闷、难过、悲观、沉重、麻木、精疲力尽、委靡不振、疲惫不堪、昏昏欲睡、无精打采、槛勉、惭愧、内疚、妒忌、遗憾、不舒服\r\n当听到不中听的话时，我们有四种选择：\r\n\r\n责备自己\r\n指责他人\r\n体会白己的感受和需要\r\n体会他人的感受和需要\r\n\r\n\r\n根据场景选择不同的应对方式，第 3 和 4 会让人理智和客观\r\n\r\n第五章 感受的根源\r\n感受的根源在于我们自身的需要(我觉得也可以理解成诉求)。通过了解我们自己的需要、愿望、期待以及想法，我们可以准确表达自己的感受。\r\n当听到不中听的话时，我们就会去体会别人和自己的感受，然后进一步分析彼此的诉求，从而理智、客观地进行非暴力沟通。\r\n第六章 请求帮助\r\n当我们明确自己的需要后，要向对方提出具体的请求。为了使得请求更容易得到积极回应，我们可以：\r\n\r\n提出的请求要具体。\r\n在交流中明确谈话目的，不要跑题\r\n主动请求反馈。可以主动问一句：\"我的意思楚了吗？\"\r\n\r\n在实践中，我们要区分请求与命令的区别：—旦人们认为不答应就会受到责罚，他们就会把请求看作是命令。\r\n因此，如果是领导对下属，可以提前清楚地表达自己无意强人所难，让避免让方将某个请求理解成命令。\r\n第七章 用全身心倾听\r\n为了倾听他人，我们需要先放下已有的想法和判断，全神贯注地体会对方，发现对方真实的需要。\r\n倾听他人有助于对他人的理解和接纳。\r\n有时，我们可以主动表达我们的理解，来帮助对方了解我们在何种程度上明白丁他的意思。\r\n当我们痛苦得无法倾听他人时，我们需要：\r\n\r\n体会自己的感受和需要\r\n大声地提出请求\r\n换—个环境\r\n\r\n第八章 倾听的力量\r\n\r\n通过倾听，我们将意识到他人的人性以及彼此的共通之处，这会使白我表达变得容易。\r\n通过倾听，可以减少可能发生的潜在暴力\r\n如果别人说“不”，有时候并不是拒绝，通过倾听，我们可以发现对方真实的诉求\r\n\r\n第九章 爱自己\r\n将非暴力沟通应用于自身，让自己与本我进行非暴力沟通，从而培育对自己的爱。\r\n当我们的表现不完美时，我们可以通过体会忧伤和自我宽恕，来看清个人成长的方向，以及避免自我惩罚。\r\n当评价自己的行为时，我们专注于尚未满足的需要。\r\n在曰常生活中，我们主动根据需要和价值观来选择生活，用“选择做”来取代“不得不”，将被动转为主动。\r\n\r\n将【不得不做】做转换成【我选择做_，是因为我想_】，激发主观能动性\r\n\r\n第十章 充分表达愤怒\r\n非暴力沟通并不主张忽视或压抑愤怒，它认为，通过深入地了解愤怒，我们可以充分表达内心的渴望。\r\n愤怒形成的原因：由于自身的感受和需要没有得到满足\r\n在愤怒时，我们应专注于自己或他人的感受和需要，将愤怒化为满足需求的动力，而不是驱使我们去惩罚他人。\r\n表达愤怒的步骤：\r\n\r\n首先，停下来，除了呼吸，什么都别做，我们避免采取行动去指责或惩罚对方。我们只是静静地体会自己\r\n想—想是什么想法使我们生气了\r\n了解自己想要满足的需要\r\n表达感受和尚未满足的需要\r\n\r\n第十一章 运用强制力避免伤害\r\n在有些情形中，我们没有机会和他人交流，这时，我们也许需要使用强制力来保护白己和他人。使用强制力的目的是出于防卫的巨的而不是为了惩罚对方。\r\n第十二章 生活的热情\r\n通过运用非暴力沟通，我们不再试图分析自己或他人有什么毛病，而是用心去了解我们的需要，这样，我们的内心将逐渐变得平和。—旦我们发现自己心底深处的愿望并采取积极的行动，我们将会重获生活的热情。\r\n第十三章 表达感激\r\n非暴力沟通表达感激的方式包含三个部分：\r\n\r\n对方做了什么事情使我们的生活得到了改善\r\n我们有哪些需要得到了满足\r\n我们的心情怎么样\r\n\r\n当另别人对我们表达感激时，我们可以与对方—起庆祝生命的美—既不自大，也不假谦虚。\r\n","categories":["Essay","读书笔记"],"tags":["读书笔记"]},{"title":"记一次小孩住院经验总结","url":"/posts/2025/2EC5R3Z.html","content":"今天，小孩因连续高烧住院了，通过这个次住院经历，我学习到了一些诊断经验，也趟了一些住院的坑，在此总结反思，以此自勉。\r\n\r\n治疗经过\r\n整个治疗过程如下：\r\n第一天（02-15）\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n时间\r\n事件\r\n备注\r\n\r\n\r\n\r\n\r\n02-15 00:30\r\n第1次，突发发热至39度，吃退烧药\r\n\r\n\r\n\r\n02-15 06:00\r\n第2次发烧，吃退烧药，决定就医\r\n\r\n\r\n\r\n02-15 09:00\r\n医生查手指血，说指标异常，需要住院\r\n\r\n\r\n\r\n02-15 10:30\r\n成功办理住院，小孩再次高烧，护士使用退热栓退烧\r\n\r\n\r\n\r\n02-15 11:30\r\n做肺部 CT\r\n小孩罕见咳嗽，且未闻干湿啰音，但是医生还是开了一个肺部\r\nCT，最终结果显示正常\r\n\r\n\r\n02-15 15:30\r\n静脉注射头孢消炎\r\n\r\n\r\n\r\n02-15 06:00 ~ 02-16 09:00\r\n不断反复高烧，通过美林进行退烧\r\n\r\n\r\n\r\n02-15 20:00\r\n静脉注射消炎药\r\n\r\n\r\n\r\n\r\n入院第一天，医院未做其它检查，只是按病毒、细菌感染进行治疗。\r\n个人认为，作为医生，应结合季节判断，初步定为病毒、细菌感染，就应该按这个方向安排一些检查进行排查。\r\n第二天（02-16）\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n时间\r\n事件\r\n备注\r\n\r\n\r\n\r\n\r\n02-16 07:00\r\n采血，进行以下检测：血常规分析-1大生化32项+心肌酶谱降钙素原-1DIC全套7项-1免疫球蛋白补体\r\nIgE6项13种呼吸道病原体核酸检测咽拭培养(一般细菌+嗜血杆菌)小儿血培养\r\n血型是主动要求的，不计入\r\n\r\n\r\n02-16 09:00\r\n静脉注射头孢、氨溴索、激素\r\n\r\n\r\n\r\n02-16 15:00\r\n继续上述治疗方案\r\n\r\n\r\n\r\n\r\n今天早晨，安排采血，主要做了表中的 4 项检查。\r\n由于从 15\r\n号住院至今，小孩依旧反复发烧，因此医生开了激素用于阻断炎症因子继续扩大。\r\n截止今天中午 12:00 已经没有出现发烧的情况，情况好转。\r\n第三天（02-17）\r\n\r\n\r\n\r\n时间\r\n事件\r\n备注\r\n\r\n\r\n\r\n\r\n02-17 08:30\r\n血常规+CRP\r\n\r\n\r\n\r\n02-17 09:00\r\n静脉注射头孢、氨溴索、激素\r\n\r\n\r\n\r\n02-17 15:00\r\n继续上述方案\r\n\r\n\r\n\r\n\r\n第四天（02-18）\r\n今天依旧是常规治疗，截止目前，小孩已经几乎恢复了，中午申请出院，医生说还要观察一天，但是今天治疗完后，也没有后续治疗了，回家观察也是一样，所以晚上直接回家。\r\n所有检查截图\r\n\r\n\r\nimage-20250224175432218\r\n\r\n部分检查的作用\r\n通过询问 DeepSeek，了解到每项检查的作作用如下：\r\n血常规分析\r\n\r\n区分感染类型\r\n\r\n细菌感染：通常表现为\r\n白细胞总数升高（尤其是中性粒细胞增多），可能伴随\r\nC反应蛋白（CRP） 或 降钙素原（PCT）\r\n明显升高。\r\n病毒感染：白细胞总数可能正常或降低，淋巴细胞比例相对增高（如EB病毒、流感等）。\r\n其他病原体：如支原体感染可能表现为白细胞正常或轻度升高，但淋巴细胞比例增加。\r\n\r\n评估炎症反应\r\n\r\nC反应蛋白（CRP） 和 血沉（ESR）\r\n等指标可反映体内炎症活跃程度，帮助判断感染严重性。\r\n某些重症感染（如脓毒症）可能伴随血小板减少或异常白细胞形态。\r\n\r\n\r\n大生化32项+心肌酶谱\r\n大生化32项包括肝肾功能、电解质、血糖、蛋白质等指标。对于发烧的小孩，这些指标能帮助评估是否有器官损伤，比如肝脏或肾脏问题。例如，如果孩子有脱水，电解质可能异常；如果持续高烧，可能影响肝功能，转氨酶升高。此外，血糖异常可能提示代谢问题或严重感染。\r\n大生化检查涵盖\r\n肝功能、肾功能、电解质、血糖、蛋白质、血脂、酶类\r\n等多项指标，帮助评估以下问题：\r\n\r\n评估脏器功能\r\n\r\n肝功能（如ALT、AST、胆红素）：排除肝炎、药物性肝损伤或EB病毒等感染引起的肝损害。\r\n肾功能（如肌酐、尿素氮）：判断是否因脱水、感染或肾炎导致肾功能异常。\r\n心肌酶谱（如CK-MB、LDH）：结合心肌酶谱检查，进一步筛查心肌损伤（见下文）。\r\n\r\n发现电解质紊乱\r\n\r\n发热伴呕吐、腹泻可能导致\r\n低钠、低钾，严重时引发抽搐或心律失常。\r\n长期食欲不振或脱水时，需监测 钙、镁\r\n等电解质平衡。\r\n\r\n识别代谢异常\r\n\r\n血糖异常：严重感染可能引发应激性高血糖，或低血糖（如脓毒症、代谢性疾病）。\r\n白蛋白降低：长期发热或营养不良可能导致低蛋白血症，影响免疫力。\r\n\r\n辅助诊断特定疾病\r\n\r\n肌酸激酶（CK）升高：提示肌肉损伤（如肌炎、横纹肌溶解）。\r\n乳酸脱氢酶（LDH）升高：可能提示组织损伤（如溶血、心肌炎、某些肿瘤）。\r\n\r\n\r\n心肌酶谱主要检查心肌损伤的标志物，比如CK-MB、肌钙蛋白。小孩发烧有时会并发心肌炎，特别是病毒感染后，比如柯萨奇病毒。心肌酶谱升高可能提示心肌受损，需要及时处理，避免病情加重。\r\n心肌酶谱主要检测\r\nCK-MB（肌酸激酶同工酶）、肌钙蛋白（cTnI/cTnT）、乳酸脱氢酶（LDH）\r\n等，用于：\r\n\r\n筛查心肌炎\r\n\r\n病毒感染（如柯萨奇病毒、流感病毒）可能引发心肌炎，表现为\r\n胸痛、心悸、乏力，严重时导致心力衰竭。\r\nCK-MB和肌钙蛋白升高\r\n是心肌损伤的标志，需结合心电图、心脏超声进一步确诊。\r\n\r\n评估心肌损伤程度\r\n\r\n持续高热可能增加心脏负荷，原有心脏疾病患儿风险更高。\r\n心肌酶谱动态监测可判断病情进展或恢复情况。\r\n\r\n鉴别其他疾病\r\n\r\n某些全身性疾病（如川崎病、重症肺炎）可能继发心肌损伤，需及时干预。\r\n\r\n\r\n这些检查通常在以下情况下考虑： ① 持续高热不退\r\n② 伴随其他严重症状（如呕吐、乏力、尿少、水肿等）\r\n③ 怀疑并发症（如心肌炎、肝肾损伤）\r\n④ 常规治疗无效\r\n当小孩发烧时，医生建议检测 降钙素原（PCT）\r\n的主要目的是帮助\r\n快速鉴别细菌感染与病毒感染，并评估感染的严重程度，从而指导抗生素的合理使用。以下是具体作用及临床意义：\r\n降钙素原（PCT）\r\n\r\n核心作用\r\n\r\n区分细菌感染 vs. 病毒感染\r\n\r\n细菌感染（尤其是全身性感染）： PCT水平\r\n显著升高（例如脓毒症、肺炎链球菌肺炎、化脓性脑膜炎等）。\r\n病毒感染（如流感、普通感冒、手足口病）： PCT通常\r\n正常或仅轻度升高（一般&lt;0.5 ng/mL）。\r\n非感染性炎症（如川崎病、幼年特发性关节炎）：\r\nPCT通常不升高，有助于与细菌感染鉴别。\r\n\r\n评估感染严重程度\r\n\r\nPCT水平与细菌感染的严重程度呈正相关：\r\n\r\n轻度局部感染（如扁桃体炎）：PCT轻度升高（0.5-2\r\nng/mL）。\r\n严重细菌感染（如脓毒症、化脓性关节炎）：PCT显著升高（&gt;2\r\nng/mL，甚至&gt;10 ng/mL）。\r\n\r\n动态监测PCT可反映治疗效果：治疗有效时，PCT水平会快速下降。\r\n\r\n指导抗生素使用\r\n\r\n高PCT水平：强烈提示细菌感染，需及时启动抗生素治疗。\r\n低PCT水平：若临床不支持细菌感染，可减少或避免不必要的抗生素使用，降低耐药风险。\r\n儿童脓毒症管理：PCT是国际指南推荐的脓毒症诊断和抗生素疗程调整的重要指标。\r\n\r\n\r\n\r\n在儿童发热中的特殊价值\r\n\r\n早期识别脓毒症 儿童脓毒症进展迅速，PCT在感染后\r\n2-4小时\r\n即可升高，比CRP（C反应蛋白）更早反映全身性细菌感染，有助于早期干预。\r\n减少误诊风险\r\n\r\n部分病毒感染（如腺病毒、EB病毒）可能引起高热和白细胞升高，易被误判为细菌感染，PCT可辅助鉴别。\r\n对于 发热伴CRP升高但PCT正常\r\n的患儿，需警惕病毒感染或非感染性炎症。\r\n\r\n指导抗生素疗程\r\n\r\n动态监测PCT（如每24-48小时检测）：\r\n\r\n若PCT下降至正常范围，可考虑停用抗生素；\r\n若PCT持续升高，需警惕治疗失败或并发症（如脓肿形成）。\r\n\r\n\r\n\r\n\r\n适用场景\r\n医生可能在以下情况建议检测PCT：\r\n\r\n持续高热不退（&gt;3天），常规治疗无效。\r\n疑似严重细菌感染：如发热伴意识模糊、呼吸急促、皮肤瘀斑、四肢冰凉等脓毒症征象。\r\n复杂病情：如发热合并基础疾病（先天性心脏病、免疫缺陷）。\r\n术后或重症患儿：排查继发细菌感染。\r\n\r\nDIC 全套7项\r\n主要目的是评估是否存在 弥散性血管内凝血（DIC）\r\n——一种由严重感染、创伤或全身性疾病引发的凝血功能紊乱危重症。DIC可能导致全身广泛微血栓形成和出血倾向，若不及时干预可能危及生命。以下是具体作用及临床意义：\r\n\r\n核心特征\r\nDIC是多种疾病（如脓毒症、重症肺炎、中毒性休克）的并发症，表现为：\r\n\r\n凝血系统过度激活：全身微血管内血栓形成，消耗凝血因子和血小板。\r\n继发性纤溶亢进：血栓分解过程中引发异常出血（如皮肤瘀斑、黏膜出血、内脏出血）。\r\n多器官功能衰竭：微血栓阻塞导致器官缺血损伤（如肾衰竭、肝损伤、脑功能障碍）。\r\n\r\n\r\n检查的作用\r\nDIC检查通常包括以下指标（具体项目可能因医院略有差异）：\r\n\r\n血小板计数（PLT）\r\n\r\n意义：DIC时血小板被大量消耗，数值\r\n进行性下降（&lt;100×10⁹/L提示风险）。\r\n注意：需动态监测，单次降低可能由其他原因（如感染）引起。\r\n\r\n纤维蛋白原（FIB）\r\n\r\n意义：凝血过程中被消耗，DIC时\r\n显著降低（&lt;1.5 g/L为危险信号）。\r\n例外：感染或炎症早期可能因应激反应暂时升高，需结合其他指标。\r\n\r\nD-二聚体（D-Dimer）\r\n\r\n意义：反映纤溶活性，DIC时\r\n显著升高（&gt;5 μg/mL提示高凝和纤溶亢进）。\r\n注意：其他血栓性疾病（如深静脉血栓）也会升高，需结合临床。\r\n\r\n凝血酶原时间（PT）\r\n\r\n意义：外源性凝血途径异常时延长（DIC时通常\r\n延长≥3秒）。\r\n\r\n活化部分凝血活酶时间（APTT）\r\n\r\n意义：内源性凝血途径异常时延长（DIC时可能延长或正常）。\r\n\r\n凝血酶时间（TT）\r\n\r\n意义：反映纤维蛋白原功能，DIC时因纤维蛋白原减少或异常而\r\n延长。\r\n\r\n抗凝血酶III（AT-III）\r\n\r\n意义：DIC时因过度消耗导致活性\r\n降低（&lt;60%提示风险）。\r\n\r\n\r\n何时做\r\n医生在以下情况会高度警惕DIC风险，建议完善检查：\r\n\r\n严重感染：\r\n\r\n脓毒症、重症肺炎、化脓性脑膜炎、坏死性筋膜炎等。\r\n发热伴 皮肤瘀斑、穿刺点渗血、血便、血尿\r\n等出血倾向。\r\n\r\n休克或器官衰竭：\r\n\r\n发热合并 血压下降、少尿、呼吸困难、意识障碍。\r\n\r\n实验室预警信号：\r\n\r\n血常规提示血小板进行性下降，或凝血功能（如PT/APTT）异常。\r\n\r\n基础疾病加重：\r\n\r\n白血病、实体瘤、严重肝病患儿发热时，DIC风险更高。\r\n\r\n\r\n总结\r\n通过这次住院经历，首先学习了小孩发烧情况下，如何科学有效地处理。同时了解了各项检查的作用和使用场景，若再发生类似事件，今后可以做到心中有数。\r\n从上面的检查项目中来看，有些项可以不必做，比如大生化32项、降钙素原等；有的项，可以提前做，比如13种呼吸道病原体核酸检测、咽拭培养(一般细菌+嗜血杆菌)这些不需要晨血的项目，可以帮助更早地定位病因。\r\n","categories":["Essay","2025年"],"tags":["生活"]},{"title":"一张彩票引发服务器宕机一整天","url":"/posts/2025/1QGRPD8.html","content":"\"No zuo no\r\ndie\"，今天算是被狠狠地教育了一顿，今天发生了一件绝对离奇的事情，一张彩票居然导致我的服务器宕机了一整天，事后回想起来，还是忍俊不禁。\r\n实情的经过是这样的...\r\n\r\n家里的服务器使用 esxi\r\n的虚拟机进行安装，服务器除了系统盘外，还有两块硬盘，一块挂载到\r\n/home 目录，一块是备份，分别为\r\nsdb1，sdc1。\r\n某天，sdc1\r\n突然掉线，不能使用了。然后我当时的想法就时，硬盘坏了，然后一顿猛虎操作，各种检测，最终定性为硬盘彻底坏了。就在准备拆硬盘时，发现硬盘供电的电源松了，那就插上试试吧，居然好了！\r\n这个时候，还挺开心，因为不是硬盘问题，省了硬盘钱。\r\n接着，我脑海里开始浮现出一个有创意的想法：\"两块硬盘不好辨识，还是贴个标签区分下吧\"，这个操作一点毛病没有，但神奇的操作就来了。我环视了下，周围没有什么可以作为标签的纸，突然发现在胶带下面压着一张陈年双色球彩票，成色挺新，纸张也不错，上面还有底纹，心想，这个当作标签，看着很高端啊，就它了。\r\n\r\n\r\nimage-20250224130536026\r\n\r\n然后就撕了一个小长条，写上标签，往硬盘线(sdb1，挂载\r\n\\home\r\n目录的硬盘)上一包，然后开始启动，此刻，灾难开始降临了！\r\n启动的时候，就出现错误：\r\ncritical target error, dev sdb, sector 1396705280 op 0x0:(READ) flags 0x83700 phys_seg 1 prio class 0Buffer I/O error on dev sdb, logical block 1932735065,async page readcritical target error, dev sdb, sector 1931223880 op 0x1:(WRITE)flags 0x9800 phys_seg 12 prio class 2EXT4-fs error (device sdb1): ext4_wait_block bitmap:582: comn ext4lazyinit: cannot read block bitmap - block_group = 5552, block\r\n磁盘无法读写。\r\n于是猜测可能是当时插拔电源的时候，导致硬盘坏道了，然后以开始不断折腾尝试，进行磁盘修复、磁盘健康检查、接线检查、重启系统、都无法解决。期间也问了\r\nDeepSeek 等 AI 助手，皆无法解决。\r\n在某次进行 sudo fsck -f /dev/sdb1\r\n当磁盘修复时，重新挂载后，可以读取到里面的文件了，于是赶紧使用\r\nrsync 将整个 /home\r\n备份。然后开始对磁盘进行格式化，esxi 虚拟机重建，一直折腾到第二天凌晨 2\r\n点，依然无法解决。\r\n最后，想着算了，反正数据备份了，重新买一块盘吧。\r\n早上起来后，脑中又开始琢磨，自己不至于这么倒霉，硬盘全坏了，现在的工况和以前正常时，好像没变呀，想着想着，突然灵光一闪，难不成是标签的原因？于是死马当活马医，然后将标签撕掉，重启后，硬盘正常被读写！\r\n然后问了 DeepSeek，可能的原因如下：\r\n\r\n彩票纸张或油墨可能含有微量金属成分，包裹时形成电磁屏蔽层，干扰\r\nSATA 信号传输（尤其是高频信号）\r\n实验数据表明，普通印刷品可使 2.5GHz 信号衰减 3-5dB，超出 SATA III\r\n规范要求的 ±0.5dB 容差\r\n\r\n真相了，该死的彩票，尽欺我老实人！\r\n经过这次事件，吸取了一些教训，以此自勉：\r\n\r\n没事不折腾\r\n遇事先思考再动手\r\n遇事不明时，不要想太复杂，由简入深地慢慢理\r\n\r\n","categories":["Essay","2025年"],"tags":["生活"]},{"title":"在加油站遭遇假优惠活动","url":"/posts/2025/34TZ2J9.html","content":"今天加油的时候，遇到加油站推荐参加 “双十一”\r\n活动，耐不住工作人员热情推销，恍惚间就下单了，然后事后冷静下来，仔细一盘算，居然是个坑。\r\n本文特此记录，吃一堑，长一智，以此自省。\r\n\r\n该加油站日常有两种优惠：\r\n\r\n方案 A：直接加油时，打 8.8 折。\r\n方案 B：充值 1000 时，赠送 120，实际得 1120\r\n元，这些金额加油时，不再享受方案 A折扣。\r\n\r\n然后在双十一，推出了一个活动 (此处称作方案 C)：399元购买 20张\r\n20元优惠券，该优惠券每满 100\r\n可用一张。同时还赠送两瓶酒、一袋纸巾、一小壶油、一袋 5kg\r\n的大米。使用优惠券后，不享受方案 A 折扣。\r\n当时工作人员介绍的说，相当于花 399，不仅有礼品拿，今后加油还相当于打\r\n8 折，我一听，还挺划算的。\r\n然后，并不是如此，每个方案分析如下：\r\n方案 A: \r\n8.8 折，没毛病。\r\n若实际消费 100元，则相当于在加油站获得了价值 \\(100/0.88=113.63\\) 元的服务。\r\n方案 B：\r\n充值 1000 时，赠送 120，这个方案初看下，和方案 A\r\n是一样的折扣，实际则不然。\r\n换算到 100元的标准，则相当于获取得 \\(100+12=112\\)\r\n元的服务。同时，还被加油站绑定了消费，今后每次都会去他这儿消费。\r\n对于这种满送的活动，计算折扣公式为：\\(送/(送+本金)*100\\)\r\n方案 C：\r\n方案 C 是最坑的方案。\r\n虽然用 399 买了 20张\r\n20元的券，但是券的价值没有超过实际的金额，因此这个相当于没有优惠，那么，我们获得的优惠是什么呢？就是他赠送的礼品。\r\n现在我们来分析下：\r\n若要使用完 20张券，得在该加油站合计消费 \\(400+(100-20)*20=400+1600=2000\\) 元\r\n若我们不参加活动，消费 2000元时，可以省下的钱为 \\(2000*(1-0.88)=240\\) 元\r\n那么，这个方案对于消费者而言，就是用\r\n240元和长期绑定的消费，换取了两瓶酒、一袋纸巾、一小壶油、一袋 5kg\r\n的大米。\r\n所以，为什么不去超市买这些东西，而去加油站买，还把自己绑定在他那儿呢？\r\n通过上面的分析，我们来总结下：\r\n\r\n\r\n\r\n方案\r\n实际折扣\r\n备注\r\n\r\n\r\n\r\n\r\n方案 A\r\n8.8 折\r\n\r\n\r\n\r\n方案 B\r\n8.93 折\r\n绑定消费\r\n\r\n\r\n方案 C\r\n看赠品的价值\r\n绑定消费\r\n\r\n\r\n\r\n当时离开了加油站，才察觉到问题所在，内心几度纠结是否要去退单，如果去的话，感觉脸上有点挂不住，可能对方还不给退，还得拉扯一通。\r\n最后一想到，自己苦苦挣扎求生已经很累了，把钱省下来带孩子出去玩玩不好吗，什么面子，见鬼去吧，最后，对方很爽快地、顺利地给我退了，服务可以。\r\n今后，遇到此类事情，我觉得不可操之过急，需要冷静对待，若时间不够，无法马上下决定时，一定要延期决策，不能被环境逼迫，做下错误的决定。\r\n若错误已经造成，应及时，积极地去面对处理。\r\n","categories":["Essay","2025年"],"tags":["生活"]},{"title":"docker常用命令集合","url":"/posts/2021/2BXPYRB.html","content":"docker 的常用命令集合。\r\n\r\n语法说明\r\n[ ] 号代表是可选项\r\n容器生命周期管理\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n命令\r\n作用\r\n语法\r\n\r\n\r\n\r\n\r\nrun\r\n创建一个新的容器并运行一个命令\r\ndocker run [OPTIONS] IMAGE [COMMAND] [ARG...]\r\n\r\n\r\nstart/stop/restart\r\n启动/停止/重启容器\r\ndocker start/stop/restart [OPTIONS] CONTAINER [CONTAINER...]\r\n\r\n\r\nkill\r\n杀掉一个运行中的容器\r\ndocker kill [OPTIONS] CONTAINER [CONTAINER...]\r\n\r\n\r\nrm\r\n删除一个或多个容器\r\ndocker rm [OPTIONS] CONTAINER [CONTAINER...]\r\n\r\n\r\npause/unpause\r\n暂停/恢复容器\r\ndocker pause/unpause CONTAINER [CONTAINER...]\r\n\r\n\r\ncreate\r\n创建一个新的容器但不启动它\r\ndocker create [OPTIONS] IMAGE [COMMAND] [ARG...]\r\n\r\n\r\nexec\r\n在运行的容器中执行命令\r\ndocker exec [OPTIONS] CONTAINER COMMAND [ARG...]\r\n\r\n\r\n\r\n容器操作\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n命令\r\n作用\r\n语法\r\n\r\n\r\n\r\n\r\nps\r\n列出容器\r\ndocker ps [OPTIONS]\r\n\r\n\r\ninspect\r\n获取容器/镜像的元数据\r\ndocker inspect [OPTIONS] NAME|ID [NAME|ID...]\r\n\r\n\r\ntop\r\n查看容器中运行的进程信息，支持 ps 命令参数\r\ndocker top [OPTIONS] CONTAINER [ps OPTIONS]\r\n\r\n\r\nattach\r\n连接到正在运行中的容器\r\ndocker attach [OPTIONS] CONTAINER\r\n\r\n\r\nevents\r\n从服务器获取实时事件\r\ndocker events [OPTIONS]\r\n\r\n\r\nlogs\r\n获取容器的日志\r\ndocker logs [OPTIONS] CONTAINER\r\n\r\n\r\nwait\r\n阻塞运行直到容器停止，然后打印出它的退出代码\r\ndocker wait [OPTIONS] CONTAINER [CONTAINER...]\r\n\r\n\r\nexport\r\n将文件系统作为一个tar归档文件导出到STDOUT\r\ndocker export [OPTIONS] CONTAINER\r\n\r\n\r\nport\r\n列出指定的容器的端口映射，或者查找将PRIVATE_PORT\r\nNAT到面向公众的端口\r\ndocker port [OPTIONS] CONTAINER [PRIVATE_PORT[/PROTO]]\r\n\r\n\r\n\r\n容器rootfs命令\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n命令\r\n作用\r\n语法\r\n\r\n\r\n\r\n\r\ncommit\r\n从容器创建一个新的镜像\r\ndocker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]\r\n\r\n\r\ncp\r\n用于容器与主机之间的数据拷贝\r\n从容器到本机：docker cp [OPTIONS] CONTAINER:SRC_PATH\r\nDEST_PATH|-从本机到容器：docker cp [OPTIONS] SRC_PATH|-\r\nCONTAINER:DEST_PATH\r\n\r\n\r\ndiff\r\n检查容器里文件结构的更改\r\ndocker diff [OPTIONS] CONTAINER\r\n\r\n\r\n\r\n镜像仓库\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n命令\r\n作用\r\n语法\r\n\r\n\r\n\r\n\r\nlogin/logout\r\n登陆/登出到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库\r\nDocker Hub\r\ndocker login/logout [OPTIONS] [SERVER]\r\n\r\n\r\npull\r\n从镜像仓库中拉取或者更新指定镜像\r\ndocker pull [OPTIONS] NAME[:TAG\\|@DIGEST]\r\n\r\n\r\npush\r\n将本地的镜像上传到镜像仓库,要先登陆到镜像仓库\r\ndocker push [OPTIONS] NAME[:TAG]\r\n\r\n\r\nsearch\r\n从Docker Hub查找镜像\r\ndocker search [OPTIONS] TERM\r\n\r\n\r\n\r\n本地镜像管理\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n命令\r\n作用\r\n语法\r\n\r\n\r\n\r\n\r\nimages\r\n列出本地镜像\r\ndocker images [OPTIONS] [REPOSITORY[:TAG]]\r\n\r\n\r\nrmi\r\n删除本地一个或多个镜像\r\ndocker rmi [OPTIONS] IMAGE [IMAGE...]\r\n\r\n\r\ntag\r\n标记本地镜像，将其归入某一仓库\r\ndocker tag [OPTIONS] IMAGE[:TAG]\r\n[REGISTRYHOST/][USERNAME/]NAME[:TAG]\r\n\r\n\r\nbuild\r\n命令用于使用 Dockerfile 创建镜像\r\ndocker build [OPTIONS] PATH | URL | -\r\n\r\n\r\nhistory\r\n查看指定镜像的创建历史\r\ndocker history [OPTIONS] IMAGE\r\n\r\n\r\nsave\r\n将指定镜像保存成 tar 归档文件\r\ndocker save [OPTIONS] IMAGE [IMAGE...]\r\n\r\n\r\nload\r\n导入使用 docker\r\nsave 命令导出的镜像\r\ndocker load [OPTIONS]\r\n\r\n\r\nimport\r\n从归档文件中创建镜像\r\ndocker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]\r\n\r\n\r\n\r\ninfo和version\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n命令\r\n作用\r\n语法\r\n\r\n\r\n\r\n\r\ninfo\r\n显示 Docker 系统信息，包括镜像和容器数\r\ndocker info [OPTIONS]\r\n\r\n\r\nversion\r\n显示 Docker 版本信息\r\ndocker version [OPTIONS]\r\n\r\n\r\n\r\n致谢\r\n本文摘抄至 runoob，方便日常使用快速查询，诚挚感谢！\r\n","categories":["System","Docker"],"tags":["docker"]},{"title":"Windows Server 2022 安装 Dockert","url":"/posts/2021/Q0YYS8.html","content":"如何在 Windows Server 2022 上安装 Docker 呢？经过实测，如果直接从\r\nDocker 官网下载 Docker Desktop\r\n进行安装，会出现启动失败的问题。特将正确的安装步骤记录如下：\r\n\r\n安装\r\n\r\n用管理员身份打开 PowerShell\r\n安装 docker 下载平台\r\nInstall-Module -Name DockerMsftProvider -Force\r\n会弹出确认选项，输入 y 即可\r\n安装 docker\r\nInstall-Package -Name docker -ProviderName DockerMsftProvider\r\n接下来会弹出一个确认框，输入 A 即可。\r\n如果第 3 步安装失败，需要手动下载并安装\r\n参考【手动安装】步骤\r\n安装完成后判断是否需要重启电脑\r\n(Install-WindowsFeature Containers).RestartNeeded\r\n如果此命令的输出为Yes\r\n，则使用以下命令重新启动服务器：\r\nRestart-Computer\r\n重启后，打开 PowerShell\r\n# 查看docker安装版本docker version# 启动容器net start docker\r\n修改镜像源\r\n在 C:\\ProgramData\\docker\\config\\daemon.json\r\n文件（如果不存在，则新建一个）中添加下列内容：\r\n&#123;    &quot;registry-mirrors&quot;:[&quot;https://letnjuzg.mirror.aliyuncs.com&quot;,&quot;https://registry.cn-hangzhou.aliyuncs.com&quot;,&quot;https://mirror.ccs.tencentyun.com&quot;,&quot;https://registry.docker-cn.com&quot;]&#125;\r\n通过运行hello-world容器来测试Docker\r\nEngine-Enterprise安装\r\ndocker run -p 52780:80 hello-world\r\n\r\n手动安装\r\ncd C:\\Users\\Administrator\\AppData\\Local\\Temp\\2\\DockerProvider# 打开配置文件 Docker_DockerSearchIndex.json 找到 preview 版本的 docker 链接进行下载，然后将下载的压缩包放到上面的目录中Start-BitsTransfer -Source https://dockermsft.blob.core.windows.net/dockercontainer/docker-18-09-0.zip -Destination docker-18-09-0.zipGet-FileHash -Path docker-18-09-0.zip -Algorithm SHA256Install-Package -Name docker -ProviderName DockerMsftProvider -VerboseRestart-Computer -Force\r\n\r\n下载地址可以查看 C:\\2目录中的 json 文件\r\n\r\n更新\r\nInstall-Package -Name docker -ProviderName DockerProvider -RequiredVersion preview -Update -Force\r\n使用\r\n在使用的过程中可能遇到一些问题，总结如下：\r\n\r\nIn the default daemon configuration on Windows, the docker client must be run with elevated privileges to connect.\r\n有可能是 docker 没有启动，输入 net start docker 启动\r\ndocker 就可以 了。\r\n提示\r\nimage: operating system linux cannot be used on this platform windows\r\n此种情况，需要切换为 linux 容器，使用如下命令切换：\r\n[Environment]::SetEnvironmentVariable(&quot;LCOW_SUPPORTED&quot;, &quot;1&quot;, &quot;Machine&quot;)Restart-Service docker\r\n如何切换回windows容器呢？\r\n[Environment]::SetEnvironmentVariable(&quot;LCOW_SUPPORTED&quot;, &quot;$null&quot;, &quot;Machine&quot;)\r\n容器进行端口映射后无法通过 127.0.0.1:port\r\n方式访问\r\n未解决\r\n\r\n致谢\r\n本文参考以下文章，在此致以诚挚谢意！\r\n\r\nLearn\r\nComputer Technologies\r\nRun\r\nDocker Containers on Windows Server 2019\r\n卸载docker\r\nhttps://www.altaro.com/msp-dojo/linux-containers-windows-server-2019/\r\nhttps://docs.microsoft.com/en-us/virtualization/windowscontainers/quick-start/set-up-environment?tabs=Windows-Server\r\nhttps://github.com/MicrosoftDocs/Virtualization-Documentation/issues/919#issuecomment-444717316\r\n\r\n","categories":["System","Docker"],"tags":["Docker","Windows Server"]},{"title":"Docker Compose 的简明使用","url":"/posts/2023/1ZZM4MX.html","content":"\r\n\r\nimage-20230415233342204\r\n\r\n使用 Docker Compose\r\n可以轻松、高效的管理容器，它是一个用于定义和运行多容器 Docker\r\n的应用程序工具。\r\n\r\n简介\r\ncompose、machine 和 swarm 是docker\r\n原生提供的三大编排工具。简称docker三剑客。\r\nDocker Compose能够在 Docker 节点上，以单引擎模式(Single-Engine\r\nMode)进行多容器应用的部\r\n署和管理。多数的现代应用通过多个更小的微服务互相协同来组成一个完整可用的应用。\r\n部署和管理繁多的服务是困难的。而这正是 Docker Compose\r\n要解决的问题。Docker Compose 并不 是通过脚本和各种冗长的 docker\r\n命令来将应用组件组织起来，而是通过一个声明式的配置文件描述整\r\n个应用，从而使用一条命令完成部署。\r\n应用部署成功后，还可以通过一系列简单的命令实现对其完整声\r\n明周期的管理。甚至，配置文件还可以置于版本控制系统中进行存储和管理。\r\ndocker-compose 安装\r\n从 compose v2 开始，docker-compose 的指令大部分已经集成到了 docker\r\n中，可以通过 docker compose（而不是 docker-compose）来使用。\r\n如果要使用 docker-compose，则需要单独安装程序，方法如下：\r\n使用 scoop 安装 docker-compose\r\nscoop install docker-compose\r\nyml 配置文件\r\nDocker Compose 使用 YAML 文件来定义多服务的应用。YAML 是 JSON\r\n的一个子集，因此也可以使用JSON。\r\nDocker Compose 默认使用文件名 compose.yaml。当然，也可以使用 -f\r\n参数指定具体文件。\r\ndocker-compose 按以下顺序使用配置文件：\r\ncompose.yaml compose.yml docker-compose.yaml docker-compose.yml compose.yaml\r\n配置示例\r\n# compose 文件 API 的版本号version: &#x27;3.9&#x27;# 服务services:  # mysql  mysql:    # 指定镜像名称    image: mysql/mysql:5.7    # 重启方式    restart: always    # 容器名称    container_name: mysql57    # 端口映射 本机:容器    ports:      - 3306:3306    # 挂载卷 本机:容器    volumes:      - /data/edu-bom/mysql/test:/var/lib/mysql    build:      context: ./mysql    environment:      # 设置 root 密码      MYSQL_ROOT_PASSWORD: admin    networks:      net:  eureka:    build:      context: ./edu-eureka-boot    restart: always    ports:      - 8761:8761    container_name: edu-eureka-boot    hostname: edu-eureka-boot    image: edu/edu-eureka-boot:1.0    depends_on:      - mysql57    networks:      net:networks:    net:volumes:    vol:\r\n顶层元素\r\n\r\n\r\nimage-20230415233342204\r\n\r\nDocker Compose 的 YAML 文件包含 6\r\n个顶层元素，分别是：version、services、networks、volumes、configs、secrets。\r\nversion\r\nversion\r\n截止目前（2023-04-15）已经弃用。它应总是位于文件的第一行。它定义了\r\nCompose 文件格式(主要是 API)的版本。注意，version 并非定义 Docker\r\nCompose 或 Docker 引擎的版本号。\r\n指定要使用的 Compose\r\n文件版本时，请确保同时指定主要版本号和次要版本号。如果没有给出次要版本，\r\n0则默认使用而不是最新的次要版本。\r\nDocker Engine 支持的 Compose 文件版本如下：\r\n\r\n\r\n\r\nCompose file format\r\nDocker Engine\r\nrelease\r\n\r\n\r\n\r\n\r\nCompose specification\r\n19.03.0+\r\n\r\n\r\n3.8\r\n19.03.0+\r\n\r\n\r\n3.7\r\n18.06.0+\r\n\r\n\r\n3.6\r\n18.02.0+\r\n\r\n\r\n3.5\r\n17.12.0+\r\n\r\n\r\n3.4\r\n17.09.0+\r\n\r\n\r\n3.3\r\n17.06.0+\r\n\r\n\r\n3.2\r\n17.04.0+\r\n\r\n\r\n3.1\r\n1.13.1+\r\n\r\n\r\n3.0\r\n1.13.0+\r\n\r\n\r\n2.4\r\n17.12.0+\r\n\r\n\r\n2.3\r\n17.06.0+\r\n\r\n\r\n2.2\r\n1.13.0+\r\n\r\n\r\n2.1\r\n1.12.0+\r\n\r\n\r\n2.0\r\n1.10.0+\r\n\r\n\r\n\r\nservices\r\nservices\r\n用于定义不同的应用服务。上边的例子定义了两个服务:一个名为\r\nlagou-mysql数据库服 务以及一个名为lagou-eureka的微服。Docker Compose\r\n会将每个服务部署在各自的容器中。\r\nservice 中很多配置项，下面根据日常使用的一致频率来分别进行介绍。\r\nimage\r\n指定 image 名称。\r\nbuild\r\n指定 Dockfile 所在的文件位置，可以是绝对位置或者相对位置，Compose\r\n会自动利用这路径下的 Dockfile 来自动构建出image，然后使用该 image\r\n进行容器的设定。\r\n使用默认文件名：\r\nversion: &quot;3.9&quot;services:  webapp:    build: ./dir #直接指定路径，前提要 dockfile 文件名刚好是 Dockerfile\r\n使用自定义文件名：\r\nversion: &quot;3.9&quot;services:  webapp:    build:      context: ./dir #透过 context 来指定路径      dockerfile: Dockerfile-alternate #说明要执行编译的 Dockfile 文件名      args: # 指定编译 image 时，所需要的 arguments        buildno: 1\r\ncommand\r\n用来覆盖容器启动后默认执行的动作。\r\nexpose\r\n开放 port 给 container 连线，但没有映射到 host 上\r\nexpose:  - &quot;3000&quot;  - &quot;8000&quot;\r\nports\r\n将 port 绑定在 host 上，然后就能在 host 的环境，与容器做交互\r\ndepends_on\r\n当使用 docker-compose up 时，依照依赖顺序来启动。\r\n当使用 docker-compose stop 时，依照依赖顺序的反序来关闭容器。\r\n\r\n只是启动顺序，但是不会等待容器的状态到 Ready\r\n如果要等待，可以使用 vishnubob/wait-for-it、eficode/wait-for\r\n来实现\r\n\r\nnetworks\r\nnetworks 用于指引 Docker\r\n创建新的网络。默认情况下，Docker Compose 会创建 bridge 网络。\r\n这是一种单主机网络，只能够实现同一主机上容器的连接。当然，也可以使用\r\ndriver 属性来指定不 同的网络类型。\r\nservices:  frontend:    image: awesome/webapp    networks:      - front-tier      - back-tiernetworks:  front-tier:  back-tier:\r\nvolumes\r\n顶层的 volumes\r\n为所有的服务提供公共的挂载卷，方便其它服务通过该位置进行共享和备份。\r\nservices:  backend:    image: awesome/database    volumes:      - db-data:/etc/data  backup:    image: backup-service    volumes:      - db-data:/var/lib/backup/datavolumes:  db-data:\r\n常用命令\r\nbuild\r\ndocker-compose build [options] [SERVICE...]\r\n重新 build 该项目所有 service 的 image\r\n--force-rm 删除临时容器\r\n--no-cache 就不用cache\r\n--pull 尝试拉取最新的image版本\r\nconfig\r\n验证 compose 文件格式，错误会显示错误原因\r\nup\r\ndocker-compose up [options] [SERVICE...]\r\n等于一整组的动作，重新 create container，start container，link\r\neach\r\n-d 将在后台运行\r\n--scale SERVICE_NAME=NUM，用来水平伸缩指定service的数量\r\nstop\r\ndocker-compose stop [options] [SERVICE...]\r\n停止状态是 running 的容器\r\nrm\r\ndocker-compose rm [options] [SERVICE...]\r\n会删除所有状态是 stopped 的容器，所以建议事先使用上面的stop\r\n来停止容器后再进行删除\r\nps\r\ndocker-compose ps [options] [SERVICE...]\r\n列出容器清单\r\nlogs\r\ndocker-compose logs [options] [SERVICE...]\r\n如果没指定 service name，则把所有 service 的 log 都输出\r\n参考\r\ndocker compose\r\n官方文档\r\n全网最详细的Docker-Compose详细教程\r\n","categories":["System","Docker"],"tags":["Docker","Software"]},{"title":"如何获取 docker 容器 IP","url":"/posts/2023/2Z6QFVS.html","content":"本文记录了几种获取 Docker 容器的 IP 地址的方式。\r\n\r\nDocker 网络解释\r\n首先来了解一下 Docker\r\n的网络是如何工作的。首先是默认的bridge 网络。当使用 Docker\r\n时，如果没有指定其它驱动默认会使用桥接网络。\r\n\r\nDocker 容器的 IP 地址\r\n默认情况下，会为连接到容器的每个 Docker\r\n网络分配一个IP地址，并为每个网络分配一个默认的子网掩码，用作稍后分配\r\nIP的地址池。\r\n通常 Docker 默认使用 172.17. 0.0/16\r\n作为容器网络的子网。\r\n使用 Docker Inspect\r\nDocker inspect 是检索 Docker\r\n对象底层信息的很棒的方式。可以以非常简单的方式在返回的 JSON\r\n里找出想要的字段。\r\ndocker inspect -f &#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27; 75000c343eb7# 输出172.24.0.3\r\n75000c343eb7 为实际容器的 id，输入 id\r\n只要保证唯一即可，不必全部输入。\r\n使用 Docker exec\r\ndocker exec redis cat /etc/hosts# 输出127.0.0.1       localhost::1     localhost ip6-localhost ip6-loopbackfe00::0 ip6-localnetff00::0 ip6-mcastprefixff02::1 ip6-allnodesff02::2 ip6-allrouters172.25.0.3      bfa21d61842as\r\n参考\r\n如何获取\r\nDocker 容器的 IP 地址\r\n","categories":["System","Docker"],"tags":["Docker","Software"]},{"title":"Docker 设置代理","url":"/posts/2023/3R4JKDX.html","content":"在使用 docker 拉取镜像时，有时候国内镜像源无法使用，需要使用 docker\r\n官方的镜像源这时需要给 docker 设置代理来提升下载速度。\r\n本文记录了 docker desktop 和 linux 中设置代理的方法和注意事项。\r\n\r\nwindows\r\nwindows 中使用 docker desktop 进行设置，具体方法如下：\r\n在【设置】-&gt;【Resources】-&gt;【Proxies】来设置代理，如下图所示：\r\n\r\n\r\nimage-20230621154906732\r\n\r\n特别注意：\r\n在设置代理地址时，不需要前面的协议(http://或https://)\r\nLinux\r\n本文以 Ubuntu 举例说明。\r\ndocker pull 和 docker build/docker run 使用代理的方式不一样！\r\ndocker pull 的代理被 systemd 接管，所以需要设置 systemd\r\n# 新增或编辑 docker 守护进程的代理配置sudo mkdir /etc/systemd/system/docker.service.d/ sudo vim /etc/systemd/system/docker.service.d/http-proxy.conf# 向文件中添加如下内容[Service]Environment=&quot;HTTP_PROXY=http://127.0.0.1:8123&quot;Environment=&quot;HTTPS_PROXY=http://127.0.0.1:8123&quot;Environment=&quot;NO_PROXY=localhost,127.0.0.0/8,192.168.23.1/24&quot;# 重启生效sudo systemctl daemon-reloadsudo systemctl restart docker\r\n参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\ndocker\r\n设置代理，以及国内加速镜像设置-次世代BUG池\r\n","categories":["System","Docker"],"tags":["Docker"]},{"title":"Docker 开源 UI 管理工具比选及安装","url":"/posts/2024/T4KD3R.html","content":"本文通过比选目前开源的 Docker GUI 管理工具，结合 Linux\r\n服务器的特点，最终选择安装 jesseduffield/lazydocker\r\n\r\n软件比选\r\n参考以下文章评测，若系统为桌面系统，建议安装\r\nDockerDesktop，因为它是官方出品。\r\n若是无桌面的服务器，可以选择 portainer 或者 lazydocker，前者是基于\r\nWeb 的 UI，后者是基于命令行的 UI。\r\n为了减少从终端到浏览器相互切换，使得管理 Ubuntu\r\n时更加顺滑，作者选择安装 lazydocker。\r\nlazydocker 安装\r\n使用以下命令一键安装：\r\ncurl https://raw.githubusercontent.com/jesseduffield/lazydocker/master/scripts/install_update_linux.sh | bash\r\n上述脚本默认下载到 home~/.local/bin\r\n中，可以通过修改环境变量 DIR 来更改安装位置。\r\n参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\ndocker\r\nui (github.com)\r\n10 Open\r\nSource Docker Visual Managers (medevel.com)\r\n3款免费又好用的\r\nDocker 可视化管理工具 - 追逐时光者 - 博客园 (cnblogs.com)\r\njesseduffield/lazydocker:\r\nThe lazier way to manage everything docker (github.com)\r\nportainer/portainer:\r\nMaking Docker and Kubernetes management easy. (github.com)\r\nInstall\r\nDocker Desktop on Linux | Docker Docs\r\njesseduffield/lazydocker:\r\nThe lazier way to manage everything docker (github.com)\r\n","categories":["System","Docker"],"tags":["Docker","Ubuntu"]},{"title":"Linux 安装 docker-compose","url":"/posts/2024/20F723F.html","content":"本文介绍如何在 Linux 环境中安装 docker-compose。\r\n\r\n安装步骤\r\n按下列步骤进行安装：\r\n# 下载 docker-composesudo curl -L https://github.com/docker/compose/releases/download/v2.24.0-birthday.10/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose# 增加执行权限sudo chmod +x /usr/local/bin/docker-compose\r\n\r\n\r\n下载前，通过 Releases ·\r\ndocker/compose (github.com) 查找最新版本，替换上面的版本号\r\n其中的 uname -s 和 uname -m 是 shell\r\n命令，它们会被替换为你的操作系统的名称和你的机器的硬件架构\r\n\r\n\r\n参考\r\nReleases\r\n· docker/compose (github.com)\r\n","categories":["System","Docker"],"tags":["Docker","Linux","docker-compose"]},{"title":"WSL2 中 Docker 突然无法通过代理拉取镜像问题排查","url":"/posts/2025/1EE38XM.html","content":"作者机器为 win11，最近将 Docker Desktop 升级到了 v4.43.2\r\n版本，然后就出现一个很奇怪的问题：代理是正常的，但是 Docker\r\n就是连接不上，拉取镜像时，直接报错 connect: connection refused。\r\n# 拉取镜像docker pull redis# 报错：Using default tag: latestError response from daemon: Get &quot;https://registry-1.docker.io/v2/&quot;: proxyconnect tcp: dial tcp 127.0.0.1:7890: connect: connection refused\r\n\r\n问题分析\r\n首先，导致这个问题的原因可能有两种情况：\r\n\r\nDocker Desktop 是通过 wsl2 安装的，期间 windows 有更新，可能导致 wsl\r\n网络产生了问题\r\n升级 Docker Desktop 后配置都没有动过，可能是 Docker Desktop\r\n本身问题\r\n\r\n从网上了解到，将 wsl 的网络改成 NAT 就可以恢复\r\nnetworkingMode = NAT。但是为了使用 wsl\r\n镜像网络的优势，先从第 2 点开始排查，最终通过改变启动顺序解决了。\r\n我的 .wslconfig 配置如下\r\n# 配置镜像网络，参考: https://learn.microsoft.com/zh-cn/windows/wsl/networking# 网络模式为镜像, 打开后代理无法使用[wsl2]networkingMode=mirroreddnsTunneling=trueautoProxy=truefirewall=truehostAddressLoopback=true[experimental]hostAddressLoopback=true\r\n解决方案\r\n首先一开始我的状态是开启了系统代理，wsl2 是 mirrored 模式，查看\r\ndocker info 中的代理结果如下：\r\nHTTP Proxy: http://127.0.0.1:7890HTTPS Proxy: http://127.0.0.1:7890No Proxy: 172.31.*,172.30.*,172.29.*,172.28.*,172.27.*,172.26.*,172.25.*,172.24.*,172.23.*,172.22.*,172.21.*,172.20.*,172.19.*,172.18.*,172.17.*,172.16.*,10.*,192.168.*,127.*,localhost,&lt;local&gt;\r\n我的代理不论是在 windows 上还是在 wsl 都能够访问，但是 docker pull\r\n依然报错：\r\ndocker pull redisUsing default tag: latestError response from daemon: Get &quot;https://registry-1.docker.io/v2/&quot;: proxyconnect tcp: dial tcp 127.0.0.1:7890: connect: connection refused\r\n然后修改 Docker Desktop 的代理配置：[Settings/Resources/Proxies]\r\n\r\n\r\nimage-20250801083235022\r\n\r\n重启 Docker Desktop 后，仍然无效。\r\n然后按以下步骤解决了：\r\n\r\n关闭系统代理\r\n关闭 Docker Desktop 的手动代理配置\r\n重启 Docker Desktop\r\n打开系统代理\r\n配置 Docker Desktop 手动代理\r\n\r\n第 3 步启动后，docker info 的代理部分为：\r\nHTTP Proxy: http.docker.internal:3128HTTPS Proxy: http.docker.internal:3128No Proxy: hubproxy.docker.internal\r\n\r\n后记：\r\n具体是什么原因导致的，我也不清楚，但终归是恢复了，就不深究了。\r\n\r\n参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\ndocker在WSL2环境中的代理问题\r\n- 冰化了还有棍儿\r\n","categories":["System","Docker"],"tags":["Docker"]},{"title":"OpenWrt中Overlay扩容","url":"/posts/2020/32CSTB6.html","content":"OpenWrt 重置或者升级后， overlay 要怎么扩容？\r\n\r\n\r\n查看所有磁盘\r\ncfdisk\r\n格式化要扩容的盘\r\nmkfs.ext4 /dev/sda3\r\n如果提示已经挂载了，则需要用 umount /dev/sda3\r\n取消挂载\r\n挂载磁盘\r\nmount /dev/sda3 /mnt/sda3\r\n// 查看是否挂载成功ls /mnt/sda3 当出现 lost+found 说明就成功了。\r\n复制原来 overlay 中的配置文件\r\ncp -r /overlay/* /mnt/sda3\r\n在挂载点中挂载\r\n重启\r\n\r\n","categories":["System","OpenWrt"],"tags":["OpenWrt"]},{"title":"OpenWrt中安装smarGate实现内网穿透","url":"/posts/2020/3FW7343.html","content":"为了能够无需任何公网 IP 实现内网穿透，在安装完 OpenWrt 后，通过安装\r\nsmarGate\r\n来解决这个问题。下面记录下关键的安装步骤。\r\n\r\n\r\n下载地址\r\n百度网盘下载：https://pan.baidu.com/s/14Iq60kxHW711NVoCVKWySg\r\n执行安装\r\n\r\nlinux下执行命令：chmod +x proxy_server &amp;&amp; nohup ./proxy_server -i1000 -o1000 -w8 &gt;/dev/null &amp;windows下执行命令：proxy_server.exe -i1000 -o1000 -w8Android 手机/设备：运行app -〉编辑模式下，配置服务端信息 -〉打开“服务端”开关 -〉重启app\r\n\r\n如何解决依赖\r\n\r\n首先使用 ldd ./proxy_server\r\n查看是否依赖缺失，如果报错，则执行下面的语句。\r\nln -s /lib /lib64ln -s /lib/ld-musl-x86_64.so.1 /lib/ld-linux-x86-64.so.2\r\n\r\n如何查看是否运行了\r\n\r\nps -ef|grep proxy_server\r\n如果有两条记录，则代表是启动成功了。\r\n","categories":["System","OpenWrt"],"tags":["OpenWrt"]},{"title":"esxi 配置 RDM 直通","url":"/posts/2024/C906NX.html","content":"esxi 硬盘直通有两种方式，分别是 RDM（Raw Device Mapping） 直通和\r\nPCIe（PCIe ） 直通。本文介绍如何通过 ssh 配置 esxi 硬盘直通。\r\n\r\nRDM 简介\r\nRDM\r\n直通通过创建一个指向物理存储设备的映射文件来实现允许虚拟机直接访问物理存储设备。\r\n开启 ssh\r\n在 esxi 的 web 管理界面中，通过 【主机(右键)/服务/启用安全 Shell\r\n(SSH)】打开 ssh。如下图所示：\r\n\r\n查找硬盘位置\r\n\r\n查找 esxi 系统所在盘的位置\r\n如下图所示：\r\n\r\n位置为：/vmfs/volumes/5fb14c74-5da1723a-c6a0-00e15a680bd8\r\n查找要直通的硬盘所在路径\r\n如下图所示：\r\n)\r\n路径为：/vmfs/devices/disks/t10.ATA_____ST500LT0122D9WS142___________________________________S0V2PJJG\r\n\r\n配置直通\r\n打开 powershell 或者任意终端，逐行输入下列命令进行配置：\r\n# 进入 esxi 所在系统盘cd /vmfs/volumes/5fb14c74-5da1723a-c6a0-00e15a680bd8# 创建直通映射文件保存目录# 在默认存储空间根目录下创建一个名为 dms.store 的目录用来存放直通镜像文件.vmdk的文件夹mkdir dms.store# 创建直通映射vmkfstools -z /vmfs/devices/disks/t10.ATA_____ST500LT0122D9WS142___________________________________S0V2PJJG /vmfs/volumes/5fb14c74-5da1723a-c6a0-00e15a680bd8/dms.store/hdd1.vmdk# 至此，直通配置完成# 新建虚拟机时【添加硬盘】，选择 `dms.store/hdd1.vmdk` 即可\r\n","categories":["System","ESXI"],"tags":["esxi"]},{"title":"黑群晖 DS3617 7.0安装","url":"/posts/2021/347YJNZ.html","content":"黑群晖是什么是不说了，直接上教程。\r\n\r\n谁制作的黑群晖\r\n弄明白谁制作的，是很重要的，只有这样，你才能下载到最原始的版本，保证系统的纯正性。黑群晖7.0的核心文件由国外redpill（红丸）团队开发，并且已经开源，地址：https://github.com/RedPill-TTG\r\n虽然知道了是谁制作的，但是作者确没有放出引导盘，本人使用的\r\n选择什么版本\r\n黑群中比较流行的有两个版本，一个是 DS918（家庭版本），一个是\r\nDS3617（企业版本）。如果机器性能好，可以考虑使用企业版本。\r\n","categories":["System","Synology"],"tags":["黑群晖"]},{"title":"TCP Ping in Ubuntu","url":"/posts/2023/3FNGNN9.html","content":"本文介绍如何在 Linux 中使用 TCP Ping 工具。\r\n\r\n写在前面，在 Ubuntu 中可以使用 netcat\r\n工具检查端口的连通性，示例：nc -zv 127.0.0.1 22。对于 wsl\r\n网络模式为 mirrored 的情况下，使用这个命令更有效。\r\n接下来正式介绍 tcping 的安装与使用方法。\r\n下载\r\nsudo apt install tcptraceroutesudo wget http://www.vdberg.org/~richard/tcpping -O /usr/bin/tcpingsudo chmod 755 /usr/bin/tcping\r\n使用\r\ntcping 127.0.0.1 22seq 0: tcp response from localhost (127.0.0.1) [open]  0.031 msseq 1: tcp response from localhost (127.0.0.1) [open]  0.095 msseq 2: tcp response from localhost (127.0.0.1) [open]  0.032 msseq 3: tcp response from localhost (127.0.0.1) [open]  0.034 msseq 4: tcp response from localhost (127.0.0.1) [open]  0.111 msseq 5: tcp response from localhost (127.0.0.1) [open]  0.035 ms\r\n","categories":["System","Linux"],"tags":["Linux"]},{"title":"Ubuntu 存储管理及挂载扩容","url":"/posts/2023/J7H344.html","content":"本文将介绍如何管理 Ubuntu\r\n的磁盘挂载，包括查看磁盘使用情况、逻辑盘扩容等。\r\n\r\n内存\r\n\r\n查看内存使用情况\r\nfree -h\r\n\r\n硬盘\r\n\r\n查看磁盘使用情况\r\ndf -h\r\n查看挂载情况\r\nmount\r\n修改现有挂载点\r\n# 取消挂载sudo umount /path/to/old/mount/point# 挂载到新的位置sudo mount /dev/sdX /path/to/new/mount/point\r\n\r\n扩容\r\n可以使用 LVM（逻辑卷管理）来扩展虚拟卷。\r\n# 查看可用磁盘sudo lsblk# 查看既有卷组sudo vgdisplay# 查看卷组中的卷sudo lvdisplay# 将新磁盘转换为物理卷(若有必要)sudo pvcreate /dev/sdb# 将新的物理卷添加到现有的卷组中sudo vgextend ubuntu-vg /dev/sda# 扩展逻辑卷, 最后一个参数为卷名sudo lvextend -l +100%FREE /dev/ubuntu-vg/ubuntu-lv# 调整文件系统大小sudo resize2fs /dev/ubuntu-vg/ubuntu-lv\r\n","categories":["System","Linux"],"tags":["Ubuntu"]},{"title":"Ubuntu 配置静态IP","url":"/posts/2023/1KVMRKY.html","content":"本文介绍如何为 Linux 中配置静态 IP。\r\n\r\n安装工具\r\nsudo apt install iproute2\r\n查看使用的网卡名称\r\nip addr\r\n\r\n\r\nimage-20231226155813822\r\n\r\n修改配置文件\r\nUbuntu 20.04 采用 netplan 来管理网络配置计划，在 /etc/netplan/\r\n目录下有一个以 yaml 结尾的文件，例如\r\n00-installer-config.yaml，不同版本的系统这个文件名可能会有些差异，但是不影响，以实际为准。\r\n配置文件优先级\r\nNetplan 解析配置文件时，会按照字母数字顺序加载所有在 /etc/netplan/\r\n目录下的 .yaml 文件，文件的命名方式将影响其优先级。\r\n配置文件优先级规则：\r\n\r\n字母顺序：文件名按字母顺序排序，字母顺序靠前的文件优先级更高。\r\n数字顺序：文件名按数字顺序排序，数字顺序靠前的文件优先级更高。\r\n合并配置：多个配置文件可以合并，优先级高的配置文件会覆盖优先级低的配置文件中的相同设置。\r\n\r\n开始配置\r\nsudo nano /etc/netplan/00-installer-config.yaml# 若是 wifi 则是 00-installer-config-wifi.yaml\r\n默认配置为：\r\n# This is the network config written by &#x27;subiquity&#x27;network:  ethernets:    enp2s0:      dhcp4: true  version: 2\r\n修改后的配置为：\r\n# This is the network config written by &#x27;subiquity&#x27;network:  ethernets:    enp2s0:      dhcp4: false      addresses:        - 192.168.23.30/24  # set static ip and mask      routes:        - to: default # can add more, example 192.168.23.0/24          via: 192.168.23.254  # set gateway      nameservers:        addresses:          - 192.168.23.11  # set dns          - 119.29.29.29  version: 2\r\n测试网络配置\r\nsudo netplan try\r\n使网络配置生效\r\nsudo netplan apply\r\n运行以下 IP 命令查看接口上的 IP 地址：\r\nip addr show ens33\r\n要查看默认路由，请运行：\r\nip route show\r\n参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\n系统运维|如何在\r\nUbuntu 服务器 22.04 上设置静态 IP 地址 (linux.cn)\r\n","categories":["System","Linux"],"tags":["Ubuntu","Linux"]},{"title":"Ubuntu 20.04 更换国内镜像源","url":"/posts/2023/1Z18QQW.html","content":"Ubuntu采用apt作为软件安装工具，其镜像源列表记录在/etc/apt/source.list文件中。修改该文件内容即可更改镜像源。\r\n\r\n备份原文件\r\nsudo cp /etc/apt/sources.list /etc/apt/sources.list.bak\r\n镜像源\r\n阿里云\r\ndeb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse# deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse# deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse# deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse# deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse## Pre-released source, not recommended.# deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse# deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse\r\n清华\r\n参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\nUbuntu20.04更换国内镜像源（阿里、网易163、清华、中科大）\r\n","categories":["System","Linux"],"tags":["Ubuntu","Linux"]},{"title":"Ubuntu 设置时区","url":"/posts/2023/1RRG58Q.html","content":"本文介绍如何在 Ubuntu 中修改时区。\r\n\r\n简易方法\r\n使用下列命令选择城市进行设置：\r\nsudo tzselect\r\n执行完成后，需要重启机器。\r\n基本方法\r\n\r\n运行以下命令来查看当前的时区：\r\ntimedatectl\r\n这将显示当前的日期、时间和时区。\r\n运行以下命令来列出所有可用的时区：\r\ntimedatectl list-timezones\r\n这将显示一个时区列表，你可以从中选择一个时区。\r\n运行以下命令来设置新的时区：\r\nsudo timedatectl set-timezone Your_Timezone\r\n请将 Your_Timezone\r\n替换为你选择的时区。例如，如果你想要设置时区为北京时间，你可以运行：\r\nsudo timedatectl set-timezone Asia/Shanghai\r\n再次运行 timedatectl\r\n命令来确认新的时区已经被正确设置。\r\ntimedatectl\r\n\r\n参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\n\r\nLinux设置和修改时间与时区\r\n\r\n","categories":["System","Linux"],"tags":["Ubuntu","Linux"]},{"title":"Ubuntu 阻止笔记本关盖后挂起","url":"/posts/2023/30R3C6S.html","content":"本文介绍如何在 Ubuntu 中阻止笔记本关盖后进程挂起。\r\n\r\n输入以下命令打开系统设置文件：\r\nsudo vim /etc/systemd/logind.conf\r\n在打开的文件中，找到 #HandleLidSwitch=suspend\r\n这一行（# 表示这一行被注释掉了）。将其改为\r\nHandleLidSwitch=ignore\r\n并删除行首的 #，使这一行生效。\r\n输入以下命令重启 systemd-logind 服务：\r\nsudo systemctl restart systemd-logind\r\n完成以上步骤后，当你关闭笔记本电脑的盖子时，系统将不再进入挂起状态。\r\n\r\n补充介绍：\r\n配置说明\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n配置名\r\n作用\r\n\r\n\r\n\r\n\r\nHandleLidSwitch=suspend\r\n当笔记本电脑使用电池供电时，合盖挂起\r\n\r\n\r\nHandleLidSwitchExternalPower=suspend\r\n当笔记本电脑插入电源插座时，合盖挂起\r\n\r\n\r\nHandleLidSwitchDocked=ignore\r\n当笔记本电脑连接到扩展坞时，合盖忽略\r\n\r\n\r\n\r\n参数说明\r\n\r\n\r\n\r\n参数\r\n作用\r\n\r\n\r\n\r\n\r\nsuspend\r\n合盖时挂起\r\n\r\n\r\nlock\r\n合盖时锁定\r\n\r\n\r\nignore\r\n什么都不做\r\n\r\n\r\npoweroff\r\n关机\r\n\r\n\r\nhibernate\r\n合盖时休眠\r\n\r\n\r\n\r\n","categories":["System","Linux"],"tags":["Ubuntu","Linux"]},{"title":"Linux 文件权限介绍","url":"/posts/2023/3MZH2CP.html","content":"本文将详细介绍 Linux\r\n中的文件权限概念和相关命令，帮助读者深入了解如何正确管理和使用文件权限。\r\n\r\n文件权限的组成\r\n使用 ls -l 我们可以查看文件或者目录的属性\r\ndrwxr-xr-x   5 root root  4096 Dec 26 07:21 homelrwxrwxrwx   1 root root     7 Aug 10 00:17 lib -&gt; usr/lib-rw-r--r--   1 root root  1382 Dec 23  2021 rsyslog.conf\r\n\r\n\r\nlinux-file-auth\r\n\r\nLinux\r\n中，文件所有者分为三类，即文件所有者(user)、群组(group)和其他人(other)所属。在设置权限时，需要分别对这\r\n3 个角色分别设置读、写、执行权限。\r\n在 ls -l 列出的结果中，第 1 个字符表示文件类型，接着 3\r\n个字符分别表示文件所有者(user)的读、写、执行权限，用户权限后 3\r\n个字符分别是用户组的读、写、执行权限，最后 3\r\n个字符分别是其它(非用户、用户组)的权限。\r\n权限表示\r\n\r\n\r\n\r\n表示方法\r\n读\r\n写\r\n执行\r\n无权限\r\n示例\r\n\r\n\r\n\r\n\r\n字符\r\nr\r\nw\r\nx\r\n-\r\nrwxr-x---\r\n\r\n\r\n数字\r\n4\r\n2\r\n1\r\n0\r\n750\r\n\r\n\r\n\r\n注意：使用数字表示时，需要将一个角色中的权限值求和来表示。例如用户的权限为\r\nrwx ，表示成 7。\r\n权限修改\r\n权限指令如下：\r\n\r\nchgrp（change group 的缩写）：改变文件所属群组\r\nchown（change owner 的缩写）：改变文件所有者\r\nchmod（change mode 的缩写）：改变文件权限\r\n\r\nchgrp\r\n语法如下：\r\nchgrp [OPTION]... GROUP FILE...\r\n其中，GROUP\r\n是你想要设置为文件或目录新的组所有者的组名，FILE\r\n是你想要修改的文件或目录的名称。\r\n例如，chgrp staff myfile 命令会将文件\r\nmyfile 的组所有权改为 staff。\r\nchown\r\nchown [OPTION]... [OWNER][:[GROUP]] FILE...\r\n其中，OWNER\r\n是你想要设置为文件或目录新的用户所有者的用户名，GROUP\r\n是你想要设置为文件或目录新的组所有者的组名，FILE\r\n是你想要修改的文件或目录的名称。\r\n例如，chown john:staff myfile 命令会将文件\r\nmyfile 的用户所有权改为 john，组所有权改为\r\nstaff。\r\nchmod\r\n\r\n符号模式\r\n你可以使用\r\nu（用户）、g（组）、o（其他）和\r\na（所有）来指定要修改的权限，使用\r\n+（添加）、-（删除）和\r\n=（设置）来指定要执行的操作，使用\r\nr（读取）、w（写入）和\r\nx（执行）来指定要修改的权限类型。\r\n例如，chmod u+x file\r\n命令会给文件的所有者添加执行权限。\r\n数字模式\r\n你可以使用三个数字来设置权限，每个数字代表一个权限组（所有者、组、其他），每个数字的值是\r\n0 到 7，代表不同的权限组合。\r\n例如，chmod 755 file\r\n命令会给文件的所有者设置读取、写入和执行权限，给文件的组和其他用户设置读取和执行权限。\r\n\r\n参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\nLinux_基础_文件权限\r\n- Catnip - 博客园 (cnblogs.com)\r\nLinux\r\n文件权限讲解（一般权限、特殊权限、隐藏权限、访问控制列表、Umask）-CSDN博客\r\n","categories":["System","Linux"],"tags":["Ubuntu","Linux"]},{"title":"Ubuntu 中安装 Docker","url":"/posts/2023/316DJB8.html","content":"本文将介绍如何在 Ubuntu 上安装\r\nDocker，本文为安装指导，仅列出详细的安装步骤和一些必要的说明。\r\n\r\n可以直接参考官方安装说明 Ubuntu\r\n| Docker Docs\r\n安装要求\r\n截至 2023-12-26，Docker 支持的 Ubuntu 版本有：\r\n\r\nUbuntu Mantic 23.10\r\nUbuntu Lunar 23.04\r\nUbuntu Jammy 22.04 (LTS)\r\nUbuntu Focal 20.04 (LTS)\r\n\r\n可以通过 lsb_release -a 或\r\ncat /etc/os-release 查看 Ubuntu 版本。\r\n卸载旧版本\r\n通过以下命令卸载旧版本：\r\nfor pkg in docker.io docker-doc docker-compose docker-compose-v2 podman-docker containerd runc; do sudo apt-get remove $pkg; done\r\n安装 Docker\r\n有多种安装方式，本文采用 apt 方式。\r\n\r\n配置 Dockert apt 仓库\r\n# Add Docker&#x27;s official GPG key:sudo apt-get updatesudo apt-get install ca-certificates curl gnupgsudo install -m 0755 -d /etc/apt/keyringscurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpgsudo chmod a+r /etc/apt/keyrings/docker.gpg# Add the repository to Apt sources:echo \\  &quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\  $(. /etc/os-release &amp;&amp; echo &quot;$VERSION_CODENAME&quot;) stable&quot; | \\  sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/nullsudo apt-get update\r\n安装最新版本的 Docker\r\nsudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\r\n测试 Docker 是否安装成功\r\n通过运行 hello-world 来测试\r\nsudo docker run hello-world\r\n当显示如下内容时，说明安装成功了。\r\nHello from Docker!This message shows that your installation appears to be working correctly.\r\n\r\n错误排查\r\n参考\r\nInstall\r\nDocker Engine on Ubuntu | Docker Docs\r\n如何在 Ubuntu 20.04\r\n上安装和使用 Docker - 知乎 (zhihu.com)\r\n","categories":["System","Linux"],"tags":["Docker","Ubuntu"]},{"title":"为 APT 配置代理","url":"/posts/2023/1MJYA7T.html","content":"在 Linux 中，可以通过配置 APT 的代理设置来为 APT\r\n添加代理。以下是一个例子：\r\n\r\n首先，打开 APT 的配置文件：\r\nsudo vim /etc/apt/apt.conf.d/proxy.conf\r\n然后，在打开的文件中添加以下内容：\r\nAcquire::http::Proxy &quot;http://your-proxy-server:your-proxy-port&quot;;Acquire::https::Proxy &quot;http://your-proxy-server:your-proxy-port&quot;;\r\nyour-proxy-server\r\n是代理服务器的地址，your-proxy-port\r\n是代理服务器的端口。\r\n保存并关闭文件后，APT 就会使用你配置的代理服务器来下载软件包。\r\n\r\n请注意，你需要使用 sudo 来编辑\r\n/etc/apt/apt.conf.d/proxy.conf\r\n文件，因为这个文件通常需要超级用户权限才能编辑。\r\n\r\n","categories":["System","Linux"],"tags":["Ubuntu","APT"]},{"title":"Linux 中如何同时执行多条命令","url":"/posts/2023/19K9M5N.html","content":"在 Linux 中，你可以使用以下几种方法来同时执行多个命令：\r\n\r\n使用分号 (;) 分隔命令\r\n使用 &amp;&amp; 运算符\r\n使用 &amp; 运算符\r\n使用管道 (|)\r\n\r\n下面进行详细的介绍\r\n\r\n\r\n使用分号 (;) 分隔命令：\r\ncommand1 ; command2 ; command3\r\n这将依次执行 command1、command2 和\r\ncommand3。即使前一个命令失败，后一个命令也会继续执行。\r\n使用 &amp;&amp; 运算符：\r\ncommand1 &amp;&amp; command2 &amp;&amp; command3\r\n这将依次执行 command1、command2 和\r\ncommand3，但是如果任何一个命令失败（返回非零退出状态），则后面的命令不会执行。\r\n使用 &amp; 运算符：\r\ncommand1 &amp; command2 &amp; command3\r\n这将同时执行 command1、command2 和\r\ncommand3，每个命令在后台运行，不会等待前一个命令完成。\r\n使用管道 (|)：\r\ncommand1 | command2 | command3\r\n这将执行 command1，然后将 command1\r\n的输出作为 command2 的输入，然后将 command2\r\n的输出作为 command3\r\n的输入。这是一种常见的方式，用于将多个命令链接在一起，形成一个命令管道。\r\n\r\n","categories":["System","Linux"],"tags":["Linux"]},{"title":"使用 FHS 规范 Linux 目录使用","url":"/posts/2023/3AYYNM8.html","content":"在 Linux 或 Unix\r\n操作系统中，所有的文件和目录都被组织成以一个根节点（/）开始的倒置的树状结构\r\n\r\n\r\nlinux2bfile2bsystem2bhierarchy\r\n\r\n文件系统的最顶层是由根目录开始的，系统使用 /\r\n来表示根目录。在根目录之下的既可以是目录，也可以是文件，而每一个目录中又可以包含子目录文件。如此反复就可以构成一个庞大的文件系统。\r\n\r\n在Linux文件系统中有两个特殊的目录，一个用户所在的工作目录，也叫当前目录，可以使用一个点\r\n.\r\n来表示；另一个是当前目录的上一级目录，也叫父目录，可以使用两个点\r\n.. 来表示。\r\n\r\n. ：代表当前的目录，也可以使用 ./ 来表示；\r\n.. ：代表上一层目录，也可以 ../ 来代表。\r\n\r\n如果一个目录或文件名以一个点 .\r\n开始，表示这个目录或文件是一个隐藏目录或文件(如：.bashrc)。即以默认方式查找时，不显示该目录或文件。\r\n目录结构\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n目录\r\n描述\r\n\r\n\r\n\r\n\r\n/\r\n第一层次结构 的根、 整个文件系统层次结构的根目录。\r\n\r\n\r\n/bin/\r\n需要在单用户模式可用的必要命令（可执行文件）；面向所有用户，例如：\r\ncat、 ls、 cp。\r\n\r\n\r\n/boot/\r\n引导程序文件，例如：\r\nkernel、initrd；时常是一个单独的分区[8]\r\n\r\n\r\n/dev/\r\n英文 device，必要设备,\r\n例如：/dev/null.\r\n\r\n\r\n/etc/\r\n特定主机，系统范围内的配置文件。关于这个名称目前有争议。在贝尔实验室关于UNIX\r\n实现文档的早期版本中，/etc 被称为etcetera， [9]\r\n这是由于过去此目录中存放所有不属于别处的所有东西（然而，FHS限制/etc只能存放静态配置文件，不能包含二进制文件）。\r\n[10]\r\n自从早期文档出版以来，目录名称已被以各种方式重新称呼。最近的解释包括逆向首字母缩略词如：\"可编辑的文本配置\"（英文\r\n\"Editable Text Configuration\"）或\"扩展工具箱\"（英文 \"Extended Tool\r\nChest\"）。 [11]\r\n\r\n\r\n/etc/opt/\r\n/opt/的配置文件\r\n\r\n\r\n/etc/X11/\r\nX窗口系统(版本11)的配置文件\r\n\r\n\r\n/etc/sgml/\r\nSGML的配置文件\r\n\r\n\r\n/etc/xml/\r\nXML的配置文件\r\n\r\n\r\n/home/\r\n用户的家目录，包含保存的文件、个人设置等，一般为单独的分区。\r\n\r\n\r\n/lib/\r\n/bin/ 和 /sbin/中二进制文件必要的库文件。\r\n\r\n\r\n/media/\r\n可移除媒体(如CD-ROM)的挂载点\r\n(在FHS-2.3中出现)。\r\n\r\n\r\n/mnt/\r\n临时挂载的文件系统。\r\n\r\n\r\n/opt/\r\n可选应用软件 和\r\n包。[12]\r\n\r\n\r\n/proc/\r\n虚拟文件系统，将内核与进程状态归档为文本文件。例如：uptime、\r\nnetwork。在Linux中，对应Procfs格式挂载。\r\n\r\n\r\n/root/\r\n超级用户的家目录\r\n\r\n\r\n/sbin/\r\n必要的系统二进制文件，例如： init、 ip、 mount。\r\n\r\n\r\n/srv/\r\n站点的具体数据，由系统提供。\r\n\r\n\r\n/tmp/\r\n临时文件(参见\r\n/var/tmp)，在系统重启时目录中文件不会被保留。\r\n\r\n\r\n/usr/\r\n命名(Unix Software\r\nResource)，用于存储只读用户数据的第二层级目录；\r\n包含绝大多数的(多)用户工具和应用程序[13]。\r\n\r\n\r\n/usr/bin/\r\n非必要可执行文件 (在单用户模式中不需要)；面向所有用户。\r\n\r\n\r\n/usr/include/\r\n标准包含文件。\r\n\r\n\r\n/usr/lib/\r\n/usr/bin/和/usr/sbin/中二进制文件的库。\r\n\r\n\r\n/usr/sbin/\r\n非必要的系统二进制文件，例如：大量网络服务的守护进程。仅超级管理员可用。\r\n\r\n\r\n/usr/share/\r\n体系结构无关（共享）数据。\r\n\r\n\r\n/usr/src/\r\n源代码,例如:内核源代码及其头文件。\r\n\r\n\r\n/usr/X11R6/\r\nX窗口系统\r\n版本 11, Release 6.\r\n\r\n\r\n/usr/local/\r\n本地数据的第三层次，\r\n具体到本台主机。通常而言有进一步的子目录，\r\n例如：bin/、lib/、share/.[14]\r\n\r\n\r\n/var/\r\n变量文件——在正常运行的系统中其内容不断变化的文件，如日志，脱机文件和临时电子邮件文件。有时是一个单独的分区。\r\n\r\n\r\n/var/cache/\r\n应用程序缓存数据。这些数据是在本地生成的一个耗时的I/O或计算结果。应用程序必须能够再生或恢复数据。缓存的文件可以被删除而不导致数据丢失。\r\n\r\n\r\n/var/lib/\r\n状态信息。 由程序在运行时维护的持久性数据。\r\n例如：数据库、包装的系统元数据等。\r\n\r\n\r\n/var/lock/\r\n锁文件，一类跟踪当前使用中资源的文件。\r\n\r\n\r\n/var/log/\r\n日志文件，包含大量日志文件，为了防止日志占满根分区，生产环境中一般是单独分区。\r\n\r\n\r\n/var/mail/\r\n用户的电子邮箱。\r\n\r\n\r\n/var/run/\r\n自最后一次启动以来运行中的系统的信息，例如：当前登录的用户和运行中的守护进程、一些守护进程的pid文件、socket文件。现已经被/run代替[15]。\r\n\r\n\r\n/var/spool/\r\n等待处理的任务的脱机文件，例如：打印队列和未读的邮件。\r\n\r\n\r\n/var/spool/mail/\r\n用户的邮箱(不鼓励的存储位置)\r\n\r\n\r\n/var/tmp/\r\n在系统重启过程中可以保留的临时文件。\r\n\r\n\r\n/run/\r\n代替/var/run目录。\r\n\r\n\r\n/lost-found\r\n这个目录平时是空的，当系统非正常关机而留下的“无家可归”的文件便会储存在这里\r\n\r\n\r\n\r\n目录实践\r\n\r\n网站、FTP 存放位置\r\n在 Linux 文件系统中，/srv\r\n目录是用来存放服务器特定的数据的。\r\n\r\n/srv/www 来保存网站的 HTML 和相关文件\r\n/srv/ftp 来存放 FTP 的文件\r\n\r\n自己编写的程序存放位置\r\n\r\n/usr/local/bin：用于存放用户编译的可执行文件，这些文件对所有用户都可用。\r\n/usr/local/sbin：用于存放用户编译的系统管理程序，这些程序通常只对超级用户可用。\r\n\r\n\r\n参考\r\n文件系统层次结构标准\r\n- 维基百科，自由的百科全书 (wikipedia.org)\r\nLinux\r\n系统目录结构 | 菜鸟教程 (runoob.com)\r\n","categories":["System","Linux"],"tags":["Linux","FHS"]},{"title":"Linux 中使用 Docker 安装 PaddleOCR","url":"/posts/2023/F9C0KW.html","content":"本文将介绍如何在 Ubuntu 的 Docker 中安装 PaddleOCR，并启用 Cuda\r\n进行加速。\r\n\r\n使用 Docker 安装\r\nPaddlePaddle 环境\r\n# 进入到用户目录，创建一个目录新目录cd ~ &amp;&amp; mkdir dockerMount/paddleOCR &amp;&amp; cd ./dockerMount/paddleOCR# 创建一个容器，使用CUDA12+CUDNN8.9# 设置docker容器共享内存shm-size为32G，建议设置32G以上sudo docker run --gpus all --name ppocr -v $PWD:/paddle --shm-size=32G --network=host -it registry.baidubce.com/paddlepaddle/paddle:2.6.0-gpu-cuda12.0-cudnn8.9-trt8.6 /bin/bash\r\n可使用 exit 退出容器。\r\n可以通过下列命令重新进入容器：\r\n# 完整方式sudo docker container exec -it ppocr /bin/bash# 简化方式sudo docker exec -it ppocr bash\r\n至此，PaddlePaddle 环境就安装成功了\r\n特别说明：\r\n官方教程使用的是 nvidia-docker 来安装的，NVIDIA/nvidia-docker:\r\n目前被 NVIDIA/nvidia-container-toolkit\r\n代替，因此，在使用时，将 nvidia-docker 换成\r\ndocker --gpu all 即可。\r\n测试 paddlepaddle 安装结果\r\n进入 python shell，然后执行 paddle.utils.run_check()\r\n查看状态\r\npythonimport paddlepaddle.utils.run_check()\r\n正常的输出结果如下：\r\nRunning verify PaddlePaddle program ...I0108 07:52:51.569307   893 program_interpreter.cc:212] New Executor is Running.W0108 07:52:51.569667   893 gpu_resources.cc:119] Please NOTE: device: 0, GPU Compute Capability: 8.9, Driver API Version: 12.2, Runtime API Version: 12.0W0108 07:52:51.570616   893 gpu_resources.cc:164] device: 0, cuDNN Version: 8.8.I0108 07:52:51.671880   893 interpreter_util.cc:624] Standalone Executor is Used.PaddlePaddle works well on 1 GPU.PaddlePaddle is installed successfully! Let&#x27;s start deep learning with PaddlePaddle now.\r\n安装PaddleOCR whl包\r\npip install &quot;paddleocr&gt;=2.0.1&quot; # 推荐使用2.0.1+版本\r\n使用 paddleocr -h 可以查看 paddleocr 是否安装成功\r\n测试\r\n\r\n准备测试图片\r\n从 Windows 中复制：\r\nscp D:\\Develop\\TestTemp\\invoice\\test-invoice\\电子发票.png username@host:/home/username/today\r\n此步骤非必须，可以直接使用 Linux 从网络中下载\r\nwget https://paddleocr.bj.bcebos.com/dygraph_v2.1/ppocr_img.zipunzip ppocr_image.zip\r\n将图片复制到 docker 容器中\r\nsudo docker cp image.png containername:/home/target-path\r\n执行测试\r\npaddleocr --image_dir ./imgs/11.jpg --use_angle_cls true --use_gpu true\r\n\r\n参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\nPaddleOCR/doc/doc_ch/environment.md\r\nat release/2.6 · PaddlePaddle/PaddleOCR (github.com)\r\nrun_check-API文档-PaddlePaddle深度学习平台\r\n开始使用_飞桨-源于产业实践的开源深度学习平台\r\n(paddlepaddle.org.cn)\r\n飞桨PaddlePaddle-源于产业实践的开源深度学习平台\r\n","categories":["System","Linux"],"tags":["Docker","Ubuntu","PaddleOCR"]},{"title":"Ubuntu 服务器安装 Nvidia Container Toolkit 使 Docker 支持 Cuda","url":"/posts/2023/HNT542.html","content":"为了能够在 Docker 中使用 GPU 进行加速，Nvidia 开发了 nvidia-docker 对\r\nContainer 进行封装，使得 Docker 容器可以调用 GPU 进行加速。现在 nvidia-docker\r\n已被归档，官方推荐使用 nvidia-container-toolkit。\r\n本文将介绍如何在 Linux 中安装 nvidia-container-toolkit。\r\n\r\n注：本文所使用的显卡为 RTX4080\r\n\r\n\r\n关系理解\r\n在 Ubuntu 的 Docker 中使用 GPU 时，需要在 host\r\n主机中安装两个环境：\r\n\r\nNvidia 驱动\r\nNVIDIA Container Toolkit\r\n\r\n其关系如下图所示：\r\n\r\n\r\nngidia-container-toolkit\r\n\r\nNvidia 驱动决定了可使用的 cuda 最大版本号，如下图右上角所示。\r\n如图所示：\r\n\r\n\r\nimage-20231227172857700\r\n\r\n安装 Nvidia 驱动\r\n查看机器环境\r\n\r\n查看发行版信息：\r\nlsb_release -a\r\n查看内核版本：\r\nuname -r\r\n查看默认 GCC 版本：\r\ngcc --version\r\n查看 GLIBC 版本：\r\nldd --version\r\n\r\n支持的 linux 版本如下：\r\nNative\r\nLinux Distribution Support in CUDA 12.6 Update 3\r\n若版本不满足要求，可以按下列方式进行升级，下文将以 Ubuntu 22.04.3\r\n为例。\r\n\r\n注意：升级内核有风险，请谨慎操作！\r\n\r\n升级内核\r\nsudo apt updateapt-cache search linux-image# 安装指定版本内核sudo apt install linux-image-5.4.0-42-generic linux-headers-5.4.0-42-generic linux-modules-5.4.0-42-generic linux-modules-extra-5.4.0-42-generic# 更新 GRUB 配置sudo update-grub# 重启sudo reboot\r\n升级 gcc\r\n# 安装 gcc12sudo apt-get install gcc-12 g++-12# 设置为默认版本sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-12 110 --slave /usr/bin/g++ g++ /usr/bin/g++-12# 修改 gcc 的优先级sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-12 100# 减小原来 gcc 的优先级sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-11 50# 选择默认的 gccsudo update-alternatives --config gcc# 查看版本gcc --version\r\n查看驱动版本\r\ncat /proc/driver/nvidia/version\r\n若提示没有该文件，则说明没有驱动。否则会显示驱动版本：\r\nNVRM version: NVIDIA UNIX x86_64 Kernel Module  535.154.05  Thu Dec 28 15:37:48 UTC 2023GCC version:  gcc version 11.4.0 (Ubuntu 11.4.0-1ubuntu1~22.04)\r\n卸载原驱动\r\nexport DRIVER_BRANCH=535.216.01sudo apt --purge remove &quot;*nvidia*$&#123;DRIVER_BRANCH&#125;*&quot;\r\n安装驱动\r\n\r\nRTX 4080 不支持 server 类型的驱动\r\n\r\n查看可安装驱动：\r\nubuntu-drivers list\r\n\r\n输入上述命令后，可能会报错：ERROR:root:aplay command not found，安装一下\r\nsudo apt install alsa-utils\r\n即可，这是一个声音驱动工具包。\r\n\r\n版本选择\r\n使用 ubuntu-drivers list 命令后，输出结果如下：\r\n➜ /home/xby ubuntu-drivers list --gpgpunvidia-driver-535nvidia-driver-550nvidia-driver-535-servernvidia-driver-545-opennvidia-driver-535-server-opennvidia-driver-550-opennvidia-driver-535-opennvidia-driver-545\r\n\r\nserver\r\n这是一个专门为服务器设计的驱动程序，提供了针对服务器硬件和应用程序的优化\r\nopen\r\n开源版本的 NVIDIA 驱动\r\n通用的驱动\r\n\r\n各个版本历史渊源详见 如何优雅地在ubuntu中安装nvidia驱动\r\n开始安装\r\n\r\n使用推荐方式安装默认版本\r\nsudo ubuntu-drivers install --gpgpu\r\n\r\n这种方式安装的驱动不是最新版本\r\n\r\n安装指定版本\r\n# 下列版本二选一# 服务器版本sudo ubuntu-drivers install --gpgpu nvidia:550-server# 通用版本sudo ubuntu-drivers install --gpgpu nvidia:550\r\n查看驱动版本\r\n# 查看驱动版本cat /proc/driver/nvidia/version# 若是 --gpgpu 版本，还需要根据驱动版本安装工具包，下面的 550 为主版本号sudo apt install nvidia-utils-550-server# 通用版本安装的 nvidia-smi 工具，没有后缀 -serversudo apt install nvidia-utils-550\r\n输入 nvidia-smi 来查看显卡状态，正常显示如下：\r\n\r\n\r\nimage-20231227172857700\r\n\r\n\r\n安装 NVIDIA Container\r\nToolkit\r\n\r\n宿主机更新 NVIDIA driver\r\ncurl -fsSL https://nvidia.github.io/libnvidia-container/gpgkey | sudo gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg \\&amp;&amp; curl -s -L https://nvidia.github.io/libnvidia-container/stable/deb/nvidia-container-toolkit.list | \\sed &#x27;s#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g&#x27; | \\sudo tee /etc/apt/sources.list.d/nvidia-container-toolkit.list\r\n\r\n请注意，该步骤会从 nvidia.github.io 上下载文件，可能需要配置代理\r\n\r\n更新包列表\r\nsudo apt update\r\n安装 NVIDIA Container Toolkit\r\nsudo apt install -y nvidia-container-toolkit\r\n\r\n配置 Docker\r\n\r\n通过 navidia-ctk 配置 docker 容器\r\nsudo nvidia-ctk runtime configure --runtime=docker\r\n重启容器\r\nsudo systemctl restart docker\r\n\r\n配置 Containerd\r\ncontainerd 是一个开源的容器运行时，它是 Docker\r\n的一个核心组件，负责管理容器的生命周期，包括镜像管理、容器执行、进程监控、网络管理等。\r\nsudo nvidia-ctk runtime configure --runtime=containerdsudo systemctl restart containerd\r\n测试\r\n使用下列代码测试是否可以在 docker 容器中使用 gpu\r\nsudo docker run --rm --runtime=nvidia --gpus all ubuntu nvidia-smi\r\n\r\n--gpus all：表示在 docker 中使用 GPU，若容器需要使用\r\nGPU，都需要添加这个参数\r\n\r\n当输出如下内容时，说明安装成功了\r\n+---------------------------------------------------------------------------------------+| NVIDIA-SMI 535.129.03             Driver Version: 535.129.03   CUDA Version: 12.2     ||-----------------------------------------+----------------------+----------------------+| GPU  Name                 Persistence-M | Bus-Id        Disp.A | Volatile Uncorr. ECC || Fan  Temp   Perf          Pwr:Usage/Cap |         Memory-Usage | GPU-Util  Compute M. ||                                         |                      |               MIG M. ||=========================================+======================+======================||   0  NVIDIA GeForce RTX 4080        Off | 00000000:65:00.0 Off |                  N/A ||  0%   33C    P8               7W / 320W |      2MiB / 16376MiB |      0%      Default ||                                         |                      |                  N/A |+-----------------------------------------+----------------------+----------------------++---------------------------------------------------------------------------------------+| Processes:                                                                            ||  GPU   GI   CI        PID   Type   Process name                            GPU Memory ||        ID   ID                                                             Usage      ||=======================================================================================||  No running processes found                                                           |+---------------------------------------------------------------------------------------+\r\ndocker compose 配置 GPU\r\n在配置中加入如下设置，允许 docker 使用 gpu\r\nservices:  ollma:  \t...    deploy:      resources:        reservations:          devices:            - driver: nvidia              count: 1 # 使用一块 GPU              capabilities: [gpu]\r\n测试 Docker 容器 GPU 状态\r\n进入到容器后，执行 nvidia-smi，若成功显示 GPU\r\n信息，则说明 docker 容器成功访问到了 GPU。\r\nbug 排查\r\n重启后失效\r\n重启后，执行 nvidia-smi，发现 driver 没有启动：\r\n➜  /home/xby nvidia-smiNVIDIA-SMI has failed because it couldn&#x27;t communicate with the NVIDIA driver. Make sure that the latest NVIDIA driver is installed and running.➜  /home/xby sudo ubuntu-drivers install --gpgpu nvidia:550nvidia-headless-no-dkms-550NoneAll the available drivers are already installed.➜  /home/xby gcc --versiongcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0Copyright (C) 2021 Free Software Foundation, Inc.This is free software; see the source for copying conditions.  There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n从上面可以看出，问题出在\r\nnvidia-headless-no-dkms-550，安装的版本是 no-DKMS（Dynamic\r\nKernel Module Support，动态内核模块支持），所以驱动无法生效。\r\n因此，手动安装\r\nsudo apt install linux-modules-nvidia-550-server-generic\r\n即可，若是非 server 版本，需要安装\r\nlinux-modules-nvidia-550-generic。\r\n\r\n参考：Ubuntu Server 24.04\r\nNVIDIA驱动的bug - 怕刺\r\n\r\n参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\nNVIDIA\r\ndrivers installation | Ubuntu\r\nNVIDIA/nvidia-docker:\r\nBuild and run Docker containers leveraging NVIDIA GPUs\r\n(github.com)\r\nNVIDIA/nvidia-container-toolkit:\r\nBuild and run containers leveraging NVIDIA GPUs (github.com)\r\nInstalling\r\nthe NVIDIA Container Toolkit — NVIDIA Container Toolkit 1.14.3\r\ndocumentation\r\nRunning\r\na Sample Workload — NVIDIA Container Toolkit 1.14.3\r\ndocumentation\r\nUbuntu Server 24.04 NVIDIA驱动的bug\r\n- 怕刺\r\n","categories":["System","Linux"],"tags":["Docker","Ubuntu","Linux"]},{"title":"Ubuntu 解决开机网络等待问题","url":"/posts/2023/25M42MH.html","content":"在 Ubuntu 重启后，可能会在开机画面中看到「A start job is running for\r\nwait for Network to be\r\nconfigured」这样的消息，一直到两分钟后才可继续进行之后的开机流程。这个问题的原因是出在哪呢？要如何解决？\r\n\r\n原因分析\r\n在登录Ubuntu操作系统后，可以使用以下指令来查看这个Systemd\r\nUnit的状态\r\nsystemd-networkd-wait-online.service\r\n\r\n\r\nimage-20231227164123904\r\n\r\n我们可以根据状态消息来确认，问题点确实是发生在开机配置网络的时候，因为配置一直无法完成，所以超时了。\r\n那个究竟是哪个网络接口无法正常被配置呢？可以使用以下指令来查看：\r\nnetworkctl\r\n\r\n\r\nimage-20231227164222065\r\n\r\n从上面这张图的结果可以看出，笔者电脑的「enp2s0」这个网络接口似乎有问题，配置了好几分钟都还没结束。\r\n解决方式\r\n方式一：配置静态 IP\r\n通常这个问题是 DHCP\r\n无法正常取得网络信息的缘故所致，因此我们要手动指定 IP\r\n\r\n该方式从根源解决问题\r\n\r\nUbuntu所使用的网络管理工具为「netplan」，设置文件都放置于「/etc/netplan」这个目录下。因此我们可以利用「grep」指令来查找「enp0s8」这个网络接口的设置是在哪个文件内进行设置的。指令如下：\r\ncd /etc/netplan; grep -r enp2s0\r\n\r\n\r\nimage-20231227164851809\r\n\r\n从结果里，可以看到，配置位于\r\n00-installer-config-wifi.yaml 文件中\r\n使用 sudo vim 00-installer-config.yaml 对 enp2s0\r\n网口配置静态 IP。\r\nnetwork:  ethernets:    enp2s0:      dhcp4: true    enp3s0:      dhcp4: false      addresses:        - 192.168.128.237/24  # 设置静态 IP 地址和掩码      routes:        - to: default          via: 192.168.128.249  # 设置网关地址      nameservers:        addresses:          - 192.168.23.11  # 设置主、备 DNS          - 119.29.29.29  version: 2\r\n保存设置并生效：\r\nsudo netplan generate &amp;&amp; sudo netplan apply\r\n方式二：配置网络等待超时\r\n配置方法：\r\ncd /etc/systemd/system/network-online.target.wants/sudo vi systemd-networkd-wait-online.service\r\n在 [Service] 下添加\r\nTimeoutStartSec=2sec\r\n[Service]Type=oneshotExecStart=/lib/systemd/systemd-networkd-wait-onlineRemainAfterExit=yesTimeoutStartSec=2sec\r\n参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\n解决Ubuntu开机过程中，配置网络的步骤需要等待两分钟的问题\r\n| MagicLen\r\nUbuntu18.04\r\n开机卡“A start job is running for wait for network to be\r\nConfigured”的解决方法_a start job is running for\r\nnetwork-CSDN博客\r\n","categories":["System","Linux"],"tags":["Ubuntu"]},{"title":"Ubuntu 设置全局代理","url":"/posts/2023/2Y5R2C0.html","content":"本文将介绍如何为 Ubuntu 设置全局代理。\r\n\r\n代理设置\r\n为系统设置代理的原理是修改对应的环境变量。Linux\r\n关于代理的环境变量有：\r\n\r\n\r\n\r\n变量名\r\n介绍\r\n\r\n\r\n\r\n\r\nhttp_proxy\r\nhttp 代理\r\n\r\n\r\nhttps_proxy\r\nhttps 代理\r\n\r\n\r\nftp_proxy\r\nftp 代理\r\n\r\n\r\nall_proxy\r\n所有代理，若未设置其它类型的代理，默认使用这个设置\r\n\r\n\r\nno_proxy\r\n指定不需要代理的主机\r\n\r\n\r\n\r\n\r\n上图中的设置等价于：\r\nexport http_proxy=http://192.168.1.103:1080export https_proxy=http://192.168.1.103:1080export all_proxy=socks://192.168.1.103:1080export no_proxy=localhost,127.0.0.0/8,::1\r\n\r\n清注意，有的系统可能需要将变量名全部大写才生效，如下：\r\nexport HTTP_PROXY=http://192.168.1.103:1080\r\n\r\n代理在所有的 shell 中生效\r\n使用 export 命令设置的环境变量只对当前 shell\r\n有效。如果你想让代理设置在所有 shell 中都有效，你需要将这些\r\nexport 命令添加到你的 shell 的初始化脚本中（如\r\n~/.bashrc 或 ~/.bash_profile），然后运行\r\nsource ~/.bashrc 或\r\nsource ~/.bash_profile，或者注销(logout)并重新登录。\r\n参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\nubuntu配置全局系统代理_乌班图全局代理-CSDN博客\r\n如何在Ubuntu系统中进行系统级的代理设置\r\n- Angry_Panda - 博客园 (cnblogs.com)\r\n","categories":["System","Linux"],"tags":["Ubuntu","Proxy"]},{"title":"Windows 免密码 ssh 登录 Linux","url":"/posts/2024/FQYR5W.html","content":"本文将介绍如何在 Windows 配置 SSH 免密登陆 Linux。\r\n\r\n生成密钥对\r\n打开 cmd 或者\r\nPowershell，按下列步骤操作：\r\n# 这条命令用于生成密钥# 随后一路回车，当看到一幅矩形图生成，那么密钥生成成功ssh-keygen -t rsa\r\n将公钥添加到 Linux 账户\r\n打开 Powershell，执行下列命令：\r\nPowershell：\r\nGet-Content ~\\.ssh\\id_rsa.pub | ssh -p 22 username@host &quot;cat &gt;&gt; ~/.ssh/authorized_keys&quot;\r\n\r\n-p 22 为默认值，可省略\r\n\r\n验证是否添加成功\r\ncmd 下输入 ssh username@host uname 如果看到输出Linux\r\n表示添加成功。\r\n同样可以直接输入 ssh username@host\r\n这时可以看到不用输入密码即可登录 Linux 了。\r\n依然无法免密码登录\r\n添加key之后还是需要输入密码,主要排查方法是\r\nssh username@host -vvv 输出debug信息，或者remote机器使用\r\ncat /var/log/secure 查看日志\r\n可能的原因是:\r\n\r\n目录权限问题\r\n远程目录.ssh 和.ssh 目录下的文件的权限需要分别设置700和600\r\n找不到密钥\r\nssh登录命令添加参数 -i C:\\User\\name\\.ssh\\id_rsa\r\n手动指定密钥文件\r\n\r\nLinux 中密钥登录 Linux\r\n在 Linux 中，可以使用如下命令实现：\r\n# 生成密钥，若存在，可跳过ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;# 复制到对象机器ssh-copy-id user@remote_host\r\n参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\nwindows免密码ssh登录linux\r\n","categories":["System","Linux"],"tags":["Linux","ssh"]},{"title":"配置丝滑高效的 Linux 终端 zsh","url":"/posts/2024/2YV025C.html","content":"在 Linux 中绕不开的就是 shell，可选择的 shell 有很多，比如\r\nbash、zsh、fish、tcsh，ksh 等等。其中 bash 在 shell\r\n一直是老大哥的地位，zsh 在 bash\r\n基础上，做出了大量改进，同时加入了Bash、ksh及tcsh的某些功能。\r\n因此作者选择在工作中使用 zsh 作为主力\r\nshell。本文将详细介绍如何通过配置\r\nzsh，提升操作丝滑度，增强使用效率，让你从此对 shell 爱不释手。\r\n\r\nzsh\r\n安装\r\nzsh 一般系统会自带，可以通过下面的命令查看是否已经安装过 zsh\r\ncat /etc/shells\r\n若显示已经安装了，可跳过本节内容。\r\n安装：\r\n# 安装sudo apt install zsh#将 zsh 设置为系统默认 shellchsh -s $(which zsh)\r\n更新\r\n# 查看当前版本zsh --version# 更新sudo apt updatesudo apt install --only-upgrade zsh\r\n使用 oh-my-zsh 简化 zsh\r\n配置\r\n安装 oh-my-zsh\r\n可以使用以下方式安装：\r\nsh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;\r\n其它安装方式见：ohmyzsh/ohmyzsh#Basic\r\nInstallation\r\n\r\n特别注意：使用 git 时，需要将\r\ngit config --global core.autocrlf true重置为\r\ngit config --global core.autocrlf input，否则插件会提示错误。\r\n\r\n开启默认插件 Z\r\noh-my-zsh 自带了 z 插件，可以使用 z\r\n自动快速跳转目录，只需要在配置中打开即可\r\nvim ~/.zshrc# 打开 ~/.zshrc 向里面 plugins 中注册插件plugins=(     # other plugins... 多个插件使用空格或者换行分隔    z)\r\n语法高亮 fast-syntax-highlighting\r\ngit clone https://github.com/zdharma-continuum/fast-syntax-highlighting.git \\  $&#123;ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom&#125;/plugins/fast-syntax-highlightingvim ~/.zshrc# 打开 ~/.zshrc 向里面 plugins 中注册插件plugins=(     # other plugins...    fast-syntax-highlighting)\r\n也可以使用 zsh-syntax-highlighting\r\n参考：zdharma-continuum/fast-syntax-highlighting:\r\nFeature-rich syntax highlighting for ZSH (github.com)\r\n自动补全 zsh-autosuggestions\r\n# 下载插件git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestionsvim ~/.zshrc# 打开 ~/.zshrc 向里面 plugins 中注册插件plugins=(     # other plugins...    zsh-autosuggestions)\r\n参考：zsh-autosuggestions/INSTALL.md\r\nat master · zsh-users/zsh-autosuggestions (github.com)\r\n自动完成 zsh-autocomplete\r\n# 下载插件，放到 .oh-my-zsh 插件目录中，是为了方便管理git clone --depth 1 -- https://github.com/marlonrichert/zsh-autocomplete.git $&#123;ZSH_CUSTOM:-$&#123;ZSH:-~/.oh-my-zsh&#125;/custom&#125;/plugins/zsh-autocomplete  vim ~/.zshrc# 在任何调用 compdef 之前添加如下内容 (!!! 不要在 plugins 中直接添加插件)source ~/.oh-my-zsh/custom/plugins/zsh-autocomplete/zsh-autocomplete.plugin.zsh\r\n这个插件可以搜索历史记录，用起来起飞~\r\n应用配置\r\nsource ~/.zshrc\r\n未完待续...\r\n参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\n5\r\nMost Frequently Used Open Source Shells for Linux (tecmint.com)\r\nZsh\r\nohmyzsh\r\n我是如何让我的\r\nZsh 像丝般顺滑的 | QuarticCat's Blog\r\ndotfiles/zsh\r\nat main · QuarticCat/dotfiles (github.com)\r\n","categories":["System","Linux"],"tags":["Linux","zsh"]},{"title":"VSCode 远程 Linux 后, 使用 Docker 插件报错Permission denied","url":"/posts/2024/2H0WTET.html","content":"VSCode SSH 连接 Linux 后，使用 Docker 插件时报错：\r\npermission denied while trying to connect to the Docker daemon socket\r\nat unix:///var/run/docker.sock: Get\r\n\"http://%2Fvar%2Frun%2Fdocker.sock/v1.24/containers/json\": dial unix\r\n/var/run/docker.sock: connect: permission denied\r\n这是由于用户的权限不够，按下列方法修改权限即可：\r\n\r\n使用 ssh 连接 Linux，然后执行下列命令：\r\ngroupadd dockersudo usermod -aG docker $USERnewgrp dockersudo chmod 666 /var/run/docker.sock\r\n","categories":["System","Linux"],"tags":["Docker","Linux","VSCode"]},{"title":"on-my-zsh 中显示绝对路径","url":"/posts/2024/2KMYJ38.html","content":"本篇文章将介绍如何修改 on-my-zsh 主题，使其显示绝对路径。\r\n\r\n查找当前使用的主题：\r\n# 使用 grep 查找主题配置grep &#x27;^ZSH_THEME&#x27; ~/.zshrc# 显示如下：ZSH_THEME=&quot;robbyrussell&quot;\r\n修改主题配置：\r\nvi ~/.oh-my-zsh/themes/robbyrussell.zsh-theme\r\n对配置作以下修改：\r\n...%&#123;$fg[cyan]%&#125;%c%&#123;$reset_color%&#125;# 修改成...%&#123;$fg[cyan]%&#125;%d%&#123;$reset_color%&#125;\r\n然后退出重新连接 ssh 即可生效。\r\n其它相关配置提示符如下：\r\n%%  一个&#x27;%&#x27;#%) 一个&#x27;)&#x27;%y  当前的tty名%l  当前的tty名，如 pts/1%M  完整主机名%m  主机名（在第一个句号之前截断）%n  当前用户名%. %c %C 前两个显示相对路径的当前文件夹名，最后一个是绝对路径（也就是说，前两个在家目录下显示&#x27;~&#x27;，最后那个显示你的用户名），&#x27;%&#x27;后的数字表示显示几层路径%N  zsh 正在执行的脚本/函数名。如果&#x27;%&#x27;后跟了数字，似乎还有其他作用%L  当前shell的层数%j  当前正在进行的工作数量%i  与%!类似：The line number currently being executed in the script, sourced file,&lt;br&gt;         or shell function given by %N. This is most useful for debugging as part of $PS4.%!  显示当前历史事件号码（也就是打开shell后第几条命令）%/ %d   显示当前工作路径（$pwd）。如果&#x27;％&#x27;后面是一个整数，它指定显示路径的元件的数量;没有数字就显示整个路径。一个负整数就是指定主目录，即％-1d代表第一部分%~  目前的工作目录相对于～的相对路径%?  返回最后命令的执行结果的代码%#  用户组，#（普通用户）/%（超级用户）\r\n","categories":["System","Linux"],"tags":["Linux","on-my-zsh"]},{"title":"Linux修改默认终端","url":"/posts/2024/TM7WNE.html","content":"# 查看可用终端cat /etc/shells  # 修改终端chsh -s /bin/zsh\r\n","categories":["System","Linux"],"tags":["Linux"]},{"title":"Ubuntu 扩容 Swap","url":"/posts/2025/3QSYEQ7.html","content":"Swap 是 Linux\r\n系统中的一种虚拟内存，用于在物理内存不足时扩展可用内存。本文将介绍如何在\r\nUbuntu 上增加 Swap 大小。\r\n\r\nswap 大小建议\r\nswap 一般建议为内存的 1~2 倍\r\nswap 扩容\r\n从代码来看，这个脚本是用于恢复 MongoDB 数据的，与 Linux 的 swap\r\n扩容无直接关系。如果你需要扩容 Linux 的 swap\r\n空间，可以参考以下步骤：\r\n\r\nLinux Swap 扩容步骤\r\n\r\n检查当前 swap 使用情况\r\n运行以下命令查看当前 swap 空间：\r\nfree -h\r\n创建新的 swap 文件\r\n假设你需要增加 2GB 的 swap 空间：\r\nsudo fallocate -l 2G /swapfile\r\n如果 fallocate 不可用，可以使用 dd：\r\nsudo dd if=/dev/zero of=/swapfile bs=1M count=2048\r\n\r\nbs 块大小\r\ncount 块数量，2G\r\n\r\n设置正确的权限\r\nsudo chmod 600 /swapfile\r\n格式化为 swap\r\nsudo mkswap /swapfile\r\n启用新的 swap 文件\r\nsudo swapon /swapfile\r\n验证是否生效\r\nswapon --showfree -h\r\n永久生效（可选）\r\n编辑 /etc/fstab 文件，修改相应的 Swap 配置：\r\nsudo vim /etc/fstab/swapfile none swap sw 0 0\r\n\r\n参考\r\n如何增加Ubuntu上的Swap大小\r\n","categories":["System","Linux"],"tags":["Ubuntu","Swap"]},{"title":"Ubuntu Nvidia 显卡驱动突然不识别","url":"/posts/2024/NZP006.html","content":"Ubuntu 安装 Nvidia 驱动后，有一天突然就无法识别到驱动了，使用\r\nnvidia-smi 查看状态显示：\r\nFailed to initialize NVML: Driver/library version mismatchNVML ibrary version: 535.154\r\n出现这个的原因是因为驱动驱动更新后，kernel mod 的 Nvidia driver\r\n的版本没有更新。\r\n\r\n如何恢复\r\n\r\n通过重启 Ubuntu，选择老版本的 kernel 启动\r\n如果因为某些原因不能够重启的话，使用 reload kernel mod\r\n方式重新让内核加载驱动\r\n# 查看驱动 lsmod | grep nvidia_# 将面列出的驱动移除sudo rmmod nvidia_drmsudo rmmod nvidia_modesetsudo rmmod nvidia_uvm# 最后移除 nvidiasudo rmmod nvidia# 重新加载驱动nvidia-smi\r\n\r\n如何预防\r\n为了防止系统自动更新 Nvidia\r\n驱动导致问题再次出现，可以禁用显卡驱动自动更新\r\n# 查看安装的驱动，标记 automatic 的包不用管apt list --installed | grep nvidia# 阻止更新，package-name 为包名称，比如 nvidia-driver-535sudo apt-mark hold package-name\r\n若要恢复，使用下列命令：\r\nsudo apt-mark unhold package-name\r\n补充更新\r\n2025-10-30\r\n可能是由于系统的 kernel 升级了，导致显卡驱动失效，可以通过重启回退\r\nkernel 恢复。\r\n参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\ncuda\r\n- Nvidia NVML Driver/library version mismatch - Stack Overflow\r\n解决Driver/library\r\nversion mismatch | Comzyh的博客\r\n","categories":["System","Linux"],"tags":["Ubuntu","Nvidia"]},{"title":"Ubuntu 扩容 docker 目录挂载的逻辑卷","url":"/posts/2025/3Z47PR7.html","content":"服务器将 /var/lib/docker\r\n挂载到了一个卷上，方便对数据进行集中管理，某天发现该卷使用空间已达\r\n100%，在使用了 docker image prune -a\r\n清除无效镜像无果后，只能对其扩容。\r\n本文将介绍如何将其它逻辑卷上的空间扩容到 docker 所在的卷上。\r\n\r\n首先，使用 df -h 查看磁盘情况：\r\n➜  /home/uyoufu df -hFilesystem                         Size  Used Avail Use% Mounted ontmpfs                              1.6G  3.7M  1.6G   1% /runefivarfs                           128K   74K   50K  60% /sys/firmware/efi/efivars/dev/mapper/ubuntu--vg-ubuntu--lv  231G   13G  206G   6% /tmpfs                              7.8G     0  7.8G   0% /dev/shmtmpfs                              5.0M   12K  5.0M   1% /run/lock/dev/nvme0n1p2                     2.0G  286M  1.6G  16% /boot/dev/nvme0n1p1                     1.1G  6.2M  1.1G   1% /boot/efi/dev/mapper/hdd--vg-lv--usr        492G  6.0G  461G   2% /srv/dev/mapper/hdd--vg-lv--home       492G  285G  182G  61% /home/dev/mapper/hdd--vg-lv--var        492G  488G     0 100% /var/lib/dockertmpfs                              1.6G   20K  1.6G   1% /run/user/1000\r\n可以看到，机械硬盘卷 /dev/mapper/hdd--vg-lv--usr\r\n上还有很多空间，因此，现在将 /dev/mapper/hdd--vg-lv--usr\r\n中的空间移动部分到 /dev/mapper/hdd--vg-lv--var 上。\r\n操作步骤如下：\r\n\r\n停止服务\r\nsudo systemctl stop docker\r\n若出现以下提示：\r\nStopping &#x27;docker.service&#x27;, but its triggering units are still active:docker.socket\r\n需要同时停用 docker.socket，操作如下：\r\nsudo systemctl stop docker docker.socket\r\n确保服务完全关闭\r\nsudo systemctl status docker docker.socket# 存在 Active: inactive (dead) since xxx 时表示已关闭\r\n缩小 usr 文件系统\r\nsudo umount /srv  # 卸载卷sudo e2fsck -f /dev/mapper/hdd--vg-lv--usr  # 检查文件系统sudo resize2fs /dev/mapper/hdd--vg-lv--usr 50G  # 缩小文件系统到 50G（调整为实际需要）sudo mount /dev/mapper/hdd--vg-lv--usr /srv  # 重新挂载\r\n扩展 var 逻辑卷\r\nsudo lvextend -l +100%FREE /dev/mapper/hdd--vg-lv--var  # 使用所有可用空间\r\n扩展 var 文件系统\r\nsudo resize2fs /dev/mapper/hdd--vg-lv--var  # 扩展到新大小\r\n重新启动服务并验证\r\nsudo systemctl start docker# 若有需要sudo systemctl start docker.socket# 检查状态sudo systemctl status docker docker.socket# 检查空间df -h\r\n\r\n","categories":["System","Linux"],"tags":["Docker","Ubuntu","uyoufu"]},{"title":"免费的视频剪辑素材资源","url":"/posts/2023/1YG7ZB2.html","content":"最近在工作上要制作几个微课，平时感觉制作一个视频还挺简单的，当到实际上手的时候，才发现力不从心，特别是素材，无从找起，因此本文对如何收集素材进行一个简要总结，以便今后更加高效的使用。\r\n\r\n本文随着视频剪辑的熟练度增加，会不定期进行更新\r\n\r\n\r\n汇总\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名称\r\n特点\r\n下载方式\r\n\r\n\r\n\r\n\r\nPexels video\r\n视频数量种类多\r\n无需注册\r\n\r\n\r\nPixabay视频\r\n视频数量种类多\r\n无需注册，免费商用\r\n\r\n\r\nMixkit\r\n视频、音乐素材多\r\n部分可商用\r\n\r\n\r\nVidevo\r\n免费视频、音乐、音效素材\r\n无需注册\r\n\r\n\r\nIgniteMotion\r\n仅背景视屏\r\n\r\n\r\n\r\nCoverr\r\n多样素材\r\n部分商用\r\n\r\n\r\nMazwai\r\n多样素材\r\n可商用\r\n\r\n\r\nVideezy\r\n多样素材\r\n\r\n\r\n\r\n\r\n鉴于经济实力，本文仅推荐一些免费的视屏资源。\r\nPexels video\r\n\r\n\r\nPexels 免费视频下载\r\n\r\n经常找图片的人相信都听说过Pexels，它是一个非常有名的免费图片素材站，后来Pexels又推出了视频\r\nPexels video，同样是免费下载\r\nPexels video\r\n上的视频数量种类多，有自然风景相关，也有人物会议等视频，视频展示采用瀑布流的方式，可以直接当前窗口预览视频，无需注册就能下载\r\nPixabay 视频素材库\r\n\r\n\r\nPixabay 视频素材库\r\n\r\n同Pexels一样，Pixabay也是非常有名的免费图片网站，它也提供了免费无版权的视频\r\nPixabay视频不仅数量多，还提供了非常多的信息，你可以在下载前预览视频，也可以查看视频的各种参数，包括视频分辨率、时长、格式、上传时间等，无需注册就可以下载，无需署名可以商业用途\r\nMixkit\r\n\r\n\r\nMixkit创意视频免费下载\r\n\r\nMixkit\r\n是Envato去年推出的一个视频、音乐的素材平台，和Envatomarket、Envato\r\nElements等付费产品不同，Mixkit\r\n的所有内容都是完全免费的，网站提供了免费的视频、音乐素材、Premiere\r\nPro模版，你可以免费下载视频，支持个人和商业使用\r\nMixkit平台的视频质量都非常高，你可以根据类别进行查找，包括城市、咖啡、天空、人物、海滩、办公、食物等，每个视频都清晰独特，适合制作创意视频使用\r\nVidevo\r\n\r\n\r\nVidevo专业视频素材库\r\n\r\nVidevo是一个专业的视频素材网站，提供成千上万的免费视频、音乐、音效素材，旨在成为你的唯一资料库。Videvo\r\n把视频分成了很多类别，有动物、商业、办公室、工业、医疗、视觉特效等，你可以通过类别标签快速找到需要的视频，找到合适的视频可以直接下载，无需注册\r\n唯一需要注意一点是有些视频是付费的，带有PREMIUM标志的需要加入会员才可以下载，如果你只是想找一些免费视频，有一个技巧就是可以点击过滤器，只看免费的视频就不会被干扰了，而且即使是免费的都有1万以上，对于个人使用完全足够了\r\nIgniteMotion\r\n\r\n\r\nIgniteMotion\r\n免费视频背景素材网站\r\n\r\nIgniteMotion\r\n是一个以特效和背景视频为主题的素材网站，它不像其他网站提供各种各样的素材，就是单纯的背景视频。\r\nIgniteMotion\r\n的背景视频有几个明确的类别，比如云朵、地球、火焰、抽象、水、科幻等，数量不多，但都适合做为素材使用，如果你在IgniteMotion\r\n中找一个视频，无需搜索就能快速找到\r\nCoverr\r\n\r\n\r\nCoverr 无版权视频库\r\n\r\nCoverr\r\n是一个全面的视频素材网站，它提供了技术、心情、自然、人物、动物、都市等多种类别的无版权视频素材，你可以直接从网站下载，无需询问，可用作个人和商业用途\r\nDareful\r\n\r\n\r\nDareful免费4K视频素材网站\r\n\r\nDareful是一个免费的4K视频素材站点，所有视频都是4K高清格式，完全免费，无需署名，可以商业使用，缺点是下载比较麻烦，需要用邮箱注册，而且下载链接需要到邮箱中找\r\nLife of Vids\r\n\r\n\r\nLife of Vids 无版权视频网站\r\n\r\nLife of Vids\r\n是一个风格独特的视频网站，有点类似博客风格，但确实提供了很多免费的视频，你可以在顶部搜索框中输入关键词搜索视频，也可以查看它的视频集合，集合中提供了多套视频素材，包括城市、自然、小镇、食物、办公等几个类别，你可以免费下载用在自己的视频中\r\nVideezy\r\n\r\n\r\nVideezy 免费高清4K视频下载\r\n\r\nVideezy\r\n是一个很全面的视频素材网站，视频和类别都非常全面，在它的分类中，不仅有像天空、自然、动物这样的分类，每个大分类下还有对应的分支，比如都市里面就有伦敦和纽约这样的城市分类，通过细致的分类，你可以快速找到需要的视频\r\n使用Videezy这样网站，不要看首页很多都是付费视频，按分类打开，里面大部分的视频素材都是免费的，可以找到很多优秀的视频\r\nMazwai\r\n\r\n\r\nMazwai免费的视频素材库\r\n\r\nMazwai是一个完全免费的视频素材库，包括各种类型的视频，其创建的目的就是让全世界的人都能免费获得视频素材，所有的视频都是网站精心挑选，并且得到作者允许，可以放心使用\r\n参考\r\n\r\n2023年10个免费的视频素材网站推荐\r\n\r\n","categories":["Skill","Video"],"tags":["Skill","Video"]},{"title":"免费制作 MG 动画","url":"/posts/2023/2WHBPR.html","content":"在进行视屏制作的过程中，有时候我们需要插入一些 MG(Motion Graphics)\r\n动画，一般使用 AE 制作，但是对于一些简单的文字、流程动画，使用 AE\r\n就杀鸡用牛刀了，因此我们一般使用一些速成的方式来制作。\r\n\r\nPPT\r\n使用 PPT 制作，合理使用路径动画、动画效果，然后导出视屏。\r\n\r\n缺点：\r\n\r\n只能整个导出，不能导出当前页\r\n不有丰富的素材库\r\n\r\n\r\n在线 MG 动画制作网站\r\n除了 PPT，我们还可以使用一些在线的 MG\r\n动画制作网站来制作，但是这类型的网站一般都是收费的，下面列出一些推荐使用的网站及免费使用的方法。\r\n秀展网\r\n网址：https://www.xiuzhan365.com/\r\n","categories":["Skill","Video"],"tags":["Skill","Video"]},{"title":"ComfyUI 入门资料整理","url":"/posts/2024/1189BHM.html","content":"本文收集 ComfyUI 相关的学习资料，按学习的进度先后进行排序。\r\n\r\n概念介绍\r\n\r\n万字教程！奶奶看了都会的 ComfyUI\r\n入门教程 - 优设网 - 学设计上优设 (uisdc.com)\r\n【comfyUI基础教程】官方文档翻译和场景使用补充，纯干货！（一、安装开始和使用技巧）\r\n- 知乎 (zhihu.com)\r\n\r\n示例\r\n\r\n使用示例时，可以直接导入示例中的 png 图片，里面保存了工作流的数据\r\n\r\n\r\nComfyUI_examples\r\n翻译笔记 - 掘金 (juejin.cn)\r\nComfyUI\r\nExamples | ComfyUI_examples (comfyanonymous.github.io)\r\nComfy Workflows\r\nComfyUI Workflows -\r\nDeveloper Community (openart.ai)\r\n\r\n模型下载\r\nControlNet\r\nSDXL:\r\nstabilityai/control-lora\r\nat main (huggingface.co)\r\n工具\r\n获取图片标注：WaifuDiffusion\r\nTagger - a Hugging Face Space by SmilingWolf\r\n参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\n\r\nComfyUi教程汇总 -\r\n知乎 (zhihu.com)\r\nBeginner's Guide to ComfyUI\r\nfor Stable Diffusion - Aituts\r\n[AIGC]\r\nComfyUI 节点解释_comfyui节点介绍-CSDN博客\r\n\r\n","categories":["Software","ComfyUI"],"tags":["ComfyUI","SD"]},{"title":"ComfyUI 节点介绍","url":"/posts/2024/2TKH0W3.html","content":"本文总结了对 SD ComfyUI 中的一些节点的理解，以便灵活运用。\r\n\r\n功能节点\r\n核心结点\r\n高级节点\r\nDiffusers Loader\r\n采样器\r\nKSampler\r\n\r\n作用：\r\n通过给定的潜空间，使用 model、positive、negative\r\n作为引导，生成一个新的潜空间。\r\n输入输出：\r\n\r\n\r\n\r\n输入\r\n参数描述\r\n输出\r\n参数描述\r\n\r\n\r\n\r\n\r\nmodel\r\n用于去噪的模型\r\nlatent\r\n图片潜空间\r\n\r\n\r\npositive\r\n正向提示词\r\n\r\n\r\n\r\n\r\nnegative\r\n负面提示词\r\n\r\n\r\n\r\n\r\nlatent_image\r\n待生成图片的潜空间\r\n\r\n\r\n\r\n\r\n\r\n配置：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名称\r\n描述\r\n\r\n\r\n\r\n\r\nseed\r\n生成噪声的种子。种子不一样时，生成的图片也不一样\r\n\r\n\r\ncontrol_after_generate\r\n控制种子的更新方式\r\n\r\n\r\nstep\r\n去噪期间要使用的迭代步数。迭代越多，结果就越准确\r\n\r\n\r\ncfg (classifier free guidance)\r\n提示词对生成结果的影响程度。值越大，越接近提示词要求，建议 5-9\r\n\r\n\r\nsampler_name\r\n使用的采样器名称\r\n\r\n\r\nscheduler\r\n计划器\r\n\r\n\r\ndenoise\r\n添加噪点的强度。AI是基于噪点扩散的，噪点强度越高，AI的创作空间就越大，出图也就和原图越不相似\r\n\r\n\r\n\r\n条件节点\r\nCLIP Set Last Layer\r\n插件节点\r\n参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\n\r\nComfyUI\r\nCommunity Manual (blenderneko.github.io)\r\nHome - Salt Documentation\r\n(getsalt.ai)\r\nComfyUI_examples\r\n翻译笔记 - 掘金 (juejin.cn)\r\nComfyUI\r\nExamples | ComfyUI_examples (comfyanonymous.github.io)\r\nComfy Workflows\r\nComfyUI Workflows -\r\nDeveloper Community (openart.ai)\r\nStable\r\nDiffusion中CFG scale与denoising strength的参数分析--以纯爱战神为例 -\r\n哔哩哔哩 (bilibili.com)\r\nwyrde/wyrde-comfyui-workflows:\r\nsome wyrde workflows for comfyUI (github.com)\r\n\r\n","categories":["Software","ComfyUI"],"tags":["ComfyUI","SD"]},{"title":"如何解决 Adguard 拖慢网速问题","url":"/posts/2020/1W2Z51R.html","content":"最近在网上发现一款去除广告神器，集颜值和功能于一身，它就是\r\nAdguard。最重要的是，它是开源的，所以在使用的过程中，完全不必担心软件留有后门。但是在使用的过程，发现它会拖慢网页的打开速度。几经周折，终于找到解决办法。\r\n\r\n现象\r\n打开 Adguard 后，在打开网页时，在左下角经常先后出现 ”正在等待\r\nlocal.adguard.com\" 和 ”正在等待 injection.adguard.com\"\r\n两个网页加载提示\r\n解决办法\r\n在百度许久无果之后，终于还得谷歌，在 Adguard\r\n的论坛里面找到了解决办法，How\r\nto disable injection totally\r\n根据里面的官方人员回复，这是因为 Adguard 的 “浏览安全” 功能会使用 injection.adguard.org/local.adguard.org.，关掉它就可以了。\r\n\r\n原文：Besides extensions, the SafeBrowsing settings can also use injection.adguard.org/local.adguard.org.\r\nYou should try to disable that option.\r\n\r\n","categories":["Software","Adguard"],"tags":["Adguard"]},{"title":"使用 AdGuardHome，实现网页加速和去广告","url":"/posts/2020/2JN1KQ1.html","content":"\r\n\r\nadguard\r\n\r\n前言\r\n最近有一款软件深深地吸引了我，界面如下：\r\n\r\n\r\nadguard1\r\n\r\n它的主要功能有三项\r\n\r\n通过对 dns 的并发查询来加速网页的打开速度，大部分可以实现秒开\r\n通过不同的规则来过滤\r\ndns，达到过滤广告的目的，最厉害的是，国内的各大视屏网站的广告也能过滤，看剧再也不用等待那漫长的\r\n70s 了\r\n通过设置过滤器，可以很好的保护自己的上网安全，防止钓鱼网站等的危害\r\n\r\n这三个特点完全戳中了我的兴趣点，而且它的界面清爽，让人不得不喜欢。\r\n\r\n选择困难症\r\nAdGuard 在各个平台上都有相应的\r\nApp，直接下载来用就可以了，但是，这些平台的软件都有一个问题，它们不能进行\r\ndns 的加速，真是让人郁闷不已。\r\n在谷歌上搜 AdGuardHome, 大家的食用方法基本分为这两派：\r\n\r\n安装在软件路由，NAS等设备上面\r\n通过购买云服务器，构建 dns 服务器\r\n\r\n我不禁呵呵了，上面两个方案，哪一个不需要花钱啊！\r\n最后，结合实际，我总结出了自己的一个使用方法，在此分享给大家：在电脑上安装\r\nAGuardHome 作为本机的 dns\r\n服务器，只要用电脑上网，就能实现加速，当然，也可以实现全局域网的加速，后面详细介绍。\r\n下载软件\r\n该软件是开源的，所以，只需要到 GitHub\r\n上下载符合自己的系统的版本就可以了。本教程将以 windows10\r\n来举例说明。\r\n开源仓库地址：https://github.com/AdguardTeam/AdGuardHome\r\n软件下载地址：https://github.com/AdguardTeam/AdGuardHome/releases\r\n安装软件\r\n\r\n将下载的软件解压，比如\r\nD:\\Program Files\\AdGuardHome;\r\n用 管理员权限 启动 cmd(命令提示符) 窗口\r\n在任务栏中的搜索框中键入 cmd, 会出现一个名为 “命令提示符”\r\n的程序，右键，用管理员身份打开；\r\n在打开的黑窗体中依次输入下面的代码\r\nd:cd D:\\Program Files\\AdGuardHomeAdGuardHome\r\n输入最后一个命令后，当黑窗体中出现如下截图的提示信息的时候，表示初始化已经成功了。\r\n\r\n注册 windows 服务\r\n打开 cmd 窗口，输入下面的命令来注册系统服务，以便开机自动启动：\r\nd:cd D:\\Program Files\\AdGuardHomeAdGuardHome -s install\r\n此处一并放上其它的命令，如果有需要，可以使用\r\nAdGuardHome -s uninstall //卸载 AdGuardHome 服务AdGuardHome -s start //开始服务AdGuardHome -s stop //结束服务AdGuardHome -s restart //重启服务AdGuardHome -s status //显示服务状态\r\nAdGuardHome 配置\r\n到现在 AdGuardHome 已经安装完成\r\n，接下来，在浏览器中输入地址：http://127.0.0.1:3000 进行配置。\r\n基本设置\r\n\r\n配置管理员接口和 DNS 服务\r\n\r\n\r\nadminInterface\r\n\r\n上图中，第一个端口是管理界面的访问端口，如果将端口 XX，那今后访问\r\nAdGuardHome 的管理界面就变成: http://127.0.0.1:XX, 建议设置成 3000。\r\n第二个端口是 DNS\r\n服务监听端口，使用默认的就可以了，如果使用其它端口，在使用时，还需要额外指定端口号，稍微繁琐，所以建议直接用默认的就可以了。\r\n添加用户名和密码\r\n\r\n\r\naddUsers\r\n\r\n\r\n注意：设置后，在界面里是没有修改用户名和密码的选项的，需要修改配置文件，所以，在添加用户名和密码的时候，不要太随意。\r\n\r\n\r\nDNS 设置\r\n在设置-&gt;DNS 设置 里，对 DNS 进行配置\r\n\r\n\r\ndns\r\n\r\n\r\n上游 DNS 服务器中输入：\r\n8.8.8.8114.114.114.114119.29.29.29223.5.5.5180.76.76.761.2.4.8\r\n打开 “并行请求”\r\n在 Bootstrap DNS 中输入：\r\n9.9.9.10149.112.112.102620:fe::102620:fe::fe:10\r\n点击应用\r\n\r\n添加过滤器\r\n过滤器的作用是通过一些预定义的规则来过滤\r\nDNS，从而达到去除广告，保护隐私的目的。\r\n过滤器的添加是在：过滤器-&gt;DNS 封锁清单 里面\r\n推荐的规则有：\r\n\r\nAdGuard Simplified Domain Names filter, 自带\r\nAdAway, 自带\r\nMalwareDomainList.com Hosts List，自带\r\nAdGuard Base\r\nfilter，https://filters.adtidy.org/extension/chromium/filters/2.txt\r\nAdGuard Tracking Protection\r\nfilter，https://filters.adtidy.org/extension/chromium/filters/3.txt\r\nAdGuard Annoyances\r\nfilter，https://filters.adtidy.org/extension/chromium/filters/14.txt\r\nanti-ad-easylist，https://raw.githubusercontent.com/privacy-protection-tools/anti-AD/master/anti-ad-easylist.txt\r\n\r\n当然，网上有特别多的规则，大家可以在 bilibili 或者 github\r\n上面搜索。\r\n修改网络适配器 DNS\r\n实现所有网络下的加速\r\n好了，到目前为止，我们已经在自己的电脑上安装了 AdGuardHome\r\n了，接下来，配置电脑本机的 DNS，让它指向我们自己的 DNS\r\n服务器，实现网页访问加速和隐私保护。\r\n\r\n打开网络适配器\r\n在 控制面板\\所有控制面板项\\网络连接\r\n选择自己当前的网络适配器\r\n右键-&gt;属性-&gt; 双击\r\nInternet 协议版 4(TCP/IPv4)\r\n使用自定义 DNS\r\n如下图\r\n\r\n\r\np1\r\n\r\n\r\n这样，就完成了配置，可以尽情地享受快速无广告的冲浪体验了。\r\n修改路由器 DNS\r\n实现局域网加速\r\n上面的设置，只能够让自己使用网络加速功能，如果要想在局域网里面让所有的终端都能够实现网络加速，我们可以将安装了\r\nAdGuardHome 服务的电脑当成局域网中的 DNS\r\n服务器，这样，只要有人连接了你的局域网，他就会享受到加速。但是这有两个缺点：\r\n\r\n安装 DNS 服务的电脑必须一直开着机\r\n如果局域网内的终端很多，可能会影响 DND 服务的那台电脑\r\n\r\n当然，如果是家庭里面使用，就完全不用担心了。\r\n下面是具体的步骤：\r\n\r\n查看自己的局域网网关\r\n\r\n\r\np3\r\n\r\n打开网络设置，找到 IPv4 地址，网关一般都是\r\n网段.1,上面我们可以看到，本机的 IP4 是 192.168.3.29,\r\n所以网段就是前面三个值，而网关为 192.168.3.1\r\n将自己电脑设置为静态 IP\r\n选择网络，然后编辑，打开 IPv4,然后按照下面的配置输入\r\n\r\n\r\n\r\np2\r\n\r\n因为我的网段是 192.168.3，所心，我输入的 IP\r\n地址也必须是在这个网段内，范围是2~255，当前例子中，使用的是\r\n192.168.3.100\r\n\r\n打开路由器管理界面，开启静态 DNS\r\n\r\n\r\np4\r\n\r\n将路由器的首选 DNS 指向安装了 DNS 服务的电脑就可以了。\r\n\r\n后记\r\n对于加速，没怎么感受到，但是网页确实干净了不少。\r\n","categories":["Software","Adguard"],"tags":["佳软","Adguard"]},{"title":"AdGuard 语法","url":"/posts/2020/K2C2JM.html","content":"为了能够更加精准的去除广告，只能自食其力，自己编写去除规则。以下是对\r\nAdugard 过滤规则的简要解释。\r\n\r\n注释\r\n注释用“!”\r\n基本规则\r\n基本语法规则\r\n@@ 表示排除规则\r\n特殊字符\r\n\r\n* 通配符。匹配任何空字符或者任一长度的字符串\r\n|| 匹配地址开头。表示：http://*.\r\n、https://*.、ws://*.、wss://*.\r\n^\r\n匹配分隔符。可以是字母、数字、_、-、.和%其中一个。\r\n| 匹配开始或者结束符。如 .com| 匹配\r\nbaidu.com\r\n\r\n正则表达式支持\r\n\r\n正则表达式会使性能变慢\r\n\r\n格式如下：\r\n! regexp 代表正则表达式语法pattern = &quot;/&quot; regexp &quot;/&quot;\r\n修饰符\r\n修饰符位于规则末尾，修饰符间用逗号分隔。\r\n致谢\r\n本文来源于 LeeYD 的博客：https://www.leeyiding.com/archives/50/\r\n","categories":["Software","Adguard"],"tags":["AdGuard","去广告"]},{"title":"使用 Docker 部署 AdguardHome","url":"/posts/2024/AC0WPY.html","content":"本文介绍如何在 Ubuntu 中通过 Docker 部署 AdguardHome 实现 DNS\r\n解析和广告过滤。\r\n\r\ndocker compose\r\n使用下面的 docker-compose 启动\r\nservices:  adguardhome:    image: adguard/adguardhome    container_name: adguardhome    restart: unless-stopped    volumes:      - ./data/workdir:/opt/adguardhome/work # 挂载数据      - ./data/confdir:/opt/adguardhome/conf # 挂载配置    ports:      - 53:53/tcp      - 53:53/udp      # - &quot;67:67/udp&quot;      # - &quot;68:68/udp&quot;      # - &quot;80:80/tcp&quot;      # - &quot;443:443/tcp&quot;      # - &quot;443:443/udp&quot;      - &quot;3000:3000/tcp&quot;      # - &quot;853:853/tcp&quot;      # - &quot;784:784/udp&quot;      # - &quot;853:853/udp&quot;      # - &quot;8853:8853/udp&quot;      # - &quot;5443:5443/tcp&quot;      # - &quot;5443:5443/udp&quot;    dns:      - 223.6.6.6      - 119.29.29.29\r\n问题排查\r\n启动容器可能会报错：required port 53 already in use\r\n这说明 53 端口已经被占用，这个端口默认被\r\nsystemd-resolved 占用。\r\n查看占用的进程\r\nsudo lsof -i :53\r\n若显示如下输出，则说明被 systemd-resolved 占用了。\r\n\r\n\r\nimage-20241126102219940\r\n\r\n解除占用\r\n\r\n先停用 systemd-resolved 服务\r\nsudo systemctl stop systemd-resolved\r\n编辑 /etc/systemd/resolved.conf 文件，取消 DNSStubListener\r\nvi /etc/systemd/resolved.conf# 将 DNSStubListener 设置为 no[Resolve]#DNS=8.8.8.8#FallbackDNS=#Domains=#LLMNR=no#MulticastDNS=no#DNSSEC=no#Cache=yes#取消注释，把yes改为no，配置必须单行存在DNSStubListener=no\r\n将 resolv.conf 指向 systemd-resolved 管理的文件\r\n在现代 Linux 系统中，systemd-resolved 是一个用于管理 DNS\r\n解析的服务。它提供了对 DNS、LLMNR 和 mDNS 的支持，并可以动态更新 DNS\r\n配置。通过将 resolv.conf 指向 systemd-resolved\r\n管理的文件，可以确保系统的 DNS 配置始终与 systemd-resolved\r\n保持一致。\r\n# 备份原来的 resolv.confsudo cp /etc/resolv.conf /etc/resolv.conf.bak# 删除原文件并建立软链接sudo ln -sf /run/systemd/resolve/resolv.conf /etc/resolv.conf\r\n查看生效\r\n# 重启服务sudo systemctl restart systemd-resolved.service# 查看是否可用lsof -i :53\r\n\r\n参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\nadguard/adguardhome\r\n- Docker Image | Docker Hub\r\nLinux\r\nsystemd-resolve占用53端口的解决方法\r\n","categories":["Software","Adguard"],"tags":["Docker","AdguardHome"]},{"title":"Windows下右键新建.md文件","url":"/posts/2020/26DVEVG.html","content":"如何在 windows 中添加右键新建 .md 文件功能？\r\n\r\n正文\r\n新建一个 .reg\r\n的文本文件，将下列代码拷贝到里面，然后双击运行即可\r\nWindows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\\.md]@=&quot;Typora.exe&quot;[HKEY_CLASSES_ROOT\\.md\\ShellNew]&quot;NullFile&quot;=&quot;&quot;[HKEY_CLASSES_ROOT\\Typora.exe]@=&quot;Markdown&quot;\r\n解释\r\n@=\"Typora.exe\" 代表的是指定 .md 文件的运行程序\r\n@=\"Markdown\" 代表的是右键时默认的文件名字，这样写新建为\r\n新建Markdown.md 文件，而且右键菜单中显示\r\nMarkDown。\r\n致谢\r\n原谅链接：https://stepneverstop.github.io/win-rightclick-create-md.html\r\n","categories":["System","Windows"],"tags":["Markdown","windows优化"]},{"title":"重置 winsock 解决电脑网络问题","url":"/posts/2021/31B2ZF5.html","content":"有人反馈电脑无法上网，检查后发现以下情况：\r\n\r\n电脑的网络图标不断显示正在获取网络和获取失败\r\n把电脑连接其它正常的网线，依旧无法连接网络\r\n用其它电脑连接当前网线，能正常上网\r\n该电脑在家可以上网\r\n\r\n\r\n基于以上情况，说明网卡硬件正常，问题集中在操作系统的软件层面。\r\n鉴于电脑网络的复杂性，直接通过 cmd\r\n运行Netsh Winsock reset 解决了问题。\r\n什么是Netsh Winsock reset？\r\nNetsh winsock reset是一个命令提示程序，用于将 winsock\r\n目录重置为默认设置或清除状态。\r\n如有时候上不了网或者网络出现问题经常用到它，简单地理解就是：重置程序通过操作系统链接网络的入口点。虽然使用此命令可以恢复网络连接，也应谨慎使用，因为可能需要重新安装LSPLSP:\r\nlayered service privider 分层服务提供商。LSP是TCP/IP等协议的接口。\r\nNetsh Winsock解决了哪些问题？\r\n\r\n解决删除广告软件，间谍软件，病毒，蠕虫，木马等后产生的网络问题。\r\n安装广告软件，间谍软件，VPN或防火墙后无法联网。\r\n无法访问任何网页或只能访问某些网页。\r\n出现与网络相关问题的弹出错误窗口。\r\n由于注册表错误，没有网络连接。\r\n发生DNS查找问题。\r\n无法续订网络适配器的IP地址或其他一些DHCP错误。\r\n没有连接消息的网络连接问题。\r\n\r\n如何在Windows 10中执行 winsock reset？\r\n\r\nwindows键+R或者windows键+x选择（管理员）命令提示符\r\n输入 cmd\r\n在命令提示框中键入\r\nnetsh winsock reset，然后回车\r\n完成重置后，您将收到消息“Winsock重置成功完成”。重新启动电脑完成Windows\r\n10 中的重置 winsock\r\n\r\n同样，要重置TCP / IP，请在 cmd 中使用命令\r\nnetsh int tcp reset。\r\n\r\n若是 win11，可以直接在【网络和\r\nInternet/高级网络设置/网络重置】中进行重置\r\n\r\n","categories":["System","Windows"],"tags":["网络"]},{"title":"win10无法连接其它电脑共享的打印机","url":"/posts/2021/2H6XD5B.html","content":"今天（2021-10-18）有些同事更新了windows，然后发现由其它电脑共享的打印机无法使用了。\r\n\r\n其间，采用了下列方式，都不成功：\r\n\r\n重启 Print Spooler\r\n修改注册表权限\r\n\r\n最后猜想是更新的问题，于是在windows更新中将 KB5006670\r\n更新给卸载后，就恢复正常了。\r\n卸载更新可以输入下列命令行卸载：\r\nwusa /uninstall /kb:5006670\r\n参考\r\nhttps://www.youtube.com/watch?v=bIdlB1iPYQQ\r\n","categories":["System","Windows"],"tags":["windows经验"]},{"title":"2022-01-04-通过公钥 ssh 远程连接 Windows Server","url":"/posts/2022/7EE4JK.html","content":"通过用户名和密码，利用 SSH\r\n登陆远程服务器进行服务器管理时，有如下缺点：\r\n\r\n每次输入密码，很麻烦，也不极客\r\n服务器开放账号密码登陆，容易补暴力破解\r\n\r\n我们可以通过配置公钥登陆来解决上述问题。\r\n\r\nSSH 中各个模块作用\r\nOpenSSH\r\n包含一系列组件和工具，用于提供一种安全且简单的远程系统管理方法，其中包括：\r\n\r\nsshd.exe，它是远程所管理的系统上必须运行的 SSH 服务器组件\r\nssh.exe，它是在用户的本地系统上运行的 SSH 客户端组件\r\nssh-keygen.exe，为 SSH 生成、管理和转换身份验证密钥\r\nssh-agent.exe，存储用于公钥身份验证的私钥\r\nssh-add.exe，将私钥添加到服务器允许的列表中，即添加到 ssh-agent\r\n中\r\nssh-keyscan.exe，帮助从许多主机收集公用 SSH 主机密钥\r\nsftp.exe，这是提供安全文件传输协议的服务，通过 SSH 运行\r\nscp.exe 是在 SSH 上运行的文件复制实用工具\r\n\r\nssh 登陆流程\r\n\r\n\r\nssh-login\r\n\r\n安装OpenSSH\r\n如果系统中没有 openssh，需要手动安装。现在 windows10 及以上都已经自带\r\nssh 了。\r\n如果需要，可以通过 Scoop 来安装 OpenSSH：\r\nscoop install openssh\r\n开放 22/tcp 端口\r\nnetsh advfirewall firewall add rule name=&quot;ssh&quot; dir=in action=allow protocol=TCP localport=21\r\n\r\n在使用 scoop 安装时，会自动打开，此步骤可以省略\r\n\r\n启动服务\r\nnet start ssh-agent &amp;&amp; net start sshd\r\n客户端生成公钥/私钥对\r\n在客户端打开 powershell 终端进行操作：\r\n# 生成公/私钥对ssh-keygen\r\n一直 enter 即可。\r\n\r\n生成的公私钥对保存在 c:%username%.ssh 中\r\n\r\n配置公钥/私钥对\r\n方法一\r\n在客户端配置文件：\r\n\r\nWindows 上是 ~/.ssh/config\r\nLinux 上是 /etc/ssh/ssh_config\r\n\r\n\r\n若没有，新建一个 config 文件，没有后缀\r\n\r\n# 别名（Host）：Host 和 HostName 的值可以相同# 如 ssh aliyun，在这里等于 ssh -i C:\\Users\\Think\\.ssh\\id_rsa_aliyun root@144.90.100.144# 用别名登录会使用别名下的配置，不用别名登录（如IP）不会使用别名下的配置Host aliyun    User root    HostName 144.90.100.144    # 私钥文件位置    IdentityFile &quot;~/.ssh/id_rsa_aliyun&quot;Host tencent    User root    HostName 100.28.144.47    IdentityFile &quot;~/.ssh/id_rsa_tencent&quot;\r\n将公钥文件 id_rsa.pub 的内容追加到服务器的\r\n~/.ssh/authorized_keys 文件末尾\r\n可以使用 # 号为每个公钥添加注释，方便管理。\r\n\r\nauthorized_keys：该文件为 ssh 普通用户公钥\r\nadministrators_authorized_keys：该文件为 ssh 管理员公钥\r\n\r\n使用方式：\r\nssh aliyun -v # 使用别名进行登陆\r\n方法二\r\n\r\n将私钥添加到 ssh-agent\r\nWindows SSH 以服务的形式管理，所以 ssh-agent\r\n是全局的，不需要每次设置。\r\n以下命令需要用管理员身份运行终端。\r\n# 查看 ssh-agent 服务状态，这里输出：StoppedGet-Service ssh-agent# 查看 ssh-agent 服务的启动类型，这里输出：DisabledGet-Service ssh-agent | Select StartType# 将 ssh-agent 服务的启动类型修改为 Manual（手动启动）。Get-Service -Name ssh-agent | Set-Service -StartupType Manual# 手动启动 ssh-agent 服务Start-Service ssh-agent# 将私钥加载进 ssh-agentssh-add C:\\Users\\Think\\.ssh\\id_rsa# 显示 ssh-agent 中的公钥，验证私钥是否添加成功ssh-add -L# 服务重启后，添加的密钥仍在 agent 中\r\n将公钥添加到服务器\r\n服务器中的公钥是储存在 ~/.ssh/authorized_keys\r\n文件里面，如果该文件不存在，手动创建一个文本文件即可，然后将公钥追加到该文件末尾。\r\n普通用户\r\n# Make sure that the .ssh directory exists in your server&#x27;s user account home folderssh username@domain1@contoso.com mkdir C:\\Users\\username\\.ssh\\ # Use scp to copy the public key file generated previously on your client to the authorized_keys file on your serverscp C:\\Users\\username\\.ssh\\id_ed25519.pub user1@domain1@contoso.com:C:\\Users\\username\\.ssh\\authorized_keys\r\n管理用户\r\n公钥的内容需要放在服务器上的一个名为\r\nadministrators_authorized_keys 的文本文件中，放在\r\nC: ProgramData\\ssh\\\r\n中。OpenSSH客户端包括scp，这是一个安全的文件传输工具，可以帮助解决这个问题。\r\n# Make sure that the .ssh directory exists in your server&#x27;s user account home folderssh user1@domain1@contoso.com mkdir C:\\ProgramData\\ssh\\ # Use scp to copy the public key file generated previously on your client to the authorized_keys file on your serverscp C:\\Users\\username\\.ssh\\id_ed25519.pub user1@domain1@contoso.com:C:\\ProgramData\\ssh\\administrators_authorized_keys\r\n\r\nwindows\r\n服务器取消管理员公钥文件重定向\r\n编辑C:\\ProgramData\\ssh\\sshd_config文件，删除或注释（使用\r\n#）底部的如下配置：\r\nMatch Group administrators       AuthorizedKeysFile __PROGRAMDATA__/ssh/administrators_authorized_keys\r\n重启windows的ssh服务\r\nRestart-Service sshd\r\n关闭密码登陆\r\n上述配置完成后，进行 ssh 测试连接，如果成功，则将密码登陆关闭。\r\n找到位于C:\\ProgramData\\ssh\\ssh_config 文件，将\r\nPasswordAuthentication 设置成 no\r\n# To disable tunneled clear text passwords, change to no here!PasswordAuthentication no#PermitEmptyPasswords no\r\n重启 sshd 服务\r\nRestart-Service sshd\r\n通过上面的操作，ssh\r\n公钥登陆配置就完成了，同时还提高了系统的安全性。\r\n致谢\r\n本文参考以下文件，对此表示诚挚感谢！\r\n\r\nWindows SSH\r\n免密登录详解\r\nWindows\r\n中的 OpenSSH\r\nOpenSSH\r\nkey management\r\nSSH免密登录（公钥登录）到win10（解决authorized_keys无效的问题）\r\n- KyleBlog.cn\r\n\r\n","categories":["System","Windows"],"tags":["ssh"]},{"title":"windows 8.1/10/11 系统激活","url":"/posts/2022/2ZJ91KM.html","content":"本文记录了 windows 和 office 的激活方法。\r\n\r\nwindows 激活\r\n一键激活\r\n用管理员身份打开 PowerShell，执行\r\nirm https://get.activated.win | iex，然后输入\r\n1 开始激活\r\n\r\n推荐使用\r\n\r\n手动激活\r\n下载激活脚本工具按提示激活\r\n脚本链接：https://cloud.uzoncloud.com:2234/#s/7ukOXakg\r\nOffice 激活\r\nOffice Tool Plus 激活\r\n详细参考 使用 OfficeToolPlus\r\n安装和激活 Office | 星辰大海\r\n\r\n推荐使用\r\n\r\n脚本激活\r\n脚本链接：https://cloud.uzoncloud.com:2234/#s/7ukOXakg\r\noffice激活也是采用上面的工具，如果激活失败，可以使用上述链接中的\r\noffice 脚本转换 office 的版本。\r\n致谢\r\n本文参考：\r\n\r\nhttps://v0v.bid/kms.html\r\nhttps://github.com/massgravel/Microsoft-Activation-Scripts\r\n\r\n在此致以诚挚谢意！\r\n","categories":["System","Windows"],"tags":["windows","星辰大海"]},{"title":"取消当你连接时将向你询问凭据","url":"/posts/2022/1S9QPH9.html","content":"在 windows 中远程其它电脑时，有时候会出现\r\n当你连接时向你询问凭据 这个提示，如下图：\r\n\r\n\r\nimage-20220923164736037\r\n\r\n这种情况会导致点击 连接(N)\r\n后需要输入输入用户名密码，在使用命令行连接的时候，影响使用体验。\r\n\r\n\r\n展开 显示选项(O)\r\n\r\n\r\nimage-20230208213715770\r\n\r\n勾选 允许我保存凭据(R)\r\n单击 连接(N) 后，就会出现输入密码框\r\n\r\n\r\nimage-20230208213850412\r\n\r\n输入密码后，下次再登陆就不会再要求输入用户密码了。\r\n\r\n至此，每次连接时要输入用户名密码的问题就解决了，可以使用命令行愉快地登陆了。\r\n命令行远程连接方式：\r\n# 192.168.1.1 换成自己需要远程的 IP 地址即可mstsc /v:192.168.1.1\r\n","categories":["System","Windows"],"tags":["Windows"]},{"title":"重装系统后快速恢复生产力","url":"/posts/2022/SWJS0K.html","content":"本文主要介绍在重装电脑后，如何激活系统及快速安装常用软件。\r\n\r\nwindows 激活\r\n在命令行中执行\r\nirm https://massgrave.dev/get | iex，然后选择相应选项进行激活。\r\n参考：\r\nhttps://github.com/massgravel/Microsoft-Activation-Scripts\r\nscoop 安装\r\n通过 scoop 安装软件时，需要魔法才好用，安装方法见 (scoop\r\n安装与重置)[https://hi.uzoncloud.com:2234/posts/2020/WCF13S.html]\r\ngit 安装\r\nscoop install git\r\nscoop 后期所有的软件安装都要基于 git 环境\r\nscoop 添加常用仓库\r\n添加 extras 软件仓库\r\nscoop bucket add extras\r\n添加自用仓库\r\nscoop bucket add uamzing https://gitee.com/galensgan/galens-bucket.git\r\n安装 aria2 加速下载\r\nscoop install aira2\r\naria2 安装后，默认是不走代理的，通过以下设置使其通过代理下载。\r\n打开 C:\\Users\\%username%\\.config\\scoop\\config.json\r\n文件，在里面添加：\r\n&#123;    // aria2 配置    &quot;aria2-options&quot;: [        &quot;--check-certificate false&quot;,        &quot;--https-proxy=http://192.168.3.14:7890&quot;, // https 代理的地址        &quot;--http-proxy=http://192.168.3.14.7890&quot; // http 代理地址  \t],&#125;\r\n安装 flow-launcher\r\n通过 scoop install flow-launcher everything\r\n安装快速搜索工具\r\n安装 typora\r\nscoop install uamazing/typora\r\noffice 安装与激活\r\noffice 使用 officeToolPlus\r\n进行安装与激活。\r\n安装时，选择批量授权版本，方便后面进行激活。\r\nofficeToolPlus 可以通过 scoop 进行安装\r\ngit 设置别名\r\n自己常用\r\nGit 别名\r\n安装 powershell7\r\nscoop install uamazing/powershell7\r\npowershell 7 显示历史记录\r\n# 安装 PSReadLineInstall-Module -Name PSReadLine# 打开配置文件notepad $profile# 向里面添加如下内容$PSOption = @&#123;    PredictionSource = &#x27;History&#x27;    # 使用 vim 的模式，可以按 esc 后，执行 vim 快捷键    EditMode = &#x27;Vi&#x27;    PredictionViewStyle = &#x27;ListView&#x27;    ShowToolTips = $false# ...&#125;Set-PSReadLineOption @PSOption\r\n更多请参考 powershell 详细配置\r\npowershell 添加 oh-my-posh\r\n插件\r\n参考：Windows | Oh My\r\nPosh\r\npowershell 添加 z.lua\r\n实现快速跳转\r\n参考： z.lua\r\n中文文档\r\n安装完成后，需要添加环境变量\r\n_ZL_HYPHEN=1，使其支持包含 - 号的目录。\r\n快捷命令：\r\n[environment]::setEnvironmentVariable(&#x27;_ZL_HYPHEN&#x27;,&#x27;1&#x27;,&#x27;User&#x27;)\r\n安装 Adguard\r\nAdguard\r\n可以帮助屏蔽广告。\r\n","categories":["System","Windows"],"tags":["Windows"]},{"title":"windows10 更新升级","url":"/posts/2023/1D7C89K.html","content":"当需要更新 win10 或者将 win7 更新到 win10 时，可以使用 microsoft\r\n提供的升级更新工具来进行操作。\r\n地址：下载\r\nWindows 10 (microsoft.com)\r\n\r\nwin7 升级可能遇到下列错误：\r\nThere was a problem running this toolWe&#x27;re not sure what happened, but we&#x27;re unable to run this tool on your PC. If you continue experiencing problems, reference the error code when contacting customer support. Error code: 0x80072F8F - 0x20000\r\n这是因为 MediaCreationTool 使用 TLS 1.2 协议, 但是在 Windows 7 and\r\nWindows 8 中这个协议默认关闭的。\r\n可以按以下步骤进行处理：\r\nMedia\r\nCreation Tool Error 0x80072F8F - 0x20000 in Windows 7/8 »\r\nWinhelponline\r\n","categories":["System","Windows"],"tags":["Windows"]},{"title":"windows11 任务栏一直转圈的解决办法","url":"/posts/2023/2STY3BG.html","content":"一些朋友的 win10、win11\r\n系统，开机进入系统后，鼠标悬停到任务栏时一直转圈，在其它位置正常，但是无法打开其它任何界面。\r\n\r\n排查解决\r\n通过排查，导致该问题可能有多个原因。\r\nCAD2010 问题\r\n原因：\r\nWin11 部分版本与 CAD2010 不兼容导致的，具体原因不详，最后卸载掉\r\nCAD2010 即可恢复正常。\r\n解决方法：\r\n由于 CAD\r\n冲突，导致资源管理器无响应，无法打开任何界面，唯一能打开的界面就是任务管理器，现在以任务管理器为媒介来卸载\r\nCAD2010。\r\n\r\nCtrl+Alt+Delete 打开任务管理器\r\n进程右上角，点击 \"运行新任务\"\r\n弹出框中输入 appwiz.cpl 来打开程序卸载界面\r\n\r\n输入后，可能会无法弹出界面，此时需要在任务栏上多次单击左键，使资源管理器重启，这样卸载界面就会显示出来了。\r\n\r\n卸载 CAD2010\r\n\r\n资讯与兴趣问题\r\n原因：\r\n【资讯和兴趣】组件的服务器在国外，国内无法正常访问。导致任务栏卡死\r\n解决方法：\r\n参考\r\n","categories":["System","Windows"],"tags":["Win11"]},{"title":"重装 windows 系统","url":"/posts/2023/2CR6PKS.html","content":"本文介绍如何彻底重装 windows\r\n系统，按照本教程一步一步进行安装，重装系统非常简单。\r\n\r\n重装相对于重置可以让系统更纯净。有时候电脑被病毒感染后，重置往往不能解决问题，此时就需要进行重装。\r\n若只需要重置电脑，win10\r\n及以上的版本在设置有重置功能，可以就此跳过本文。\r\n\r\n\r\n简介\r\n通过本文的方法安装 windows 有以下几个优势：\r\n\r\n安装方式简单，不影响 U 盘的正常使用\r\n安装的系统为官方iso，无任何其它捆绑软件\r\n激活后为正版系统，支持升级，放心使用\r\n\r\n安装盘制作\r\n从 Download .\r\nVentoy 处下载 ventoy-1.0.94-windows.zip，然后根据\r\nGet start .\r\nVentoy 教程制作启动盘。\r\n简要步骤如下：\r\n\r\n插入 U 盘\r\n解压 ventoy 安装包后，执行文件\r\nVentoy2Disk_X64.exe\r\n选择目标 U 盘，然后单击【安装】，便完成启动盘的制作了\r\n\r\n\r\nimage-20230807111055919\r\n\r\n当出现如下提示时，表示安装成功了：\r\n\r\n\r\nimage-20230807111540544\r\n\r\n\r\nwindows 系统 iso 下载\r\n使用 microsoft 提供的工具 下载\r\nWindows 10 (microsoft.com) 下载安装镜像(.iso)文件。\r\n\r\n更详细的教程可以在网络上找一下，应该不难\r\n\r\n下载完成后，将下载的 .iso 文件复制到刚刚制作的 U 盘中即可。\r\n简要步骤如下：\r\n\r\n下载 microsoft 提供的下载工具\r\n\r\n\r\nimage-20230807122815793\r\n\r\n打开下载好的 MediaCreationTool22H2.exe\r\n\r\n\r\n\r\n点击【下一步】，然后选择保存 iso 文件的位置即可。\r\n\r\n开始安装 Windows\r\n备份 C 盘内容\r\n先备份目标机器上 C\r\n盘中的文件，包括桌面上的内容。在系统重装时，会清理原 C\r\n盘的内容，有时候需要格式化 C 盘，因此需要提前备份，避免数据丢失。\r\n进入 BIOS 设置 U 盘启动\r\n通过 BIOS 快捷键，进入 BIOS 中，设置\r\n最常见的是ESC键、Delete键、F12键，若不行可以尝试以下对应的BIOS快捷键或快捷启动按键。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n组装机主板\r\n快捷键\r\n品牌笔记本\r\n快捷键\r\n品牌台式机\r\n快捷键\r\n\r\n\r\n\r\n\r\n华硕主板\r\nF8\r\n联想笔记本\r\nF12\r\n联想台式机\r\nF12\r\n\r\n\r\n技嘉主板\r\nF12\r\n宏基笔记本\r\nF12\r\n惠普台式机\r\nF12\r\n\r\n\r\n微星主板\r\nF11\r\n华硕笔记本\r\nESC\r\n宏基台式机\r\nF12\r\n\r\n\r\n映泰主板\r\nF9\r\n惠普笔记本\r\nF9\r\n戴尔台式机\r\nESC\r\n\r\n\r\n梅捷主板\r\nESC/F12\r\n联想ThinkPad\r\nF12\r\n神舟台式机\r\nF12\r\n\r\n\r\n七彩虹主板\r\nESC/F11\r\n戴尔笔记本\r\nF12\r\n华硕台式机\r\nF8\r\n\r\n\r\n华擎主板\r\nF11\r\nalienware笔记本\r\nF2/F12\r\n方正台式机\r\nF12\r\n\r\n\r\n昂达主板\r\nF11\r\n神舟笔记本\r\nF12\r\n清华同方台式机\r\nF12\r\n\r\n\r\n双敏主板\r\nESC\r\n东芝笔记本\r\nF12\r\n海尔台式机\r\nF12\r\n\r\n\r\n翔升主板\r\nF10\r\n三星笔记本\r\nF12\r\n明基台式机\r\nF8\r\n\r\n\r\n精英主板\r\nESC/F11\r\nIBM笔记本\r\nF12\r\n\r\n\r\n\r\n\r\n冠盟主板\r\nF11/F12\r\n富士通笔记本\r\nF12\r\n\r\n\r\n\r\n\r\n富士康主板\r\nESC/F12\r\n海尔笔记本\r\nF12\r\n\r\n\r\n\r\n\r\n顶星主板\r\nF11/F12\r\n方正笔记本\r\nF12\r\n\r\n\r\n\r\n\r\n铭瑄主板\r\nESC\r\n清华同方笔记本\r\nF12\r\n\r\n\r\n\r\n\r\n盈通主板\r\nF8\r\n微星笔记本\r\nF11\r\n\r\n\r\n\r\n\r\n捷波主板\r\nESC\r\n明基笔记本\r\nF9\r\n\r\n\r\n\r\n\r\nIntel主板\r\nF12\r\n技嘉笔记本\r\nF12\r\n\r\n\r\n\r\n\r\n杰微主板\r\nESC/F8\r\nGateWay笔记本\r\nF12\r\n\r\n\r\n\r\n\r\n致铭主板\r\nF12\r\neMachines笔记本\r\nF12\r\n\r\n\r\n\r\n\r\n磐英主板\r\nESC\r\n索尼笔记本\r\nESC\r\n\r\n\r\n\r\n\r\n磐正主板\r\nESC\r\n小米笔记本\r\nF12\r\n\r\n\r\n\r\n\r\n冠名主板\r\nF9\r\n\r\n\r\n\r\n\r\n\r\n\r\n斯巴达卡主板\r\nESC\r\n\r\n\r\n\r\n\r\n\r\n\r\n华南主板\r\nDEL/F11\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n由于硬盘大多数采用的是 MBR 分区，因此在设置启动项时，要以 lagacy\r\n模式启动。\r\n可以参考这篇文章：ventoy\r\n安装系统时无法选择 MBR 分区的盘\r\n\r\n安装系统\r\n当启动 U 盘后，会进入 ventoy\r\n的系统安装界面，按以下步骤逐步操作即可：\r\n\r\n选择需要安装的 windows 版本\r\n\r\n选择 Boot in normal mode\r\n\r\n\r\nimage-20230807134159730\r\n\r\n安装界面启动后，一直点下一步\r\n当到选择操作系统时，选择【专业版】\r\n\r\n一键激活系统\r\n当系统安装完成，下载激活脚本MAS_AIO，双击打开即可激活。\r\n或者按该教程激活 windows: windows\r\n8.1/10/11 系统激活\r\n参考\r\n本文参考以下文章，在此报以诚挚谢意！\r\n\r\nGet start .\r\nVentoy\r\n\r\n","categories":["System","Windows"],"tags":["Windows"]},{"title":"ventoy安装系统时无法选择MBR分区的盘","url":"/posts/2022/X71YPD.html","content":"ventoy 是一款超级方便的系统安装软件。在利用 ventoy\r\n给一些老电脑安装系统时，发现无法选择安装盘符，提示无法安装在 MBR\r\n分区上。\r\n\r\n分区格式区别\r\nMBR分区表\r\nMaster Boot Record，即硬盘主引导记录分区表，只支持容量在 2.1TB\r\n以下的硬盘，超过2.1TB的硬盘只能管理2.1TB，最多只支持4个主分区或三个主分区和一个扩展分区，扩展分区下可以有多个逻辑分区。\r\nGPT分区表\r\nGPT，全局唯一标识分区表(GUID Partition\r\nTable)，与MBR最大4个分区表项的限制相比，GPT对分区数量没有限制，但Windows最大仅支持128个GPT分区，GPT可管理硬盘大小达到了18EB。只有基于UEFI平台的主板才支持GPT分区引导启动。\r\n故障原因\r\n硬盘分区格式为MBR格式时，启动模式应该为Legacy。\r\n硬盘分区格式为GUID（GPT）格式时，启动模式应该为UEFI。\r\n所以，出现无法安装的原因就是在启动的时候，选择了 UEFI\r\n启动。为了解决这个问题，可以修改 Bios 中的启动设置。\r\nlegacy启动设置常见的选项\r\n\r\n如果有以下选项，就需要修改，没有就略过\r\n\r\n\r\nSecure Boot 改成\r\nDisabled，禁用安全启动，部分机型需先设置 BIOS\r\n密码才有权限修改 Secure Boot，通常是找到\r\nSet Supervisor Password 设置密码\r\nCSM 改成 Enable 或 Yes 或\r\nALWAYS，表示兼容模式\r\nOS Mode Selection 设置为\r\nCSM OS，表示兼容模式\r\nBoot mode 或 UEFI mode 或\r\nBoot List Option 改成\r\nLegacy，表示传统启动方式\r\nOS Optimized Defaults 改成 Disabled 或\r\nOther OS，禁用默认系统优先设置\r\nAdvanced 选项下 Fast BIOS Mode 设置为\r\nDisabled，关闭快速启动，有些电脑需要关闭快速启动才能识别U盘，比如三星\r\n\r\n","categories":["System","Windows"],"tags":["windows","ventoy"]},{"title":"Windows 中配置无线网络唤醒(wowlan)","url":"/posts/2024/3QV9Z7H.html","content":"本文仅对无线网络唤醒(简称wowlan)做一个配置记录，具体的教程见本文的参考文章。\r\n网络上关于无线网唤醒的文章，99%\r\n的都是关于有线的，无线的至今还没发现成功过。\r\n作者以实践证明，无线网络唤醒是可以的！\r\n\r\n前言\r\n首先，为什么要使用无线网络唤醒呢？其实本人就一条原因：\r\n不想电脑上多插一根网线\r\n配置\r\n配置 wowlan 主要有 3 个地方需要配置\r\n\r\nBIOS 中打开 PCIE 唤醒\r\n设备管理中设置唤醒\r\n\r\n【高级/唤醒幻数据包】 Enable\r\n【高级/唤醒模式匹配】 Enable\r\n【电源管理/*】所有设置都打上勾\r\n\r\n路由器绑定静态 IP\r\n\r\n在路由器上将需要 wowlan 的电脑绑定一个固定 IP\r\n更改电脑的 IP 分配方式为手动，然后输入路由器给定的静态 IP\r\n\r\n\r\n网络结构\r\n折腾记录\r\n2024-10-22\r\n升级 win11 24h2 导致 wowlan 失败\r\n作者的电脑以前一直使用 wowlan，某天将其从 win11 23h2 升级到 win11\r\n24h2 后，发现 wowlan 失效了。\r\n期间使用了以下方式排查问题：\r\n\r\n重置 BIOS 设置\r\n重置路由器\r\n升级网卡驱动\r\n重置网络\r\n\r\n最后，使用【网络和 Internet/高级网络设置/网络重置】解决了问题。\r\n2024-12-10\r\n路由器修改了 DNS 服务导致 wowlan 失败\r\n路由器莫名其妙地将 baidu.com 解析成 127.0.0.1 了，于是修改了下 DNS\r\n解析服务，发现 wowlan 又失效了。\r\n使用【网络和 Internet/高级网络设置/网络重置】也恢复不了。\r\n经过测试，有以下现象：\r\n\r\n路由器上显示该电脑在线\r\n使用有线可以唤醒\r\n才睡眠的几秒内，可以唤醒\r\n\r\n猜测是无线网卡有问题，可能是进入了节能模式。但不知道如何解决，可能要放弃无线唤醒方案了。\r\n2024-12-13\r\n为了折腾无线网络唤醒，这几天每天 6\r\n点早早起来测试，最终，今天有重大突破，事情有了转机。\r\n今天发现通过向局域网内广播幻数据包可以唤醒：\r\n\r\n\r\nimage-20241213080139079\r\n\r\n然后再总结一下现象及一些测试结果：\r\n\r\n睡眠约 10s 内可以通过无线网卡远程唤醒，睡眠太久就无法被唤醒了\r\n局域网内广播幻数据包，任何时候都可以唤醒\r\n局域网内单点广播幻数据包，仅睡眠 10s 内可以唤醒\r\n使用有线网卡，任何时候都可以唤醒\r\n以前可能通过单点广播唤醒，但是修改了路由器的 DHCP 后，就失效了\r\n去掉路由器的静态绑定后，依然是约 10 秒内可以通过无线远程唤醒\r\n\r\n所以，我猜测可能的原因是：\r\n\r\n路由器配置修改后，导致 ARP 缓存失效了，只要电脑一睡眠，ARP\r\n就被清除了。\r\n电脑有什么配置被修改了，导致网卡深度睡眼后，不接受单点广播，只接受广播唤醒。\r\n\r\n把可能的配置都修改了一遍，还是没有效果，看来只能放弃了。\r\n2024-12-16\r\n又开始折腾了，我严重怀疑就是这个路由器有问题，于是将路由器彻底重置了一下，网段改成\r\nA 类局域网。\r\n然后重新配置了远程唤醒，终于成功了！\r\n2025-03-15\r\n今天发现无线远程唤醒又失效了，最近对路由器的唯一操作就是添加了一个端口映射。\r\n根据以往的经验，应该是路由器的 ARP 丢失了。先重置一下路由器试试。\r\n参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\n无线网络唤醒，从入门到放弃\r\n- elmagnifico's blog\r\n","categories":["System","Windows"],"tags":["Windows","wowlan"]},{"title":"新版 Edge 取消圆角样式","url":"/posts/2023/77AD03.html","content":"新版 Edge 浏览器引入了圆角的样式，可以通过以下方式进行关闭：\r\n\r\n在地址栏中输入：edge://flags\r\n搜索 Microsoft Edge rounded corners，将其修改成\r\nDisabled 即可。\r\n\r\n","categories":["Software","Edge"],"tags":["Edge","software"]},{"title":"VSCode 中 Copilot 响应慢的解决办法","url":"/posts/2023/13DV6YK.html","content":"当在 Visual Studio Code 中安装 Copilot\r\n插件后，发现其提示很慢，可能通过以下设置来减少响应延迟。\r\n\r\n\r\n关闭\r\nEditor › Suggest: Snippets Prevent Quick Suggestions\r\n减少 Editor: Quick Suggestions Delay 值\r\n\r\n","categories":["Software","Copilot"],"tags":["VSCode","Copilot"]},{"title":"Github Copilot 的免费替代软件","url":"/posts/2023/1T84381.html","content":"\r\n\r\nimg\r\n\r\nCopilot\r\n对于提升开发效率有很大的帮助，可以大大减少开发中的复制粘贴、重复写低逻辑代码的时间，同时还可以在没有思路时，提供一个参考方向。就像一个不那么资深的助手，在辅助你编程。\r\n截止目前为止，Github Copilot 已经开始收费，每月 10 美元，包年 100\r\n美元。因此本文收录一些免费的平替软件，以备不时之需，有时间再来做一个详细的测试。\r\n\r\n软件列表\r\n\r\nCodeGeeX\r\nCodeium\r\nTabnine\r\n\r\n参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\n\r\n三款Github\r\nCopilot的免费替代 - 费弗里 - 博客园 (cnblogs.com)\r\n10 大\r\nGitHub Copilot 替代品（2023 年）-HashDork\r\nhttps://www.v2ex.com/t/891044\r\nFauxpilot: Github\r\ncopilot 的开源替代品，目前已收获8k+ star - 智源社区\r\n(baai.ac.cn)\r\nCodeGeeX\r\nvs. Codeium vs. Tabnine Comparison (sourceforge.net)\r\n\r\n","categories":["Software","Copilot"],"tags":["Software","Copilot"]},{"title":"ElasticSearch Docker 部署","url":"/posts/2024/2087YCV.html","content":"本文简要记录如何使用 Docker 部署 ElasticSearch，并安装 hanlp\r\n分词器提高中文分词效果。\r\n\r\n什么是 ElasticSearch\r\n以下是官方原文：\r\nElasticsearch 是一个开源的分布式 RESTful\r\n搜索和分析引擎、可扩展的数据存储和向量数据库，能够解决不断涌现出的各种用例。作为\r\nElastic Stack 的核心，Elasticsearch\r\n会集中存储您的数据，让您飞快完成搜索，微调相关性，进行强大的分析，并轻松缩放规模。\r\nDocker 部署\r\n以下为完整的 docker compose 文件，包括：\r\n\r\nElasticSearch\r\nKibana\r\n\r\ndocker compose 文件如下：\r\nservices:  elastic-search:    image: docker.elastic.co/elasticsearch/elasticsearch:8.12.0    container_name: elastic-search    restart: always    ports:      - 9200:9200      - 9300:9300    volumes:      # - ./data/config:/usr/share/elasticsearch/config      - ./data/data:/usr/share/elasticsearch/data # 数据文件      - ./data/plugins:/usr/share/elasticsearch/plugins # 插件文件    environment:      - &quot;cluster.name=elasticsearch&quot; #设置集群名称为elasticsearch      - &quot;ES_JAVA_OPTS=-Xms1G -Xmx1G&quot; #设置使用jvm内存大小，设置ES的初始内存和最大内存，否则导致过大启动不了ES      - &quot;discovery.type=single-node&quot; # 单节点    user: &quot;1000:0&quot;  kibana:    image: kibana:8.12.0 # 与 elastic-search 版本保持一致    container_name: kibana    restart: always    depends_on:      - elastic-search    ports:      - 9301:5601\r\n创建默认配置文件\r\n./data/config/elasticsearch.yml，内容如下：\r\ncluster.name: &quot;docker-cluster&quot;network.host: 0.0.0.0\r\n安装步骤\r\n启动 docker 容器\r\n# 为挂载容器设置权限，这一步非常重要，否则 es 会启动失败# 这里的 1000:1000 是 Elasticsearch 容器中 elasticsearch 用户的 UID 和 GIDmkdir -p data/&#123;data,config,plugin&#125;sudo chown -R 1000:0 ./datasudo chmod -R 777 ./data# 启动docker compose up -d# 放行端口sudo ufw allow 9200,9300,9301/tcp# 复制容器内容的需要挂载的配置文件docker cp -a elastic-search:/usr/share/elasticsearch/config data# 打开 config 的目录挂载，然后重新启动# 这是为了方便挂载 config 目录，若直接挂载，es 初始化会有问题docker compose up -d\r\n设置用户名和密码\r\n按如下步骤设置用户名和密码：\r\n# 这个命令会依次为 elastic, kibana, logstash_system,beats_system 四个用户设置密码docker exec -it elastic-search bin/elasticsearch-setup-passwords interactive\r\n还有一个更简单的方式，直接重置 elastic 用户的密码：\r\ndocker exec -it elastic-search bin/elasticsearch-reset-password -u elastic -s\r\n\r\n\r\nimage-20241209164442267\r\n\r\n此处密码一定要保存好。\r\n若要重置为指定密码，可以使用：\r\ndocker exec -it elastic-search bin/elasticsearch-reset-password -u elastic -i\r\n完整命令帮助如下：\r\n\r\n\r\nimage-20241209164847822\r\n\r\n配置 kibana\r\n打开 kibana\r\n使用浏览器打开 kibana\r\n地址为：http://docker-host-ip:9301\r\n\r\n\r\nimage-20241209105942826\r\n\r\n\r\n右下角提示，需要配置 publicBaseUrl，由于是内网使用，可以不用管它\r\n\r\n生成 enrollment token\r\n远程到 docker 宿主机，执行以下命令获取：\r\ndocker exec -it elastic-search bin/elasticsearch-create-enrollment-token --scope kibana\r\n结果如图所示：\r\n\r\n\r\nimage-20241209163029414\r\n\r\n将 token 复制到输入框后，点确认。\r\n获取验证码\r\n上一步之后，会弹出验证码弹窗：\r\n\r\n\r\nimage-20241209163236791\r\n\r\n使用如下命令获取验证码：\r\ndocker exec -it kibana bin/kibana-verification-code\r\n\r\n\r\nimage-20241209163443586\r\n\r\n输入之后，等待配置完成。\r\n配置分词插件\r\n中文分词器对比\r\nElasticsearch\r\n常见分词器对比区别\r\n最终选择 hankcs/HanLP:\r\n中文分词 作为分词器。\r\nHanLP 插件安装\r\n本节主要参考：p3psi-boo/elasticsearch-analysis-hanlp-8.x\r\n配置与测试可以在 /app/dev_tools#/console\r\n开发者工具中进行\r\n下载分词器\r\n# 进入到插件目录cd data/plugins# 下载分词器插件# 可以使用 export https_proxy=http://127.0.0.1:8087 为 wget 配置代理wget https://github.com/p3psi-boo/elasticsearch-analysis-hanlp-8.x/releases/download/v1.0.0/elasticsearch-analysis-hanlp.zip -O analysis-hanlp.zip# 解压并删除unzip analysis-hanlp.zip &amp;&amp; rm analysis-hanlp.zip\r\n下载分词模型\r\nanalysis-hanlp\r\n插件下载完成后，还需要下载分词模型，接着上一步继续操作：\r\ncd analysis-hanlp# 下载模型wget https://file.hankcs.com/hanlp/data-for-1.7.5.zip# 解压到 data 目录并删除unzip data-for-1.7.5.zip &amp;&amp; rm data-for-1.7.5.zip# 重启 elastic-search 容器docker restart elastic-search\r\n修改默认分词器\r\n打开 kibana 的控制台 Console - Dev\r\nTools - Elastic，在里面输入执行命令或者直接通过 http 请求接口。\r\n本节主要参考：Specify\r\nan analyzer\r\n创建索引\r\n以下参数会创建一个 search-iepc-document 索引并设置 hanlp\r\n为默认分词器\r\n# 创建索引PUT /search-iepc-document&#123;  &quot;settings&quot;: &#123;    &quot;number_of_shards&quot;: 1,    &quot;number_of_replicas&quot;: 1,    &quot;analysis&quot;: &#123;      # 自定义token器      &quot;tokenizer&quot;: &#123;        &quot;hanlp_tokenizer&quot;: &#123;          &quot;type&quot;: &quot;hanlp&quot;,          &quot;enable_custom_config&quot;: true,          &quot;enable_custom_dictionary&quot;: true,          &quot;enable_number_quantifier_recognize&quot;: true,          &quot;enable_place_recognize&quot;: true,          &quot;enable_organization_recognize&quot;: true,          &quot;enable_stop_dictionary&quot;: true        &#125;      &#125;,      &quot;analyzer&quot;: &#123;        &quot;default&quot;:&#123;          &quot;filter&quot;: [&quot;lowercase&quot;],          &quot;tokenizer&quot;: &quot;hanlp_tokenizer&quot;        &#125;,        &quot;hanlp_analyzer&quot;: &#123;          &quot;tokenizer&quot;: &quot;hanlp_tokenizer&quot;,          &quot;filter&quot;: [&quot;lowercase&quot;]        &#125;      &#125;    &#125;  &#125;,  &quot;mappings&quot;: &#123;    # 包含两个字段    &quot;properties&quot;: &#123;      &quot;fileId&quot;: &#123;        &quot;type&quot;: &quot;text&quot;      &#125;,      &quot;content&quot;: &#123;        &quot;type&quot;: &quot;text&quot;      &#125;    &#125;  &#125;&#125;\r\n为索引创建默认分词器\r\n若要修改设置，可以先关闭索引，然后更新设置\r\n# 关闭服务POST search-iepc-document/_close# 打开服务POST search-iepc-document/_open# 设置默认分词器PUT search-iepc-document/_settings&#123;  &quot;settings&quot;: &#123;    &quot;analysis&quot;: &#123;      # 定义 tokenizer      &quot;tokenizer&quot;: &#123;        &quot;hanlp_tokenizer&quot;: &#123;          &quot;type&quot;: &quot;hanlp&quot;,          &quot;enable_custom_config&quot;: true,          &quot;enable_custom_dictionary&quot;: true,          &quot;enable_number_quantifier_recognize&quot;: true,          &quot;enable_place_recognize&quot;: true,          &quot;enable_organization_recognize&quot;: true,          &quot;enable_stop_dictionary&quot;: true        &#125;      &#125;,      # 定义 analyzer      &quot;analyzer&quot;: &#123;        &quot;default&quot;:&#123;          &quot;filter&quot;: [&quot;lowercase&quot;],          &quot;tokenizer&quot;: &quot;hanlp_tokenizer&quot;        &#125;,        &quot;hanlp_analyzer&quot;: &#123;          &quot;tokenizer&quot;: &quot;hanlp_tokenizer&quot;,          &quot;filter&quot;: [&quot;lowercase&quot;]        &#125;      &#125;    &#125;  &#125;&#125;\r\n生成 API_KEY\r\n为了能够通过 API 调用，需要生成一个 API_KEY。\r\n访问 Kibana 这个页面进行生成：http://host:9301/app/management/security/api_keys\r\n更加详细的权限控制参考：Create\r\nAPI key API\r\n在配置时，建议启用受限权限：\r\n\r\n\r\nimage-20241210103304902\r\n\r\npython 连接\r\nfrom elasticsearch import Elasticsearchclient = Elasticsearch(    &quot;https://192.168.23.30:9200&quot;,    api_key=&quot;T0xWJRucldVOHM6MwTUJVLWJfS33lJeSkZQcE1Z3xVFBDUQ==&quot;,    # verify_certs=False, # 关闭证书验证, 开发中可以启用    ca_certs=&quot;certs/elastic-search.crt&quot;, # 证书从 elastic-search 容器中的 config/certs 中复制    ssl_assert_hostname=False,  # 禁用主机名验证)\r\n常用 kibana 控制台命令\r\n以下命令可直接在 kibana 的控制台 /app/dev_tools#/console\r\n中使用\r\n\r\n\r\nimage-20241210104240909\r\n\r\n详情如下：\r\n# 查看分词效果GET _analyze&#123;  &quot;analyzer&quot;: &quot;hanlp&quot;,  &quot;text&quot;: &quot;受弯构件在进行正截面抗弯承载力计算。美国,|=阿拉斯加州发生8.0级地震&quot;&#125;# 创建索引PUT /search-iepc-document&#123;  &quot;settings&quot;: &#123;    &quot;number_of_shards&quot;: 1,    &quot;number_of_replicas&quot;: 0,    &quot;analysis&quot;: &#123;      &quot;tokenizer&quot;: &#123;        &quot;hanlp_tokenizer&quot;: &#123;          &quot;type&quot;: &quot;hanlp&quot;,          &quot;enable_custom_config&quot;: true,          &quot;enable_custom_dictionary&quot;: true,          &quot;enable_number_quantifier_recognize&quot;: true,          &quot;enable_place_recognize&quot;: true,          &quot;enable_organization_recognize&quot;: true,          &quot;enable_stop_dictionary&quot;: true        &#125;      &#125;,      &quot;analyzer&quot;: &#123;        &quot;default&quot;:&#123;          &quot;filter&quot;: [&quot;lowercase&quot;],          &quot;tokenizer&quot;: &quot;hanlp_tokenizer&quot;        &#125;,        &quot;hanlp_analyzer&quot;: &#123;          &quot;tokenizer&quot;: &quot;hanlp_tokenizer&quot;,          &quot;filter&quot;: [&quot;lowercase&quot;]        &#125;      &#125;    &#125;  &#125;,  &quot;mappings&quot;: &#123;    &quot;properties&quot;: &#123;      &quot;fileId&quot;: &#123;        &quot;type&quot;: &quot;text&quot;      &#125;,      &quot;content&quot;: &#123;        &quot;type&quot;: &quot;text&quot;      &#125;    &#125;  &#125;&#125;# 设置默认分词器PUT search-iepc-document/_settings&#123;  &quot;settings&quot;: &#123;    &quot;analysis&quot;: &#123;      &quot;tokenizer&quot;: &#123;        &quot;hanlp_tokenizer&quot;: &#123;          &quot;type&quot;: &quot;hanlp&quot;,          &quot;enable_custom_config&quot;: true,          &quot;enable_custom_dictionary&quot;: true,          &quot;enable_number_quantifier_recognize&quot;: true,          &quot;enable_place_recognize&quot;: true,          &quot;enable_organization_recognize&quot;: true,          &quot;enable_stop_dictionary&quot;: true        &#125;      &#125;,      &quot;analyzer&quot;: &#123;        &quot;default&quot;:&#123;          &quot;filter&quot;: [&quot;lowercase&quot;],          &quot;tokenizer&quot;: &quot;hanlp_tokenizer&quot;        &#125;,        &quot;hanlp_analyzer&quot;: &#123;          &quot;tokenizer&quot;: &quot;hanlp_tokenizer&quot;,          &quot;filter&quot;: [&quot;lowercase&quot;]        &#125;      &#125;    &#125;  &#125;&#125;# 测试POST search-iepc-document/_analyze&#123;  &quot;text&quot;: &quot;受弯构件在进行正截面抗弯承载力计算。美国,|=阿拉斯加州发生8.0级地震&quot;,  &quot;analyzer&quot;: &quot;hanlp_analyzer&quot;&#125;# 关闭服务POST search-iepc-document/_close# 打开服务POST search-iepc-document/_openPOST search-iepc-document/_analyze&#123;    &quot;text&quot;: &quot;HanLP是面向生产环境的自然语言处理工具包。2021年HanLPv2.1为生产环境带来次世代最先进的多语种NLP技术。HanLP只做我们认为正确、先进的事情，而不一定是流行、权威的事情。晓美焰来到北京立方庭参观自然语义科技公司。当下雨天地面积水分外严重。总统普京与特朗普通电话讨论美国太空探索技术公司。采用优等生鲜肉，欢迎新老师生前来就餐。&quot;,    &quot;analyzer&quot;: &quot;hanlp_analyzer&quot;&#125;# 按内容搜索POST search-iepc/_search&#123;  &quot;query&quot;:&#123;    &quot;match&quot;: &#123;      &quot;content&quot;: &quot;桥梁 支座 要求&quot;,    &#125;,  &#125;,  &quot;size&quot;: 3&#125;# 复杂查询# 按内容搜索POST search-iepc/_search&#123;  &quot;query&quot;: &#123;    &quot;bool&quot;: &#123;      &quot;filter&quot;: [        &#123;          &quot;term&quot;: &#123;            &quot;fileId&quot;: &quot;1713859954114&quot;          &#125;        &#125;      ],       &quot;must&quot;: [        &#123;          &quot;match&quot;: &#123;            &quot;content&quot;: &quot;混凝土压杆承载力设计值如何计算&quot;          &#125;        &#125;      ]    &#125;  &#125;,  &quot;highlight&quot;: &#123;    &quot;fields&quot;:&#123;      &quot;content&quot;:&#123;          &quot;type&quot;:&quot;plain&quot;,          &quot;order&quot;: &quot;score&quot;,          &quot;number_of_fragments&quot;: 3      &#125;    &#125;  &#125;&#125;# 一般通用查询POST search-iepc/_search&#123;  &quot;query&quot;: &#123;    &quot;bool&quot;: &#123;      &quot;must&quot;: [        &#123;          &quot;match&quot;: &#123;            &quot;content&quot;: &quot;混凝土压杆承载力设计值如何计算&quot;          &#125;        &#125;      ]    &#125;  &#125;,  &quot;highlight&quot;: &#123;    &quot;fields&quot;:&#123;      &quot;content&quot;:&#123;          &quot;type&quot;:&quot;plain&quot;,          &quot;order&quot;: &quot;score&quot;,          &quot;number_of_fragments&quot;: 3      &#125;    &#125;  &#125;&#125;# 按词出现的先后顺序查找POST search-iepc/_search&#123;  &quot;query&quot;: &#123;    &quot;match_phrase&quot;: &#123;      &quot;content&quot;: &quot;抗裂验算 全预应力 混凝土&quot;    &#125;  &#125;&#125;# 按先后顺序查询POST search-iepc/_search&#123;  &quot;query&quot;:&#123;    &quot;match&quot;: &#123;      &quot;content&quot;: &#123;        &quot;query&quot;: &quot;抗裂验算 全预应力 混凝土&quot;,        &quot;operator&quot;: &quot;and&quot;      &#125;    &#125;  &#125;&#125;# 通过 id 查找数据GET search-iepc/_doc/66150b2166d66170065f78d2# 删除指定id的数据POST search-iepc/_delete_by_query&#123;  &quot;query&quot;: &#123;    &quot;bool&quot;: &#123;      &quot;filter&quot;: &#123;        &quot;ids&quot;: &#123;          &quot;values&quot;: [&quot;661f97cb2d1b78567953f85e&quot;]        &#125;      &#125;    &#125;  &#125;&#125;# 查找但不评分GET search-iepc/_search&#123;  &quot;query&quot;:&#123;    &quot;constant_score&quot;: &#123;      &quot;filter&quot;:&#123;         &quot;term&quot;: &#123;          &quot;fileId&quot;: 1713488916377        &#125;      &#125;    &#125;  &#125;&#125;# 通过 fileId 查找删除数据POST search-iepc/_delete_by_query&#123;  &quot;query&quot;:&#123;    &quot;constant_score&quot;: &#123;      &quot;filter&quot;:&#123;         &quot;term&quot;: &#123;          &quot;fileId&quot;: 1713431812754        &#125;      &#125;    &#125;  &#125;&#125;# 清空所有POST search-iepc/_delete_by_query&#123;  &quot;query&quot;: &#123;    &quot;match_all&quot;:&#123;&#125;  &#125;&#125;\r\n结语\r\n上面的安装方式使用了\r\nelasticsearch-analysis-hanlp，这种方式有个弊端，无法快速迭代分词器。\r\n后期若有升级需要，可以将 hanlp\r\n独立成服务，然后制作一个网络分词器插件进行调用。\r\n参考\r\n\r\nElasticsearch\r\nGuide 8.16\r\nInstall\r\nElasticsearch with Docker\r\nedisonwd/hanlp-jupyterlab-docker\r\nwalterinsh/hanlp\r\n- Docker Image | Docker Hub\r\n中文分词器：KennFalcon/elasticsearch-analysis-hanlp:\r\nHanLP Analyzer for Elasticsearch (github.com)\r\n\r\n","categories":["Software","ElasticSearch"],"tags":["ElasticSearch"]},{"title":"VSCode 中 Copilot 不进行提示","url":"/posts/2023/25NK7XP.html","content":"在 vscode 中安装了 copilot 后，当编写代码时，若 copilot\r\n不转圈(不工作)，可能是 copilot 没有登陆成功导致的。重启 vscode\r\n后，会自动触发登陆弹窗，登陆即可正常使用。\r\n","categories":["Software","Copilot"],"tags":["Software","Copilot"]},{"title":"FreeCAD 创建 BSplineCurve","url":"/posts/2025/37FBBPR.html","content":"本文介绍如何在 FreeCAD 中创建 BSplineCurve。\r\n\r\nBSplineCurve\r\n代码如下：\r\nfrom FreeCAD import Baseimport PartV = Base.Vectorpoles = [V(-2, 2, 0),V(0, 2, 1),V(2, 2, 0),V(2, -2, 0),V(0, -2, 1),V(-2, -2, 0)]# non-periodic splinen=Part.BSplineCurve()n.buildFromPoles(poles)Part.show(n.toShape())# periodic splinen=Part.BSplineCurve()n.buildFromPoles(poles, True)# 保存到文件Part.show(n.toShape())\r\nBezierCurve\r\nfrom FreeCAD import Baseimport Partp1 = Base.Vector(-1, 0, 0)p2 = Base.Vector(0, 1, 0.2)p3 = Base.Vector(1, 0, 0.4)p4 = Base.Vector(0, -1, 1)bc = Part.BezierCurve()bc.setPoles([p1, p2, p3, p4])curveShape = bc.toShape()\r\n","categories":["Software","FreeCAD"],"tags":["FreeCAD"]},{"title":"StableDiffusion 专有名词理解","url":"/posts/2024/1HAPA4N.html","content":"本文对 SD 和 ComfyUI\r\n中的一些名词进行解释，按文末参考文章中出现的先后顺序进行排列。\r\n\r\n本文主要采用 GPT 进行解释。\r\n\r\n\r\n正文\r\nHires Fix\r\n\"Hires fix\"\r\n又称为高分辨率修复，是一种在深度学习和图像生成领域中用来提高图像分辨率和细节的技术。\r\nStable\r\nDiffusion中文网：Hires. Fix是什么意思？ - Stable Diffusion中文网\r\n(stablediffusion-cn.com)\r\n【深度学习】Stable\r\nDiffusion中的Hires. fix是什么？Hires. fix原理_hires.fix-CSDN博客\r\nVAE\r\n变分自编码器VAE：原来是这么一回事\r\n| 附开源代码 - 知乎 (zhihu.com)\r\nESRGAN\r\n【Super\r\nResolution】超分辨率——ESRGAN_esrgan网络结构-CSDN博客\r\nLora\r\nAI\r\n绘画Stable Diffusion 研究（十七）SD lora 详解（上）-CSDN博客\r\n主要参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\nComfyUI_examples\r\n翻译笔记 - 掘金 (juejin.cn)\r\n其它参考\r\nAI绘画_w风雨无阻w的博客-CSDN博客\r\n","categories":["Software","ComfyUI"],"tags":["SD"]},{"title":"FreeCAD 中 ConfigurationTable 与 VarSet 的在参数化中的应用及对比","url":"/posts/2025/KA40NG.html","content":"FreeCAD\r\n中的参数化功能很强大，其中的表达式可以使用任意对象上的字段作为参数，本文将介绍主流的参数定义方式\r\nConfiguration Table 和 VarSet 的应用及对比。\r\n\r\n未完成，请阅读参考文章。\r\nConfiguration Table\r\nVarSet\r\n参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\n配置表 -\r\nFreeCAD Documentation --- Configuration Tables - FreeCAD\r\nDocumentation\r\n变量集与电子表格\r\n： r/FreeCAD --- Variable Sets vs. Spreadsheets : r/FreeCAD\r\n","categories":["Software","FreeCAD"],"tags":["FreeCAD"]},{"title":"FreeCAD Assembly4 桥梁组装最优实践","url":"/posts/2025/2Q4WCJB.html","content":"为了基于 FreeCAD\r\n实现桥梁参数化构件的复用，通过对比当前比较受欢迎的几种组装方案：Assembly、A2Plus，Assembly4，最终选择\r\nAssembly4 作为组装技术基座。\r\n本文将介绍在 Assembly4 工作台下，桥梁结构组装的最优实践。\r\n\r\n\r\n假设 Assembly4 已经安装\r\n\r\n参数化创建\r\n\r\n激活 Assembly4 (命令:\r\nGui.activateWorkbench(\"Assembly4Workbench\"))\r\n单击 【New Assembly】(命令:\r\nGui.runCommand('Asm4_newAssembly',0)) 生成一个\r\nAssembly\r\n激活\r\n【Assembly/Variables】，在属性浏览器中，右键，然后【添加属性】，其中，组名必须为\r\nVariables\r\n\r\n\r\nimage-20251020102627245\r\n\r\n该步骤也可以使用 【Variables】按钮(命令：\r\nGui.runCommand('Asm4_variablesCmd',0))\r\n添加，但是该功能的数据类型有限，建议使用上面的方式添加属性。\r\n在 Part 目录中，使用 【Design Part】\r\n工作台创建实体，若要引用变量，则使用\r\n&lt;&lt;Variables&gt;&gt;.名称 格式调用 Variables\r\n对象中的字段。\r\n引用变量有两种方式，按显示名称 &lt;&lt;显示名称&gt;&gt;.\r\n引用和按内部名称 内部名称. 引用。\r\n内部名称引用的方式由于绑定了对象的名称，而名称不能修改，若要更换变量所在的对象，则会不方便。\r\n将 Part 中的实体导入到 Assembly 中，方便外部文件导入\r\n使用 【InsertPart】(命令:\r\nGui.runCommand('Asm4_variantLink',0)) 将实体从 Part\r\n目录中导入到 Assembly 对象下。\r\n最终的目录结构如下图所示：\r\n\r\n\r\nimage-20251020103549491\r\n\r\n\r\n组装步骤\r\n\r\n\r\nimage-20251020100651882\r\n\r\n\r\n在组装文件中选择 Assembly\r\n单击 【Create a variant Part】功能\r\n选择需要导入的 Assembly，修改名称，然后插入\r\n插入完成后，会要求附加到坐标系，此时可以忽略或者指定要绑定的坐标系。\r\n\r\n\r\nimage-20251020101019978\r\n\r\n若绑定了坐标系，则调整位置时，不能使用\r\nPlacement.Position 进行调整，要使用\r\nAttachmentOffset.Position\r\n进行修改。若使用前者，在文件重新打开时，AttachmentOffset.Position\r\n的值会覆盖\r\nPlacement.Position，导致在前者中设置的变量不生效。\r\n\r\n使用 Assembly4 工作台导入 Assembly 后，在 Variables\r\n中定义的字段会自动附加到导入的对象上，方便在当前对象修改参数。\r\n","categories":["Software","FreeCAD"],"tags":["FreeCAD"]},{"title":"Frp客户端实现反向代理","url":"/posts/2021/3H6CDHV.html","content":"当我们使用公益的Frp服务端时，我们对Frp服务器没有管理权限，此时，我们可用的端口可能就只有一个，为了能够在内网机器部署多个应用，我们就需要在内网机实现反向代理和Https。那么要如何实现呢？请听我娓娓道来。\r\n\r\n域名购买\r\n要实现反向代理，必须要有一个域名，建议在阿里云购买域名，因为阿里云域名可以很方便的实现\r\nLet's Encrypt 证书 DNS 认证及自动更新。\r\n安装 Frp 客户端\r\n软件安装教程，请自行在网上获取，本人采用 scoop 安装，可以使用\r\nscoop install frp 进行安装。\r\n配置：\r\n# 连接frp服务器[common]server_addr = xxx.xxx.xxx.xxx# frp 服务连接的端口server_port = 4431token= asfsdf32894sdf# 网站1[http1]type = httpscustom_domains = web1.example.comlocal_port = 443# 网站2[http2]type = httpscustom_domains = web2.example.comlocal_port = 443\r\n客户端这样设置，是为了将所有流量原封不动的转发到本机的443端口，然后再由本机的宝塔面板安装反向代理软件（推荐\r\nnginx）来反向代理请求。\r\n安装宝塔面板\r\n不论是 Linux 或者 Windows\r\nServer，都可以安装宝塔面板。宝塔面板可以很方便搭建网络环境，也可以很方便实现\r\nSSL 证书的自动更新。对于新手来说，非常友好。\r\n下载地址：https://www.bt.cn\r\n宝塔面板安装完成后，就可以在上面建立网站了，由于所有流量都聚集在本机的\r\n443\r\n端口，所以，宝塔面板首先要安装反向代理软件，然后再将请求代理到不同的网站。\r\n由于 frp 原封不动地转发了 https 流量，所以 https\r\n的证书就可以在反向代理软件中配置了。宝塔面板网站安装及申请 SSL\r\n教程请在网上自行查找。\r\n","categories":["Software","Frp"],"tags":["frp"]},{"title":"Markdown 语法使用手册","url":"/posts/2019/3Y73VWH.html","content":"Markdown 语法。\r\n\r\n基本语法\r\n1. 斜体和粗体\r\n使用 * 和 ** 表示斜体和粗体。\r\n示例：\r\n这是 斜体，这是 粗体。\r\n2. 分级标题\r\n使用 === 表示一级标题，使用 --- 表示二级标题。\r\n示例：\r\n这是一个一级标题============================这是一个二级标题----------------------------### 这是一个三级标题\r\n你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ##\r\nH2, ### H3，#### H4。\r\n3. 外链接\r\n使用 [描述](链接地址) 为文字增加外链接。\r\n示例：\r\n这是去往 本人博客\r\n的链接。\r\n4. 无序列表\r\n使用 *，+，- 表示无序列表。\r\n示例：\r\n\r\n无序列表项 一\r\n无序列表项 二\r\n无序列表项 三\r\n\r\n5. 有序列表\r\n使用数字和点表示有序列表。\r\n示例：\r\n\r\n有序列表项 一\r\n有序列表项 二\r\n有序列表项 三\r\n\r\n6. 文字引用\r\n使用 &gt; 表示文字引用。\r\n示例：\r\n\r\n野火烧不尽，春风吹又生。\r\n\r\n7. 行内代码块\r\n使用 `代码` 表示行内代码块。\r\n示例：\r\n让我们聊聊 html。\r\n8. 代码块\r\n使用 四个缩进空格 表示代码块。\r\n示例：\r\n这是一个代码块，此行左侧有四个不可见的空格。\r\n9. 插入图像\r\n使用 ![描述](图片链接地址) 插入图像。\r\n示例：\r\n\r\n\r\n山水\r\n\r\n高阶语法\r\n1. 内容目录\r\n在段落中填写 [TOC] 或者{:toc}\r\n以显示全文内容的目录结构。\r\n[TOC] {:toc}\r\n2. 标签分类\r\n在编辑区任意行的列首位置输入以下代码给文稿标签：\r\n标签： 数学 英语 Markdown\r\n或者\r\nTags： 数学 英语 Markdown\r\n3. 删除线\r\n使用 ~~ 表示删除线。\r\n这是一段错误的文本。\r\n4. 注脚\r\n使用 [^keyword] 表示注脚。\r\n这是一个注脚1的样例。\r\n这是第二个注脚2的样例。\r\n5. LaTeX 公式\r\n$ 表示行内公式：\r\n质能守恒方程可以用一个很简洁的方程式 \\(E=mc^2\\) 来表达。\r\n$$ 表示整行公式：\r\n\\[\\sum_{i=1}^n a_i=0\\]\r\n\\[f(x_1,x_x,\\ldots,x_n) = x_1^2 + x_2^2 +\r\n\\cdots + x_n^2 \\]\r\n\\[\\sum^{j-1}_{k=0}{\\widehat{\\gamma}_{kj}\r\nz_k}\\]\r\n访问 MathJax\r\n参考更多使用方法。\r\n6. 加强的代码块\r\n支持四十一种编程语言的语法高亮的显示，行号显示。\r\n非代码示例：\r\n$ sudo apt-get install vim-gnome\r\nPython 示例：\r\n@requires_authorizationdef somefunc(param1=&#x27;&#x27;, param2=0):    &#x27;&#x27;&#x27;A docstring&#x27;&#x27;&#x27;    if param1 &gt; param2: # interesting        print &#x27;Greater&#x27;    return (param2 - param1 + 1) or Noneclass SomeClass:    pass&gt;&gt;&gt; message = &#x27;&#x27;&#x27;interpreter... prompt&#x27;&#x27;&#x27;\r\nJavaScript 示例：\r\n/*** nth element in the fibonacci series.* @param n &gt;= 0* @return the nth element, &gt;= 0.*/function fib(n) &#123;  var a = 1, b = 1;  var tmp;  while (--n &gt;= 0) &#123;    tmp = a;    a += b;    b = tmp;  &#125;  return a;&#125;document.write(fib(10));\r\n7. 流程图\r\n示例\r\nst=&gt;start: Start:&gt;https://www.zybuluo.comio=&gt;inputoutput: verificationop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?sub=&gt;subroutine: Your Subroutinee=&gt;endst-&gt;io-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;sub-&gt;io\r\n更多语法参考：流程图语法参考\r\n8. 序列图\r\n示例 1\r\nAlice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks!\r\n示例 2\r\nTitle: Here is a titleA-&gt;B: Normal lineB--&gt;C: Dashed lineC-&gt;&gt;D: Open arrowD--&gt;&gt;A: Dashed open arrow\r\n更多语法参考：序列图语法参考\r\n9. 甘特图\r\n甘特图内在思想简单。基本是一条线条图，横轴表示时间，纵轴表示活动（项目），线条表示在整个期间上计划和实际的活动完成情况。它直观地表明任务计划在什么时候进行，及实际进展与计划要求的对比。\r\ntitle 项目开发流程section 项目确定    需求分析       :a1, 2016-06-22, 3d    可行性报告     :after a1, 5d    概念验证       : 5dsection 项目实施    概要设计      :2016-07-05  , 5d    详细设计      :2016-07-08, 10d    编码          :2016-07-15, 10d    测试          :2016-07-22, 5dsection 发布验收    发布: 2d    验收: 3d\r\n更多语法参考：甘特图语法参考\r\n10. Mermaid 流程图\r\nA[Hard edge] --&gt;|Link text| B(Round edge)B --&gt; C&#123;Decision&#125;C --&gt;|One| D[Result one]C --&gt;|Two| E[Result two]\r\n更多语法参考：Mermaid\r\n流程图语法参考\r\n11. Mermaid 序列图\r\nAlice-&gt;John: Hello John, how are you?loop every minute    John--&gt;Alice: Great!end\r\n更多语法参考：Mermaid\r\n序列图语法参考\r\n12. 表格支持\r\nMarkdown 制作表格使用 | 来分隔不同的单元格，使用 -\r\n来分隔表头和其他行。\r\n语法格式如下：\r\n|  表头   | 表头  ||  ----  | ----  || 单元格  | 单元格 || 单元格  | 单元格 |\r\n对齐方式\r\n我们可以设置表格的对齐方式：\r\n\r\n-: 设置内容和标题栏居右对齐。\r\n:- 设置内容和标题栏居左对齐。\r\n:-: 设置内容和标题栏居中对齐。\r\n\r\n实例如下：\r\n| 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 |\r\n效果如下：\r\n\r\n\r\n\r\n项目\r\n价格\r\n数量\r\n\r\n\r\n\r\n\r\n计算机\r\n$1600\r\n5\r\n\r\n\r\n手机\r\n$12\r\n12\r\n\r\n\r\n管线\r\n$1\r\n234\r\n\r\n\r\n\r\n13. 定义型列表\r\n\r\n名词 1\r\n\r\n定义 1（左侧有一个可见的冒号和四个不可见的空格）\r\n\r\n代码块 2\r\n\r\n这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）\r\n代码块（左侧有八个不可见的空格）\r\n\r\n\r\n14. Html 标签\r\n本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html\r\n写一个纵跨两行的表格：\r\n&lt;table&gt;\r\n    &lt;tr&gt;\r\n        &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt;\r\n        &lt;th&gt;星期一&lt;/th&gt;\r\n        &lt;th&gt;星期二&lt;/th&gt;\r\n        &lt;th&gt;星期三&lt;/th&gt;\r\n    &lt;/tr&gt;\r\n    &lt;tr&gt;\r\n        &lt;td&gt;李强&lt;/td&gt;\r\n        &lt;td&gt;张明&lt;/td&gt;\r\n        &lt;td&gt;王平&lt;/td&gt;\r\n    &lt;/tr&gt;\r\n&lt;/table&gt;\r\n\r\n\r\n\r\n值班人员\r\n\r\n\r\n星期一\r\n\r\n\r\n星期二\r\n\r\n\r\n星期三\r\n\r\n\r\n\r\n\r\n李强\r\n\r\n\r\n张明\r\n\r\n\r\n王平\r\n\r\n\r\n\r\n15. 内嵌图标\r\n本站的图标系统对外开放，在文档中输入\r\n&lt;i class=&quot;icon-weibo&quot;&gt;&lt;/i&gt;\r\n即显示微博的图标： \r\n替换 上述 i 标签 内的 icon-weibo\r\n以显示不同的图标，例如：\r\n&lt;i class=&quot;icon-renren&quot;&gt;&lt;/i&gt;\r\n即显示人人的图标： \r\n更多的图标和玩法可以参看 font-awesome\r\n官方网站。\r\n16. 待办事宜 Todo 列表\r\n使用带有 [ ] 或 [x]\r\n（未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如：\r\n- [ ] **Cmd Markdown 开发**\r\n    - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率\r\n    - [ ] 支持以 PDF 格式导出文稿\r\n    - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments)\r\n    - [x] 改进 LaTex 功能\r\n        - [x] 修复 LaTex 公式渲染问题\r\n        - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers)\r\n- [ ] **七月旅行准备**\r\n    - [ ] 准备邮轮上需要携带的物品\r\n    - [ ] 浏览日本免税店的物品\r\n    - [x] 购买蓝宝石公主号七月一日的船票\r\n对应显示如下待办事宜 Todo 列表：\r\n\r\nCmd Markdown 开发\r\n\r\n改进 Cmd\r\n渲染算法，使用局部渲染技术提高渲染效率\r\n支持以 PDF 格式导出文稿\r\n新增Todo列表功能 语法参考\r\n改进 LaTex 功能\r\n\r\n修复 LaTex 公式渲染问题\r\n新增 LaTex 公式编号功能 语法参考\r\n\r\n\r\n七月旅行准备\r\n\r\n准备邮轮上需要携带的物品\r\n浏览日本免税店的物品\r\n购买蓝宝石公主号七月一日的船票\r\n\r\n\r\n\r\n\r\n\r\n这是一个 注脚 的 文本。↩︎\r\n这是另一个 注脚 的 文本。↩︎\r\n\r\n\r\n","categories":["Software","Markdown"],"tags":["Markdown"]},{"title":"Git 中 .gitignore 语法","url":"/posts/2021/13VFWMA.html","content":"可以创建一个名为 .gitignore\r\n的文件，列出要忽略的文件的模式。\r\n\r\n文件 .gitignore 的格式规范如下：\r\n\r\n所有空行或者以 # 开头的行都会被 Git 忽略。\r\n可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。\r\n匹配模式可以以（/）开头防止递归。\r\n匹配模式可以以（/）结尾指定目录。\r\n要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。\r\n\r\n所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。\r\n\r\n星号（*）匹配零个或多个任意字符\r\n[abc] 匹配任何一个列在方括号中的字符\r\n（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；\r\n问号（?）只匹配一个任意字符\r\n如果在方括号中使用短划线分隔两个字符，\r\n表示所有在这两个字符范围内的都可以匹配（比如 [0-9]\r\n表示匹配所有 0 到 9 的数字）\r\n使用两个星号（**）表示匹配任意中间目录，比如\r\na/**/z 可以匹配 a/z 、 a/b/z 或\r\na/b/c/z\r\n\r\n# 忽略所有的 .a 文件*.a# 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件!lib.a# 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO/TODO# 忽略任何目录下名为 build 的文件夹build/# 忽略 doc/notes.txt，但不忽略 doc/server/arch.txtdoc/*.txt# 忽略 doc/ 目录及其所有子目录下的 .pdf 文件doc/**/*.pdf\r\n一个仓库可能只根目录下有一个 .gitignore\r\n文件，它递归地应用到整个仓库中。 然而，子目录下也可以有额外的\r\n.gitignore 文件。子目录中的 .gitignore\r\n文件中的规则只作用于它所在的目录中。\r\nGitHub 有一个十分详细的针对数十种项目及语言的 .gitignore\r\n文件列表， 可以在 https://github.com/github/gitignore 找到它。\r\n","categories":["Software","Git"]},{"title":"Git 实用小技巧","url":"/posts/2021/XG9YG0.html","content":"本文总结了 Git\r\n在使用中比较实用的一些小技巧，随着今后的使用逐渐补充。\r\n\r\ngit commit -m 换行\r\n先输入第一个引号，按Enter即可换行，完成后再补齐后面的引号。\r\n","categories":["Software","Git"]},{"title":"git 常用命令总结","url":"/posts/2020/189RMV7.html","content":"本文记录 Git 在日常使用中需要掌握的原理和基本命令，提升使用效率。\r\n\r\n概念理解\r\n使用 Git\r\n之前需要对它的储存有一个清晰的了解，在使用中才能得心应手。\r\nGit 有三种状态，你的文件可能处于其中之一：\r\n已提交（committed）、已修改（modified）\r\n和 已暂存（staged）。\r\n\r\n已修改（modified）表示修改了文件，但还没保存到数据库中。\r\n已暂存（staged）表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。\r\n已提交（committed）表示数据已经安全地保存在本地数据库中。\r\n\r\n\r\n\r\ngit三大分区\r\n\r\n配置\r\nGit 的设置文件为\r\n.gitconfig，它可以在用户主目录下(全局配置)，也可以在项目目录下(项目配置)。\r\n\r\n显示当前的Git配置\r\n\r\ngit config --list\r\n\r\n编辑 Git 配置文件\r\n\r\ngit config -e [--global]\r\n常用 Git 配置：\r\n# 颜色设置git config --global color.ui true # git status等命令自动着色git config --global color.status autogit config --global color.diff autogit config --global color.branch autogit config --global color.interactive auto# 添加代理git config --global https.proxy http://127.0.0.1:1080git config --global https.proxy https://127.0.0.1:1080#移除代理git config --global --unset http.proxygit config --global --unset https.proxy\r\n获取 Git 仓库\r\n1. 在已存在目录中初始化仓库\r\ngit init\r\n2. 克隆现有的仓库\r\n# 第一种方式git clone &lt;url&gt;     # 第二种方式,可以将目标目录进行重命名git clone &lt;url&gt; targetDirectoryName\r\n增删文件\r\n1. 添加文件/文件夹\r\n可以用 git add\r\n开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。\r\n可以将这个命令理解为“将内容添加到下一次提交中”。\r\n# 添加指定文件到暂存区git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录git add [dir]# 添加当前目录的所有文件到暂存区git add . 或 git add -a# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交git add -p\r\n2. 删除文件\r\ngit rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区git rm --cached [file]# 改名文件，并且将这个改名放入暂存区git mv [file-original] [file-renamed]\r\n代码提交\r\n# 提交暂存区到仓库区git commit -m [message]# 提交暂存区的指定文件到仓库区git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区，不会提交未跟踪的文件或者目录git commit -a# 提交时显示所有diff信息git commit -v# 将add和commit合为一步，该操作也不会提交未跟踪的文件或者目录git commit -am &#x27;message&#x27;# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化git commit --amend [file1] [file2] ...\r\n分支\r\n# 列出所有本地分支git branch# 列出所有远程分支git branch -r# 列出所有本地分支和远程分支git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch]# 检出版本v2.0$ git checkout v2.0# 从远程分支develop创建新本地分支devel并检出$ git checkout -b devel origin/develop# 检出head版本的README文件（可用于修改错误回退）git checkout -- README \r\n标签\r\n# 列出所有taggit tag# 新建一个tag在当前commitgit tag [tag]# 新建一个tag在指定commitgit tag [tag] [commit]# 删除本地taggit tag -d [tag]# 删除远程taggit push origin -d [tag]# 查看tag信息git show [tag]# 提交指定taggit push [remote] [tag]# 提交所有taggit push [remote] --tags# 新建一个分支，指向某个taggit checkout -b [branch] [tag]\r\n\r\n分支与标签的区别，Git 中 branch 与 tag\r\n的区别和使用场景\r\n\r\n查看信息\r\n# 显示有变更的文件git status# 显示当前分支的版本历史git log# 显示commit历史，以及每次commit发生变更的文件git log --stat# 搜索提交历史，根据关键词git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名git log --follow [file]git whatchanged [file]# 显示指定文件相关的每一次diffgit log -p [file]# 显示过去5次提交git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序git shortlog -sn# 显示指定文件是什么人在什么时间修改过git blame [file]# 显示暂存区和工作区的差异git diff# 显示暂存区和上一个commit的差异git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异git diff HEAD# 显示两次提交之间的差异git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化git show [commit]# 显示某次提交发生变化的文件git show --name-only [commit]# 显示某次提交时，某个文件的内容git show [commit]:[filename]# 显示当前分支的最近几次提交git reflog\r\n远程同步\r\n# 下载远程仓库的所有变动git fetch [remote]# 显示所有远程仓库git remote -v# 显示某个远程仓库的信息git remote show [remote]# 增加一个新的远程仓库，并命名git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并git pull [remote] [branch]# 上传本地指定分支到远程仓库git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突git push [remote] --force# 推送所有分支到远程仓库git push [remote] --all\r\n撤销\r\n# 恢复暂存区的指定文件到工作区git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区git checkout [commit] [file]# 恢复暂存区的所有文件到工作区git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变git reset [file]# 重置暂存区与工作区，与上一次commit保持一致git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支git revert [commit]# 暂时将未提交的变化放入暂存区，稍后再从暂存区中移入git stashgit stash pop# 取消当前的合并操作git merge --abort\r\n其它\r\ngit init                                                  # 初始化本地git仓库（创建新仓库）git config --global user.name &quot;xxx&quot;                       # 配置用户名git config --global user.email &quot;xxx@xxx.com&quot;              # 配置邮件git config --global color.ui true                         # git status等命令自动着色git config --global color.status autogit config --global color.diff autogit config --global color.branch autogit config --global color.interactive autogit config --global --unset http.proxy                    # remove  proxy configuration on gitgit clone git+ssh://git@192.168.53.168/VT.git             # clone远程仓库git status                                                # 查看当前版本状态（是否修改）git add xyz                                               # 添加xyz文件至indexgit add .                                                 # 增加当前子目录下所有更改过的文件至indexgit commit -m &#x27;xxx&#x27;                                       # 提交git commit --amend -m &#x27;xxx&#x27;                               # 合并上一次提交（用于反复修改）git commit -am &#x27;xxx&#x27;                                      # 将add和commit合为一步git rm xxx                                                # 删除index中的文件git rm -r *                                               # 递归删除git log                                                   # 显示提交日志git log -1                                                # 显示1行日志 -n为n行git log -5git log --stat                                            # 显示提交日志及相关变动文件git log -p -mgit show dfb02e6e4f2f7b573337763e5c0013802e392818         # 显示某个提交的详细内容git show dfb02                                            # 可只用commitid的前几位git show HEAD                                             # 显示HEAD提交日志git show HEAD^                                            # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本git tag                                                   # 显示已存在的taggit tag -a v2.0 -m &#x27;xxx&#x27;                                  # 增加v2.0的taggit show v2.0                                             # 显示v2.0的日志及详细内容git log v2.0                                              # 显示v2.0的日志git diff                                                  # 显示所有未添加至index的变更git diff --cached                                         # 显示所有已添加index但还未commit的变更git diff HEAD^                                            # 比较与上一个版本的差异git diff HEAD -- ./lib                                    # 比较与HEAD版本lib目录的差异git diff origin/master..master                            # 比较远程分支master上有本地分支master上没有的git diff origin/master..master --stat                     # 只显示差异的文件，不显示具体内容git remote add origin git+ssh://git@192.168.53.168/VT.git # 增加远程定义（用于push/pull/fetch）git branch                                                # 显示本地分支git branch --contains 50089                               # 显示包含提交50089的分支git branch -a                                             # 显示所有分支git branch -r                                             # 显示所有原创分支git branch --merged                                       # 显示所有已合并到当前分支的分支git branch --no-merged                                    # 显示所有未合并到当前分支的分支git branch -m master master_copy                          # 本地分支改名git checkout -b master_copy                               # 从当前分支创建新分支master_copy并检出git checkout -b master master_copy                        # 上面的完整版git checkout features/performance                         # 检出已存在的features/performance分支git checkout --track hotfixes/BJVEP933                    # 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支git checkout v2.0                                         # 检出版本v2.0git checkout -b devel origin/develop                      # 从远程分支develop创建新本地分支devel并检出git checkout -- README                                    # 检出head版本的README文件（可用于修改错误回退）git merge origin/master                                   # 合并远程master分支至当前分支git cherry-pick ff44785404a8e                             # 合并提交ff44785404a8e的修改git push origin master                                    # 将当前分支push到远程master分支git push origin :hotfixes/BJVEP933                        # 删除远程仓库的hotfixes/BJVEP933分支git push --tags                                           # 把所有tag推送到远程仓库git fetch                                                 # 获取所有远程分支（不更新本地分支，另需merge）git fetch --prune                                         # 获取所有原创分支并清除服务器上已删掉的分支git pull origin master                                    # 获取远程分支master并merge到当前分支git mv README README2                                     # 重命名文件README为README2git reset --hard HEAD                                     # 将当前版本重置为HEAD（通常用于merge失败回退）git rebasegit branch -d hotfixes/BJVEP933                           # 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）git branch -D hotfixes/BJVEP933                           # 强制删除分支hotfixes/BJVEP933git ls-files                                              # 列出git index包含的文件git show-branch                                           # 图示当前分支历史git show-branch --all                                     # 图示所有分支历史git whatchanged                                           # 显示提交历史对应的文件修改git revert dfb02e6e4f2f7b573337763e5c0013802e392818       # 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818git ls-tree HEAD                                          # 内部命令：显示某个git对象git rev-parse v2.0                                        # 内部命令：显示某个ref对于的SHA1 HASHgit reflog                                                # 显示所有提交，包括孤立节点git show HEAD@&#123;5&#125;git show master@&#123;yesterday&#125;                               # 显示master分支昨天的状态git log --pretty=format:&#x27;%h %s&#x27; --graph                   # 图示提交日志git show HEAD~3git show -s --pretty=raw 2be7fcb476git stash                                                 # 暂存当前修改，将所有至为HEAD状态git stash list                                            # 查看所有暂存git stash show -p stash@&#123;0&#125;                               # 参考第一次暂存git stash apply stash@&#123;0&#125;                                 # 应用第一次暂存git grep &quot;delete from&quot;                                    # 文件中搜索文本“delete from”git grep -e &#x27;#define&#x27; --and -e SORT_DIRENTgit gcgit fsck# 生成一个可供发布的压缩包git archive\r\n参考文章\r\n[1]. https://git-scm.com/book/zh/v2\r\n[2]. https://segmentfault.com/a/1190000039147662\r\n","categories":["Software","Git"],"tags":["Git"]},{"title":"Git 中 branch 与 tag 的区别和使用场景","url":"/posts/2021/3RHTYZB.html","content":"正文开始之前，我想我们需要弄明白几个问题：\r\n\r\ntag 是什么？\r\n使用 tag 的好处？\r\ntag 和 branch 的区别以及使用场景？\r\n\r\n\r\ntag 是什么\r\ntag , 翻译过来是标签的意思，顾名思义，标签是为了标记某种事物。\r\n它实际上是 Git 版本库的一个快照，指向某个 commit 的指针。\r\n使用tag 的好处\r\ntag\r\n的存在，是因为我们需要这种标记的功能。目前的项目开发中，当发布版本时 tag\r\n就派上用场了。例如 v1.0.1，v1.0.2… ，发布的时候，只需要在 master\r\n中打上一个标签就可以了，而不需要一个版本对应一个分支。\r\n区别和使用场景\r\n想到这里，你可能觉得 tag 和 branch\r\n有点相似。没错，的确是有点像，但是它们的职责分工和本质都是不同的。\r\ntag 对应某次 commit, 是一个点，是不可移动的。\r\nbranch 对应一系列 commit，是很多点连成的一根线，有一个HEAD\r\n指针，是可以依靠 HEAD 指针移动的。\r\n所以，两者的区别决定了使用方式，改动代码用 branch ,不改动只查看用\r\ntag。\r\ntag 和 branch 的相互配合使用，有时候起到非常方便的效果，例如\r\n已经发布了 v1.0 v2.0 v3.0\r\n三个版本，这个时候，我突然想不改现有代码的前提下，在 v2.0\r\n的基础上加个新功能，作为 v4.0 发布。就可以 检出 v2.0 的代码作为一个\r\nbranch ，然后作为开发分支。\r\n注意\r\n需要说明的是，创建 tag 是基于本地分支的\r\ncommit，而且与分支的推送是两回事，就是说分支已经推送到远程了，但是你的\r\ntag 并没有，如果把 tag 推送到远程分支上，需要另外执行 tag\r\n的推送命令。\r\n点击查看关于tag的操作总结\r\n参考\r\n本文参考自：https://blog.csdn.net/lcgoing/article/details/86241784\r\n","categories":["Software","Git"],"tags":["Git"]},{"title":"Git 结束符不匹配导致提交时差异对比失效，表现为整个文件删除和新增","url":"/posts/2022/30QXK0B.html","content":"今天换了电脑开发，发现在进行 git commit\r\n之后，只要文件有修改，即使是一模一样的内容，都是先删除，然后再新增，无法保存仅修改部分的代码。\r\n\r\n\r\nimage-20220315090318257\r\n\r\n\r\n正文\r\n通过测试有如下发现：\r\n\r\n对于原电脑的文件，仅在第一次编辑时，会发生上述情况\r\n对于当前电脑的，git 提交时，不会出现上述情况\r\n\r\n由此，可以推测出，是新旧电脑在文件的处理上不一致导致的。顺着这个思路，开始解决这个问题。\r\n通过 google，其原因是由于 End of Line(eof:行尾结束符)\r\n不同导致的。其中\r\n\r\n\r\n\r\nEOF\r\n说明\r\n备注\r\n\r\n\r\n\r\n\r\nCRLF\r\n回车换行\r\n\r\n\r\n\r\nCR\r\n回车\r\n\r\n\r\n\r\nLF\r\n换行\r\n\r\n\r\n\r\n\r\n\r\nwindows 上，行尾结束符为 CRLF\r\nunix 系统，行尾结束符为 LF\r\n\r\n通过对比新旧电脑的文件，其原因确实如此。\r\n解决方法有以下几个：\r\n\r\n修改 git 设置\r\n# 检出时自动切换成 CRLF 结束符git config --global core.autocrlf true\r\n在项目目录中通过 .gitattributes 来进行配置\r\n如果使用了 prettier，可以用过 prettier 来进行设置\r\n修改 vscode，全局设置\r\n在 vscode 的配置中，搜索 eol，将其修改为\r\nLF\r\n修改 vscode 项目级配置\r\n# 在项目根目录新建 .editorconfig 文件# 在里面添加如下配置：root = true[*]indent_style = spaceindent_size = 4# 此处设置行尾结束符为 lfend_of_line = lfcharset = utf-8trim_trailing_whitespace = falseinsert_final_newline = false\r\n\r\n参考\r\n\r\nhttp://schacon.github.io/git/gitattributes.html\r\nvs\r\ncode设置保存时自动将CRLF 转换成 LF\r\n\r\n","categories":["Software","Git"],"tags":["Git"]},{"title":"yarn 拉取私有仓库时返回403无权限","url":"/posts/2022/34RK9KS.html","content":"在使用 yarn install 安装私有包时，由于仓库需要认证，但\r\nYarn 的安装过程不允许交互式提示，所以当 Git\r\n请求用户名时，它无法提供，会导致权限被拒的情况：\r\nremote: [session-2a4ee1aa] Access deniedfatal: unable to access &#x27;https://gitee.com/my-packages/camera-preview.git/&#x27;: The requested URL returned error: 403root@d24630a9ec27:/app/frontend-cross# git ls-remote --tags --heads https://gitee.com/my-packages/camera-preview.git\r\n可以使用两种方法来解决。\r\n\r\n在 Git 中设置凭据\r\n使用如下命令来设置凭据，然后使用使用 git\r\n访问仓库，按提示输入用户名和密码。\r\ngit config --global credential.helper store\r\n\r\n这种方法会在你的计算机上明文存储你的密码\r\n\r\n使用 ssh\r\n直接在 package.json 文件中使用 SSH URL 而不是 HTTPS URL 来引用 Git\r\n依赖。需要在 gitee.com 上设置 SSH 密钥。然后，像这样引用：\r\n&quot;dependencies&quot;: &#123;  &quot;camera-preview&quot;: &quot;git+ssh://git@gitee.com/my-packages/camera-preview.git&quot;&#125;\r\n\r\n这种方法的优点是它不需要存储你的用户名和密码，但是需要配置 SSH\r\n密钥\r\n\r\n","categories":["Software","Git"],"tags":["Git"]},{"title":"Git 中自己常用别名总结","url":"/posts/2022/18J366C.html","content":"本文主要记录自己在使用过程中用到的别名，方便快速进行配置。\r\n\r\n前言\r\nGit 并不会在你输入部分命令时自动推断出你想要的命令。\r\n如果不想每次都输入完整的 Git 命令，可以通过 git config\r\n文件来轻松地为每一个命令设置一个别名。\r\n定义语法\r\ngit config --global alias.别名 &quot;组合命令&quot;# 示例git config --global alias.cm &quot;commit -m&quot;# 今后提交时，只需要输入下列命令即可git cm &quot;message&quot;\r\n设置别名自动更正\r\n使用 Git\r\n别名的一个很酷的好处是它与自动更正功能的原生集成。如果你犯了错误，默认情况下，Git\r\n会建议使用与你输入的命令相似的命令，包括别名。\r\ngit config --global help.autocorrect 20\r\n常用别名\r\n直接将下面的代码整体复制到 powershell\r\n中运行即可，包括注释也可以一并复制。\r\n# 获取所有配置的别名git config --global alias.alias &quot;config --get-regexp alias&quot;# 获取最后一次提交的日志git config --global alias.last &#x27;log -1 --stat&#x27;# 显示loggit config --global alias.lg &quot;log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;# 列出所有分支，并按提交日期对它们进行排序，优先显示最新的 git 分支git config --global alias.br &quot;branch -a --format=&#x27;%(HEAD) %(color:yellow)%(refname:short)%(color:reset) - %(contents:subject) %(color:green)(%(committerdate:relative)) [%(authorname)]&#x27; --sort=-committerdate&quot;# 快速提交代码git config --global alias.cm  &quot;commit -m&quot;# 修改 commit 内容git config --global alias.cmm  &quot;commit --amend&quot;# checkout 简写git config --global alias.ck &quot;checkout&quot;# merge 简写git config --global alias.mg &quot;merge&quot;# pull pushgit config --global alias.pl &quot;pull&quot;git config --global alias.ps &quot;push&quot;# add 和 commit 一起生效# 在 windows 中git config --global alias.save &quot;!git add -A &amp;&amp; git commit -m&quot;# 在 linux 中git config --global alias.save &quot;!f() &#123; git add -A &amp;&amp; git commit -m \\&quot;$1\\&quot;;&#125;; f&quot;\r\n\r\ngit 中如果内容过长，想要退出时，可以按 q 退出\r\n\r\n如果别名扩展的前缀是感叹号!，则它将被视为 shell\r\n命令。例如：\r\ngit config --global alias.save &quot;!git add -A &amp;&amp; git commit -m &#x27;feat: 新增别名&#x27;&quot;\r\n配置文件位置\r\ngit 的全局配置文件为：C:\\Users\\%username%\\.gitconfig\r\n其中别名的配置内容如下：\r\n[alias]        last = log -1 --stat        lg = log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit        alias = config --get-regexp alias        br = branch -a --format=&#x27;%(HEAD) %(color:yellow)%(refname:short)%(color:reset) - %(contents:subject) %(color:green)(%(committerdate:relative)) [%(authorname)]&#x27; --sort=-committerdate        cm = commit -m        cmm = commit --amend        ck = checkout        mg = merge        pl = pull        ps = push        save = git push add -A &amp;&amp; git commit -m\r\n","categories":["Software","Git"],"tags":["Git"]},{"title":"yarn install 时提示无法连接 github","url":"/posts/2022/24T5YRV.html","content":"在使用 yarn install 安装依赖包时，提示如下错误：\r\nCommand: gitArguments: ls-remote --tags --heads git://github.com/adobe-webplatform/eve.gitDirectory: D:\\Develop\\BIM\\swToolsFrontEndOutput:fatal: unable to connect to github.com:github.com[0: 20.205.243.166]: errno=Unknown error\r\n\r\n在上面的错误中，我们可以找到错误关键词\r\ngit:、unable to connect to github.com，根据此信息，我们便可定位错误。\r\n引发上述错误是因为 git 弃用了 git: 协议，所以只需要将\r\ngit 中的 git: 协议改成 https:\r\n即可，命令如下:\r\ngit config --global url.&quot;https://&quot;.insteadOf git://\r\n","categories":["Software","Git"],"tags":["Git"]},{"title":"Git中 子模块的添加与删除","url":"/posts/2023/2Y0295C.html","content":"在使用 hexo\r\n搭建博客时，往往需要添加主题来美化博客。这个时候，通常在自己的主仓库中使用子模块来进行维护。\r\n使用子模块，既能够保持主仓库与主题的联结，又不会增加主仓库的体积，需要更新时，只需要在子模块中更新一下就可以了。\r\n\r\n添加子模块\r\n添加子模块主要有以下步骤：\r\n添加子模块\r\n使用如下命令添加子模块：\r\ngit submodule add &lt;url&gt; &lt;path&gt;\r\n\r\nurl: 为子模块的 git 地址\r\npath: 该子模块相对于主仓库的路径，以 ./ 开头\r\n\r\n验证结果\r\n添加完成后，使用如下命令可以查看子模块是否添加成功：\r\ngit diff --cached# 输出以下内容，说明添加成功了：diff --git a/.gitmodules b/.gitmodulesindex 8b13789..61f1572 100644--- a/.gitmodules+++ b/.gitmodules@@ -1 +1,4 @@+[submodule &quot;themes/next&quot;]+       path = themes/next+       url = https://github.com/next-theme/hexo-theme-next.gitdiff --git a/themes/next b/themes/nextnew file mode 160000index 0000000..2e5757e--- /dev/null\r\n提交结果\r\n使用 git commit &lt;message&gt; 来提交添加结果\r\n使用子模块\r\n克隆项目后，默认子模块目录下无任何内容。需要在项目根目录执行如下命令完成子模块的下载：\r\ngit submodule initgit submodule update\r\n或：\r\ngit submodule update --init --recursive\r\n执行后，子模块目录下就有了源码。\r\n更新子模块\r\n子模块的维护者提交了更新后，使用子模块的项目必须手动更新才能包含最新的提交。\r\n在项目中，进入到子模块目录下，执行\r\ngit pull更新，查看git log查看相应提交。\r\n完成后返回到项目目录，可以看到子模块有待提交的更新，使用git add，提交即可。\r\n删除子模块\r\n时子模块的项目维护地址发生了变化，或者需要替换子模块，就需要删除原有的子模块。\r\n删除子模块较复杂，步骤如下：\r\n\r\nrm -rf 子模块目录 删除子模块目录及源码\r\nvi .gitmodules\r\n删除项目目录下.gitmodules文件中子模块相关条目\r\nvi .git/config 删除配置项中子模块相关条目\r\nrm .git/module/*\r\n删除模块下的子模块目录，每个子模块对应一个目录，注意只删除对应的子模块目录即可\r\n\r\n\r\n注意：删除完成后，先要 git commit\r\n提交一下，然后才可以再添加同名的子模块。\r\n\r\n如果仍然报错，执行如下：\r\ngit rm --cached 子模块名称\r\n完成删除后，提交到仓库即可。\r\n","categories":["Software","Git"],"tags":["Hexo","NexT","Software","Git"]},{"title":"JitsiMeet 获取所有的房间列表","url":"/posts/2023/220EMHS.html","content":"当部署 jitsi-meet\r\n后，若与现有的系统进行集成，需要获取当前所有活动的房间列表来方便管理。此时需要通过\r\nprosody 提供的 lua 插件来实现。\r\n\r\n本文基于 docker 部署 jitsi-meet\r\n\r\n\r\n阅读本文时请保证有 JitsiMeet docker\r\n部署及设置 jw 授权 相关知识作为前提。\r\n配置\r\n使用 jitsi 提供的 muc_census,muc_size\r\n两个插件来实现，具体配置步骤如下：\r\n映射 prosody 端口\r\n在 prosody 配置中，添加 ports 端口映射\r\n# ...prosody:  ports:    - 7280:5280\r\n修改 .env 文件加载插件\r\n# 添加如下配置# prosody 额外加载的模块XMPP_MODULES=muc_census,muc_size# room_name 完整名称的前缀，在 muc_size 中要用到XMPP_MUC_DOMAIN_PREFIX = muc\r\n\r\nprosody 在 .env 中的所有配置可以通过\r\nprosody\\rootfs\\defaults\\conf.d\\jitsi-meet.cfg.lua\r\n来查看，里面以\r\n$+大写字母的变量都是配置变量，可以根据代码推理每个配置的作用。\r\n\r\n防火墙放行 7280/tcp 端口\r\n# 开放 tcpnetsh advfirewall firewall add rule name=jitsi-prosody-tcp dir=in action=allow protocol=TCP localport=7280\r\nnginx 反向代理\r\n# nginx.conf 主文件http &#123;    include mime.types;\t    # http_servers/jitsi.conf\t# jitsi 会议配置    server &#123;        listen       443 ssl;        server_name  your-prosody-domain;        #ssl_certificate      F:/encrypt/keys/web/iepc/iepc.shenweitech.cn-chain.pem;        #ssl_certificate_key  F:/encrypt/keys/web/iepc/iepc.shenweitech.cn-key.pem;        ssl_certificate      F:/encrypt/keys/root/fullchain.pem;        ssl_certificate_key  F:/encrypt/keys/root/privkey.pem;        ssl_session_cache    shared:SSL:1m;        ssl_session_timeout  5m;        ssl_ciphers  HIGH:!aNULL:!MD5;        ssl_prefer_server_ciphers  on;        location / &#123;\t\t\t            proxy_pass   http://服务器ip:7280;            proxy_connect_timeout 600;            proxy_read_timeout 600;\t\t\t            proxy_set_header Upgrade $http_upgrade;            proxy_set_header Connection &quot;upgrade&quot;;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;            proxy_set_header Host $host;\t           &#125;\t        add_header Access-Control-Allow-Origin &quot;*&quot;;        default_type &#x27;text/html&#x27;;        charset utf-8;\t&#125;&#125;\r\n使用\r\n获取当前所有房间\r\n\r\nurl：get\r\nhttp://服务器ip:5280/room-census\r\n结果\r\n&#123;  &quot;room_census&quot;: [    &#123;      &quot;room_name&quot;: &quot;test@muc.meet.jitsi&quot;,      &quot;participants&quot;: 2,      &quot;created_time&quot;: 1687876740000    &#125;  ]&#125;\r\n\r\n获取房间的成员\r\n\r\nurl：get\r\nhttp://192.168.3.240:5280/room?room=test&amp;domain=meet.jitsi\r\n其中 room 为需要查看的房间的名称，上述 room_name 中 @\r\n之前的部分\r\n结果\r\n[  &#123;    &quot;display_name&quot;: &quot;test3&quot;,    &quot;jid&quot;: &quot;test@muc.meet.jitsi/8c5f7b20&quot;,    &quot;email&quot;: &quot;&quot;  &#125;,  &#123;    &quot;display_name&quot;: &quot;galens&quot;,    &quot;jid&quot;: &quot;test@muc.meet.jitsi/adc31d69&quot;,    &quot;email&quot;: &quot;&quot;  &#125;]\r\n\r\n如果设置了 jwt 认证，则需要传递一个 token\r\n参数，token 中 payload 的 room 值必须包含查询的房间名或者为\r\n* 号\r\n&#123;    &quot;context&quot;: &#123;        &quot;user&quot;: &#123;            &quot;avatar&quot;: &quot;https:/gravatar.com/avatar/abc123&quot;,            &quot;name&quot;: &quot;John Doe&quot;,            &quot;email&quot;: &quot;jdoe@example.com&quot;,            &quot;id&quot;: &quot;abcd:a1b2c3-d4e5f6-0abc1-23de-abcdef01fedcba&quot;        &#125;,        &quot;group&quot;: &quot;a123-123-456-789&quot;    &#125;,    &quot;aud&quot;: &quot;jitsi&quot;,    &quot;iss&quot;: &quot;my_client&quot;,    &quot;sub&quot;: &quot;meet.jit.si&quot;,    &quot;room&quot;: &quot;test,test-other,so-on&quot;, // 或者 *    &quot;exp&quot;: 1500006923&#125;\r\n参考\r\nGet the\r\nlist of rooms - Developers / Jitsi Meet API - Jitsi Community Forum -\r\ndevelopers &amp; users\r\njitsi-meet/resources/prosody-plugins/mod_muc_census.lua\r\nat master · jitsi/jitsi-meet · GitHub\r\njitsi-meet/resources/prosody-plugins/mod_muc_size.lua\r\nat master · jitsi/jitsi-meet · GitHub\r\n","categories":["Software","JitsiMeet"],"tags":["Software","Jitsi"]},{"title":"JitsiMeet Docker 安装及负载均衡配置","url":"/posts/2023/2WH7C5Z.html","content":"\r\n\r\nimage-20230625233244755\r\n\r\njitsi 是一款开源的视屏会议软件，最大支持 75\r\n人同时在线。本文将介绍如何在 docker 中安装和使用 jitsi。本文主要以\r\nUbuntu 为例，若是 Windows，建议使用 wsl 进行安装。\r\n\r\n安装 Docker\r\nWindows: 下载 Download Docker\r\nDesktop | Docker 进行安装\r\nUbuntu: Install Docker\r\nEngine on Ubuntu\r\n安装 Jitsi-meet\r\n本节主要参考：Self-Hosting\r\nGuide - Docker | Jitsi Meet\r\n\r\n下载最新发布版本\r\n# 查找最新版本下载地址，然后使用 wget 下载# 下载后的文件可能没有后缀，需要使用 mv 添加一个 `.zip` 后缀wget $(curl -s https://api.github.com/repos/jitsi/docker-jitsi-meet/releases/latest | grep &#x27;zip&#x27; | cut -d\\&quot; -f4)\r\n解压\r\nunzip &lt;filename&gt;\r\n配置 .env\r\n# 复制示例配置cp env.example .env\r\n设置强密码\r\n# linux 中，在 .env 目录中执行# 若执行报错，主检查 ./gen-passwords.sh 的结束符是否为 LF# 可以通过 cat ./gen-passwords.sh -ne 查看结束符，若为 ^M$ 为则 CRLF，若为 $ 则是 LF bash ./gen-passwords.sh\r\n创建所需的 CONFIG 目录\r\nLinux\r\nmkdir -p ~/.jitsi-meet-cfg/&#123;web,transcripts,prosody/config,prosody/prosody-plugins-custom,jicofo,jvb,jigasi,jibri&#125;\r\nWindows\r\necho web,transcripts,prosody/config,prosody/prosody-plugins-custom,jicofo,jvb,jigasi,jibri | % &#123; mkdir &quot;~/.jitsi-meet-cfg/$_&quot; &#125;\r\n启动服务\r\ndocker compose up -d\r\n浏览器访问 https://localhost:8443\r\n\r\n下面将介绍如何进行生产环境配置，修改完成后，需要再次执行以下命令重新应用配置\r\ndocker compose downdocker compose up -d\r\n修改 .env 进行自定义配置\r\n编辑 .env 文件\r\nvim .env\r\n修改内容如下：\r\n# 修改 Docker 对外暴露的端口# Exposed HTTP portHTTP_PORT=7080# Exposed HTTPS portHTTPS_PORT=7043# 修改访问的网址# Public URL for the web service (required)# 如果是本机测试，不要添加协议，但要添加端口，如下# PUBLIC_URL=192.168.3.240:7043# 若是外部地址非 443 端口，需要自行添加PUBLIC_URL=https://yourdomain# 容器主机的 IP, 当服务器位于 NAT 环境时，需要配置# 特别注意，要同时配置容器 host ip 和 public ipJVB_ADVERTISE_IPS=192.168.23.12,public-ip# 添加 jwt 认证# Enable authenticationENABLE_AUTH=1# 创建房间后，其他人只需要输入房间名称即可进入# Enable guest accessENABLE_GUESTS=1# Select authentication type: internal, jwt, ldap or matrixAUTH_TYPE=jwt# JWT authentication# Application identifierJWT_APP_ID=my_jitsi_app_id# Application secret known only to your token generatorJWT_APP_SECRET=my_jitsi_app_secret# 取消自动赋予 ownerENABLE_AUTO_OWNER=false\r\n所有 .env 的配置，可在以下地方查到：\r\ndocker-jitsi-meet/jicofo/rootfs/defaults/jicofo.conf\r\n配置 jwt 授权\r\njitsi 默认任何人都可以创建房间，为了使自建的 jitsi\r\n资源不被恶意使用，需要限制创建房间的权限。\r\n通过 修改 .env 配置文件\r\n来添加权限认证，当 ENABLE_AUTH=1 后，只有有合法正确的\r\njwt 值时，才可以新建房间。\r\n具体的 .env 配置如下\r\n# Select authentication type: internal, jwt, ldap or matrixAUTH_TYPE=jwt# JWT authentication# Application identifierJWT_APP_ID=my_jitsi_app_id# Application secret known only to your token generatorJWT_APP_SECRET=my_jitsi_app_secret\r\n在生成 jwt 时，payload 内容如下：\r\n&#123;  &quot;context&quot;: &#123;    &quot;user&quot;: &#123;      &quot;avatar&quot;: &quot;https:/gravatar.com/avatar/abc123&quot;,      &quot;name&quot;: &quot;John Doe&quot;,      &quot;email&quot;: &quot;jdoe@example.com&quot;,      &quot;id&quot;: &quot;abcd:a1b2c3-d4e5f6-0abc1-23de-abcdef01fedcba&quot;,      &quot;affiliation&quot;: &quot;owner or member&quot;, // 需要使用 mod_token_affiliation 插件    &#125;,    &quot;group&quot;: &quot;a123-123-456-789&quot;  &#125;,  &quot;aud&quot;: &quot;*&quot;,  &quot;iss&quot;: &quot;your_app_id&quot;,  &quot;sub&quot;: &quot;meet.jitsi.com&quot;,  &quot;room&quot;: &quot;your_room or *&quot;,  &quot;moderator&quot;: true, // 需要使用 mod_token_moderation 插件  &quot;nbf&quot;: 1664475176,  &quot;exp&quot;: 1695998576&#125;\r\n可以通过 JSON Web Tokens -\r\njwt.io 来生成 token，然后在 url 后面添加 jwt=your-token\r\n参数来传递授权进行使用。\r\n例如：https://your-domain/room-name?jwt=your-token\r\n插件\r\n插件位置\r\n从 docker-compose.yml 文件中可知，自定义插件被挂载到了\r\n${CONFIG}/prosody/prosody-plugins-custom\r\n中，$(CONFIG) 默认值为 ~/.jitsi-meet-cfg。\r\n\r\n\r\nimage-20241108110315365\r\n\r\n因此，可以将自定义插件保存到\r\n~/.jitsi-meet-cfg/prosody/prosody-plugins-custom。\r\n插件查找\r\n当功能不满足要求时，可以从以下地址查找插件实现：\r\n\r\njitsi-contrib/prosody-plugins:\r\nProsody plugins for Jitsi\r\njitsi-meet/resources/prosody-plugins\r\n在 github 上搜索 jitsi mod\r\n\r\n设置用户角色\r\njitsi 默认所有使用 token\r\n加入会议的用户都有主持人，为了更好地管理会议，可以使用插件通过 token 的\r\npayloads 来分配所属角色。\r\n目前找到两个插件皆可实现该功能，但测试下来，都有一些 bug :\r\n\r\nprosody-plugins/token_affiliation\r\n这个插件通过在用户加入会议后，再次修改角色来实现权限控制，但它存在滞后性，经常用户加入会议后，提示为主持人，然后才被修改为普通成员\r\njitsi-token-moderation-plugin/mod_token_moderation.lua\r\n这个插件通过重写 set_affiliation 方法来实现控制\r\n但是会议中，无法为其它用户分配主持人角色\r\n\r\n经权衡，最终选择方案 2\r\nmod_token_affiliation 插件\r\n插件安装\r\ncd ~/.jitsi-meet-cfg/prosody/prosody-plugins-custom# 下载wget -O mod_token_affiliation.lua https://raw.githubusercontent.com/jitsi-contrib/prosody-plugins/main/token_affiliation/mod_token_affiliation.lua\r\n启用插件\r\n打开 .env 文件，添加如下内容：\r\n# 取消自动赋予 ownerENABLE_AUTO_OWNER=false# 启用组件，多个组件之间使用 , 号分隔# token_verification 是系统默认的组件XMPP_MUC_MODULES=token_verification,token_affiliation\r\n生成 token 时，向 content.user 中添加 affiliation\r\n字段，示例如下：\r\n&#123;  &quot;aud&quot;: &quot;myapp&quot;,  &quot;iss&quot;: &quot;myapp&quot;,  &quot;sub&quot;: &quot;meet.mydomain.com&quot;,  &quot;iat&quot;: 1601366000,  &quot;exp&quot;: 1601366180,  &quot;room&quot;: &quot;*&quot;,  &quot;context&quot;: &#123;    &quot;user&quot;: &#123;      &quot;name&quot;: &quot;myname&quot;,      &quot;email&quot;: &quot;myname@mydomain.com&quot;,      &quot;affiliation&quot;: &quot;owner&quot; // 选项: owner、member、空     &#125;  &#125;&#125;\r\n方案 2\r\n安装插件\r\ncd ~/.jitsi-meet-cfg/prosody/prosody-plugins-custom# 下载wget https://raw.githubusercontent.com/nvonahsen/jitsi-token-moderation-plugin/refs/heads/master/mod_token_moderation.lua\r\n启用插件\r\n打开 .env 文件，添加如下内容：\r\n# 启用组件，多个组件之间使用 , 号分隔XMPP_MUC_MODULES=token_moderation\r\n生成 token 时，添加 moderator 字段，示例如下：\r\n&#123;  &quot;context&quot;: &#123;    &quot;user&quot;: &#123;      &quot;avatar&quot;: &quot;https:/gravatar.com/avatar/abc123&quot;,      &quot;name&quot;: &quot;John Doe&quot;,      &quot;email&quot;: &quot;jdoe@example.com&quot;,      &quot;id&quot;: &quot;abcd:a1b2c3-d4e5f6-0abc1-23de-abcdef01fedcba&quot;,      &quot;affiliation&quot;: &quot;owner or member&quot;, // 需要使用 mod_token_affiliation 插件    &#125;,    &quot;group&quot;: &quot;a123-123-456-789&quot;  &#125;,  &quot;aud&quot;: &quot;*&quot;,  &quot;iss&quot;: &quot;your_app_id&quot;,  &quot;sub&quot;: &quot;meet.jitsi.com&quot;,  &quot;room&quot;: &quot;your_room or *&quot;,  &quot;moderator&quot;: true, // 需要使用 mod_token_moderation 插件  &quot;nbf&quot;: 1664475176,  &quot;exp&quot;: 1695998576&#125;\r\n添加事件回调\r\n本节主要参考：prosody-plugins/event_sync\r\njitis meet 使用 prosody 进行即时通讯，诸多业务都可以使用 prosody\r\n插件来实现，本节使用event_sync/mod_event_sync_component.lua\r\n插件来实现事件回调\r\n为了接入既有系统，需要获取会议的创建结束信息，通过该插件来添加事件回调到既有的系统中。\r\n插件安装\r\n# 进入自定义插件库cd ~/.jitsi-meet-cfg/prosody/prosody-plugins-custom# 下载插件wget -O mod_event_sync_component.lua https://raw.githubusercontent.com/jitsi-contrib/prosody-plugins/main/event_sync/mod_event_sync_component.lua\r\n插件修改\r\n\r\n可以使用 vscode 远程服务器后对文件进行修改\r\n\r\n回调返回 display_name\r\n原插件没有返回用户的\r\ndisplay_name，当用户通过网址进入时，无法确定用户的身份，因此需要返回用户自己设置的\r\ndisplay_name 供回调服务器处理。\r\n修改 occupant_joined 调用：\r\n-- 找到 occupant_joined 函数调用位置-- 将local occupant_data = room_data:on_occupant_joined(occupant_jid, event.origin);-- 修改为local occupant_data = room_data:on_occupant_joined(occupant_jid, event);\r\n修改 EventData:on_occupant_joined 函数：\r\n-- 找到 EventData:on_occupant_joined 函数,修改为如下代码：function EventData:on_occupant_joined(occupant_jid, event)    local event_origin = event.origin    local user_context = event_origin.jitsi_meet_context_user or &#123;&#125;;    -- get displayName    local display_name = event.occupant:get_presence():get_child_text(&#x27;nick&#x27;, &#x27;http://jabber.org/protocol/nick&#x27;);    -- N.B. we only store user details on join and assume they don&#x27;t change throughout the duration of the meeting    local occupant_data = &#123;        occupant_jid = occupant_jid,        name = user_context.name,        id = user_context.id,        email = user_context.email,        joined_at = now(),        left_at = nil,        display_name = display_name    &#125;;    self.occupants[occupant_jid] = occupant_data;    self.active[occupant_jid] = true;    return occupant_data;end\r\n添加单点参会功能\r\n\r\n可选，实践下来不太好用\r\n\r\n本节参考：mod_http_muc_kick\r\n- Prosody Community Modules\r\n当用户加入后，检测是否有同名用户，若有，则踢出存在的同名用户，保证同一时间，只有一个同名用户参会\r\n-- 1. 在顶部添加导入local st = require &quot;util.stanza&quot;-- 2. 找到 function occupant_joined(event) 方法，在 `local occupant_data = room_data:on_occupant_joined(occupant_jid, event);` 之后添加如下代码for _, occupant in room:each_occupant() do            local pr = occupant:get_presence();    local displayName = pr:get_child_text(            &#x27;nick&#x27;, &#x27;http://jabber.org/protocol/nick&#x27;);            if displayName == occupant_data.display_name and occupant.nick~=occupant_data.nick then        -- 获取原用户的角色, 若为moderator, 则将新用户设置为moderator        local oldRole = room:get_role(occupant.nick);        room:set_role(true, occupant.nick, nil);        if oldRole == &#x27;moderator&#x27; then            room:set_role(true, occupant_data.occupant_jid, &#x27;moderator&#x27;);            room:set_affiliation(true, occupant_data.occupant_jid, &#x27;owner&#x27;);        end        \t\troom:set_role(true, occupant.nick, nil);        module:log(&#x27;info&#x27;, &#x27;踢出用户 %s kicked %s from %s&#x27;,displayName, occupant.nick, room.jid);                     -- 发送 kickParticipant 命令        local presence = st.presence(&#123;            to = occupant.jid,            from = room.jid,            type = &quot;unavailable&quot;        &#125;):tag(&quot;status&quot;):text(&quot;你已被移出房间 &quot; .. room.jid):up();        module:send(presence);    endend\r\n启用插件\r\n向 ~/.jitsi-meet-cfg/prosody/config/conf.d 目录中添加以\r\n.cfg.lua 为后缀的配置文件，配置文件格式参考\r\n~/.jitsi-meet-cfg/prosody/config/prosody.cfg.lua。\r\n~/.jitsi-meet-cfg/prosody/config/prosody.cfg.lua 是\r\nprosody 的配置入口文件，conf.d 目录中任何 .cfg.lua\r\n都会被包含在这个配置中。\r\n每个插件建议都新建一个配置文件，保证配置独立。\r\n# 进入到配置目录cd ~/.jitsi-meet-cfg/prosody/config/conf.d# 创建 event_sync.cfg.lua 配置sudo touch event_sync.cfg.lua\r\n编辑 sudo vim event_sync.cfg.lua\r\n配置，添加如下内容：\r\nComponent &quot;event_sync.meet.jitsi&quot; &quot;event_sync_component&quot;    muc_component = &quot;conference.meet.jitsi&quot;    api_prefix = &quot;http://your.api.server/api&quot;\r\n注意：api_prefix 末尾没有 / 号\r\n\r\n更多配置，参考：prosody-plugins/event_sync/README.md\r\n\r\n该组件回调的 api\r\n为：post http://your.api.server/api/events/xx\r\n触发的事件回调如下：\r\nlocal URL_EVENT_ROOM_CREATED = api_prefix..&#x27;/events/room/created&#x27;;local URL_EVENT_ROOM_DESTROYED = api_prefix..&#x27;/events/room/destroyed&#x27;;local URL_EVENT_OCCUPANT_JOINED = api_prefix..&#x27;/events/occupant/joined&#x27;;local URL_EVENT_OCCUPANT_LEFT = api_prefix..&#x27;/events/occupant/left&#x27;;\r\n打开防火墙端口\r\ndocker-jitsi-meeting 中的通信结构如下图所示\r\n\r\n\r\n80,443/tcp 是 UI 的 web 端口\r\n80,443 通过 修改 .env 配置文件\r\n章节进行指定，本文中分别修改为：7080，7043\r\n10000/udp 是 RTP media 端口，即 Jitsi Vedio Bridge\r\n使用的端口\r\n\r\n通过以下命令新建防火墙入站规则：\r\nwindows 中：\r\n# 开放 tcpnetsh advfirewall firewall add rule name=jitsi-meeting-tcp dir=in action=allow protocol=TCP localport=7043,7080# 开放 udpnetsh advfirewall firewall add rule name=jitsi-meeting-udp dir=in action=allow protocol=UDP localport=10000\r\nubuntu 中：\r\nsudo ufw allow 7043,7080/tcpsudo ufw allow 10000/udp\r\n配置端口转发\r\n若服务器位于 NAT 中，需要在 NAT 中配置端口转发，将外网的\r\n80/tcp,443/tcp,10000/udp\r\n端口分别转发到服务器对应的端口上。\r\n配置 nginx 反向代理\r\n有时候外网的80,443 被 nginx 占用了，我们需要设置 nginx\r\n反向代理 jitsi，此时需要将 10000/udp 转发到 docker\r\n所在服务器，然后在 nginx 中添加如下设置：\r\n# nginx.conf 主文件http &#123;    include mime.types;\t    # http_servers/jitsi.conf\t# jitsi 会议配置    server &#123;        listen       443 ssl;        server_name  yourdomain;        ssl_certificate      F:/encrypt/keys/root/fullchain.pem;        ssl_certificate_key  F:/encrypt/keys/root/privkey.pem;        ssl_session_cache    shared:SSL:1m;        ssl_session_timeout  5m;        ssl_ciphers  HIGH:!aNULL:!MD5;        ssl_prefer_server_ciphers  on;        location / &#123;\t\t\t            proxy_pass   https://192.168.23.12:7043;            proxy_connect_timeout 600;            proxy_read_timeout 600;\t\t\t            proxy_set_header Upgrade $http_upgrade;            proxy_set_header Connection &quot;upgrade&quot;;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;            proxy_set_header Host $host;\t           &#125;        location /xmpp-websocket &#123;            proxy_pass https://192.168.23.12:7043;            proxy_http_version 1.1;            proxy_set_header Upgrade $http_upgrade;            proxy_set_header Connection &quot;upgrade&quot;;        &#125;        location /colibri-ws &#123;            proxy_pass https://192.168.23.12:7043;            proxy_http_version 1.1;            proxy_set_header Upgrade $http_upgrade;            proxy_set_header Connection &quot;upgrade&quot;;        &#125;\t        add_header Access-Control-Allow-Origin &quot;*&quot;;        default_type &#x27;text/html&#x27;;        charset utf-8;\t&#125;&#125;\r\n完成上述步骤的设置后，即可通过 https://yourdomain\r\n来进行访问了\r\n通过 IFrame 集成进现有系统\r\n可以使用 IFrame API与现有系统进行集成。\r\n\r\n加载 external_api\r\n&lt;script src=&#x27;https://&lt;your-domain&gt;/external_api.js&#x27;&gt;&lt;/script&gt;\r\n实例化 api\r\napi = new JitsiMeetExternalAPI(domain, options)\r\n\r\ndomain 不带协议号（https/http）\r\noptions 见 IFrame\r\nAPI | Jitsi Meet\r\n\r\n\r\njitsi 更新\r\n本节从 stable-9799 到 stable-9955 升级作为示例。\r\n# 进入到存放版本数据的根目录# 下载最新版本文件wget $(curl -s https://api.github.com/repos/jitsi/docker-jitsi-meet/releases/latest | grep &#x27;zip&#x27; | cut -d\\&quot; -f4)# 获取当前最新版本Jitsi_latest_name=$(curl -s https://api.github.com/repos/jitsi/docker-jitsi-meet/releases/latest | jq -r &#x27;.name&#x27;)jitsi_latest_dir_name=$(unzip -l $Jitsi_latest_name | grep &quot;/$&quot; | head -1 | awk &#x27;&#123;print $NF&#125;&#x27; | sed &#x27;s/\\/$//&#x27;)# 解压文件unzip $Jitsi_latest_name# 删除原文件rm $Jitsi_latest_namemv $jitsi_latest_dir_name $Jitsi_latest_name# 获取上一次最新的版本jitsi_previous_dir_name=$(ls -1dt */ | sed -n &#x27;2p&#x27; | tr -d &#x27;/&#x27;)# 将原来的 .env 复制到新的安装目录中cp ./$jitsi_previous_dir_name/.env ./$Jitsi_latest_name/.env# 拉取新版本docker compose -f ./$Jitsi_latest_name/docker-compose.yml pull# 停止原来的 dockerdocker compose -f ./$jitsi_previous_dir_name/docker-compose.yml down# 启动新的版本docker compose -f ./$Jitsi_latest_name/docker-compose.yml up -d\r\njitsi 迁移\r\n若需要迁移 jitsi 到其它服务器，可按以下步骤进行：\r\n\r\n复制 ~/.jitsi-meet-cfg 到新服务器对应位置\r\n清空 ~/.jitsi-meet-cfg/prosody/config/certs 目录\r\n复制 jitsi 的 docker 环境配置文件 .env 到新服务器的 docker-compose\r\n目录，参考 安装 Jitsi-meet 章节\r\n创建容器并启动\r\n放行端口\r\n重新映射 10000 端口到新服务器\r\n\r\njitsi 相关镜像简介\r\n\r\nbase\r\nDebian stable base image with the S6 Overlay for process control and\r\nthe Jitsi repositories enabled. All other images are based on this\r\none.\r\nbase-java\r\nSame as the above, plus Java (OpenJDK).\r\nweb\r\n\r\nJitsi Meet web UI, served with nginx.\r\n\r\nJitsi Meet 的 web 界面\r\nprosody\r\n\r\nProsody, the XMPP server.\r\n\r\n用于即时通讯的开源库\r\njicofo\r\nJicofo, the XMPP focus component.\r\njvb\r\n\r\nJitsi Videobridge, the video router.\r\n\r\nJitsi 的视屏中转中心，处理视屏流的分发\r\njigasi\r\nJigasi, the SIP (audio only) gateway.\r\njibri\r\nJibri, the broadcasting infrastructure.\r\n\r\n参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\njitsi/docker-jitsi-meet:\r\nJitsi Meet on Docker\r\nSelf-Hosting\r\nGuide - Docker | Jitsi Meet\r\nlib-jitsi-meet/doc/tokens.md\r\nat master · jitsi/lib-jitsi-meet · GitHub\r\nprosody-plugins/event_sync/README.md\r\nat main · jitsi-contrib/prosody-plugins · GitHub\r\nIFrame\r\nAPI | Jitsi Meet\r\nA\r\ntutorial on how to customize the Jitsi meet front end -\r\nMeetrix.IO\r\nJSON\r\nWeb Token (JWT) authentication Prosody plugin\r\njitsi-meet/resources/prosody-plugins\r\nThe Jitsi\r\nJSON Web Token (JWT)\r\n","categories":["Software","JitsiMeet"],"tags":["Software","Jitsi"]},{"title":"JitsiMeet 中 Prosody 插件配置","url":"/posts/2023/3G2MHZ7.html","content":"在私有化部署 jitsi-meet 后，通过配置其中的 prosody\r\n服务，可以实现更加多样化的功能，比如获取房间信息、获取房间用户信息、配置回调等等。\r\n本文将简要介绍 prosody 插件系统，方便读者快速上手。\r\n\r\n本文基于 docker 的安装方式来进行介绍\r\n\r\n\r\n阅读本文时请保证有 JitsiMeet docker\r\n部署及设置 jw 授权 相关知识作为前提。\r\n简介\r\nprosody 使用的插件为 lua 脚本，可用 lua 插件位于 jitsi-meet/resources/prosody-plugins，可以查看源代码理解其功能。\r\n加载插件\r\nprosody 的配置文件位于\r\nprosody\\rootfs\\defaults\\conf.d\\jitsi-meet.cfg.lua 中。\r\n插件注册\r\n注册插件的格式如下，以 event_sync_component\r\n为例：\r\nComponent &quot;event_sync.&#123;&#123; $XMPP_DOMAIN &#125;&#125;&quot; &quot;event_sync_component&quot;    muc_component = &quot;conference.&#123;&#123; $XMPP_DOMAIN &#125;&#125;&quot;    api_prefix = &quot;http://127.0.0.1:7001/call-back/prosody&quot;\r\n\r\n注意：这个方式需要重新编译 prosody 镜像文件，如果觉得麻烦，可以使用第\r\n3 节中的在 docker 中使用自定义插件\r\n\r\nComponent 介绍：\r\n在 Lua 中，Component 是 Prosody XMPP\r\n服务器中的一个模块，用于定义一个组件（component）。组件是一种特殊类型的\r\nXMPP 实体，可以与其他 XMPP 实体进行通信，但是它们通常不具有完整的 XMPP\r\n功能。组件通常用于扩展 XMPP\r\n服务器的功能，例如添加聊天室、文件传输等功能。\r\nComponent 模块用于定义一个组件，并将其添加到 Prosody\r\nXMPP 服务器中。它接受一个 Lua 表作为参数，该表包含组件的配置信息。\r\n在上例中，\"event_sync.&#123;&#123; $XMPP_DOMAIN &#125;&#125;\"\r\n表示注册的模块的名称，\"event_sync_component\"\r\n表示组件的名称，组件名称为组件定义的文件名\r\nmod_event_sync_component.lua 的中间部分。\r\n插件变量\r\n插件中通过 module:get_option(\"api_headers\") 来获取\r\njitsi-meet.cfg.lua 中定义的变量。例：\r\nlocal api_timeout = module:get_option(&quot;api_timeout&quot;, 20);local api_headers = module:get_option(&quot;api_headers&quot;);local api_retry_count = tonumber(module:get_option(&quot;api_retry_count&quot;, 3));local api_retry_delay = tonumber(module:get_option(&quot;api_retry_delay&quot;, 1));\r\n在 jitsi-meet.cfg.lua 中通过 “&#123;&#123;.Env.fieldName&#125;&#125;”\r\n的方式来获取 .env 文件中定义的变量，注意引号不要丢。例：\r\nexternal_service_secret = &quot;&#123;&#123;.Env.TURN_CREDENTIALS&#125;&#125;&quot;;\r\n\r\n特别注意：修改 jitsi-meet.cfg.lua\r\n内容并不会生效，因为重启 docker\r\n后会重置这个配置文件，该文件仅作为一个参考，仅在 .env\r\n文件中的修改才会生效。\r\n\r\n在 docker 中使用自定义的插件\r\n若使用 docker 安装 jitsi-meet，每当 prosody 服务重启后都会重置\r\nconf.d\\jitsi-meet.cfg.lua 文件，因此无法在\r\njitsi-meet.cfg.lua 文件中通过 Component\r\n的方式来注册插件。\r\n可以使用以下的方法来解决：\r\n\r\n将自定义插件保存到\r\n.jitsi-meet-cfg\\prosody\\prosody-plugins-custom\r\n目录中，这个目录被 prosody 所挂载\r\n修改插件的源文件，使其中的参数符合自己的使用环境\r\n在 .env 文件中使用\r\nXMPP_MUC_MODULES=event_sync_component 来启用\r\nevent_sync_component 插件\r\n\r\n在 docker 中修改插件\r\n使用 docker 安装后，如果需要修改 docker 中的 prosody\r\n插件，可以通过以下步骤修改：\r\n\r\n打开 docker，切换到【Container】，进入到 prosody\r\n容器中\r\n\r\n\r\nimage-20230627230120904\r\n\r\n找到【Files/prosody-plugins】，找到想要修改的插件，双击修改并保存，然后重启容器即可应用修改\r\n\r\n\r\nimage-20230627230335324\r\n\r\n\r\n参考\r\njitsi-meet/resources/prosody-plugins\r\nat master · jitsi/jitsi-meet · GitHub\r\nThird-Party\r\nSoftware | Jitsi Meet\r\njitsi-contrib/prosody-plugins:\r\nProsody plugins for Jitsi (github.com)\r\n","categories":["Software","JitsiMeet"],"tags":["Software","jitsi"]},{"title":"JitsiMeet 进行压力测试","url":"/posts/2023/3G78E45.html","content":"当私有化部署 jitsi-meet\r\n后，需要对它进行压力测试来评估其性能，通过官方提供的 jitsi/jitsi-meet-torture\r\n工具来进行测试评估。\r\n在 windows docker 环境下，未能成功部署测试。最后使用 python 通过\r\nselenium 来模拟多个用户实现了测试。\r\n\r\n代码\r\npython 实现代码如下：\r\nfrom selenium import webdriverfrom selenium.webdriver.common.by import Byimport timefrom selenium.webdriver.edge.service import Serviceclass CacheStore:    service = None    driver = Nonedef get_edge_driver():    &quot;&quot;&quot;    获取 Edge 浏览器驱动    :return:    &quot;&quot;&quot;    if CacheStore.driver is not None:        return CacheStore.driver    if CacheStore.service is None:        CacheStore.service = Service(service_args=[&quot;--verbose&quot;])    # 默认设置    options = webdriver.EdgeOptions()    # 设置 ms:inPrivate 为 True，关闭个性化设置弹窗    options.set_capability(&quot;ms:inPrivate&quot;, True)    options.add_argument(&quot;--headless&quot;)    driver = webdriver.Edge(service=CacheStore.service, options=options)    driver.set_window_size(1920, 1080)    return driverdef join_participants(room_instance_url):    driver = get_edge_driver()    driver.get(room_instance_url)    # 获取用户名并输入    username_input = driver.find_element(        By.CSS_SELECTOR, &quot;.css-1m7m6m3-fieldContainer input&quot;    )    # 使用时间戳为用户名    user_name = str(int(time.time()))    username_input.send_keys(user_name)    # 单击加入会议按钮    join_button = driver.find_element(By.CSS_SELECTOR, &quot;.css-1hbmoh1-actionButton&quot;)    join_button.click()    # 等待 1 秒    time.sleep(0.5)    # 单击视屏按钮    try:        video_button = driver.find_element(By.CSS_SELECTOR, &quot;.display-video .jss29&quot;)        print(&quot;user: &#123;&#125; join meeting and show screen&quot;.format(user_name))        video_button.click()    except Exception as e:        print(&quot;user: &#123;&#125; join meeting with no screen&quot;.format(user_name))        passif __name__ == &quot;__main__&quot;:    # 循环创建 100 个用户    for i in range(100):        join_participants(&quot;https://meeting.cn/test&quot;)    # 等待 10 分钟    time.sleep(600)\r\n参考\r\nLoad\r\nTesting Jitsi Meet - Meetrix.IO\r\nJitsi-Meet\r\nTorture/Load Test with Docker and JWT\r\njitsi/jitsi-meet-torture\r\n(github.com)\r\n","categories":["Software","JitsiMeet"],"tags":["Software","Jitsi"]},{"title":"JitsiMeet 使用 Docker 私有化部署获取事件回调","url":"/posts/2023/YQ1DGH.html","content":"私有化部署 jitsi-meet 后，可以通过 prosody 服务的\r\nevent_sync_component 插件来向指定服务器回调事件。\r\n该插件支持的事件有：\r\n\r\n房间创建\r\n房间释放\r\n用户加入\r\n用户退出\r\n\r\n\r\n简介\r\n当事件被触发后，该组件将会向指定的外部 API 发送 Post 请示，请求体为\r\nJson 格式。\r\n如果使用 JWT token 认证的话，同时还会发送 token 中 context 中的\r\nname，email 和 id。\r\n安装\r\n\r\n本文通过 docker 的方式安装的 jitsi-meet，这种安装方式不支持通过\r\nComponent\r\n的方式手动注册插件，也无法添加额外的配置变量。\r\n因此需要改动插件的源代码，使其符合自己的使用需求\r\n\r\n下载插件\r\n# 打开 powershell# 查找 prosody 容器的 iddocker ps -f name=prosody# 假设 id 为：f04634fde422docker exec -it f04634fde422 /bin/bash# 进入 prosody-plugins-custom 目录cd prosody-plugins-custom/# 下载 event_sync_component 插件到该目录wget -O mod_event_sync_component.lua https://raw.githubusercontent.com/jitsi-contrib/prosody-plugins/main/event_sync/mod_event_sync_component.lua\r\n修改插件\r\n\r\n可以使用 vscode 远程服务器后，安装 Docker\r\n插件对容器进行对文件进行修改\r\n\r\n\r\n修改变量\r\n由于prosody镜像的原因，导致无法直接配置 prosody\r\n变量，因此为了能够可以使用插件，打开插件源代码，对里面的部分定义进行修改，内容如下：\r\n-- 为 prosody 虚拟机环境的地址，一般都为 muc.meet.jitsilocal main_muc_component_host = &quot;muc.meet.jitsi&quot;;-- 将其修改成回调服务器地址即可local api_prefix = &quot;http://192.168.3.240:7001/api/v1/callbacks&quot;;\r\n返回 display_name\r\n原插件没有返回用户的\r\ndisplay_name，当用户通过网址进入时，无法确定用户的身份，因此需要返回用户自己设置的\r\ndisplay_name 供回调服务器处理。\r\n修改 occupant_joined：\r\n-- 找到 occupant_joined 函数-- 将local occupant_data = room_data:on_occupant_joined(occupant_jid, event.origin);-- 修改为local occupant_data = room_data:on_occupant_joined(occupant_jid, event);\r\n修改 EventData:on_occupant_joined：\r\n-- 找到 EventData:on_occupant_joined 函数,修改为如下代码：function EventData:on_occupant_joined(occupant_jid, event)    local event_origin = event.origin    local user_context = event_origin.jitsi_meet_context_user or &#123;&#125;;    -- get displayName    local display_name = event.occupant:get_presence():get_child_text(&#x27;nick&#x27;, &#x27;http://jabber.org/protocol/nick&#x27;);    -- N.B. we only store user details on join and assume they don&#x27;t change throughout the duration of the meeting    local occupant_data = &#123;        occupant_jid = occupant_jid,        name = user_context.name,        id = user_context.id,        email = user_context.email,        joined_at = now(),        left_at = nil,        display_name = display_name    &#125;;    self.occupants[occupant_jid] = occupant_data;    self.active[occupant_jid] = true;    return occupant_data;end\r\n\r\n加载插件\r\n向 .env 文件中的 XMPP_MUC_MODULES 添加\r\nevent_sync_component，使该组件生效：\r\nXMPP_MUC_MODULES=muc_census,muc_size,event_sync_component\r\n重新创建容器\r\ndocker-compose up -d\r\n至此，事件回调插件加载成功。\r\n参考\r\nGet\r\ncallbacks on my custom server - Developers - Jitsi Community Forum -\r\ndevelopers &amp; users\r\nprosody-plugins/event_sync/README.md\r\nat main · jitsi-contrib/prosody-plugins · GitHub\r\n","categories":["Software","JitsiMeet"],"tags":["Docker","Software","jitsi"]},{"title":"JitsiMeet 为房间添加描述","url":"/posts/2023/3JD9V8X.html","content":"在搭建 jitsi-meet\r\n后，有时候希望会议中不显示房间名称，而是显示自定义的主题，可以通过以下方法实现。\r\n\r\n在 url 中配置\r\n在 url 中添加 #config.subject=\"your subject\"\r\n配置，如下：\r\nhttps://meet.jit.si/abbe961f-53a0-44de-84e2-177df24cd16#config.subject=&quot;TestMeeting&quot;\r\n\r\n注意：\r\n\r\n房间 id 后面有一个 # 号\r\n主题要用双引号括起来\r\n\r\n\r\n使用租户模式\r\n租户模式格式如下：\r\nhttps://domain.com/tenant/roomname\r\ntenant 代表租户名称，可以通过创建不同的租户来隔离同名的房间\r\n参考\r\nIs\r\nthere any way to add room name/description\r\njitsi-prefix-room-name\r\n","categories":["Software","JitsiMeet"],"tags":["Software","jitsi"]},{"title":"JitsiMeet 通过 JWT 配置用户的主持人角色","url":"/posts/2023/2SE43YW.html","content":"有些时候我们可能需要预定会议，同时允许会议的成员提前加入到会议中，根据\r\njitsi-meet\r\n的逻辑，第一个加入的成员必定为主持人(modertator)，为了保证主持人是会议的预定者，在预定者加入时，我们需要修改预订者的角色为\r\nmoderator。\r\n本文将介绍如何通过JWT 认证来设置用户的主持人角色。\r\n\r\n前提\r\n该方式需要使用 JWT 认证的方式。转到 JitsiMeet docker 部署及设置 jw 授权\r\n了解如果配置 JWT。\r\n安装\r\n\r\n从 jitsi-token-moderation-plugin\r\n下载该插件\r\n按 在 docker\r\n中使用自定义的插件 方法安装插件\r\n\r\n使用\r\n在生成 token 时，包含 moderator 参数即可，例：\r\n&#123;  &quot;context&quot;: &#123;    &quot;user&quot;: &#123;      &quot;avatar&quot;: &quot;https:/gravatar.com/avatar/abc123&quot;,      &quot;name&quot;: &quot;John Doe&quot;,      &quot;email&quot;: &quot;jdoe@example.com&quot;,      &quot;id&quot;: &quot;abcd:a1b2c3-d4e5f6-0abc1-23de-abcdef01fedcba&quot;    &#125;,    &quot;group&quot;: &quot;a123-123-456-789&quot;  &#125;,  &quot;aud&quot;: &quot;*&quot;,  &quot;iss&quot;: &quot;your_app_id&quot;,  &quot;sub&quot;: &quot;meet.example.com&quot;,  &quot;room&quot;: &quot;your_room&quot;,  &quot;moderator&quot;: true,  &quot;nbf&quot;: 1664475176,  &quot;exp&quot;: 1695998576&#125;\r\n\r\n注意：\r\nmoderator 的值是 boolean 值\r\n\r\n当用户使用该 token 加入房间时，就自动设置为主持人了。\r\n参考\r\nSet\r\nrole for meeting participants with API\r\nnvonahsen/jitsi-token-moderation-plugin:\r\nLua plugin for jitsi which determines whether users are moderator or not\r\nbased on token contents (github.com)\r\n","categories":["Software","JitsiMeet"],"tags":["Software","jitsi"]},{"title":"JitsiMeet 配置多个 JVB 实例实现视屏的负载均衡","url":"/posts/2023/3J3YEMD.html","content":"JitsiMeet 中的 jvb\r\n负载均衡是按会议来进行分发的。无法实现同一个会议不同用户的负载均衡。\r\n因此本文未继续研究，以待需要再行补充。\r\n\r\n参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\nDocker\r\nJVB Scaling! - Install &amp; Config / Docker - Jitsi Community Forum -\r\ndevelopers &amp; users\r\nJitsi-Meet\r\n(docker) for a large event - The aftermath! (Server sizing tips) -\r\nInstall &amp; Config - Jitsi Community Forum - developers &amp;\r\nusers\r\njitsi\r\ndocker multiple jvb-掘金 (juejin.cn)\r\n","categories":["Software","JitsiMeet"],"tags":["Software","Jitsi"]},{"title":"MySql 创建用户并设置访问权限","url":"/posts/2025/3HBSA6A.html","content":"为了保证数据库的安全，在 MySql\r\n中，使用不同权限的账号来访问数据库。本文将介绍如何生成用户并赋予其访问权限。\r\n\r\n具体步骤如下：\r\n# 连接到 MySQL 服务器# 使用管理员账号登陆mysql -u root -p# 创建新用户# 用户名为 newuser# 密码为 password# 访问 ip 为 &#x27;localhost&#x27;, 当为 % 时表示允许从任意 ip 访问CREATE USER &#x27;newuser&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;password&#x27;;# 授予新用户访问特定数据库的权限GRANT ALL PRIVILEGES ON dbName.* TO &#x27;newuser&#x27;@&#x27;localhost&#x27;;# 如果只想授予特定权限，可以指定权限类型。例如，只授予 SELECT, INSERT, UPDATE, 和 DELETE 权限：# GRANT SELECT, INSERT, UPDATE, DELETE ON exampledb.* TO &#x27;newuser&#x27;@&#x27;localhost&#x27;;# 刷新权限FLUSH PRIVILEGES;\r\n其它备用命令：\r\n# 修改用户密码# host 指创建用户时指定的 hostALTER USER &#x27;username&#x27;@&#x27;host&#x27; IDENTIFIED BY &#x27;newpassword&#x27;;# 或者SET PASSWORD FOR &#x27;username&#x27;@&#x27;host&#x27; = PASSWORD(&#x27;newpassword&#x27;);\r\n","categories":["Software","MySql"],"tags":["MySql"]},{"title":"JitsiMeet Ubuntu 安装及负载均衡配置","url":"/posts/2023/3K7WKHR.html","content":"\r\n本文介绍基于 Ubuntu 20.04 安装\r\nJitsi-meet，同时实现多个视屏桥的负载均衡。本文只记录安装步骤，安装原理请自行阅读下面的参考文章。\r\n\r\n名词解释\r\nMUC：Multi User Chat\r\nssh 连接 Ubuntu 服务器\r\nssh username@ipInLAN# 示例：ssh yourUserName@192.168.1.1\r\nJitsi-meet 安装\r\n\r\n下列命令中，位于一个代码块中的命令行可以整体复制并运行。\r\n\r\n安装环境准备\r\n# Retrieve the latest package versions across all repositoriessudo apt update# Ensure support for apt repositories served via HTTPSsudo apt install apt-transport-https\r\n# Jitsi requires dependencies from Ubuntu&#x27;s universe package repositorysudo apt-add-repository universe\r\nsudo apt update\r\n设置完全限定域名（FQDN）可选\r\n\r\n设置 hostname\r\nsudo hostnamectl set-hostname meet.example.org\r\n修改 hosts: sudo vim /etc/hosts\r\n向 hosts 里添加如下内容：\r\n127.0.0.1 localhostx.x.x.x meet.example.org\r\n\r\nx.x.x.x 是公网 IP 地址\r\n\r\n测试是否联通\r\nping &quot;$(hostname)&quot;\r\n\r\n添加 Prosody 包\r\nUbuntu 18.04 and 20.04\r\necho deb http://packages.prosody.im/debian $(lsb_release -sc) main | sudo tee -a /etc/apt/sources.listwget https://prosody.im/files/prosody-debian-packages.key -O- | sudo apt-key add -sudo apt install lua5.2\r\nUbuntu 22.04\r\nsudo curl -sL https://prosody.im/files/prosody-debian-packages.key -o /etc/apt/keyrings/prosody-debian-packages.keyecho &quot;deb [signed-by=/etc/apt/keyrings/prosody-debian-packages.key] http://packages.prosody.im/debian $(lsb_release -sc) main&quot; | sudo tee /etc/apt/sources.list.d/prosody-debian-packages.listsudo apt install lua5.2\r\n添加 Jitsi 包\r\nUbuntu 18.04 and 20.04\r\ncurl https://download.jitsi.org/jitsi-key.gpg.key | sudo sh -c &#x27;gpg --dearmor &gt; /usr/share/keyrings/jitsi-keyring.gpg&#x27;echo &#x27;deb [signed-by=/usr/share/keyrings/jitsi-keyring.gpg] https://download.jitsi.org stable/&#x27; | sudo tee /etc/apt/sources.list.d/jitsi-stable.list &gt; /dev/null\r\nUbuntu 22.04\r\ncurl -sL https://download.jitsi.org/jitsi-key.gpg.key | sudo sh -c &#x27;gpg --dearmor &gt; /usr/share/keyrings/jitsi-keyring.gpg&#x27;echo &quot;deb [signed-by=/usr/share/keyrings/jitsi-keyring.gpg] https://download.jitsi.org stable/&quot; | sudo tee /etc/apt/sources.list.d/jitsi-stable.list\r\n更新包\r\nsudo apt update\r\n设置防火墙\r\n防火墙端口简介：\r\n\r\n\r\n\r\n端口\r\n作用\r\n\r\n\r\n\r\n\r\n80/tcp\r\n证书验证与更新接口\r\n\r\n\r\n443/tcp\r\njitsi 访问接口\r\n\r\n\r\n10000/udp\r\nAudio/Video 传输\r\n\r\n\r\n22/tcp\r\nssh\r\n\r\n\r\n3478/udp\r\n用于查找 stun 服务\r\n\r\n\r\n5349/tcp\r\nAudio/Video 交流\r\n\r\n\r\n5222/tcp\r\nxmpp 通信\r\n\r\n\r\n9090/tcp\r\nwebsocket 视屏桥中继\r\n\r\n\r\n\r\n设置命令：\r\nsudo ufw allow 80/tcpsudo ufw allow 443/tcpsudo ufw allow 10000/udpsudo ufw allow 22/tcpsudo ufw allow 3478/udpsudo ufw allow 5349/tcpsudo ufw allow 5222/tcpsudo ufw enable\r\n设置完后查看状态：\r\nsudo ufw status verbose\r\n安装 Jitsi Meet\r\n# jitsi-meet installationsudo apt install jitsi-meet\r\n在安装的过程中，会让你选择证书，若处于 NAT 中，且前端还有一层 Nginx\r\n时，可以使用自签名证书。\r\nNAT 设置\r\n机器位于 NAT\r\n之后，需要打开/etc/jitsi/videobridge/sip-communicator.properties文件：\r\nsudo vim /etc/jitsi/videobridge/sip-communicator.properties\r\n添加以下设置：\r\norg.ice4j.ice.harvest.NAT_HARVESTER_LOCAL_ADDRESS=&lt;Local.IP.Address&gt;org.ice4j.ice.harvest.NAT_HARVESTER_PUBLIC_ADDRESS=&lt;Public.IP.Address&gt;\r\n\r\n参考：want-to-replace-url-for-stun-mapping-harvester-addresses\r\n\r\n修改系统限制\r\nsudo vim /etc/systemd/system.conf\r\n修改为：\r\nDefaultLimitNOFILE=65000DefaultLimitNPROC=65000DefaultTasksMax=65000\r\n查看修改结果：\r\nsystemctl show --property DefaultLimitNPROCsystemctl show --property DefaultLimitNOFILEsystemctl show --property DefaultTasksMax\r\n若没有生效，需要重启系统 sudo reboot 或者重启守护进程\r\nsystemctl daemon-reexec：\r\n到这一步，即可通过域名进行访问\r\n配置参会时输入用户名\r\n打开配置文件：\r\nsudo vim /etc/jitsi/yourDomain-config.js\r\n在第 570 行左右，找到 requireDisplayName，将其修改为\r\ntrue。\r\n重启 prosody\r\nsudo systemctl resetart prosody\r\njwt 授权\r\n为了方便使用 IFrame\r\nAPI\r\n的方式与现有的系统集成，需要配置会议授权，方便对会议进行管理。\r\n配置 JWT\r\nsudo apt-get install jitsi-meet-tokens\r\n安装过程中，会要求输入 ApplicationId 和 Secret：\r\n\r\n\r\nimage-20231102154852501\r\n\r\n生成 token 有格式要求，见：lib-jitsi-meet/doc/tokens.md\r\n生成 token 后，可以在 url 中添加 jwt=xxx\r\n来进行测试。\r\n允许访客进入\r\n打开配置文件：\r\nsudo vim /etc/prosody/conf.d/meet.mydomain.com.cfg.lua\r\n向 VirtualHost \"jitmeet.example.com\" 中添加\r\nallow_empty_token = true：\r\nVirtualHost &quot;jitmeet.example.com&quot;    authentication    = &quot;token&quot;;    app_id            = &quot;example_app_id&quot;;         -- application identifier    app_secret        = &quot;example_app_secret&quot;;     -- application secret known only to your token                                                  -- generator and the plugin    allow_empty_token = true;                     -- tokens are verified only if they are supplied by the client\r\n添加事件回调\r\n为了实现现有系统获取会议的创建结束信息，需要在 jitsi-meet\r\n中添加事件回调到既有的系统中。\r\n插件配置\r\n下载插件：\r\ncd /usr/share/jitsi-meet/prosody-plugins/sudo wget -O mod_event_sync_component.lua https://raw.githubusercontent.com/jitsi-contrib/prosody-plugins/main/event_sync/mod_event_sync_component.lua\r\n启用插件：\r\n打开配置文件\r\nsudo vim /etc/prosody/conf.d/meet.mydomain.com.cfg.lua\r\n添加如下内容\r\n-- 组件域名的主要作用是标识和路由消息到特定的组件, 可以不使用真实的域名Component &quot;event_sync.meet.mydomain.com&quot; &quot;event_sync_component&quot;    muc_component = &quot;conference.meet.mydomain.com&quot;    api_prefix = &quot;http://your.api.server/api&quot;\r\n注意：api_prefix 末尾没有 / 号\r\n\r\n更多配置，参考：prosody-plugins/event_sync/README.md\r\n\r\n回调的 api 为：http://your.api.server/api/events/xx\r\n重启 prosody：\r\nsudo systemctl restart prosody\r\n插件修改\r\n由于允许访客访问，原插件没有返回用户的\r\ndisplay_name，当用户通过网址进入时，无法确定用户的身份，因此需要返回用户自己设置的\r\ndisplay_name 供回调服务器处理。\r\nsudo vim /usr/share/jitsi-meet/prosody-plugins/mod_event_sync_component.lua\r\n\r\n修改 occupant_joined：\r\n-- 找到 occupant_joined(约在 289 行) 函数-- 将local occupant_data = room_data:on_occupant_joined(occupant_jid, event.origin);-- 修改为local occupant_data = room_data:on_occupant_joined(occupant_jid, event);\r\n修改 EventData:on_occupant_joined：\r\n-- 找到 EventData:on_occupant_joined(约在 144 行) 函数,修改为如下代码：function EventData:on_occupant_joined(occupant_jid, event)    local event_origin = event.origin    local user_context = event_origin.jitsi_meet_context_user or &#123;&#125;;    -- get displayName    local display_name = event.occupant:get_presence():get_child_text(&#x27;nick&#x27;, &#x27;http://jabber.org/protocol/nick&#x27;);    -- N.B. we only store user details on join and assume they don&#x27;t change throughout the duration of the meeting    local occupant_data = &#123;        occupant_jid = occupant_jid,        name = user_context.name,        id = user_context.id,        email = user_context.email,        joined_at = now(),        left_at = nil,        display_name = display_name,        nick = event.occupant.nick,        role = event.occupant.role,        stable_id = event.occupant.stable_id,        bare_jid = event.occupant.bare_jid    &#125;;    self.occupants[occupant_jid] = occupant_data;    self.active[occupant_jid] = true;    return occupant_data;end\r\n重启 prosody\r\nsudo systemctl restart prosody\r\n\r\n添加踢出用户功能\r\n当用户加入后，检测是否有同名用户，若有，则踢出存在的同名用户\r\n-- 在顶部添加导入local st = require &quot;util.stanza&quot;-- 找到 function occupant_joined(event) 方法，在 `room_data:on_occupant_joined` 之后添加如下代码for _, occupant in room:each_occupant() do            local pr = occupant:get_presence();    local displayName = pr:get_child_text(            &#x27;nick&#x27;, &#x27;http://jabber.org/protocol/nick&#x27;);            if displayName == occupant_data.display_name and occupant.nick~=occupant_data.nick then        -- 获取原用户的角色, 若为moderator, 则将新用户设置为moderator        local oldRole = room:get_role(occupant.nick);        room:set_role(true, occupant.nick, nil);        if oldRole == &#x27;moderator&#x27; then            room:set_role(true, occupant_data.occupant_jid, &#x27;moderator&#x27;);            room:set_affiliation(true, occupant_data.occupant_jid, &#x27;owner&#x27;);        end        \t\troom:set_role(true, occupant.nick, nil);        module:log(&#x27;info&#x27;, &#x27;踢出用户 %s kicked %s from %s&#x27;,displayName, occupant.nick, room.jid);                     -- 发送 kickParticipant 命令        local presence = st.presence(&#123;            to = occupant.jid,            from = room.jid,            type = &quot;unavailable&quot;        &#125;):tag(&quot;status&quot;):text(&quot;你已被移出房间 &quot; .. room.jid):up();        module:send(presence);    endend\r\n参考：mod_http_muc_kick\r\n- Prosody Community Modules\r\n视频负载均衡\r\n安装环境准备\r\n在另一台主机上执行 安装环境准备 和 添加 Jitsi 包\r\n安装 jitsi-videobridge2\r\nsudo apt install jitsi-videobridge2\r\n修改 sip 配置\r\n分别修改主服务器、视频服务器的配置：\r\nsudo vi /etc/jitsi/videobridge/sip-communicator.properties\r\n禁用主服务器的证书验证：\r\n向 /etc/jitsi/videobridge/sip-communicator.properties\r\n添加如下配置\r\norg.jitsi.videobridge.xmpp.user.shard.DISABLE_CERTIFICATE_VERIFICATION=true\r\n将主服务器的 sip 配置复制到负载均衡服务器\r\norg.ice4j.ice.harvest.DISABLE_AWS_HARVESTER=trueorg.ice4j.ice.harvest.STUN_MAPPING_HARVESTER_ADDRESSES=meet-jit-si-turnrelay.jitsi.net:443org.jitsi.videobridge.ENABLE_STATISTICS=trueorg.jitsi.videobridge.STATISTICS_TRANSPORT=mucorg.jitsi.videobridge.xmpp.user.shard.HOSTNAME=192.168.23.20 # 此处为主服务所在的 iporg.jitsi.videobridge.xmpp.user.shard.DOMAIN=auth.yourdomainorg.jitsi.videobridge.xmpp.user.shard.USERNAME=jvborg.jitsi.videobridge.xmpp.user.shard.PASSWORD=siBYPh4zorg.jitsi.videobridge.xmpp.user.shard.MUC_JIDS=JvbBrewery@internal.yourdomainorg.jitsi.videobridge.xmpp.user.shard.MUC_NICKNAME=8705d9ca-4031-4080-8435-78d1f5f3025e # 此处值应唯一，不与其它服务冲突org.jitsi.videobridge.xmpp.user.shard.DISABLE_CERTIFICATE_VERIFICATION=trueorg.ice4j.ice.harvest.NAT_HARVESTER_LOCAL_ADDRESS=192.168.23.20org.ice4j.ice.harvest.NAT_HARVESTER_PUBLIC_ADDRESS=223.xxx.xxx.xxx\r\n使用 Sctp 模式\r\n增加视频桥后，连接时会报错：\r\n\r\n\r\nimage-20231106111136879\r\n\r\n有两种方式可以解决，本文采用最简单的方式即 Sctp 方式：\r\n编辑文件\r\nsudo vim /etc/jitsi/videobridge/jvb.conf\r\n在 videobridge修改如下内容：\r\n\r\n允许 sctp\r\n关闭 websocket\r\n\r\nsctp &#123;  // Whether SCTP data channels are enabled.  enabled=true,&#125;stats &#123;  // The interval at which stats are gathered.  interval = 5 seconds&#125;websockets &#123;  enabled=false  server-id=&quot;default-id&quot;  // Whether to negotiate WebSocket compression (permessage-deflate)  enable-compression = true            // Optional, even when &#x27;enabled&#x27; is set to true  #tls=true  // The domains used when advertising a colibri-ws URL. Must be set when enabled = true  domains= []  // The domain used when advertising a colibri-relay-ws URL. If empty defaults to the value of `domains`.  relay-domains = []&#125;\r\n同时修改端口\r\n本配置位于 NAT 内，只有一个公网出口，为了不与其它 jitsi-videobridge2\r\n冲突，修改连接端口。\r\n\r\n使用 sctp 后，不需要修改 websocket 端口\r\n\r\n设置防火墙\r\nsudo ufw allow 22/tcpsudo ufw allow 10000/udp # 如果是在 NAT 后面，此处的修改要与其它主机的 jitsi-videobridge2 端口不一样sudo ufw enable\r\n重启服务\r\nsudo service jitsi-videobridge2 restart\r\n查看日志\r\n通过查看日志，可以了解 jitsi-videobridge2\r\n启动情况，并根据日志记录排查错误问题。\r\nsudo cat /var/log/jitsi/jvb.log\r\n配置 OCTO\r\n当配置多个视频桥后，它只能对多个会议进行负载均衡，无法对单个会议生效。因此需要配置\r\nOCTO 来达到这一目的。\r\n打开 octo\r\n编辑文件\r\nsudo vim /etc/jitsi/jicofo/jicofo.conf\r\n增改如下内容：\r\njicofo &#123;  bridge &#123;    selection-strategy = RegionBasedBridgeSelectionStrategy  &#125;  octo &#123;    enabled = true,    id = &quot;1&quot;  &#125;&#125;\r\n基中，selection-strategy 的值有：\r\n\r\nRegionBasedBridgeSelectionStrategy：按地区选择视频桥\r\nSplitBridgeSelectionStrategy：总是使用不同的视频桥，主要用于测试\r\n\r\n视频桥配置适配\r\n打开所有视屏桥服务器如下文件\r\nsudo vim /etc/jitsi/videobridge/sip-communicator.properties\r\n分别增加如下配置\r\norg.jitsi.videobridge.octo.BIND_ADDRESS=x.x.x.x # 当前主机 iporg.jitsi.videobridge.octo.PUBLIC_ADDRESS=x.x.x.x # 公网 iporg.jitsi.videobridge.octo.BIND_PORT=4096org.jitsi.videobridge.REGION=regionVN # 全局唯一\r\n开放端口 4096\r\nsudo ufw allow 4096/tcp\r\n修改视频桥配置：\r\nsudo vim /etc/jitsi/videobridge/jvb.conf\r\n高 sctp 中增加 sctp-datachannels = true\r\nsctp &#123;  // Whether SCTP data channels are enabled.  enabled=true,    // Whether bridge-to-bridge communication should use SCTP datachannels (as opposed to websockets)  sctp-datachannels = true&#125;\r\n重启服务\r\nsudo service jicofo restartsudo service jitsi-videobridge2 restart\r\n本节参考\r\n\r\njitsi-videobridge/doc/relay.md\r\nat master · jitsi/jitsi-videobridge (github.com)\r\n\r\n配置文件路径\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n路径\r\n作用\r\n\r\n\r\n\r\n\r\n/etc/prosody/conf.avail/[your-domain].cfg.lua\r\n域配置\r\n\r\n\r\n/etc/jitsi/meet/[your-domain]-config.js\r\njitsi 系统配置\r\n\r\n\r\n/etc/jitsi/videobridge/config\r\nvideobridge 配置文件\r\n\r\n\r\n/etc/jitsi/videobridge/sip-communicator.properties\r\nsip 配置文件\r\n\r\n\r\n/var/log/prosody\r\nprosody 日志位置\r\n\r\n\r\n/var/log/jitsi/jvb.log\r\njvb 日志位置\r\n\r\n\r\n/var/log/jitsi/jicofo.log\r\njicofo 日志位置\r\n\r\n\r\n/usr/share/jitsi-meet/prosody-plugins/mod_event_sync_component.lua\r\neven_sync 插件位置\r\n\r\n\r\n\r\n其它\r\n如果需要额外的功能，可以通过安装 prosody 模块来实现，详见：Prosody Community\r\nModules\r\n参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\n\r\nSelf-Hosting\r\nGuide - Debian/Ubuntu server | Jitsi Meet\r\njitsi-videobridge/doc\r\nat master · jitsi/jitsi-videobridge (github.com)\r\nlib-jitsi-meet/doc/tokens.md\r\nat master · jitsi/lib-jitsi-meet (github.com)\r\nprosody-plugins/event_sync/README.md\r\nat main · jitsi-contrib/prosody-plugins (github.com)\r\nConfiguration\r\n| Jitsi Meet\r\nScaling\r\nUp Your Jitsi with Jitsi Bridges (doganbros.com)\r\nHow\r\nto add another videobridge. Getting error when adding a new video bridge\r\nto the standalone setup - Install &amp; Config - Jitsi Community Forum -\r\ndevelopers &amp; users\r\nWant\r\nto replace url for STUN MAPPING HARVESTER ADDRESSES? - Install &amp;\r\nConfig - Jitsi Community Forum - developers &amp; users\r\ndisable\r\nwebsockets to the bridge and use sctp\r\njitsi-videobridge/doc/web-sockets.md\r\nat master · jitsi/jitsi-videobridge (github.com)\r\nIs\r\nport 9090 required for JVB with Websockets? - Install &amp; Config -\r\nJitsi Community Forum - developers &amp; users\r\nNeed\r\nto test that whether it's working or not after enabling OCTO / OCTO\r\nconfiguration - Install &amp; Config - Jitsi Community Forum -\r\ndevelopers &amp; users\r\njicofo/jicofo-selector/src/main/resources/reference.conf\r\nat master · jitsi/jicofo (github.com)\r\nThis\r\nis tutorial to configure octo feature on jitsi.\r\n(github.com)\r\nworking-multi-jitsi-meet-multi-videobridge-setup\r\ntutorial-jibri-overview-troubleshooting-tips-tricks-solve-your-jibri-problems-quickly\r\n\r\n","categories":["Software","JitsiMeet"],"tags":["Jitsi-meet"]},{"title":".NET 中使用 Minio 遇到的一些坑","url":"/posts/2022/22T138.html","content":"本文总结了在 .NetCore 中使用 Minio 的过程中遇到的一些问题。\r\n\r\n连接客户端时报错\r\n在连接客户端时，报错：Minio.Exceptions.InvalidEndpointException: MinIO API responded with message=No path allowed in endpoint.\r\n连接代码为：\r\nMinioClient minioClient = new MinioClient(&quot;https://XXXX:9000&quot;,accessKey:&quot;Q3AM3UQ867SPQQA43P2F&quot;,secretKey:&quot;zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG&quot;).WithSSL();\r\n解决方法：\r\n把 url 的前缀 https:// 去掉即可。\r\n签名验证失败\r\n在使用 minioClient时，报错：\r\nMinIO API responded with message=The request signature we calculated does not match the signature you provided. Check your key and signing method.\r\n解决办法\r\n出现这种问题的原因是 minio 在校验 signature 是否有效的时候，必须从\r\nhttp header 里面获取 host，而我们这里没有对 header\r\n作必要的处理。如果源请求未携带这个头，则 minio 处无法获取请求头中的\r\nhost。\r\n可以在 nginx 中添加如下配置解决：\r\nlocation /&#123;     proxy_set_header X-Real-IP $remote_addr;     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;     proxy_set_header X-Forwarded-Proto $scheme;     proxy_set_header Host $http_host;     proxy_connect_timeout 300;     # Default is HTTP/1, keepalive is only enabled in HTTP/1.1     proxy_http_version 1.1;     proxy_set_header Connection &quot;&quot;;     proxy_pass http://localhost:9000;     chunked_transfer_encoding off;          // 非常重要\t proxy_cache_convert_head off;     &#125;\r\n参考\r\nhttp://www.dreamwu.com/post-2068.html\r\nhttps://docs.min.io/docs/setup-nginx-proxy-with-minio.html\r\nhttps://segmentfault.com/a/1190000019422246\r\n访问bucket被拒绝\r\n当调用 BucketExistsAsync(\"public\")\r\n时，报错：MinIO API responded with message=Access denied on the resource: public/.\r\n解决办法\r\n这个问题是由代理转换 HEAD 请求到 GET 请求引起的。\r\n我在使用nginx作为反向代理时遇到了这个问题，并通过添加以下配置解决了它:\r\nproxy_cache_convert_head off;\r\n参考\r\n\r\nhttps://github.com/minio/minio-js/issues/842#issuecomment-810282099\r\nhead请求_HTTP请求方法\r\n\r\n","categories":["Software","Minio"],"tags":[".NET","Minio"]},{"title":"一文带你了解Navicat中MongoDB查询的高级用法","url":"/posts/2022/1C3RDWC.html","content":"Navicat 是一款非常流行的数据库管理软件，可以通过 GUI\r\n界面进行数据库管理，也可以通过编写代码来操作数据库。\r\n在使用 Navicat 进行 MongoDB 查询时，我们不仅可以使用 MongoDB\r\n中的基础查询语句，还可以使用使用其内置的 JavaScript\r\n引擎执行代码段，进行各种数据库操作。\r\n\r\nJavaScript 引擎介绍\r\n在 Navicat 查询界面中，可以编写复杂 JavaScript\r\n函数操作数据库。经过使用测试，它的脚本功能有以下特点：\r\n\r\n会将脚本中最后一条语句的返回值输出到结果界面\r\n在查询窗口生命周期内，脚本中定义的变量会一直存在\r\n比如重复执行 let userId = 'myUserId'\r\n时，会提示变量已经重复声明了：\r\nlet userId = &#x27;ganmx&#x27;&gt; [Error] SyntaxError: redeclaration of let userIdat line 1, column 1&gt; 时间: 0.002s\r\n\r\n查询入口\r\n所有的查询都以内置的 db\r\n对象开始，比如查找用户的语句为：\r\ndb.user.find()\r\n集合引用\r\n通过以下方式来获取集合对象：\r\n\r\ndb.collectionName\r\ndb.getCollection('collectionName')\r\n\r\n集合函数\r\n集合对象上的提供的函数有：\r\n\r\naggregate(pipeline,options)\r\nbulkWrite(operations,options)\r\nconvertToCapped(maxBytes)\r\ncopyTo(newCollection)\r\ncount(query,options)\r\ncreateIndex(keyPatterns,options)\r\ndataSize()\r\ndeleteMany(filter,options)\r\ndeleteOne(filter,options)\r\ndistinct(field,query,options)\r\ndrop()\r\ndropIndex(index)\r\ndropIndexes()\r\nensureIndex(keys,options)\r\nexplain(verbosity)\r\nfind()\r\nfind(query,projection)\r\nfindAndModify(document)\r\nfindOne(query,projection)\r\nfindOneAndDeleted(filter,options)\r\nfindOneAndReplace(filter,replacement,options)\r\nfindOneAndUpdatae(filter,update,options)\r\ngetDB()\r\ngetMongo()\r\ngetIndexes()\r\ngetPlanCache()\r\ngetShardDistibution()\r\ngetShardVersion()\r\ngroup(options)\r\nhelp()\r\ninitializeOrderedBulkOp()\r\ninitializeUnorderedBulkOp()\r\ninsert(document,options)\r\ninsertMany(documents,options)\r\ninsertOne(document,options)\r\nisCapped()\r\nlatencyStats(options)\r\nmapReduce(map,reduce,options)\r\nreIndex()\r\nremove(query,options)\r\nrenameCollection(target,dropTarget)\r\nreplaceOne(filter,replacement,options)\r\nsave(document,options)\r\nstats(scale|options)\r\nstorageSize()\r\ntotalIndexSize()\r\ntotalSize()\r\nupdate(query,update,options)\r\nupdateMany(filter,update,options)\r\nupdateOne(filter,update,options)\r\nvalidate(full)\r\nwatch(pipeline,options)\r\n\r\n全局变量\r\nMongoDB 的查询编辑器等同于浏览器的 console，因此 console\r\n上暴露的方法与变量，在 MongoDB 中都可以使用，比如\r\nMath、Date 等等。\r\nfindOne 返回值\r\nfindOne 返回的类型为：NAVBson，它表示文档值\r\nfind 返回值\r\n与 finOne 不一样，find\r\n的返回值是一个集合，返回值类型为：NAVCollectionChainInfo，里面每个元素的类型是\r\nNAVBson。\r\n可以通过下标访问集合中的每个元素，如果要使用数组的方法，需要调用\r\n.toArray() 后再进行操作\r\n它提供以下函数：\r\n\r\naddOptions(flag)\r\nbatchSize(size)\r\nclose()\r\ncollation(&lt;collation documents&gt;)\r\ncomment(comment)\r\ncount(applySkipLimit)\r\nexplain(verbose)\r\nforEach(function)\r\nhasNext()\r\nhelp()\r\nhint(index)\r\nisClosed()\r\nisExhausted()\r\nitcount()\r\nlimit(&lt;number&gt;)\r\nmap(function)\r\nmax(indexBounds)\r\nmaxScan(maxScan)\r\nmatTimeMS(&lt;time limit&gt;)\r\nmin(indexBounds)\r\nnext()\r\nnoCursorTimeout()\r\nobjsLeftInBatch()\r\npretty()\r\nreadConcern(level)\r\nreadPref(mode,tagSet)\r\nreturnKey()\r\nshowRecordId()\r\nsize()\r\nskip(offset)\r\nsnapshot()\r\nsort(sort)\r\ntailabel(awaitData)\r\ntoArray()\r\n\r\naggregate 返回值\r\naggregate\r\n的返回值类型是：NAVCollectionCursor，它提供以下方法：\r\n\r\nclose()\r\nforEach(function)\r\nhasNext()\r\nhelp()\r\nisClosed()\r\nisExhausted()\r\nitcount()\r\nmap(function)\r\nnext()\r\nobjsLeftInBatch()\r\npretty()\r\ntoArray()\r\n\r\n事务\r\n在 Navicat 中，使用以下语句启用 MongoDB 事务\r\nsession = db.getMongo().startSession();session.startTransaction();try&#123;   \t// custom code here        session.commitTransaction();&#125; catch(error) &#123;    session.abortTransaction();&#125;session.endSession();\r\n函数示例\r\n以下为删除用户示例：\r\nfunction deleteUsers() &#123;     const users = db.user.find(&#123;        status: 0    &#125;).toArray()    session = db.getMongo().startSession();    session.startTransaction();    try&#123;        // 删除关联的信息，比如 userExtra        db.user_extra.deleteMany(&#123;            userId: &#123;                $in: users.map(x =&gt; x._id)            &#125;        &#125;, &#123;            sesion        &#125;)        // 删除自己        db.user.deleteMany(&#123;            userId: &#123;                $in: users.map(x =&gt; x._id)            &#125;        &#125;, &#123;            sesion        &#125;)                        session.commitTransaction();    &#125; catch(error) &#123;        session.abortTransaction();    &#125;    session.endSession();&#125;deleteUsers()\r\n\r\n为什么需要将逻辑包裹在函数中呢？请看后文解析。\r\n\r\n查询器生命周期\r\n查询编辑器的生命周期等同于 tab\r\n窗体的存续时间，而不是在每次执行【运行】后就会释放。因此，如果在编辑器根中定义了变量，下次再运行，会提示变量重复声明。\r\n可以使用闭包来解决这个问题：\r\n// 多次运行这段代码时，不会出现变量重复声明的异常function handleInFunc() &#123;    let userIdTemp = &#x27;pingkl&#x27;    let users = db.user.find(&#123;        userId: userIdTemp    &#125;)    return &#123;        userId: &#x27;pingkl&#x27;    &#125;&#125;handleInFunc()\r\n参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\nNavicat\r\nMongoDB\r\n","categories":["Software","Navicat"],"tags":["NexT","Navicat","MongoDB"]},{"title":"Kodbox中用Minio当存储时上传大文件提示上传失败","url":"/posts/2022/2QWMRNH.html","content":"本人使用 kobox 搭建了一个私有网盘，用 minio 搭建了一个对象存储作为\r\nkodbox 的存储，但是最近在 kodbox 中上传稍大点的文件（大于 100K\r\n左右）时，就提示上传失败，又很神奇的是，在 minio\r\n却发现该文件已经成功上传了。\r\n正文\r\n上述问题困扰了我两天，然后偶然看到一个答案，顺利解决了。\r\n\r\nI think the problem is caused by the proxy converting HEAD requests\r\nto GET requests.\r\nI ran into this problem when using nginx as a reverse proxy and\r\nsolved it by adding the following configuration:\r\nproxy_cache_convert_head off;\r\n\r\n所以，解决方法就是在 nginx 配置中添加：\r\nproxy_cache_convert_head off;\r\n后记\r\n官方关于 minio\r\n中反向代理的配置不全，导致怎么配置都有问题。这两天觉都没睡好，唉，坑是真的多呀，心累，不折腾了~\r\n参考\r\n\r\nminio/minio-js#842\r\n(comment)\r\n\r\n","categories":["Software","Minio"],"tags":["Minio","Kodbox"]},{"title":"Minio-js的正确安装与使用","url":"/posts/2022/2N5VCDY.html","content":"本文主要介绍 minio-js\r\n的正确安装与使用。在网上搜了好久，都没有找到一个能正常运行\r\nminio-js 的使用教程，包括官网。所以本文对此进行总结。\r\n\r\n正文\r\nnode 环境安装\r\n运行该示例包，需要在 node 环境下，一般使用这个包的，都有 node\r\n环境，此处不再赘述。\r\n\r\n如果没有 node 环境，可以使用 scoop 安装，很是方便。\r\nscoop 安装方法：https://uyoufu.uzoncloud.com/2020/14XXNWG.html\r\n\r\n下载源码\r\ngit clone https://github.com/minio/minio-jscd minio-js# 安装依赖包npm install# 下面的步骤可选# 代表将 minio-js 作为一个包安装到 nodejs 全局的 node_modules 中# 由于是本地目录，所以 node_modules 中的 minio-js 相当于一个快捷方式npm install -g\r\n\r\n暂时没有发现 npm install -g\r\n之后对于测试有什么方便的地方，所以本文就不运行该行命令\r\n\r\n安装 minio\r\nnpm install --save minio\r\n怎么运行示例\r\n在项目的 examples\r\n目录下，我们可以看到有很多的例子，如果要运行某个示例，运行如下命令：\r\n# 格式node relativePath# 如果当前在 minio-js 目录，要运行 bucket-exists.js 示例node examples/bucket-exists\r\n自定义测试\r\n当然，自己也可以自定义 minio\r\n运行脚本来进行测试。参考示例中的文件编写即可。\r\n\r\n注意：\r\n只支持 CommonJs 语法，不支持 ES6 语法。\r\n\r\n参考\r\n\r\ngithub 官方文档\r\n\r\n","categories":["Software","Minio"],"tags":["Minio","Minio-js","Javalscript","uyoufu"]},{"title":"Docker 中安装 MinIO 作为静态资源服务","url":"/posts/2022/3PMWKNV.html","content":"\r\n\r\nhttps://min.io/\r\n\r\n本文主要记录在 Ubuntu 24.04 x64 上使用 Docker 安装 MinIO\r\n作为静态资源服务的流程。基于\r\nMinIO，可以满足图床、静态存储、对象存储等应用场景。\r\n\r\ndocker-compose 安装 MinIO\r\n\r\n本文使用的 Docker 版本为：Docker version 27.3.1, build ce12230\r\n\r\ndocker-compose.yml 内容如下：\r\n# 高版本的 docker-compose 会自动配置 version, 此处为空services:  minio:    image: minio/minio    ports:      - 51080:9000 # api 端口      - 51180:9001 # 控制台端口    environment:      MINIO_ROOT_USER: root    # 管理后台用户名      MINIO_ROOT_PASSWORD: root_password # 管理后台密码，最小8个字符    volumes:      - ./data/data:/data               # 映射当前目录下的data目录至容器内/data目录      - ./data/config:/root/.minio/     # 映射配置目录    command: server --console-address &#x27;:9001&#x27; /data  # 指定容器中的目录 /data    restart: always    networks:      - nginx_network networks:  nginx_network:    external: true\r\n将上述内容保存为 docker-compose.yml\r\n文件，然后在目录中执行 docker compose up -d 运行实例。\r\n配置 nginx\r\n一台服务器可能有多个服务，因此将 nginx 独立成一个单独的\r\ndocker-compose，其它容器通过 nginx_network 与 nginx\r\n容器相连。\r\nnginx 的 docker-compose.yml 如下：\r\nservices:  nginx:    restart: always    container_name: nginx    image: nginx    ports:      - 80:80      - 443:443    volumes:      - ./data/cert:/etc/nginx/cert      - ./data/conf.d:/etc/nginx/conf.d # 每个服务的 nginx 配置单独成一个 `*.conf` 文件放到 conf.d 目录中，nginx 会自动加载    environment:      - NGINX_PORT=80      - TZ=Asia/Shanghai    # privileged: true    networks:      - nginx_networknetworks:  nginx_network:    external: true\r\nminio 的 nginx 配置为（文件路径\r\nxxx/data/conf.d/minio.conf）：\r\nupstream minio_upstream &#123;    # minio 为主机名，在 docker-compose 中定义的，端口为 docker 中 MinIO 的端口    server minio:9000;&#125;server &#123;    # 域名与端口    server_name obs.uamazing.cn;    listen 443 ssl;        # ssl    ssl_certificate /etc/nginx/cert/uamazing.cn_ecc/uamazing.cn.cer;    ssl_certificate_key /etc/nginx/cert/uamazing.cn_ecc/uamazing.cn.key;    ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3;    ssl_ciphers EECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:!MD5;    # 强制 https    add_header Strict-Transport-Security &quot;max-age=31536000&quot;;    # 其它 ssl 优化    ssl_prefer_server_ciphers on;    ssl_session_cache shared:SSL:2m;    ssl_session_timeout 1h;    ssl_session_tickets off;    # 不限制文件大小    client_max_body_size 0;    # 禁用了代理缓冲, 提升速度    proxy_buffering off;    access_log /var/log/nginx/proxy_access.log main;    error_log /var/log/nginx/proxy_error.log info;    location / &#123;        # 设置多个 HTTP 头部来传递客户端的真实 IP 地址、请求的原始协议和主机名等信息        # 这些头部对于后端服务器处理请求、记录日志和进行安全审计非常重要        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_set_header X-Forwarded-Proto $scheme;        proxy_set_header Host $http_host;        proxy_set_header X-NginX-Proxy true;        proxy_connect_timeout 3600;        proxy_read_timeout 3600;        proxy_send_timeout 3600;        proxy_http_version 1.1;        proxy_set_header Upgrade $http_upgrade;        proxy_set_header Connection &quot;upgrade&quot;;        chunked_transfer_encoding off;        proxy_pass http://minio_upstream;    &#125;&#125;\r\nMinIO 创建静态\r\n为了实现图床功能，可以在 MinIO 中创建一个 public 仓库来实现。\r\n具体步骤如下：\r\n\r\n使用管理端口登陆 MinIO\r\n创建 Bucket\r\n通过【Buckets/Create Bucket\r\n+】来创建一个新的存储桶，输入存储桶的名称，示例中为\r\npublic，最终结果如下图所示：\r\n\r\n\r\nimage-20240927171130390.png\r\n\r\n修改 public Bucket 的访问策略\r\n单击【Access\r\nPolicy】后面的铅笔图标，将其从【Priave】修改为【Public】，单击应用【Set】应用\r\n\r\n\r\nimage-20240927171643219\r\n\r\n由于 Public 策略允许查看 Bucket\r\n某个目录下的文件列表，因此要对该权限进行禁用。将访问策略从【Public】改成【Custom】，然后移除\r\nStatement.Action 中的 s3:ListBucket 和\r\ns3:ListBucketMultipartUploads，最终结果如下：\r\n&#123;    &quot;Version&quot;: &quot;2012-10-17&quot;,    &quot;Statement&quot;: [        &#123;            &quot;Effect&quot;: &quot;Allow&quot;,            &quot;Principal&quot;: &#123;                &quot;AWS&quot;: [                    &quot;*&quot;                ]            &#125;,            &quot;Action&quot;: [                &quot;s3:GetBucketLocation&quot;            ],            &quot;Resource&quot;: [                &quot;arn:aws:s3:::public&quot;            ]        &#125;,        &#123;            &quot;Effect&quot;: &quot;Allow&quot;,            &quot;Principal&quot;: &#123;                &quot;AWS&quot;: [                    &quot;*&quot;                ]            &#125;,            &quot;Action&quot;: [                &quot;s3:AbortMultipartUpload&quot;,                &quot;s3:DeleteObject&quot;,                &quot;s3:GetObject&quot;,                &quot;s3:ListMultipartUploadParts&quot;,                &quot;s3:PutObject&quot;            ],            &quot;Resource&quot;: [                &quot;arn:aws:s3:::public/*&quot;            ]        &#125;    ]&#125;\r\n单击【Set】进行应用。\r\n\r\n增加读写用户\r\n若要在程序中向 public 桶中上传文件，需要创建一个具有读写\r\npublic 目录权限的 Access Key。\r\n在【Access Keys】 中单击【Create Access key +】添加访问\r\nkey，详见下图。\r\n在创建时，需要打开\r\nRestict beyond user policy，修改为下列权限策略：\r\n&#123;    &quot;Version&quot;: &quot;2012-10-17&quot;,    &quot;Statement&quot;: [        &#123;            &quot;Effect&quot;: &quot;Allow&quot;,            &quot;Action&quot;: [                &quot;s3:*&quot;            ],            &quot;Resource&quot;: [                &quot;arn:aws:s3:::public&quot;,                &quot;arn:aws:s3:::public/*&quot;            ]        &#125;    ]&#125;\r\n最终结果如下图所示：\r\n\r\n\r\nimage-20240927180156357\r\n\r\n\r\n若要 key 永久生效，Expiry 则应为空\r\n\r\n添加完成后，即可在程序中使用该 Access Key 和 Secrect Key\r\n进行上传操作。\r\n","categories":["Software","Minio"],"tags":["Docker","MinIO"]},{"title":"使用 OfficeToolPlus 安装和激活 Office","url":"/posts/2023/3H07Q23.html","content":"Office Tool Plus\r\n是一个强大且实用的 Office 部署工具。\r\nOffice Tool Plus 基于 Office\r\n部署工具 和 OSPP\r\n制作，可以很方便的部署 Office，其内置迅雷引擎可帮助您更快地下载\r\nOffice，当然，你也可以使用 Office Tool Plus\r\n内置的各种小工具或者功能快捷、方便地激活和管理 Office 哦！\r\n\r\n系统要求：Windows 10 或更高版本，不支持其他操作系统（例如 Linux 或\r\nmacOS）。\r\n\r\n\r\n若是 win10 以下的系统，推荐使用手动激活的方式：Windows/Office一键激活\r\n软件下载\r\n打开下载界面: 下载 | Office Tool\r\nPlus 官方网站 (landian.vip)\r\n按图中所示选择版本进行下载。\r\n\r\n\r\nimage-20230605092738025\r\n\r\nOffice 安装\r\n下载完成后，将压缩包解压，然后单击 Office Tool Plus.exe\r\n打开安装界面\r\n\r\n选择【部署】\r\n选择安装 office 版本\r\n\r\n\r\nimage-20230605093617556\r\n\r\n\r\n建议选择带有年份的升级版本，比如 Office 2021\r\n企业长期版本，下方将以该版本为例进行安装\r\n\r\n选择要安装的产品\r\n\r\n\r\nimage-20230605093736350\r\n\r\n添加语言\r\n\r\n\r\nimage-20230605093819077\r\n\r\n开始部署\r\n单击【开始部署】进行下载和安装\r\n\r\nOffice 激活\r\n当提示安装完成后，单击左侧菜单【激活】跳转到激活页面。\r\n可按下图的步骤进行安装：\r\n\r\n\r\nimage-20230605094214932\r\n\r\n安装详细步骤如下：\r\n\r\n展开许可证管理\r\n安装许可证\r\n选择在部署步骤中安装的 Office 版本，然后单击【确定(O)】安装许可证\r\n\r\n\r\nimage-20230605094445942\r\n\r\n设置 KMS 激活服务器\r\n可以在 https://www.kms.pub/rank.html 处查询 KMS\r\n服务器，推荐使用检测成功次数较多的服务器，比如：win.kms.pub\r\n将激活服务器网址输入到 KMS\r\n主机名称框中，然后单击【设置主机(S)】\r\n单击【激(A)】进行激活\r\n出现如下提示则代表激活成功：\r\n\r\n\r\nimage-20230605094921072\r\n\r\n\r\n参考\r\n\r\nOffice Tool Plus\r\nYerong™ | NekoNeko\r\n\r\n","categories":["Software","Office"],"tags":["Software","Office"]},{"title":"创建和发布 NuGet 包","url":"/posts/2024/2CAZW8Q.html","content":"NuGet 是适用于 .NET 的包管理器。\r\n它使开发人员能够创建、共享和使用有用的 .NET 库。 NuGet\r\n客户端工具可生成这些库并将其作为“包”。\r\n本文简要记录了如何创建 NuGet 包并发布。\r\n\r\n安装 NuGet\r\n可以使用 scoop 安装\r\nscoop install nuget\r\n其它安装方式参考：安装\r\nNuGet 客户端工具 | Microsoft Learn\r\n首发准备\r\n\r\n生成 .nuspec 配置文件\r\n在含有&lt;project-name&gt;.csproj或者&lt;project-name&gt;.vbproj文件的文件夹中执行下列命令：\r\nnuget spec\r\n设置 NuGet 密钥\r\n通过 NuGet Gallery |\r\nAPI Keys 生成 nuget 密钥，然后通过下列命令进行设置\r\nnuget setApiKey &lt;your_API_key&gt;\r\n\r\n发布 NuGet 包\r\n\r\n修改 *.nuspec 配置文件\r\n修改项目信息，包括版本号、标题、作者等信息\r\n生成包\r\nnuget pack &lt;project-name&gt;.csproj -Build -Properties Configuration=Release -Properties Platform=x64\r\n发布包\r\nnuget push YourPackage.nupkg -Source https://api.nuget.org/v3/index.json\r\n\r\n参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\nNuGet 文档 |\r\nMicrosoft Learn\r\n.NET\r\nFramework生成NuGet包_.net framework 4.6.1 打包成nuget-CSDN博客\r\n","categories":["Software","Nuget"],"tags":["DotNET","NuGet"]},{"title":"Redis6 及以后版本安装为 windows 服务","url":"/posts/2023/2N7QY7C.html","content":"网上安装 redis 为 windows 服务的教程大多基于 redis3\r\n编写的，然而这并不适用于 redis 更高的版本。redis\r\n高版本安装为服务应使用如下方法：\r\n\r\n一定要安在 Redis for\r\nWindows Release 中下载 xxx-Service 版本 来安装。\r\n以管理员身份运行终端：\r\n# 创建 redis 服务sc create Redis binpath=C:\\Software\\Redis\\RedisService.exe start=auto# 启动服务net start Redis# 关闭服务net stop Redis# 卸载服务sc delete Redis\r\n参考：\r\nhttps://github.com/redis-windows/redis-windows\r\n","categories":["Software","Redis"],"tags":["Software","Redis"]},{"title":"Powershell 实用插件推荐及安装","url":"/posts/2023/3VM57JB.html","content":"本文将列举 Powershell7\r\n中比较好用的插件或配置，并介绍大致安装步骤。\r\n\r\n有的只适合于 windows，linux 若有类似功能，则可不安装\r\n\r\n\r\nbusybox\r\nBusyBox 是一个开源项目，它提供了大约 400 个常见 UNIX/Linux\r\n命令的精简实现，扩展了 powershell 命令。\r\n安装方式：scoop\r\nsudo\r\npowershell 提权，直接使用 sudo pwsh 即可将当前 shell\r\n升级成管理员权限\r\n安装方式：scoop install sudo\r\noh-my-posh\r\npowershell 样式美化\r\n安装方式：Windows | Oh My\r\nPosh\r\n自己使用的主题为 montys：\r\n\r\n\r\nimage-20230613224321201\r\n\r\nz.lua\r\n实现路径快速跳转\r\n参考：z.lua\r\n自定义别名\r\n可以自定义一些自己常用的别名，方便使用\r\n# 设置打开当前目录名称function openCurrentPathInExplore()&#123; explorer.exe .&#125;Set-Alias open openCurrentPathInExplore\r\n安装 PSReadLine 插件\r\nPSReadLine\r\n给命令行操作提供更加强大的线性编辑体验，比如显示输入历史，语法着色等等。\r\n# 查看PS仓库Get-PSRepository# 若没有仓库，可以添加一个默认Register-PSRepository -Default# 更新 PowerShellGetInstall-Module -Name PowerShellGet -Force# 安装 PSReadLineInstall-Module PSReadLine\r\n配置 PSReadLine :\r\n# 打开 pwsh 配置notepad $profile# 添加如下配置# 配置 PSReadLine$PSOption = @&#123;    PredictionSource = &#x27;HistoryAndPlugin&#x27;    # 使用 vim 的模式，可以按 esc 后，执行 vim 快捷键    EditMode = &#x27;Vi&#x27;    PredictionViewStyle = &#x27;ListView&#x27;    ShowToolTips = $true# ...&#125;Set-PSReadLineOption @PSOption\r\n修改启动默认路径\r\n# 在配置中添加如下内容，启动时自动定位到用户目录Set-Location ~\r\n完整配置\r\n在 powershell 中输入notepad $profile\r\n来打开配置文件，如果没有的话，输入\r\nNew-Item -Path $PROFILE -Type File -Force 来进行新建。\r\n$profile\r\n的位置为：C:\\Users\\%username%\\Documents\\PowerShell\r\n配置后的文件内容如下：\r\n# oh-my-posh初始化oh-my-posh init pwsh --config &#x27;C:\\Users\\galens\\.posh\\montys.json&#x27; | Invoke-Expression# z.lua 配置Invoke-Expression (&amp; &#123; (lua D:/Application/z.lua/z.lua --init powershell once enhanced) -join &quot;`n&quot; &#125;)# 设置打开当前目录名称function openCurrentPathInExplore()&#123; explorer.exe .&#125;Set-Alias open openCurrentPathInExplore\r\n参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\nPowerShell/PSReadLine: A\r\nbash inspired readline implementation for PowerShell\r\n(github.com)\r\nPSReadLine/PSReadLine/SamplePSReadLineProfile.ps1\r\nat master · PowerShell/PSReadLine (github.com)\r\n在\r\nUbuntu 上安装 PowerShell - PowerShell | Microsoft Learn\r\nSet-PSReadLineOption\r\n(PSReadLine) - PowerShell | Microsoft Learn\r\n","categories":["Software","Powershell"],"tags":["Software","Powershell7"]},{"title":"z.lua 安装","url":"/posts/2023/1JSFERW.html","content":"z.lua 是一个快速路径切换工具，它会跟踪你在 shell\r\n下访问过的路径，通过一套称为 Frecent 的机制（源自\r\nFireFox），经过一段简短的学习之后，z.lua\r\n会帮你跳转到所有匹配正则关键字的路径里 Frecent 值最高的那条路径去。\r\n\r\n安装 lua 环境\r\n使用 scoop install lua 安装 lua 环境\r\n下载 z.lua\r\n可以直接下载 z.lua 整个 git 仓库，方便后续升级。\r\ngit clone https://github.com/skywind3000/z.lua.git\r\npowershell 配置\r\n# 打开配置文件notepad $profile# 添加如下配置# z.lua 配置# once 表示只有当前路径改变，才会将新路径添加到数据库# enhanced 表示使用增强匹配算法，具体参考其官方说明Invoke-Expression (&amp; &#123; (lua D:/Application/z.lua/z.lua --init powershell once enhanced) -join &quot;`n&quot; &#125;)\r\n-i 参数仅在有多个候选项时才会出现，enhanced\r\n状态下，一般只会匹配到一个数据。\r\n增强模式匹配逻辑\r\n对于一个给定的正则关键字序列（即 z\r\n命令后面的参数），只有同时满足两个条件才算匹配成功：\r\n\r\n正则关键字将按顺序进行匹配（这条和默认匹配法相同）。\r\n最后一个关键字可以和路径名的最后一段相匹配。\r\n如果两条规则同时启用找不到任何结果，那么将会退回到只用规则 1\r\n进行筛选。\r\n\r\n详细查看：增强匹配算法\r\n参考\r\nz.lua\r\n官方说明(中文)\r\nz.lua\r\n中文文档\r\n","categories":["Software","Powershell"],"tags":["Software","Powershell"]},{"title":"Powershell 安装 NerdFonts 字体","url":"/posts/2023/2SJBCB8.html","content":"\r\n\r\nimage-20230613234640253\r\n\r\n为了支持 oh-my-posh 的美化，我们需要在 powershell 中安装\r\nNerdFonts 字体。下面将分别介绍在不同场景下 PowerShell\r\n的字体安装方法。\r\n\r\n字体安装\r\n从 Nerd Fonts -\r\nIconic font aggregator, glyphs/icons collection, &amp; fonts\r\npatcher下载 NerdFonts\r\n字体，里面有很多变体，选择自己喜欢的一个下载，然后安装即可。\r\n\r\n\r\nimage-20230613234640253\r\n\r\nwindows terminal 中设置\r\npowershell 字体\r\n在日常的使用中，一般都是通过 windows terminal 来打开 powershell\r\n使用，因此，可以找到 windows terminal\r\n的设置-&gt;找到对应的shell，打开外观设置，然后指定相应的字体。\r\nvscode 中设置 powershell\r\n字体\r\n按 Ctrl+,打开【设置】界面，搜索\r\nfont，切换到【用户】设置区，找到 【功能/终端】，在\r\nIntegrated: Font Family\r\n中输入自己需要的字段，如果字体之间有空格，需要放到引号内。\r\n\r\n\r\nimage-20230614001020595\r\n\r\n","categories":["Software","Powershell"],"tags":["Software","PowerShell","NerdFonts"]},{"title":"scoop 安装与重置","url":"/posts/2020/WCF13S.html","content":"本文主要介绍 scoop 初始安装及重置电脑后的恢复。\r\n\r\n安装\r\nscoop 安装环境要求：\r\n\r\nWindows 版本不低于 Windows 7\r\nPowerShell 3+\r\n.NET Framework 4.5+\r\n用户名无中文\r\n\r\n首先，保证电脑有 PowerShell 3，如果没有，需要安装 Windows Management\r\nFramework，下载地址：https://www.microsoft.com/en-us/download/details.aspx?id=54616\r\n将下列脚本保存为 .ps1 文件，然后用管理员身份运行即可\r\n# scoop.ps1# 设置用户变量[environment]::setEnvironmentVariable(&#x27;SCOOP&#x27;,&#x27;D:\\scoop&#x27;,&#x27;User&#x27;)# 启用$env:SCOOP=&#x27;D:\\scoop&#x27;# 设置系统全局变量[environment]::setEnvironmentVariable(&#x27;SCOOP_GLOBAL&#x27;,&#x27;D:\\scoop_global&#x27;,&#x27;Machine&#x27;)# 启用$env:SCOOP_GLOBAL=&#x27;D:\\scoop_global&#x27;# 允许本地脚本执行set-executionpolicy remotesigned -s cu# 下载安装scoop# 官方# iex (new-object net.webclient).downloadstring(&#x27;https://get.scoop.sh&#x27;)# 或国内iwr -useb https://gitee.com/RubyKids/scoop-cn/raw/main/install.ps1 | iex# 添加 extrasscoop bucket add extras https://github.com/lukesampson/scoop-extras# 添加自用源scoop bucket add uamazing https://gitee.com/galensgan/galens-bucket.git\r\naria2 多线程下载\r\n下载 aria2 多线程加速下载\r\nscoop install aria2\r\n设置 aria2 走代理\r\n打开 C:\\Users\\%username%\\.config\\scoop\\config.json\r\n文件，在里面添加：\r\n&#123;    // aria2 配置    &quot;aria2-options&quot;: [        &quot;--check-certificate false&quot;,        &quot;--https-proxy=http://192.168.3.14:7890&quot;, // https 代理的地址        &quot;--http-proxy=http://192.168.3.14.7890&quot; // http 代理地址  \t],&#125;\r\n重置后恢复\r\n由于电脑重置后，环境变量的丢失，导致原本安装的 scoop\r\n失效，此时只需要恢复其环境变量就可以了。\r\n分别添加如下环境变量：\r\n\r\n\r\n\r\n变量名\r\n值\r\n操作\r\n\r\n\r\n\r\n\r\nscoop\r\n局部 scoop 路径\r\n新增\r\n\r\n\r\nscoop_global\r\n全局 scoop 路径新增\r\n新增\r\n\r\n\r\npath\r\nscop 路径 + ''\r\n追加\r\n\r\n\r\n\r\n添加完成后，就可以恢复 scoop 使用了。\r\n","categories":["Software","Scoop"],"tags":["scoop"]},{"title":"VisualAssistX破解安装教程(一手资料)","url":"/posts/2023/11S1RTW.html","content":"Visual Assist X（以下简称 VAX）是一款功能强大的 Visual Studio\r\n插件，它可以具有强大的代码导航、代码重构、代码生成、代码校正等\r\n12 项主要功能，简而言之，用上它之后，编程更加高效了。\r\n本文将介绍如何安装与破解\r\n\r\n软件安装\r\n下载破解补丁对应的 VAX 版本，可以从此处Archive of\r\nVisual Assist builds and release notes\r\n(wholetomato.com)进行下载。\r\n\r\n作者为保护正版，仅提供最新版本的前一个版本的补丁。\r\n\r\n如何查看版本：\r\n以 2488 版本为例，我们在历史版本界面，找到\r\nVisual\r\nAssist Build 2023.2，然后右键，复制链接，链接中\r\nhttps://wholetomato.com/downloads/getBuild.asp?VA_X_Setup2488_0.exe\r\nSetup 后面的数字即版本信息。\r\n\r\n\r\nimage-20230823181501026\r\n\r\n软件下载完成后，直接安装即可，不再赘述。\r\n软件破解\r\n破解工具下载：\r\n破解工具从作者的博客中下载，地址：i1tao - 博客园\r\n(cnblogs.com)\r\ni1tao - 博客园\r\n(cnblogs.com)\r\n\r\n重要：\r\n如果之前注册安装过VAX的，请先运行\r\n..\\\\VAX Reginfo Clearner\\\\Trial-Reset.exe\r\n对之前注册信息进行清理.\r\n\r\n\r\n安装 VAX\r\n将附件中的 oledlg.dll\r\n复制到VS各个版本的主程序(devenv.exe)所在的目录.\r\n启动VS，进入VAX的配置项来输入下面的key完成注册：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nkeyName\r\nvalue\r\n\r\n\r\n\r\n\r\nKey1\r\nCracked_By_Cr39_0xc5(i1tao) (255-user license) Support ends\r\n2029.1.100001R-4AK2FM-EZ4NC1-R3NGD9-AE98BE-XWCZ8E-HA59TD-E5UJBE-JUKWMD-E3KTC9-7WJAWR\r\n\r\n\r\nkey2\r\nCracked_By_Cr39_0xc5(i1tao) (255-user license) Support ends\r\n2029.1.100001R-4AK2FM-EZ4NC1-R3NMFW-W5PKG4-7CZFJW-PE9PV8-WRQJKU-1QWPTK-AVCE77-WG9BCM\r\n\r\n\r\n\r\n激活流程按下图红字标识序号进行：\r\n\r\n\r\nimage-20230823182754397\r\n\r\n参考\r\n本文参考以下文章，在此表示诚挚谢意，同时，感谢作者对该破解资源的付出和分享！\r\n\r\nFeatures in Visual\r\nAssist - Whole Tomato Software\r\ni1tao - 博客园\r\n(cnblogs.com)\r\nArchive of\r\nVisual Assist builds and release notes (wholetomato.com)\r\n\r\n","categories":["Software","VisualStudio"],"tags":["VS","VAX"]},{"title":"Windows Terminal 终端安装及美化","url":"/posts/2021/3APEE3Y.html","content":"\r\n\r\n常规展示\r\n\r\nWindows 上的终端难用又难看，直到我遇到了 Windows Terminal 和\r\nPowershell\r\n7。那丝滑般的操作手感，美得不可方物的界面，还有其强大的功能支持，瞬间坠入爱河，爱了爱了~\r\n\r\n由于 WindowsTerminal 设置已经 UI 可视化，因此该文章已经弃用。关于\r\nPowershell 的相关配置，已经更新到 PowerShell 的分类中\r\n\r\n\r\n下面我们就一步一步开始安装和配置。\r\n安装 Windows Terminal\r\n\r\n如果是 win10，直接去 Microsoft Store 搜索\r\nWindows Terminal 下载即可;\r\n如果是 windows server，按照以下步骤进行安装:\r\n\r\n下载 GitHub 下载 .msixbundle 软件包，Releases ·\r\nmicrosoft/terminal (github.com)\r\n用管理员身份运行 Powershell，在里面输入如下命令进行安装\r\nAdd-AppPackage 安装包的全路径名称\r\n路径如果有空格，需要用双引号括起来。\r\n\r\n还可以通过 scoop 进行安装\r\nscoop install windows-terminal\r\n\r\n安装字体\r\n这里仅推荐一款字体：Fira Code。该字体支持 ligature\r\n连字功能，而且是一款专门为代码显示准备的字体。该字体开源，广受海内外程序员好评！\r\n单击此处从\r\nGitHub 下载\r\n下载完成后，解压，然后打开 ttf\r\n目录，全选，右键点击安装。\r\n\r\notf 与 ttf 的字体区别在于 ttf 字体定位更准，建议使用 ttf。\r\n\r\n安装新款 Powershell Core\r\n首先声明，我们这儿用的 Powershell 与 Windows 自带的 Powershell\r\n是完全不同的两个东西，除了功能相似和名字相同，两者内在已经天差地别。\r\n自带的 Powershell\r\n错误提示冗长，颜值低，速度慢，总之就是不值得去用。\r\n那么 Powershell Core 是什么呢？这是伟大的 .Net Core\r\n跨平台战略的一个重要组成部分，微软设想，要让强大的 .Net\r\n在所有平台上通用，让这么强大的 Powershell 在所有平台上都能用，古老的\r\nbash 可以退休了！\r\n基于以上愿景，微软开始了漫长而辉煌的征程。\r\n下载地址：Releases ·\r\nPowerShell/PowerShell (github.com)\r\n安装过程中会提示安装选项，全部勾选就可以了。\r\n\r\n\r\n安装界面\r\n\r\n上面的各个选项分别是：\r\n\r\n添加 PowerShell 到环境变量\r\n注册到 Windows 事件\r\n允许 PowerShell 远程\r\n在文件管理器中右键菜单\r\n给 PowerShell 文件添加用 PowerShell\r\n7-preview 右键菜单\r\n\r\n安装 Powershell 插件\r\n这一步是整个过程的灵魂。\r\n直接上代码：打开刚装好的新版 powershell，逐行输入命令。\r\n# 1. 安装 PSReadline 包，该插件可以让命令行很好用，类似 zshInstall-Module -Name PSReadLine -AllowPrerelease -Force# 2. 安装 posh-git 包，让你的 git 更好用Install-Module posh-git -Scope CurrentUser# 3. 安装 oh-my-posh 包，让你的命令行更酷炫、优雅Install-Module oh-my-posh -Scope CurrentUser# 4。安装 ZLocation，可以通过 z xx(xx是路径的关键词) 快速定位路径Install-Module ZLocation -Scope CurrentUser\r\n安装过程可能有点慢，好像卡住了一样，但是请耐心等待几分钟。另外，可能需要挂代理才能下载、安装。这几个包的都不大，所以如果迟迟装不上，就基本上是网络问题。\r\n后面两个包的来源可能不受系统信任，不用管它，如果让你选择是否信任，直接输入\r\nY 即可。\r\n配置 Windows Terminal\r\n这一项也是灵魂。\r\n只有新款 Powershell 而没有 Windows Terminal，好比吃肉不放盐。\r\n打开Windows Terminal，然后按快捷键 Ctrl+Shift+,\r\n打开配置文件，直接上配置代码，遇到不懂的地方，自己读注释。记得将此设置默认配置（代码已经给出）。\r\n// This file was initially generated by Windows Terminal Preview 1.4.2652.0// It should still be usable in newer versions, but newer versions might have additional// settings, help text, or changes that you will not see unless you clear this file// and let us generate a new one for you.// To view the default settings, hold &quot;alt&quot; while clicking on the &quot;Settings&quot; button.// For documentation on these settings, see: https://aka.ms/terminal-documentation&#123;    &quot;$schema&quot;: &quot;https://aka.ms/terminal-profiles-schema&quot;,    // 默认的配置就是我们的新 powershell（重要！！！）    // 认准这个Id: &quot;&#123;574e775e-4f2a-5b96-ac1e-a2962a402336&#125;&quot;    &quot;defaultProfile&quot;: &quot;&#123;574e775e-4f2a-5b96-ac1e-a2962a402336&#125;&quot;,    // You can add more global application settings here.    // To learn more about global settings, visit https://aka.ms/terminal-global-settings    // If enabled, selections are automatically copied to your clipboard.    &quot;copyOnSelect&quot;: false,    // If enabled, formatted data is also copied to your clipboard    &quot;copyFormatting&quot;: false,    // A profile specifies a command to execute paired with information about how it should look and feel.    // Each one of them will appear in the &#x27;New Tab&#x27; dropdown,    //   and can be invoked from the commandline with `wt.exe -p xxx`    // To learn more about profiles, visit https://aka.ms/terminal-profile-settings    &quot;profiles&quot;:    &#123;\t\t        &quot;defaults&quot;:        &#123;            // Put settings here that you want to apply to all profiles.\t\t\t&quot;startingDirectory&quot; : &quot;.&quot;,\t\t\t&quot;useAcrylic&quot;: true        &#125;,        &quot;list&quot;:        [            &#123;                // Make changes here to the powershell.exe profile.                &quot;guid&quot;: &quot;&#123;61c54bbd-c2c6-5271-96e7-009a87ff44bf&#125;&quot;,                &quot;name&quot;: &quot;Windows PowerShell&quot;,                &quot;commandline&quot;: &quot;powershell.exe&quot;,                &quot;hidden&quot;: true // 隐藏原来的 PowerShell            &#125;,            &#123;                // Make changes here to the cmd.exe profile.                &quot;guid&quot;: &quot;&#123;0caa0dad-35be-5f56-a8ff-afceeeaa6101&#125;&quot;,                &quot;name&quot;: &quot;命令提示符&quot;,                &quot;commandline&quot;: &quot;cmd.exe&quot;,                &quot;hidden&quot;: true // 隐藏 cmd            &#125;,            &#123;                &quot;guid&quot;: &quot;&#123;b453ae62-4e3d-5e58-b989-0a998ec441b8&#125;&quot;,                &quot;hidden&quot;: true, // 隐藏 Azure Cloud Shell                &quot;name&quot;: &quot;Azure Cloud Shell&quot;,                &quot;source&quot;: &quot;Windows.Terminal.Azure&quot;            &#125;,            &#123;                &quot;guid&quot;: &quot;&#123;574e775e-4f2a-5b96-ac1e-a2962a402336&#125;&quot;,                &quot;hidden&quot;: false,                &quot;name&quot;: &quot;PowerShell&quot;,             \t\t\t\t// 注意：一定要写上 -nologo，否则开启 powershll 会有一段话输出，很讨厌！                // 路径自己去核实，如果是正式版本，就是 .../7/pwsh.exe\t\t\t\t&quot;commandline&quot;: &quot;C:/Program Files/PowerShell/7-preview/pwsh.exe -nologo&quot;, \t\t\t\t&quot;source&quot;: &quot;Windows.Terminal.PowershellCore&quot;,\t\t\t\t// 启动菜单一定要设置为 &lt;.&gt;，否则后面重要的一步将会无效！\t\t\t\t&quot;startingDirectory&quot;: &quot;.&quot;,\t\t\t\t// 字体\t\t\t\t&quot;fontFace&quot;: &quot;Fira Code&quot;,\t\t\t\t&quot;fontSize&quot;: 11,\t\t\t\t&quot;historySize&quot;: 9001,\t\t\t\t&quot;padding&quot;: &quot;5, 5, 20, 25&quot;,\t\t\t\t&quot;snapOnInput&quot;: true,\t\t\t\t&quot;useAcrylic&quot;: false,\t\t\t\t// 颜色\t\t\t\t&quot;colorScheme&quot;: &quot;Homebrew&quot;            &#125;        ]    &#125;,    // Add custom color schemes to this array.    // To learn more about color schemes, visit https://aka.ms/terminal-color-schemes    &quot;schemes&quot;: [        // Homebrew 配色，该配色经过 刘鹏 改良\t\t&#123;\t\t\t&quot;name&quot;: &quot;Homebrew&quot;,\t\t\t&quot;black&quot;: &quot;#000000&quot;,\t\t\t&quot;red&quot;: &quot;#FC5275&quot;,\t\t\t&quot;green&quot;: &quot;#00a600&quot;,\t\t\t&quot;yellow&quot;: &quot;#999900&quot;,\t\t\t&quot;blue&quot;: &quot;#6666e9&quot;,\t\t\t&quot;purple&quot;: &quot;#b200b2&quot;,\t\t\t&quot;cyan&quot;: &quot;#00a6b2&quot;,\t\t\t&quot;white&quot;: &quot;#bfbfbf&quot;,\t\t\t&quot;brightBlack&quot;: &quot;#666666&quot;,\t\t\t&quot;brightRed&quot;: &quot;#e50000&quot;,\t\t\t&quot;brightGreen&quot;: &quot;#00d900&quot;,\t\t\t&quot;brightYellow&quot;: &quot;#e5e500&quot;,\t\t\t&quot;brightBlue&quot;: &quot;#0000ff&quot;,\t\t\t&quot;brightPurple&quot;: &quot;#e500e5&quot;,\t\t\t&quot;brightCyan&quot;: &quot;#00e5e5&quot;,\t\t\t&quot;brightWhite&quot;: &quot;#e5e5e5&quot;,\t\t\t&quot;background&quot;: &quot;#283033&quot;,\t\t\t&quot;foreground&quot;: &quot;#00ff00&quot;\t\t&#125;,\t],    // Add custom actions and keybindings to this array.    // To unbind a key combination from your defaults.json, set the command to &quot;unbound&quot;.    // To learn more about actions and keybindings, visit https://aka.ms/terminal-keybindings    &quot;actions&quot;:    [        // Copy and paste are bound to Ctrl+Shift+C and Ctrl+Shift+V in your defaults.json.        // These two lines additionally bind them to Ctrl+C and Ctrl+V.        // To learn more about selection, visit https://aka.ms/terminal-selection        &#123; &quot;command&quot;: &#123;&quot;action&quot;: &quot;copy&quot;, &quot;singleLine&quot;: false &#125;, &quot;keys&quot;: &quot;ctrl+c&quot; &#125;,        &#123; &quot;command&quot;: &quot;paste&quot;, &quot;keys&quot;: &quot;ctrl+v&quot; &#125;,        // Press Ctrl+Shift+F to open the search box        &#123; &quot;command&quot;: &quot;find&quot;, &quot;keys&quot;: &quot;ctrl+shift+f&quot; &#125;,        // Press Alt+Shift+D to open a new pane.        // - &quot;split&quot;: &quot;auto&quot; makes this pane open in the direction that provides the most surface area.        // - &quot;splitMode&quot;: &quot;duplicate&quot; makes the new pane use the focused pane&#x27;s profile.        // To learn more about panes, visit https://aka.ms/terminal-panes        &#123; &quot;command&quot;: &#123; &quot;action&quot;: &quot;splitPane&quot;, &quot;split&quot;: &quot;auto&quot;, &quot;splitMode&quot;: &quot;duplicate&quot; &#125;, &quot;keys&quot;: &quot;alt+shift+d&quot; &#125;    ]&#125;\r\n\r\n特别注意，用其他配色可能降低颜值。\r\n\r\n添加 Powershell 启动参数\r\n在 powershell 中输入\r\nnotepad.exe $Profile\r\n紧接着在弹出的页面中输入下面这一长串代码，保存并关闭。这个 Profile\r\n配置文件与 .zshrc / .bashrc 文件一样，都是控制启动前参数的。\r\n&lt;# * FileName: Microsoft.PowerShell_profile.ps1 * Author: 刘 鹏 * Email: littleNewton6@outlook.com * Date: 2020, May. 1 * Copyright: No copyright. You can use this code for anything with no warranty.#&gt;#------------------------------- Import Modules BEGIN -------------------------------# 引入 posh-gitImport-Module posh-git# 引入 oh-my-poshImport-Module oh-my-posh# 设置 PowerShell 主题Set-PoshPrompt -Theme Paradox#------------------------------- Import Modules END   -------------------------------#-------------------------------  Set Hot-keys BEGIN  -------------------------------# 设置 Tab 键补全# Set-PSReadlineKeyHandler -Key Tab -Function Complete# 设置 Ctrl+d 为菜单补全和 IntellisenseSet-PSReadLineKeyHandler -Key &quot;Tab&quot; -Function MenuComplete# 设置 Ctrl+d 为退出 PowerShellSet-PSReadlineKeyHandler -Key &quot;Ctrl+d&quot; -Function ViExit# 设置 Ctrl+z 为撤销Set-PSReadLineKeyHandler -Key &quot;Ctrl+z&quot; -Function Undo# 设置向上键为后向搜索历史记录Set-PSReadLineKeyHandler -Key UpArrow -Function HistorySearchBackward# 设置向下键为前向搜索历史纪录Set-PSReadLineKeyHandler -Key DownArrow -Function HistorySearchForward#-------------------------------  Set Hot-keys END    -------------------------------#-------------------------------  引用与上述冲突的模块 BEGIN    -------------------------------# 引用模块 ZLocation，必须放到上面模块设置完成后的位置，否则会不生效Import-Module ZLocation#-------------------------------    Functions BEGIN   -------------------------------#-------------------------------    Functions BEGIN   -------------------------------# Python 直接执行$env:PATHEXT += &quot;;.py&quot;# 更新 pip 的方法function Update-Packages &#123;    # update pip    Write-Host &quot;Step 1: 更新 pip&quot; -ForegroundColor Magenta -BackgroundColor Cyan    $a = pip list --outdated    $num_package = $a.Length - 2    for ($i = 0; $i -lt $num_package; $i++) &#123;        $tmp = ($a[2 + $i].Split(&quot; &quot;))[0]        pip install -U $tmp    &#125;    # update TeX Live    $CurrentYear = Get-Date -Format yyyy    Write-Host &quot;Step 2: 更新 TeX Live&quot; $CurrentYear -ForegroundColor Magenta -BackgroundColor Cyan    tlmgr update --self    tlmgr update --all&#125;#-------------------------------    Functions END     -------------------------------#-------------------------------   Set Alias Begin    -------------------------------# 1. 编译函数 makefunction MakeThings &#123;    nmake.exe $args -nologo&#125;Set-Alias -Name make -Value MakeThings# 2. 更新系统 os-updateSet-Alias -Name os-update -Value Update-Packages# 3. 查看目录 ls &amp; llfunction ListDirectory &#123;    (Get-ChildItem).Name    Write-Host(&quot;&quot;)&#125;Set-Alias -Name ls -Value ListDirectorySet-Alias -Name ll -Value Get-ChildItem#-------------------------------    Set Alias END     -------------------------------\r\n到此，配置完成！在命令行里面狂欢吧。\r\n参考\r\n[1] 原文链接：Windows Terminal\r\n完美配置 PowerShell 7.1\r\n[2] awesome-powershell\r\n[3] posh-git\r\n[4] PSReadLine\r\n[5] ZLocation\r\n[6] oh-my-posh\r\n[7] 其它参考\r\n","categories":["Software","WindowsTerminal"],"tags":["WindowsTerminal"]},{"title":"vscode 个人常用快捷键","url":"/posts/2020/1G6WK1H.html","content":"总结一下 vscode 的常用快捷键，避免在今后的开发中遗忘，同时，也减少从\r\ngoogle 查询相关资料的时间。\r\n\r\n快捷键\r\n基本\r\n\r\n\r\n\r\n功能\r\n快捷键\r\n\r\n\r\n\r\n\r\nF1\r\nShow Command Palette\r\n\r\n\r\nCtrl+,\r\nUser Settings\r\n\r\n\r\nCtrl+K Ctrl+S\r\nKeyboard Shortcuts\r\n\r\n\r\n\r\n编辑\r\n\r\n\r\n\r\n功能\r\n快捷键\r\n\r\n\r\n\r\n\r\nCtrl+/\r\nToggle line comment\r\n\r\n\r\nCtrl+ left click\r\njump to definition\r\n\r\n\r\n\r\n设置\r\n右侧预览小地图\r\n右侧预览要地图要的名称叫 Minimap, 如果要打开或者关闭，在设置里面搜索\r\nminimap，然后在 enable 那项打上钩就可以了。\r\n更多\r\nAll: https://code.visualstudio.com/docs/getstarted/keybindings\r\nwindows：\r\nhttps://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf\r\n","categories":["Software","VSCode"],"tags":["vscode"]},{"title":"vs中生成操作：内容、编译、嵌入资源的区别","url":"/posts/2021/1K35WF3.html","content":"vs 中不同的生成操作有什么区别呢？请让我娓娓道来。\r\n\r\n概述\r\n\r\n内容(Content)\r\n不编译该文件，但将其包含在“内容”(Content) 输出组中。\r\n编译(Compile)\r\n将该文件编译到生成输出中。此设置用于代码文件。\r\n嵌入资源(Embedded Resource)\r\n将该文件作为 DLL 或可执行文件嵌入主项目生成输出中。\r\n\r\n读写\r\n\r\n内容的读写和运行目录下的其他文件没有区分。\r\n编译和嵌入资源读写，需要按如下方法读取：\r\n\r\n// 读取程序中嵌入的文件Stream stream = Assembly.GetExecutingAssembly().GetManifestResourceStream(&quot;命名空间.文件夹名（多层级用.分隔）.文件名（带后缀）&quot;);\r\n参考\r\nvs2022\r\n生成操作\r\n","categories":["Software","VisualStudio"],"tags":["vs"]},{"title":"vscode 中使用 prettier 格式化代码和 eslint 校验语法","url":"/posts/2021/2VC1G0D.html","content":"本文主要针对 ESLint 和 Prettier\r\n的使用进行总结，通读本文，你将理解：\r\n\r\nESLint 和 Prettier 是什么?\r\n为什么在进行 Javascript 编码时，要使用它们？\r\n在 vscode 中怎么使用它们？\r\n\r\n\r\n关于学习 ESLint 与 Prettier\r\n看到某些up,文章把 ESLint、Prettier\r\n写得很复杂，有的还不全面，导致入门者在网上学得云里雾里的，然后就觉得这个好难。\r\n这两个东西其实很简单，这就娓娓道来。等读完此篇文章后，建议在使用中根据需求再去阅读官方文档，不要去看别人的各种总结，因为大部分总结都很片面。看个一两篇入门是可以。\r\nESLint 是什么\r\n是一个开源的 JavaScript 的 linting 工具，使用 espree 将 JavaScript\r\n代码解析成抽象语法树 (AST)，然后通过AST\r\n来分析我们代码，从而给予我们两种提示：\r\n\r\n代码质量问题：使用方式有可能有问题(problematic\r\npatterns)\r\n代码风格问题：风格不符合一定规则 (doesn’t adhere to certain\r\nstyle guidelines)\r\n\r\n简单来说，ESLint\r\n对代码的语法和格式按照规则进行检测，并提示和自动修正。\r\nPrettier 是什么\r\nESLint\r\n主要解决的是代码质量问题，但是对于代码风格（一般使用\r\nAirbnb JavaScript\r\n风格指南），ESLint 未完全实现。所以此时，就会使用 Prettier\r\n进行补充。\r\n简单来说，Prettier 只对代码的格式 进行检查和修正，用来补充\r\nESLint 对代码格式规范的不足。\r\n怎么使用\r\n为什么 vscode 中要安装插件\r\n上述两个工具都是通过安装的 Eslint 和 Prettier\r\n这两个包来实现代码检查和格式化的。在我们使用 vscode 进行编码的时候，\r\nvscode 需要安装 EsLit 和 Prettier 这两个插件，监听 vscode\r\n的操作事件(比如保存事件)，然后对代码按包中的规则来进行处理。\r\n如何配置\r\n推荐在项目中增加配置文件来配置 vscode、 Eslint 和\r\nPrettier，这样，配置可以共享给其它成员，也不会影响另外的项目开发。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n配置文件（相对于项目根目录）\r\n作用\r\n\r\n\r\n\r\n\r\n.vscode/settings.json\r\nvscode 在当前项目中的配置文件\r\n\r\n\r\n.eslintrc.js\r\neslint 配置文件\r\n\r\n\r\n.prettierrc\r\nprettier 配置文件，更多文件格式参考 Configuration File\r\n· Prettier\r\n\r\n\r\n\r\n由于 prettier 与 eslint\r\n之间有些配置不能完全兼容，在使用的时候，很难配置，因此，原作者推荐 使用\r\nPrettier-Eslint 插件，方便用户配置和使用。\r\n下面讲如何使用 Prettier-ESLint 插件\r\nPrettier-ESLint 使用\r\n插件安装\r\n\r\nvscode 中安装 Prettier-ESLint、和 Eslint 插件\r\n\r\nnpm 包安装\r\n一般 js 项目：\r\nyarn add -D prettier eslint\r\nTypeScript 项目：\r\nyarn add -D prettier eslint @typescript-eslint/parser typescript\r\nVue 项目：\r\nyarn add -D prettier eslint vue-eslint-parser\r\n项目设置\r\n找到项目目录下的 .vscode/settings.json\r\n文件，添加如下内容：\r\n&#123;  &quot;editor.defaultFormatter&quot;: &quot;rvest.vs-code-prettier-eslint&quot;,  &quot;editor.formatOnPaste&quot;: false, // required   &quot;editor.formatOnType&quot;: false, // required  // 关闭VSCode在Save时候自动格式化，因为VSCode自带的格式化和ESlint规范并不兼容  &quot;editor.formatOnSave&quot;: false, // optional   // 函数名后添加空格，与 eslint 规范兼容  // 在代码开发时，可以使用 shift+alt+f 来格式化代码  &quot;typescript.format.insertSpaceBeforeFunctionParenthesis&quot;: true,  &quot;javascript.format.insertSpaceBeforeFunctionParenthesis&quot;: true,  &quot;files.autoSave&quot;: &quot;onFocusChange&quot;, // optional but recommended  // set as &quot;true&quot; to run &#x27;prettier&#x27; last not first  &quot;vs-code-prettier-eslint.prettierLast&quot;: false,  // 在保存时，自动根据 eslint 来修复格式问题  &quot;editor.codeActionsOnSave&quot;: [    &quot;source.fixAll.eslint&quot;  ]&#125;\r\n更多设置参考：Visual\r\nStudio Code Default Settings\r\n参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\n\r\n官方：idahogurl/vs-code-prettier-eslint:\r\nA Visual Studio Code Extension to format JavaScript and TypeScript code\r\nusing the prettier-eslint package. (github.com)\r\nESLint 官方文档\r\nPrettier 官方文档\r\nPrettier 在线配置\r\nUsing\r\nPrettier and ESLint to automate formatting and fixing JavaScript -\r\nLogRocket Blog\r\nIntegrating\r\nPrettier and ESLint With VS Code\r\neslint-vs-prettier\r\n搞懂 ESLint 和\r\nPrettier\r\nVisual\r\nStudio Code Default Settings\r\n\r\n","categories":["Software","VSCode"],"tags":["vscode","prettier","eslint"]},{"title":"使用 VSCode 远程开发最佳实践","url":"/posts/2024/1XYHCAM.html","content":"首先分析一下，为什么要远程开发？本人认为远程开发主要有以下优点：\r\n\r\n一处搭建，多处使用\r\n只需要在远程机上搭建好开发环境，在任何电脑上都可以进行开发，非常便利\r\n开发环境隔离，可以在不同的开发环境之间快速切换\r\n对本机性能要求低\r\n\r\n\r\n远程开发方式选择\r\n远程开发方式：\r\n\r\nRemote - SSH\r\n通过使用 SSH 远程连接计算机或者虚拟机中\r\nRemote - Containers\r\n通过 SSH 远程连接到 Docker 容器，在 Docker 中进行开发\r\nRemote - WSL\r\n在 Windows 中远程 WSL 进行开发。这种方式无法实现环境隔离，但是可以在\r\nWindows 中获取 Linux 开发的体验\r\n\r\n选择比较：\r\n由于业务原因，有的软件必须基于 Windows 进行开发，只能选择 Windows+WSL\r\n组合，但是 WSL 无法实现开发环境隔离，因此还需要加上 Docker。\r\n虽然可以仅使用 Docker\r\n实现远程开发，但这会带来一个问题，需要在每个开发容器中安装 ssh、git、zsh\r\n等一系列工具和 vscode\r\n的插件，增加部署负担，增加额外的内存消耗；若需要增加映射端口或者新增挂载，则必须要重建容器，这个时候，容器里的配置将会清空，又得从头配置一次。\r\n综合考虑，最终选择了 Windows + Docker Desktop + WSL\r\n组合使用的方式。\r\n方案实施\r\n具体的实施方案为：\r\n\r\n在 Docker 中跑应用\r\n将代码文件挂载到 WSL 的某个工作目录\r\n使用 VSCode 远程 WSL，打开工作目录进行编程\r\n\r\n举例说明\r\n下面以 vue 项目为例举例说明\r\n首先，在 WSL 中，创建一个远程工作目录，例如\r\n~/docker-envs，将下面的 docker-compose.yml\r\n复制过去，运行 docker compose up -d 启动开发环境\r\nservices:  vue-env:    container_name: vue-env    image: node:lts    volumes:      - ./vue:/app    working_dir: /app    ports:      - 9527:9527    # 为容器启动一个轻量级的 init 系统，可以处理孤儿进程并转发信号，解决 stop 速度慢的问题    init: true    command: [ &quot;sh&quot;, &quot;-c&quot;, &quot;exec sleep infinity&quot; ]\r\n然后，使用下面的命令进入到容器内开始初始化项目\r\ndocker exec -it vue-env bash# 项目初始化及依赖安装此处省略...# 退出容器\r\n接着，执行 docker exec -it vue-env npm run dev\r\n启动开发环境，这个终端不能退出，在开发中需要一直保持。\r\n最后，使用 VSCode 远程 WSL，打开 ~/docker-envs/vue\r\n进行开发。\r\n使用体验\r\n2025-10-14\r\n从 2024年 10月迄今，使用上述远程开发方式大约有\r\n1年的时间了，在使用的过程中，出现一些影响开发体验的情况，在此总结一下。\r\nTypescript 重新编译耗尽磁盘 IO\r\n有时候在开发或者编译 TS 项目时，会出现磁盘 IO 耗尽的情况，导致 Docker\r\n无法响应命令，需要等待一段时间才恢复。\r\n这种情况可能是由于 Docker 卷挂载开销，编译时频繁的文件同步会消耗大量\r\nIO，尤其是热重载或增量编译。\r\n目前使用来看，出现的机率不是很高，也可能是由于内存原因。因此先保持原样。\r\n2025-10-28\r\n上周末抽空将 DockerDesktop 卸载了，然后在 wsl 使用原生的方式安装\r\nDocker，使用了几天，至今未发现磁盘占用率过高的问题，开发的时候，爽多了。\r\n2025-11-05\r\n今天感觉能完全复现磁盘占用过高问题了，当使用\r\ndocker exec -it containerName npm run dev\r\n重启开发环境之后，再使用\r\ndocker exec -it containerName npm run build:pro\r\n进行编译，当出现以下输出时，磁盘占用率基本就会到\r\n100%，同时进度卡住不能动。\r\n• Compiling:└── SPA ██████████████       69% building 10075/10126 modules 51 active\r\n","categories":["Software","VSCode"],"tags":["Docker","VSCode"]},{"title":"VSCode 为 eggjs 配置远程调试","url":"/posts/2025/1KK88PR.html","content":"本文将介绍如何在 VSCode 中为 eggjs 配置远程调试。\r\n笔者的开发框架是这样的：源码位于 wsl 中，然后将源代码挂载到 Docker\r\n容器内部，容器负责开发环境的运行。在开发时，使用 VSCode 远程到\r\nwsl，然后打开源码目录进行开发。\r\n\r\n配置步骤\r\n\r\n将 eggjs 中的远程调试端口 9999 暴露到主机中\r\n按官方介绍，默认的调试端口应该是\r\n9229，但是在实测中，该端口未启用，而是使用了 9999\r\n在 .vscode/launch.json 中，添加如下配置\r\n&#123;    // Use IntelliSense to learn about possible attributes.    // Hover to view descriptions of existing attributes.    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [                &#123;            &quot;type&quot;: &quot;node&quot;,            &quot;request&quot;: &quot;attach&quot;,            &quot;name&quot;: &quot;Remote Egg Debug&quot;,            &quot;address&quot;: &quot;127.0.0.1&quot;,            &quot;port&quot;: 9999,            &quot;restart&quot;: true,            // 本地程序所在的目录            &quot;localRoot&quot;: &quot;/home/xxx/app/docker-dev-envs/eggjs&quot;,            // 服务器对应程序所在的目录            &quot;remoteRoot&quot;: &quot;/app/eggjs&quot;        &#125;    ]&#125;\r\n\r\n参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\nNode.js —\r\nDebugging Node.js\r\nvscode本地debug远程，出现错误，期望获取正确的debug方式\r\n· Issue #4700 · eggjs/egg\r\n","categories":["Software","VSCode"],"tags":["VSCode","eggjs"]},{"title":"VSCode 为 midwayjs 配置远程调试","url":"/posts/2025/GJ9ABG.html","content":"本文将介绍如何在 VSCode 中为 midwayjs 配置远程调试。\r\n笔者的开发框架是这样的：源码位于 wsl 中，然后将源代码挂载到 Docker\r\n容器内部，容器负责开发环境的运行。在开发时，使用 VSCode 远程到\r\nwsl，然后打开源码目录进行开发。\r\n\r\n配置步骤\r\n\r\n在 package.json 文件中，向 dev 中添加\r\n--inspect=0.0.0.0:9229， 即\r\n\"cross-env NODE_ENV=local mwtsc --watch --inspect=0.0.0.0:9229 --run @midwayjs/mock/app.js\"\r\n将 midwayjs 中的远程调试端口 9229 暴露到主机中\r\n修改 tsconfig.json，在 compilerOptions\r\n中增加 {\"inlineSourceMap\": true} 配置\r\n在 .vscode/launch.json 中，添加如下配置\r\n&#123;    // Use IntelliSense to learn about possible attributes.    // Hover to view descriptions of existing attributes.    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [                &#123;            &quot;type&quot;: &quot;node&quot;,            &quot;request&quot;: &quot;attach&quot;,            &quot;name&quot;: &quot;Midway Remote&quot;,            &quot;address&quot;: &quot;127.0.0.1&quot;,            &quot;port&quot;: 9229,            &quot;restart&quot;: true,            // 本地程序所在的目录            &quot;localRoot&quot;: &quot;/home/xxx/app/docker-dev-envs/midwayjs&quot;,            // 服务器对应程序所在的目录            &quot;remoteRoot&quot;: &quot;/app/midwayjs&quot;        &#125;    ]&#125;\r\n\r\n参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\n新版本如何在chrome中调试\r\n· midwayjs/midway · Discussion #4122\r\n调试 |\r\nMidwayhttps://github.com/eggjs/egg/issues/4700)\r\n","categories":["Software","VSCode"],"tags":["VSCode","midwayjs"]},{"title":"Windows Terminal 配置文件详解","url":"/posts/2020/S47705.html","content":"Windows Terminal\r\n让人一见到就爱上了，为了能够更加方便的自定义，下面列出相关的配置及说明。\r\n\r\nsettings.json\r\n// This file was initially generated by Windows Terminal Preview 1.4.2652.0// It should still be usable in newer versions, but newer versions might have additional// settings, help text, or changes that you will not see unless you clear this file// and let us generate a new one for you.// To view the default settings, hold &quot;alt&quot; while clicking on the &quot;Settings&quot; button.// For documentation on these settings, see: https://aka.ms/terminal-documentation&#123;    &quot;$schema&quot;: &quot;https://aka.ms/terminal-profiles-schema&quot;,    &quot;defaultProfile&quot;: &quot;&#123;61c54bbd-c2c6-5271-96e7-009a87ff44bf&#125;&quot;,    // You can add more global application settings here.    // To learn more about global settings, visit https://aka.ms/terminal-global-settings    // If enabled, selections are automatically copied to your clipboard.    &quot;copyOnSelect&quot;: false,    // If enabled, formatted data is also copied to your clipboard    &quot;copyFormatting&quot;: false,    // A profile specifies a command to execute paired with information about how it should look and feel.    // Each one of them will appear in the &#x27;New Tab&#x27; dropdown,    //   and can be invoked from the commandline with `wt.exe -p xxx`    // To learn more about profiles, visit https://aka.ms/terminal-profile-settings    &quot;profiles&quot;:    &#123;\t\t        &quot;defaults&quot;:        &#123;            // Put settings here that you want to apply to all profiles.\t\t\t&quot;startingDirectory&quot; : &quot;.&quot;,\t\t\t&quot;background&quot;: &quot;#013456&quot;,\t\t\t&quot;acrylicOpacity&quot;: 0.8,\t\t\t&quot;useAcrylic&quot;: true        &#125;,        &quot;list&quot;:        [            &#123;                // Make changes here to the powershell.exe profile.                &quot;guid&quot;: &quot;&#123;61c54bbd-c2c6-5271-96e7-009a87ff44bf&#125;&quot;,                &quot;name&quot;: &quot;Windows PowerShell&quot;,                &quot;commandline&quot;: &quot;powershell.exe&quot;,                &quot;hidden&quot;: false            &#125;,            &#123;                // Make changes here to the cmd.exe profile.                &quot;guid&quot;: &quot;&#123;0caa0dad-35be-5f56-a8ff-afceeeaa6101&#125;&quot;,                &quot;name&quot;: &quot;命令提示符&quot;,                &quot;commandline&quot;: &quot;cmd.exe&quot;,                &quot;hidden&quot;: false            &#125;,            &#123;                &quot;guid&quot;: &quot;&#123;b453ae62-4e3d-5e58-b989-0a998ec441b8&#125;&quot;,                &quot;hidden&quot;: false,                &quot;name&quot;: &quot;Azure Cloud Shell&quot;,                &quot;source&quot;: &quot;Windows.Terminal.Azure&quot;            &#125;        ]    &#125;,    // Add custom color schemes to this array.    // To learn more about color schemes, visit https://aka.ms/terminal-color-schemes    &quot;schemes&quot;: [],    // Add custom actions and keybindings to this array.    // To unbind a key combination from your defaults.json, set the command to &quot;unbound&quot;.    // To learn more about actions and keybindings, visit https://aka.ms/terminal-keybindings    &quot;actions&quot;:    [        // Copy and paste are bound to Ctrl+Shift+C and Ctrl+Shift+V in your defaults.json.        // These two lines additionally bind them to Ctrl+C and Ctrl+V.        // To learn more about selection, visit https://aka.ms/terminal-selection        &#123; &quot;command&quot;: &#123;&quot;action&quot;: &quot;copy&quot;, &quot;singleLine&quot;: false &#125;, &quot;keys&quot;: &quot;ctrl+c&quot; &#125;,        &#123; &quot;command&quot;: &quot;paste&quot;, &quot;keys&quot;: &quot;ctrl+v&quot; &#125;,        // Press Ctrl+Shift+F to open the search box        &#123; &quot;command&quot;: &quot;find&quot;, &quot;keys&quot;: &quot;ctrl+shift+f&quot; &#125;,        // Press Alt+Shift+D to open a new pane.        // - &quot;split&quot;: &quot;auto&quot; makes this pane open in the direction that provides the most surface area.        // - &quot;splitMode&quot;: &quot;duplicate&quot; makes the new pane use the focused pane&#x27;s profile.        // To learn more about panes, visit https://aka.ms/terminal-panes        &#123; &quot;command&quot;: &#123; &quot;action&quot;: &quot;splitPane&quot;, &quot;split&quot;: &quot;auto&quot;, &quot;splitMode&quot;: &quot;duplicate&quot; &#125;, &quot;keys&quot;: &quot;alt+shift+d&quot; &#125;    ]&#125;\r\n来源\r\n【1】详解Windows\r\nTerminal配置文件settings.json\r\n【2】windows\r\nterminal 官方文档\r\n","categories":["Software","WindowsTerminal"],"tags":["WindowsTerminal"]},{"title":"iEPC 安装教程","url":"/posts/2022/R23RB6.html","content":"本文为 iEPC 安装教程，方便新用户安装使用。\r\n\r\n安装 iEPC 有两种方式，分别为：\r\n\r\n通过命令行安装\r\n手动安装\r\n\r\n建议通过命令行的方式进行安装，这种方式更简单。\r\n命令行方式\r\n打开 Powershell（不要以管理员启动），将以下命令依次复制到命令行中，按\r\nEnter 执行。\r\n# 安装 scoop 软件安装器irm https://app-installer.pages.dev/install | iex# 安装 iepcscoop install iepc\r\n至此，安装完成！\r\n启动方式\r\n安装完成后，在搜索栏输入 iepc\r\n即可搜索到已经安装的程序。\r\n也可以直接在命令行中输入 iepc 启动程序。\r\n错误处理\r\n上述第一个命令若出现如下错误：\r\nPowerShell requires an execution policy in [Unrestricted,\r\nRemoteSigned, ByPass] to run Scoop. For example, to set the execution\r\npolicy to 'RemoteSigned' please run 'Set-ExecutionPolicy RemoteSigned\r\n-Scope CurrentUser'.\r\n需要以管理员身份打开 Powershell，输入\r\nSet-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser\r\n，然后输入 A，开启远程脚本执行权限。\r\n手动方式\r\n软件下载\r\n请通过企业微信中的iEPC数字化管理平台登陆\r\niEPC，然后在知识文库中进行下载。或者向同事拷贝安装包进行安装。\r\n安装环境\r\n该软件需要安装以下两个环境:\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n序号\r\n名称\r\n版本要求\r\n官网下载地址\r\n\r\n\r\n\r\n\r\n1\r\nWebView2 Runtime\r\n大于或等于 103.0.1264.71\r\nwin10及以上，win7 x64位\r\n\r\n\r\n2\r\n.NET Framework\r\n大于或等于 4.6.2\r\n点击跳转\r\n\r\n\r\n\r\n如果是 win10 用户，只需要安装第一个环境；如果是 win7\r\n用户，需要安装上面两个环境。\r\n\r\n特别说明：\r\nwin7 受支持的 webview2 最高版本为：\r\n\r\nruntime：109.x\r\nsdk: 1.0.1519.0\r\n\r\n\r\n选择官网下载时，对 WebView2 Runtime\r\n按下图所示选择版本：\r\n\r\n对 .NET Framework 按下图所示选择版本：\r\n\r\n\r\n\r\nimage-20221117114034963\r\n\r\n\r\n选择运行时版本\r\n\r\n安装 iEPC Desktop\r\n\r\n下载新版本软件，可以从企业微信的\r\niEPC数字化工程管理平台 上下载\r\n解压软件到安装目录\r\n解压位置根据自己需求来，想放到哪儿就解压到那儿。\r\n如果已经安装过，直接解压到原安装目录覆盖即可更新。\r\n点击 iEPCDesktop.exe 开始使用\r\n可以将它建立一个快捷方式到桌面，方便使用。\r\n\r\n\r\nimage-20220708164006662\r\n\r\n\r\niEPC 目录说明\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n目录\r\n作用\r\n可删除\r\n\r\n\r\n\r\n\r\nConfig\r\n软件配置\r\n否\r\n\r\n\r\nResources\r\n系统资源目录，比如图标\r\n否\r\n\r\n\r\nruntimes\r\n系统目录\r\n否\r\n\r\n\r\nUpdate\r\n系统更新模块\r\n否\r\n\r\n\r\nData\r\n保存用户的操作历史，比如项目登陆历史\r\n是\r\n\r\n\r\niEPCDesktop.exe.WebView2\r\n打开 iEPC\r\n后自动生成，用于页面的缓存。若使用中出现异常问题，可以考虑删除该目录进行重置\r\n是\r\n\r\n\r\nLog\r\n运行日志目录\r\n是\r\n\r\n\r\npublic\r\n静态数据，主要用于缓存模型文件\r\n是\r\n\r\n\r\ntemp\r\n临时目录\r\n是\r\n\r\n\r\n\r\n常见问题汇总\r\n\r\n安装 iEPC 后，打开是空白怎么处理？ 这种情况是由于没有\r\nwebview2\r\n运行环境导致的，按上述环境要求安装后即可恢复正常。\r\n安装 iEPC 后，打开时闪退怎么处理？ 这种情况是由于\r\n.netframwork 的版本太低导致的，安装最新版本的\r\n.netframework 环境即可恢复正常。\r\n如何查看 WebView2 Runtime 版本？\r\n打开 PowerShell（win+X），在里面输入下列内容：\r\nGet-ItemProperty -Path &#x27;Registry::HKEY_LOCAL_MACHINE\\SOFTWARE\\WOW6432Node\\Microsoft\\EdgeUpdate\\Clients\\&#123;F3017226-FE2A-4295-8BDF-00C3A9A7E4C5&#125;&#x27; -Name pv\r\n如图即为 WebView2 Runtime 版本：\r\n\r\n\r\nimage-20220726132715459\r\n\r\n如果小于 103.0.1264.71，则需安装更高版本，&gt;&gt;&gt;传送门\r\n如果运行结果如下图，说明环境完全没有，需要安装。\r\n\r\n\r\nnoWebview2\r\n\r\n如何查看 .NET Framework 版本？ 打开\r\nPowerShell，在里面输入下列内容：\r\nGet-ChildItem &#x27;HKLM:\\SOFTWARE\\Microsoft\\NET Framework Setup\\NDP&#x27; -Recurse | Get-ItemProperty -Name version -EA 0 | Where &#123; $_.PSChildName -Match &#x27;^(?!S)\\p&#123;L&#125;&#x27;&#125; | Select PSChildName, version\r\n如图所示即为 .NET Framework 版本 \r\n如果小于 4.6.2，则需安装更高版本，单击跳转下载\r\n\r\n","categories":["Software","iEPC"],"tags":["软件安装"]},{"title":"01-建筑结构可靠性设计","url":"/posts/2022/2XR0S9K.html","content":"通过学习本章，心有所得，总结如下。\r\n\r\n设计基准期计算\r\n\r\n\r\nimage-20220315234743456\r\n\r\n\r\n超越概率 = 1 - p\r\n\r\n建筑结构分项系数\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n系数\r\n说明\r\n作用效应对承载能力不利时\r\n作用效应对承载能力有利时\r\n\r\n\r\n\r\n\r\n\\(\\gamma_G\\)\r\n永久作用\r\n1.3\r\n&lt;=1.0\r\n\r\n\r\n\\(\\gamma_P\\)\r\n预应力作用\r\n1.3\r\n&lt;=1.0\r\n\r\n\r\n\\(\\gamma_Q\\)\r\n可变作用\r\n1.5\r\n0\r\n特别注意，有利时，可变荷载的分项系数为 0\r\n\r\n\r\n\r\n基本组合计算\r\n如果组合中，有两个及以上的可变荷载，需要\r\n取最大的两个分别作为主导荷载\r\n进行计算。其计算公式如下：\r\n\r\n\r\nimage-20220315234804078\r\n\r\n当有 2 个及以上可变荷载时，快速计算公式如下：\r\n\r\n\r\nimage-20220315234849739\r\n\r\n标准组合计算\r\n如果组合中，有两个及以上的可变荷载，需要\r\n取最大的两个分别作为主导荷载\r\n进行计算。其计算公式如下：\r\n\r\n\r\nimage-20220315234952803\r\n\r\n当有 2 个及以上可变荷载时，快速计算公式如下：\r\n\r\n\r\nimage-20220315235059208\r\n\r\n求内力的极值\r\n最大值\r\n如果题目让求内力（弯矩、轴力）的最大值，则应：\r\n\r\n同时组合所有可能参与的活载\r\n对一些较大的活载，分别设为 \\(S_{Q1}\\) 来计算，然后取最大值\r\n\r\n最小值\r\n如果题目中让求内力的最小值时，则应：\r\n\r\n组合时，尽可能少地考虑活载的组合\r\n\r\n其它经验\r\n在审题时，要注意给定的一些条件。比如提到钢结构 和\r\n检修材料，就要知道据《钢规》3.3.4 条规定，要进行折减。\r\n要注意一些陷阱，有些时候给的多余参数是没用的。比如当只有一个活荷载时，给你组合系数，计算时，就不需要乘以组合系数。\r\n还要熟知一些简单结构的内力计算公式。比如简支梁在均布荷载下，跨中最大弯矩计算公式。\r\n","categories":["RegisteredStructure","01-建筑结构可靠性设计和作用"],"tags":["一注结构专业","考试"]},{"title":"iEPC 设计协同使用教程","url":"/posts/2023/2W88WG9.html","content":"\n  d75ef329778776b4f3f8fa697b97b760b271f482fd34e20f6443bec5c9bb22f002fe666a90819676c97f91d62abc1417bb203ef71971f9dd2a799567e2f4a79b496bc5cbe7ade328cb129314785b24e371a1d2c6d2b5873ddbc835dc6b7edc776e24e9c04a157de16592e7fa2743d7bffba9e8175b6c3765b4c7233b84101f4c87c8a58e21bc76dc7ccf2e9d60654415b23f0bf08bc8c9dbdaacd9158c29af7bc621d3975b5b035c20b7d57a441b5835d74cf939e2a45fed974542c7f9163e1704bfea7cd9d7e61e6fb0b2b5f1ed6b7556c7f23431a041e1d0ceb0af93a37158765519352a28911c371b787c58b9efc22677ec3cb62fd46de798496c0c2d0c9eac5e02f59dfcf876a597dcd0734f0a8e85577cfa735837e65f626c99511d24fb0ee64fbfb914bad73d6f8e422afba86626cfe3ed4f10a1dcd10095221a43822053d6722d66fd640d8d9750b06d431925cf8e43a2b69a4e0683ef708db3321b36eca053aae266e07049bcfd12231ff323969d6520102d725d7a06f99a19c2fca10081f93d977d1766a0822d79762cf4e99bbc1352ab854d79217afd912907310eb8b1ad9cd9181c112e46d3fa8e2141600aa4dc803d3913bb5e939a4dfcc5ef74f3c35e719df4bf40f5af8bf25eaf383708fb4b046a65c29c1cf322a8cb159e43dd854990a179660c6fe805f91053ff1d30f627c967e426dc3f4415bf2c649694884f4accfb54793aeb7e4971728ebed1ccbb2cd8d8aaa22fded05e5349d1f5b7bf96e59921b7d9365c62b54828fc40022df47cc28cad238465dcdbd96769c150c858bbbeefaa06a4b5184cd79ef676377e8b63f09c5046669345509539a78ae5705de02f68095f95bfe459b0fbbc29b106f3984454d67fb4b10ce5bf4f4e77f0cd81e01be6f3f6595ed61b2adec5c53f3e0118b6ab004e0009e1fa304d27bc41e899504f9f7627107686dbf671e24c51619d235aee662aba072781883272c04e81478cf8864b988d6da8dab3ae71fad855333a98a7b9672183bee2c12eabfbdfbdc0a90e61193b1af901c5ccd779543ae1fdc0e5d6b0193b7a05012ee9bcc2fb706ab9ef7ad6ba4b68ac85d6af39d55e1d5b05d45d4688be5bf7e86e74992fff97ae12ecf4185e8ec915a65ad9521bc01479f55909dfceda5768ecb9d66bffe131c428015181df3a9625dc40b7d4461c4b32db3dd0c2ed39c73bbb4e73525fd8053fb25e2663e0f9b808f2d14e77e0b867625e44ea00fca9bffe11e2bcc7cd71e9d3fbecc12ccaafea34dd809a1b3b45bf06a24f31e9b52953264fd159ee2888627e7b9ada146f3b898b3e576d42e1d067c83c59874163ae75ba1d2a4141b030b5d12120551cedd854b555067611a7f572755de35c8a1fc3a453ca590dbb1ff764503c4837463b156da6d93bcf37753fb034f3f1d0c81fea188bea08366fb2ed6a7bab7f8a01dd67c3d241a78de16f2be3ee7aab6fb300e5a32c4ce422979f89278f54afc0e0185bccc077560dbe766bd667c3e40f71a07ce18d1ddb65b06ca41e2c50a889c08deef3d2f17e406a4bbbe22f35ac9416e0bec038281bd04cc1ad056e976b5b6bbed13f43e8ce99e821db5505b02ed382d6914e702e2afe966bf0cfb36c6e0b6e496a5902b80d74a6a2785b5b6f14a4949e01b938490f2555d7a55f997de728b76aa2f1fcc889c37e05ce0a13cd4943f6f24a331279bc607022c78c3e15ac4edec803c08395d929608ff814a1ee334ebc237c872951906d05ed0498a90fc4c0231063c15c772f75526626666f1ff541055e4835dd86b4794bf194d3a94e91ccb8f654d6b96388907c80b84748fad48504ebeb2d491734cdedc13310a90f3d161b7b3dcfacbd6230955bfd4ac87b94a1195389283a730ea6e2190819ed435955aaf40bc410c713cc74a7a2ac7cc54e184778ea33d1bea5ac70deb4de92826e9f533c4eb368b566059fa68ca4201320466bd7eced2dcffccfd443bca429a61b2f3efaf3ebc369afb68009ba71074572687457d7883e5d5ba6e1041f20769c99f45099703208bb2913dbbfcecccf803f3aa02688c3cf77a79b03383ca7dc8f1abd533275cbc944002d4e71d9fc5514d7d1478ec5330a522be4b984e51f26f108d6f642f25902f8645c909fc500e72c5c3cb788ea0411153c200fd6ba8070091246789ad990c58ca5cc7a043ba5bd21bbaf1964fb30f598d6163e68cbffd803b031847e02faa0c84a2f353de6aeb2519c3c7abb6dc3f740f692a1e46cf06a85d64edfa5fc2362d29dd5c8b32e45b1942b8e56a2af867cf15a440629f148c1643cc08d5e0a0b32a7525b0640c9568a8e6993f2b8fdf7c5b533aa2e6271e29f4009054268d9bfa91c08f1976016fb4ee227d86ebcaeaf4d926c15e9b290aacd6789e1bc75aa191d374bfc4a08bce89d9a7bbaef1539c3ea66ab3cdacc750d97c8137a24a66fd4ee7a7411f9cf9b3cdfdea8cb7190b125ea148f87e1d290418fa175b8dc1939a10a86efa62470bd9b5faf9e40b0428855985a6a1dadad9016c391ee4e82755358afeba035298e03804e91778efb621b48879fd02cd54980278a158d273b7dd6f3762512cb36e01ebfa26b3ded4960d5b37c58e8d86417ce832ca369e7d778a4a629025ba5877247e6191486e791cf764d4aabc365f3409cb7be4cf3d9677d3b0297a95bdeb7ca309a114a18f33e0da5b5b90e2f0a2d2a9a34f8d8ce9c8e2052940fa65deace9ffc8cea9eafc5f3ef2dfa2b0443847bb9b7d5f904b6efb81bc6c36a5bdf279ae26a5ac76e134c17308b702f5640cc980702aee4ff9eb7c84ebc8ad440efc92f855e502dd9c3bc24918409c3b2cc323335349202166ece8c13df25b979386407eeb2bf83d92ff3839511800cc918b3f5ed0b3a9541642dae90a8a39a55ecec18f21f84e421983e66ff28d1d0879d404799d0a9c43678c994cbcd8234d7a7cea9b74bc6eac92a3b617faef1fcc6d563b9c6c92978d2b734ee687d0a62125741fc8acac2d21492553aeae145825583c77f2a8c198dc9aa5718d4e83f341ca8c760426b0f5446fbf938d71edaecc1d7b9bbbc23082cafb7a51712e7c2aea9345165deff1b6c81ae863719375a92fa706bb75e766fd8257549ffe25dfb8103f70c92ad172af22fe422f46e88acbeeee5c2704e62fd5557cfeb6d2f4c999ffe0e77a2d3a10cc60025d220cc80e07094a7d74325cd1ff6a877312d51ea7f56db50b3171a256581bcbe026e33ae8b7dc9c74637d2592f226b2bfa158268ddcfc0c2d592c3529785279216f2b0d7f7c5f0ea65b123e7f0c81cf02510ed974fb851fd8a7425a948d2013e9e0d3543b61d16c440f0d428a249133cc41e37545c3801057e6d028b5559d3315f3c2c34f1047e373e32cce45dbb46df6fd78a3be07dbc2cee2748b343207d31220e533fdc28c3b27b4eb9646a3de83c0c42afea76206f2c8812e953f4d662b06b0b1cadf7c713fdf356aacd1b1bc01f6f329573efd82ac81a3e6fce7e6690bcecec0e1346204086712bd836d31eb3226d0b40f92490256f087dddc5e3821775c489f334a8aa25154e65b8959231838abf3ef752fd479517a26545fd7871aaa42911ca4271830c134ad333ffdf596586938deb898b6764648e28e1212f3def50e5f623ac0870771d4b0cb4f994e550a8cbb10ad6f530c747a56f8d7a509163ac48527048ee1ea0d2339b03993334e2c7760238b5d7ef8bf4ebd57b3f5004cc59e94b8f636ee57c3a4b5ba6c370028c3168295a4ccd5a6ab3dc0f2d49ad09765bedc24d6ded0f7298f00b2000c739332fce497d09d9a99f312f17bd2a577461d7a7be86d2a047f98d242e2df7c465847ac142db2c49ef7a1886968448be972e846f634677cfa5592d0b8fd795612fd662359e9c80a233659195eebcbdecd48152466237aa042ca50fed1ac185402ef419a9ee9498851fa0c53f5fd55976b8de90728ff15a3e1c2fb8bb6995313a5a83ef11b6cfae01b2ac1bedf3470a55d321e7a6b2e411045a89886710b74f2a7faecd37de1b8d3b3ddf3fc975e3a90f09a6bc2d06f17905e8d0351e626689909bfe0c17ec50db838bcda721dc81275bcdba47baf79e631c9a0548621c05d47898a2bed1bfd9ba0989f5b9c91ad4f4782d05e7459b115943f66976fbd05fdfca5e00d1c502a33542b0cb94ee14b1033a39cff84ae94e8272cb50c1921258482ce62415c8225ff5b4fff653bb1cbbaa7d1316249f1ee6870992904d035274b257c7e50dc559174aebefa06802cdbdb3cd017e968df0216e40c7e3b979d46ad2298a71160c00173ceb2cc68273dfb71ef07739f8981c6539b77ec4befb5890ec6104ce7971e4b394cb21d5f0ab11a060ec4f2be9452288e35241d587927dcd11e79356ce143285db494a156a1fb748ff97c65eff2ff21d91e0b6d0558c754b547cd6bf983cad11e977c7962319b64aae456ea5484cdfc0f6f47fe32366d8e5a5b4840520a594534db4d15dc9ba23ce250da59939fcf3ba395d1cf7957df4fcfbcdd6a9f8c6a35387ea294a8ac23d257de1e3d8e359a0295bc72e0bc0ca764b24cc5ef941af55095a439b53af5f5730e3bb6faeeab33f312f87685f6036867c473ac4192a70254627f81bcf56075b3e3886d8f8ced1ec53aecfdb3e3ad026fa5323abec32b2a59c6860dff7e8f7e329b8813ee988ec4a7ef0840c3d296d22f11a495cb0762212956bc9508bede97599159da99c1af731073341f1eb20ef5a08fb39b7cdaf23fe7f5ed6b918b60e169ac9b5e0f2005062f05692dc6a554107063c2e35de9990a6189f1e5fbe4267d22ac4ad0ba932088b2f28e3700ebd66c8a153725dae02491fc39366f9ad219ba0920379158891aa201f839a3ea145c5d103488d54f7692b0d72a0bdf8a6e0c6d1810e42e815a14a1ed3093a4dc495c8e1f12c581437b864bd1f0b1384f6b2435ac4c2406d8108d38c67a94e11e766dcb7a47ffda4c6bd95b460fa3d1810905d5043cca8d9c2d275c19ff4e43fb938766f1a5ed1103c3f2f49c44e0dd2df187e4b9430f0da6501a8f577c313984736bac100168a3c6c220c462e518f81477ee8ce20c43fbbb70dba05eea45e4f9fe937f81ab56e05a63d1d28756d1cc42d2abb4337eab18211f4b5639a831e354df0fff1ebebacf6df56b893f694288995a0a74c48c38b40f389b8c3ab30b112aff7f7b04b148ed7fd3df3b484ce3e1f0b2eef9928d6a7e8899ff908a49725cf6a9ff676bde684cbfe5712b44e81908631d17108bf653157ab31c6e4324f37b2fa1b863ecfe71e403bb688779f74f55a229331048b0038dba8a15b5fd22b3b8215c7ad166333cf17b356620b6acbb983f30af774cbce92d2a64724730ff3204a028af50f7684dcf8e1b251db91c3d4369f7babc37b92f1cdc49111a9eee04ec3371d6f7df1ead95283e40a4a7c75e86ae49c40b182c9763a69c876024b27f1ac15cdc3fbd2efd4cfddc3a25b0bf2d37a2595ea20dc83cf2127b535c4db67b4f803a47f7bc81dfe9e85cf5daf115962d3efc86d074372b0ac30841beb4c364a82625212c43a472362757b77c5faa68f69c1355a516a6ecedccd2a47a9f41e86ed9ad04a274a5496be0a75305e71db8fb6eb2a53627f48c319c8b65f0803baad3aec92c0379af675e0ae8c49011ea3920d792f6e1e14dfa23fd5aa97019307bb7a0cb2af3e2d0e285f03de0e25143700d98f793cac6c1b9cacba871f518baab950f69dc1db868831ecda5976b7d93fdeb13971a341d2dfd51a28f2ac8922d059d4233c58a56952ae0b79dab27654a1891c0758e92eeda437e7da8f82a21f3f822fa177c8f5f8d67d1baeda831766f4cd601a87a2d5ca319dd12ab2d24fb156aa2802298417a6b6a035d9c8b464eab6c025ff2110a2a143b8dd8dd51aae60a653f7286f222591ada7cdb1c545ce2237eba2a88f1d4eefa062f3843a2a8f82d32c7e8e24e69a2284a1d538566db0add07d4b01afd95cc62680feed0f9dfcb8fc5656d7951479d1345081c133b9e75289218d3ffa47c4a9e5d18ddb39f18882e612452a8f3502ea91fb5f4a93e17d834581b291e76d4799fb42a42c660a268f55f3a8df80573e329c91f4bd12201e757cf391f7ec2b468bf3627fbbc43c0878c3a588253c5b53f5fb503048bf2c9863359b2bcb4ed8912e1b52bc852090d1538137d44d5bcf1fb33fbf93807a8b2a25b0d507253c3dcb31aa0c39dd5ede0330370da08055ca563cebc5fe566139867f936165445b0823ec5ccb0c4cf814b0d685c8b2bdebe7015c56047e50a7dcbfac7b08fff7be306c8896b9b9b21d13b423fea11c2d5db69a25760e7b94623761b4df727387a6f881cedd24c514a61748949aa8604f6550ddefa56f592c9d3ca404cbeda76ee686d778ed0ddd3da2ff43712822958f496bdaf219a0e5fd1ff5c65339be36824e7a383ac7cffea348d7757c5ef59233043692306128140d203371e58188acf99afcd315063ff710145a124e7c7c267c46cd715fa30b8729b720492be8c3a10d9250a0b2ee92d7b4ce8dcc5ba354d3383d49c036da15fda9ab5c62f33ee813de8f1559ce1b03323b77351ed4ea54b9b84ac0037fa8957514ea3e2835b2695d8db0be98e68684fa5e8ebb5351e8051c53ad215e257ca1d9db87c3ef08bde8e4dcdfd13c15411293a4d5ec472f1130d478c211b169cb3e200b757075f8e7155f2ec0aa7664df87fb566bf56b37fe2c1d56da50063979065739b8459d8904f91d22e8e6ebc00971d65dbe7c6e85dba329dd6c50c8ff1f2469ecd49d411e54425865fa82be39dc6131b3d55d95770c1ec15600b7066b43f00edafa47ea149605247887b7ef97d5a6a235ac8d2e6aa7209acd50b2706b6fcf4dd02aec99da2d788bc320235cf4fc7cae8f896e971280bc71b6e6dfcfa3d6d61e079946767cc99afd195ad243b52b67ecfe3cd481a3fd81cbb9a4eefb9c996d57d50d7cfd2db9eeee9ef031e77379da38026b3d485d412cff2cf8f9c4a83b8ea1692881287db8ab98c7a9bad7f72975985f95a6d06e9593402047f0c9bbb7d80a2d528a294ea2dca0b2d17d60f0b3c4d38de2a77b0ae41f2f3fe12378ff09e5b77f8a86d359825a7f6779cdf0607b90075fbeba90fb28be61d79aa536fcfe7ad217a65c8c866b04deb609e7f89666e8a189d818a2d53abd969723c6c37e4d21627f72f33eec4886c838e7b5769202952a3bac57494f0dc298c26db901a40b62bca4153d715f71365c569942648e9ea77ba6071894846a67be5fd58697372b8b24ffd2eded6255fd8544cc541d9b06c4d9b6ff5da265db5a5ffc7730009dfef954ea9bef607bba53b950e3eed3164531626b93b91f671ccd051e1d95caf41f7e09207124f51f6593823e4c41482c4c8f4df59e12cb30fa6feeef4a6eb99527a9f25aa4d8bb69b399a91a0bc10d91a42e4e9c7ed1b236eb9dc7b45a56930287a4e996fcd2b7181097b90713a9c94eaf19bee0baa7235188cc00d3d26db0587859878533e170f05ddd1b20ef204705d3642ed4dd206cb9dc195eafd4396414c96e53953034a07a708198333393e48a80f273080cd02727078a50f1680fdaeb6d6325b6e560ec868173c001f4f3668ca6deb3880bdcda03cdec6bd8088923498da37be0449b64e98a55df14e22f5abbba13be69c9759659c9863d6b3658a4df2516c251b85ee448533059d72f17891d4be47eca57e9538768d90034d38844b344f4a80f86bd4b16d3a1655e69e260f101dbf3bae7191cbde5daaeac460fe25cc2adac5fd9a7fa9ad2bbb9fa63c60917cc37aa39edd67f211c513ab58a92ea19927a437d6a17cbc62ea000dd891d110f905c9020fac9f38b42da188daec320dc4895bc5f1f989e6fbe270c42f6def00f5c8c97d19994670b7c61942e9dbf168180867114cedb9d658e0c543e88e572b4f693be04f055affeb6aef4b5f13c88e1d5257f7295262df02a018424ba5436fd1b1d9b10ae47cb3ea796926736f751a6158aa2bc4038ed9a0129f50dfbab2b2848af6d7e221153c16bac058fbfebb4356fdcb900e59dfa2936099190e9d6a44891e327d7506457f9f07f0a6a20a6a7dc652f4149afa20d72fb3bf03beeebae6153152f9029db7b09fa20439775f9cb70e808c626ab37f6b48b7d379f11d7613801b51119c2b0f809cf839393e49270f7ea2dc95bf42c1443fcec75520a2a02ec48ff86bbe327a3af11a45ba78805dd0a17ff8724dc8e7f89a222b85d4c251124e8170c1251e73b95586355241795dd38c8dbfc3cf41e1665238e47baa0ffd46e0c7308eeef0c7a13efbe565bce926904f683624eab425f3664f41cca68586b2d6c6c3ff69e0a68af3f02ac99d357216d3f81eb11435787e0347e743538c12a002b363d3fdea96061ac4eac753d4b4923606e4a55ad7143e45654bd146ff48dfda30c0f0cbcbeb829feea138ee2a156d1e128a7c094abb920c1dc834c33a01e8b10e16185a677403ae5a1687538efabe562fb1f6ef28cb486fb3684f534699a599361de554cb53dbf66374b970e9f69c9b223db9380d19f8854e88996e873391d32ffc28ce2aaf624b7bc014dfc1e9011c56727ff697789d70437cc167015737fdc83e9aaaf40ef8177e0a484731e5401ea7f9d082f8e1f2b5a2d4321985c218f92fcdd3ae5e43ddacdf35766e1077466d1e7e255bcaa905865c81d1e2a27d2421b0cf5fe0a95708a58add31e5b17f3d8e42fc19c3f64b29eb7875980089c3c712aee63383ac4d822edd5c30817121a3c5c26b6cb50993c05c847e07a3b1d4834c935a9c55923f7bbd7ecb40b84e002ee347665b0447cc640a20e680a14cbde049866020cd13d700785ada5e85250728e3d513a4a934cc2affbe6a033f9f2917b2a49a97dbf84e129af500f1bf1c76ce14ddcb8b0b5dc02b00190435345c43caa075eafb3095783d1c11dc4bc7f0fe473aea15707c687fbb19a2917b98f0849a76860f730bb770ddd0055ee08cfa35c48d00273daaf0609c55367f02154e8d0f1088e0ee62ebb5a48d5fe573c717d2ead902ae915f49ebce217e3520a43663700ffa290a3e2bfb00ad151c623f4318b261d75f95047d30418eb58d5d732028c35ea568fd72e8151ab3c7404b727508fbc91660e9951d05c2ed703c95d0426737cd310329f379f9e4042948dd5a902d2914d576f4be86c27a387b8f1343c17ef3d77e22e5df1db0f8f37a0f8db43c55f2d2529c3dd2b284b115595a161541eb5260b536a95280ae2d077632cf87c026e530cd0407b825cb2fc59c0e0a4e1aac9b48d770e7bb46d6f295818137f2d22caba555e8bdb2ca3136d0402bb3bb1074deae1e6e501dd27dcec6277eab0a7333c4222072da0f441805140c60840f7c9a851f13b536d951367408a3cc10aca8d0a530c716b38e7cb911f1b0a7bd4e0b5e9a86981fd154f907114dd5fc589f50fdc69a01a5d333d14df067234d68dc441056f5141dd36e0cf064d7d47b7d743967138cb5289186aa80735ef07498f34d8b06e4b6ef74547a9c9b9e89b51344656875c95149216ab108ef4d993d5ed47fc162d282601172ed19669752727a7740b53e740a5dfd481c968fff3dedb7250bcbaf2785c966f0e312e45f74b0486958a41bfe4c524055b25807da9237c8c56a76a8c01471cbd7668c4c3301abd5171164eeab978f2a548abb3c623e064eca976ee57834a86408b7bfb4546388de22019f1b0115440bd707cc8a300c1ce64340b56ccc36b353771381ff26ccac35db68b47edec3a47acbf7a54a4a92333a8702a81ff97dc6e6e665e8b50d071c057a7d453359cb72ed691c7ed118adfb2ac6cef0edfe2aaa36e255b8429890ebb52bba832bbe71fbb08a7668d526181ce20fa0a85e359d7be68784ef9eed4b23dbba859c7bbe71c9abc8984a9204eadc6ae38a6552b1191c8b8c8eb1be6ac0e1cf8b48649c464f4dd405be7682cc02b8bd012af1c2f43993721ec660c0c592699097a6d21c4a66a566398430a5754736fb514c7ac11f89572c791c94462c9eb858f3080c16771a88e6c27d006bddc6fd72efc0e97a0b1124f08d8b925cbe8435bc5e5e446429a89f0f33699eb5ac53d28d58d56df3eedc28054d98afaf8807eb7507014fb0d0195750ee02ce9a665f8efa61ac8df15cd0a433de3b44ca593ee2053aefab1ee856b1c1d8ef5805332882b20b1605976eb74578768561d677befee0b77697e234078601947d4ab1d70a4c5eb3d3cabdc4e5f4da65658c1e30e4269d663bc24e6c1f1d1733513fa9adb483e00688d5dde950e7e4c2c5eb347e693be20abb0171c8787a1bddc9f89efd7e7713e94a3076dc2829960608beaad9dbc73d3e44e2348e453c4cd663270942b30736a5d21d0d961e8d7c10889520db7cf16d6bda0893d3269f53e4020bd2b316e37147c8eb32302a6f9ef2ee8d8fb099f0a75d51a06bb321b9204592bd41bab5f2f8172b02d810196d4f9f1117350475b99a87e9fa45e64d11d2afe591f9aa393ac80c9673d4b4760a10bf956f9653562a5bb8810895577abeddbd8a8c8a8fec89ab2decce1233d921b9e1b9d7f0c9f59ae264c2c6fb5304294db347fa7ef2a4916c5a3f5d0470da4cd57c0631c74268d629cfc43859a68042f4e786fb5582a350f26ecc3c1fb9ab0d9907caf6b57ec206a4a87a84303fa4d6ca07d7e468165d2670e1ec50c966ab4f491785d99082f976694c1e799c4df9d0e2d791126a9700be4645dd80c4b74dd2bb74282c015aa717edc2e95913972079cb51c544486da9864b58877b22f3b0cfb8e5b682ec3e8150c66e32a9f6013fe56202ae1668825579342284dda52a976661b253a10a78a4f302402036b4838c8535e2d4086faa965addb84faf296c6cc96cbcd64d639eab7d7143824edd4b6a7b0ed831dd25c090b25ac28571344514f5628d2b2f655492e90b1b19b653fe2bbe945c00b90c491602ffde13b53f804ba63a724933db7795ec9fff53322284863cc82f60890427f7bf6d42a953bef31dabb9b411a4af78e144c2610957195daea13fd4e905a9d75d34d7a263afff78c8fa8221c87168bb81ea79285cfe90ee15ec7275c2fd505a154381bbdf481d081efa2a2abf0491d621ee80b6ac40daa4b04581d07824c4ba1b8c59a2e07aaf2da5b1ebec183de0aa33b025c9d410603680fbd2372ef8591281396efb4865bfe010a76ee364520002db347c9a2b67146fe3dec3d9a453ed862b59f254c87b90d7dc930e921ee0884dce153b018e6c1d802c8e66dc3fd00abf3b2cd9f22efb3a87e3b7831d20d2cb0650996fa700ca2fafd585194397b6e0fe314203ee569efe930304516a858b6aa085e31137d9c473a57e8b94b5052addb9ba3b48242fae26bc280b3c1bcc27d02e6bf5e099dd227fd231e3532878b4c10b88339761a643318548081cdd7b0c88816d82a3e56341971f65bc4bf9b604b97a7f664fa86803816046b39b91b4877355f4020330508b797ddf7341653e003062f55d14902e7a96b1e30b067583efb547722f9883f5a1a320914b5a467568d6cf037bc7784c86b1e23525297634a394b3b47be185681f3b73d527255bd6e354e451b99898ce446a0e5e2668b3e2f02f828670e0845fe918a39b0e39cc0f971ffadf8bf7665167ae955b1bee1c1a3292bce0e8307a3be95ed8a85c37f22d5e06bc038af075cfa7e3e827ff0500566c7216fdbfedae085c852d27be6f1e517c1c40ad837103feb94ad8fc2466fc3ddd9da4eb80701e34dd4320ef8ea4498d073ed726350982dcf48c7068bbe045d3aa1bdc3ff661a2692f3b8bfdc8f0581b46d659de30e4c498b8790e58b28ec6da331ce78ffb893479ab5e8f5247f5c892a3f5c516a27c7e228ae0904d925b1f5745878ab347925f35e05b103b2d25ebdb9f57853695ea227e66759eed6ac3f468e2239fefeb70712839ec2387d3679389582543054b18f58ed2182d5e4f58169c1389c7d1e5c9cfbf3e65e16fe595a34857ca70bdf8728c4c0dd7419d2c1cffc949110815206d79aee0e973cbe8d9036cf4273f17db397ea9ed96229aa51e0890feb949fc1019297f35d0818066833cd293599f2b7c48a12b33ea65db056d8252d1b80bd2a35af1edbe45a8a895f31ad6386dd5243bd3be14188893af13896fbff8f3202842becd6e03e14abb0ba225ccfc4c257f31d34d277153da142369c5835f10d5b3a484fddf2df95acdda1762b50c3b320187245f398c235985a6cb8477557a180dee63d10bf432e097597315681ffec451fdc1eec2c09ba0729fa3ab371243f1795bf5e595473225c72b17e61eb791faed905e5dda0c5626d973c89be2d9cd6b916bd33c9745e4857d249d45f83d0bd18e1d93ecf2481a95fa86aa1c5e4f9dcf31b350c6f4679587648ef78735b2aea28b20af25a08b30eaef9aaceb0586de8869346fe8d615a4f02fee9b617b948583cea36ce727a32fa30aa3216eb2fb63285bf352dd87f3a03a22f3cfde2c70c6ca5db9f7510d804fe9c292be6e23d9f86813b6c48c25fc02e49447ed4db8cc5062b9f016460f57535c5ba7dbf8a6916ea07f658daa84da6c278c294b6efc62c475c403607e33bca37dfb33b82f23a0643e768ad1690b34b6e24ad0e9c342d647f15142f459725674c6d03099a5c982ca3854fd9fc230a06d34dcc3e3d8fff3aee325ca63cd7eaac3583eee0cfe9774251e7e7ccaf8512929baac452e03424f631481df710e9dd3b13f28b951b4004c81868f4c18fc51d80a4e9c52a95c50b593f6e6a8b987eecb8c5da03580599b1315c7c4ff18f8895b4b288b5d743b9dd00c385a115a8ab7812054e8601774b7ddeb69f73f01157aa275db67aee415cd786a7fc42a85d654d5838322c443c276ab3a930f07b2e71eff09862b08a95eaad403e89e24b5151a3eafaa99c852c906074ee069ff1fcbe503f2172550d492ffc4b104bdfb69bbd54dd39cee872b110453d8718a09730b43dacb4a22fddf561edb46dc238d1361000cf96dc799353c6cde217c3d05fb8eead0b38d4a9642c28701462d327fb62cfd0f8c02e866c5b976dab9bec5d5af054cec19f6056f3eab7ba17885688eb0c2e19714153bc675fa90ca3417b6ff9074b3320a8e8660de6ba3dd136e3869fa9dcee5d4408af5309332efcfdc434d2c7b43d8d7764f7b32a92024faeb27e0b7112a4b14306f4bd3eb3332ab4f46fcd0bf66ecca3cc807af33675cf7fe04148c08abac665e3efd2e52bc25a85ebcb400664bda5d398764a1eca9774757310421db7a21f7c8bc6c179556a455a1518e9da823b7f1157bd96ebebcf2f0497812341c95ba523fb97df3f2418df4a3ebd758b17b6e39321b9eb4a83f70ca3c028e3103ba37a6e4ac6de6d54afcba552064d089d8f94864ee25400f6eabf9563110da9a84073a90649f853efad1bce19e5d0af28763552520d21dfa24c6920b67320413911a25aea44fec89429c2e0dd9e66c9af3fe054d5595b712d7e762de4b99418ec8219d133409c5414e29cff45b059fb4fc5af10940aa0f724161243476c9b7e75f8ce77a7a3d550db8ede93f9bab70007f26f64dcbe81cc6c9d916d47658f8285850cf0aac89047ac052ae68161c864d667f18e8ad1ba07b6e8a0d19999a81a09abfc4ff4803ba5a99f42f1b9ea22d600fe5943c1ad9855a92c9f58cce13f778437548930d5d2e19af59f93d55a01f4e765f7bf6290d458bdad7cd4c4b68791e157fc570f7ffbff44d41da2dc9904f649359a2330cca8d81a2d8e5cd4309fb2d4cd5f98505204f10f8192de19a921d16fb1d9593fb7c0fa9a30a5ae12218de587458626dfd86a89aaf537d76f637a0d34665ef7ebb475ca1b79020f6b53f81ea78c0f459d4b6f078863d68498a1053c08d2c6e64efc27ff40a0d80d67d5638798b80475eef2cac86449368595aa0245323cc5703d0806d65b39196ddda79a433cc296543e62a84858efa2493b818523bff6bd2ba0e8a0164388a5a51c0c37e136a0eb4a28b62d892a94e43af41d8e5d7d4b140e42c383420fa69b8f07098bcb34988128918285ea0c44822b6d6c39d76513e6c05b1a948cdc2807a4a2a161da39e37720e6afc5c8fb16bdf295f99d1af6d74149db234dd9b83a97cf7ebcedbb5d1137c36d22505ce9ce733ff9339c7b504ff0777d427425358124edcb757f1f2b3ebefe09a645b6d3a1a0893db7823f56a757bed5063435e0e85fae2146702d6492b3e312c541759b5cbc201c5dbce6e1809b192c0eb42fbd0fefe4f2cc26db62a275db25ff670919ca965465c530427577098d73b5e566b85e878010b6e6d8752259df8cd65fb7ce8ebcb9c44fbca8b4e566bfca1624499065b9c25c5a1a58cf4a10f06e9bf76f6dfe8fd41834537dcbb64302af08e41df662195b747b3134586172a81c583cd7204ed4bdf26fa8a5e6c236f4cb3b59b33a72915dba321275cf59b71f5f6b726c8ca656e4399fc849545bddb2e25460fbb68c6819a30ccdaf8002c968d04aab4eab5149f1080838a819c9d36c9e91d84f7bb2480fd3fccd37bc101a7a377a0901fdc6d634553fe1afcddd2b24b986fd6813c311802e5be683c1ff1f21f860e02f0750e89598fec96f902c3a35800f14d2fd59a261d03508c15b93a02686e159bf677626167299b670983022360d6d4d3a8fdc08ed52515a71538c5097dc7cca80665aa50213b00e8bf46639acf9bb98ff06a157809ff0243246e25e48a4af1267a4d6b9cd7330bd6a14616e378b6ecafa16569288762f65e451fb66013af57349c7013789bdf9e2eade0af186ac3e697f6f393fdfee9da08313a2957a3e87df5a9373c2ef5a6b3f2561571455f6559e84f48f4c9cf5af0191bf214fa41382882f5919d7f5cf93bd6d3ff93a64893af15ebb5dc85583e24b9aea1d21e37337eecc42ffc9885ff0f443ec02d402b35dd47d0a6853ba77de8e0f35a2173cc81c3a09d547e1ffe3a50932157a4038a948eda4d9f17e4bf7307e56ccc8c0af7f362a5903f18d853a0279697e1072d41d2502c910a932627ce00ab7783535acfefad4052dd1fcbfae5f2d9bb3c344950e9f0cf806fdca6b08cb12bfd1dbbdd69277627199173528805e244cf49ea3a09b96924c81efe930e0031b3817cfd1becfd957e227a4ce13ea63dd357c7443d81d3eaa8b9a57ceb0e491beb9e54cf9c3d431b6ade3eb3244d82bd14481aef38755e8977893cbb1f6fc8b74f8b4e95cfa092963db2d1aadf5940ce1a318fa09517d48b59588eaf873d8f29f6a5475cfd448b3883de3a75053b1f2c0addfca75646b66e3b467a5c07f132463fb7407f5efb43f1841abccd896b60414e72b138a682bfa0b5fe82af82372f46e6c7a6c65bd08079a68e8e37ac887fbe686575aa9e2f7e580cd7cc55debbf375f29ab98e61409df47f9f10e870bd68d077f8272f6da4bf406ea2029ce741b33b4a3ccce754160a87ee621561e934ec39b0b3d8659c9cf766e563007cde5d79dd39ca58b8a278c4d3b948b9284f80daaf61c3306ce493ec4bde0cf81cc1dcc20558b01329bc45af8f42b4acb8e9f4555a6612d1d622245da58343a7bfd436cd3a9ddbecf53d2821373532fe43c64bfbc6bdb70f80e882b3d146d10eda07fdc78c341054d3245023ab6d7870c9b8611f0c57a43c894a71381dd6a743f3caf404a22f6c89554239761adabb37cb19a4fa170cafced3d67ff2bf970a85dd7d8dfbe1e0a48430915d6994647299825152e89019980c15afc3b7843e45f74efaba20eea90ca4d86d0e81b1f38a6eb3f64a8d4274cb58c9ad65df49f2669f6941351d74b7cdda03921a756ce24d77903db3613f6dbe8ae1db7c3b103c838b0f5df0c8f78034ddf9f2a8140f70d65ca04e1d5b5bb1efda4b235752eb7ffca641e62ac7974c247844a1d747505b29c29d075f750e381633929209872de074ca83d63196776004da7197cd79befaef8560c6718a62b474776b67cf7f9f930adf67553f3656022e602bc519c9109b80bf7aae792d6b0323377f2df1efd7e3b30b1e338368a18ec3749cc9904a77cce06346f223dd1a61eff6ccd7305494e78e7e9b51f5357745fee3ca40d13daf22a3f885a786694f19e55f5375832e000bc8104a1e4083bac95fe77cec40583d1c890808b9f8d5fa7a706ac49bddce85a09cf5eafe1dc13514948ce08f328fa30dbd910d647564aab8df12728c4b189c9553861ce1e7c273d68f2521d20ba6fcb331a76fc62655651b46c031d91b7ae052690a940f075d3e031a5b397cd24c72a50b32a22a7cda66b5200d2610b4332f085949adc7a12510671e78b0190b1de044fd859f6a905b3a13c43eb806db66b1dbec22f9963823d20abe40867b73fad38dd1967c4368a46b56c8d35b95b32cc96ff1069109edf5b90f360a5df89b2ef5210ba4fbb5fc771401252b7769b81cbf3861134e0d2751ee517ebeb7fc92abcd579a4e8253be0047c0181c54d5ae5d196093cbdf30f2bc10c78ee8e4e30074ba92b18aa70a79aaf0420740414b63958b6ac100043d837bd0708796a3b3d35cbcd09567e6386813a6607255ee4a9480d32a7355d5f440d18f51f1f2abd7d05c011b0050eb7b21482154d0556063a9e95ea75ba442522e2b622f6528e5da380991900934bebe9ce802a5ccb695cdfcf165af6defcbd281d0ba4a2928ccffc71c34899a8f4f96f4084cddacdf136bbfb6f702834eeb03853d9c73ccf3b0681744a078bc2d70d9adc909c5879e47f445e09e6ac090b3348df872075f38f4533c42738cdcc880ffd67717542b9b14810b499fee54366fe522ae7cddf08a2fc3a6d3185ad10c2321743942ce4854cfcdd9828f9ddc0598596b9ddc22085e6b30b8606309d8d31a1e6244481e507e20d0f68479bd847f0f007e50df74c23cc0d0ff0a9668ee656088691b414225917117820c0498166e3282282dfb7b3cf2821eb8830f98ddaa8a2d7588e65c55da8d6b904a3c24802d22ac27204a61d49ed2dc7ce85ae5a6a4ffc2a3061bf6b7aae79cc119f6850aa33fb909d51323fb64e97eee2e953c9c4ef1d5bca57f31ed072ff7d35e15c032442512c1a41ca0a12d9c7df5593714547aa57a4df0c3b491612121a3e993195648f00f422ad98c31c77fba9a7f367093e1863fef94460fa361f744cc408d0fc5e0701479126a2520209758877dff11d7f8e77a876259b6573526fd1d86c57d24ba8699ca077b9a83b6a4f51aaf72c48098a03bc36ba48392f015d2b60f01542b8055b7cf0a41c4d7a386be527709a48946cf4f7860d4ca70d7b99961c57c0d122b5fe58174e5c417d78c06bffbd019892cab02e0e8c63d9aa05c2296952026b2d1767f4e27cebdfeed7f43ce25e07b96840a57b76eaf42c5d0c2e6759b79f264f96c2979bb4e6b48be8a5d036036e38ad345412a05f1a8fa19b0c8c90405a6061ea1b88d0664ed498b4ef7ead19ffa56e22e3b8dbe0581df80a2f406d5a4eb8a4cbd95c2d2cf1357b6bd0412bc114ebc60784746b971f536eaa39eb64bd4570c4b87723dadc6ae7c3ee689adb59e4a11bfe697e0731de680955fd470f4f0979b659f7d02f52408e1c2d2caad453f0cc4da3c67d26a956304405b991726b60831ee5c94cb1fb0e4347dbe347eec418a8d560603a86e2df8b3bd19ec1d97f27b8028cdba681d4a952f4c584403e31139f1aa2b229de4738147a588ec0be007c209bac0af4de61339841aacd2e76148cb27dede2453d61928c5c3ab84af6c5e223f8940ae96645206976bbb1959090e102e96aab7e2d43b3af0ee7b8fb1f6d8a771f837b69899b17663059cc574adb2f4ce212e9b17f65cd74413ea2a5ca02aa1a21c9b4c53f4d5c60a8a67d26bd0c0d3b3c3af50d88892975e5db1192c7fbcc6d1800994ad10aa3cb738dee03a1814315b284f6c965d9660af5d58488ddd979bca88bfaae1209eda9440da93556b3df5ba9084e48c3fc708f7151912007da72610075174cf1f5f5076519972f3da412b1b88fd99e51be1b20f57f9aad5b29b6920627d6dbb3be25b644a8d00a9544abb715374299903882e313f36eaf8e9bd03f0a6d5f3e64a843bf26dbcd689419217d5d2c2ff58d2205672ca2545c3b7453ae151af50e17d49a5f428f3ee45d9fae6703bcd98f370cf53418a8de26a88aa6b45c6c18a9a3bb5a8c4857978107938eafa0e45b1671ce319405c7605a4d53307b44fccb83db6e03a3e403b482ce0d878bc311c11ba235fb40d73e2df64093fbedc3bac69d2839abd545c4bf339fe4ca4cb753bb1efb7d2b8de027e401ddecf0aa7c8f4045ad5afaea38604ead3ed982075a434cfdf169a4252d1c4a2e6941a1bb63c26d7334f96f7521ef3a121f460e500609c91e738a8bdf9a6b3ccf48687436482b4fd7425e7ce6a31bea3fc492f0656b9d8d994bec1f5e7640242710fb31ab750d1da32dc11ec091ef9b56b1f40a840c5893f41b592423b1db157bc6820e44373302f76210c0805a269923d8679dcb4ef92da18756208c146e12af0955063dcc4fc7d010ab74c1bfbe2873f1aa93d59fe24913aad0559c339f5a56e65b63ab2526b4b65e0a887c24d1e9d85e324f894ac31daa04f394c9279b6797eeaa9de41056aa788c73743f89c369004acfcdf9cbf8a042596c5945def96e07763ffbd4a29b7fddc8e23b11e0a51acc80a9783d0538fcc2052135fd501bb65a79c56f7acca1c44d1f64c1750389a92a1f2d934eecc69ab4222e05470080f3775d6983bf72b5f31be76cc4913f5ca83d353513312e22abecbd03a3969bc2e2a1990bc530a3c85dad6da7e8754ffad9132bce79844099489cae73455726f7a286d56091b6eda80ad93955dda8b8be18cbd0e5f396d812e66dda68591a50362d5e2d0e413a1aa111ee2fe062e28d6a70d41b2b14a5243e62d7c415e0de5b66aa651212151526287bf5d532903780b24cc9e56c1071b2fbdbf675c8be46193e3fd0f29b96831db160e4268250f386afbb6ae9773fd9bcc0c028b9c99f896fdbd017327aaab63223c2df320339a13e3708466696dcf75a60dee23fe4367d3776bfadfc3fa9fd3115213bbafdfe8ab1787ef07105b8e8447c2f301a8a2f428058153319bbe08564d6d25dd7c9eef65dfbc01fa38d0eddf70ba77445699f1b50ad8f6b813b5e0dd88228b4db735c09f35969fb4859fda5e06e5bec8bc7c98f6c0921e851ead0b4d812549e16a053f839f6b3f5b6cccfed095d1532c0d3e9d15ed057b890a820f7a9c515714b5c1ff14fc3dfa934a53b1ca8412cd19e64a874470d3a8cec5ceae49247912aca53790426a3630db138875955f70f7a7e2f5257f78811fa4d217526b0fba61007db135ce9c1cf84b79895c73881e44283a7fac2a560201368b7688d16ebf87a8c79e7fb3fa96f5ba150ed7f56bcb448c3e1363e74832ea34f51013a8e159b6c50701ca315d1d0a2cb017df9e0483879cf80ae06dfe1ab75190dce530d3c607228cbd4e4d311042578d47285741e656d618b75a8cb55d01fd74f5a28018f0fa860635e8c91ed37c563b70bc0bfc52a893c29365de5407912a2a94fc3abc57bc662b9b9af6e3cfca920f5d4e86531bd634eb3fe69e4294b19e07efceede962d56e77280ecb874e63208c4c4ffba2f84b1d233fbcd9bce1375e7b53013f7c07de24c18e54bad7a3f5857881db6093e49750870b8ef543a7f9774add38965b4cd4f2718b1b9a289fda61b7f81f4eac5823ff2b5123e12360050e6f6b33962a30e6125c3d5a8a19ec038c87f60f3e23aa20028b65fa5a34d834d73c42ef0fe7d76b2e6b957c9d12fd8f51120f55511c8fad4fa815050ff84255aefde4ac5997c59594d8bdf01d23b4b3f700327d25ba9ba7a7a5449b6c66d22314e2b9868fc453613a3dd8c588094dd545c779e8c679402f675514355862946301bdc78cecef792cf5716dc061e76ee7322af45eef32eecf127c9b32c907a22756b4fa077cddbad95d1bc254d180c59e2b15ef10b2881534a23f1455a66bbdc10d20aab1038299f88e0ad9e9c7c0a1f93fa6480cf5663305de024fb8916f719e60a144ce049d392362ae46b0edf44092a1d386510eb21a7ce01943c3b473844fac36b1cdcfcd09fac4eaa2d52e2ac00da5eb0bb10f5921544706fc469c7e4f406ecf6b4e6f2b7b2333ecbe580677a23d2f9dc62d0e3eae7f3284950cb9d2de88323a8d0b8f77b13a96f7a093be0d3e42c225b947096fa5a993b10734107b31dcde3e70460a1facc1952adb2b24c65134984d4ca4d914be2ce7753eb9b5f71147a34825b95434a8acb64f6c374a5c81505f59cf39fb183cd734956812bb4cfd71552af5e40a18d3f1b239000554575e6e4ab9770fa2913f397f30b10cc60990fb922c9ac4d723913fb14756f9164b6d9da3d6deaa548e163c6841bf2a75d5bd77bb395eee42ec6239bda18739b300f746eaa233c84c98bf1afbdf35e898fd6add16de1801e11234930981aba08c0c6b7b7f15edc644618e11db3fbd92f75026f777b78b8a717bd17e21dca89e8b682e1e36a78ceea869aa5ca9e935978493467a60fc03a692137f017935bbd9e1752bc39b1a1ad23769293d764b236e52bc4b1829fb3511682ff8414464203ba23648349d46f9f6a9dda1319992efe4c5cbbe25efcfbce8365f5a30b9bf8c421db9e4df7bba8b5cd37f98d535794e1beb6ccfcade1f18939641d560a8f365b881b4a0b7b697366085d9e081a4560697303ebb3fcd4ee9d8f2d737136b56f76bfcccc53b06018dbed7e9212ea953b7614616c31c608ae10b936bbb5360827362bbc8687dd438eccae326b670ddc4e7541c637a8fe7885405457cb12285147b0290e29a456576d2dea820d073a9a48b77ecce38d1036e36bc8df26101c13a3b4f68bce05a24d6bb0eab0ad612d072816657aebde42913d1dc2b1f017568113668825a40a781d436e9a3ebad0c42747d7d973f3ec3e0d9fd3d3a3ec903a01fb59afb7492fb57c5cbbf33d69ba0c0bd196a450deec6ff2def20071da7368c04d5e1fc77e4fc3d4f77af3d02d37d1d7c90be97a75e56ccee8c945dac71e85f2a15f5bfc718cc0327fdeeb23be74bc8e7df22a93ced699819c8495067a31db81b8d0a86c4e003701bbb20df6f488688e024d2098d85496a519214fec5fdf0e00c55df6bdc6630bb0ba59122d9bbb7afa37f2fe9d8df140bd55518a1d5aba0c4803b779e9dbade1379206a14ffbd51c7d94afdd1154417f4e9a3384dee00b189bdf82fbe438e1a4b37efb7704d2c7a820635449490c76c76784a9bbd84330f368e4912eca534a324ab09e06ce1181cb2a3af09f1e1774720ef0dfcfe852a1e1f25274f022920c4426e39676b59f2d87a41506ffe306eae5fd8a0b6d2ea683409f9b0d9b64e7797693a96f1370d317979b996f12e7f2a4bcd9b87436d2fa1e36718e2c061eb7ae18b970aa7fefebfac702287245dd9c0be2eb84fced942c3358b72d2d4c4ef3e963fecfafc88b2c83f31c2f45b5a8fe85e80afe3cd3117a8decb15b6ccc274b1eb04f2e12aaf2adfc55302fd63a02e5543436b168a57fbd5ba584452c513cfbc7aec82dbfea1d7cd002959ea12c6b6d2f9bc5153fa780148c8c75987830395ebe0738831e0b401eb8588bd598d41573247948493e2a4293aa444a668b7ff39026dfd4b401e499c0f718231e2b9f25421cdcbba6708367bd2dac7aa8880ceb81719c1349da92dd1ac7a7a56d038ef02dfc6e156e019bdc014a0284e53a908f7d663263abe2f3027b465c57f8a6f902620c31c1315fcc9ff6282e9ce71ef4ad465b6491996b0a7d7993f85109cb96f0b6004e00b8ea1d4d234245d4921102d9ceaeaafdc96c02dcae11e99fdf223fd31d0ef6db0ab2b752aa52aac47d66b6a976b2d000109a296700affb961efb99208c6925552a6ca539edd9fc000621896408dda7ffacfe00fd63899e61b045035852d1d499f5651656884132ae00da9fcf82f25ee2f5a66eb4b15cfbd4b5f86839b645af3678a004b71d41c94da8fc53d1f0294e2ee5f311e284823a3a1f9afd9c745494dfae1c235067993c1bc65eec172981c4ac367f253c70d6ebbc33ecfe979c151db23ce92380024e6a3b64f8bcb3f340c13df360ea15a982499f6f35aca322323cc226f6a5ad7c99362a05ac80fcf6a562f76a4af99ad4965f0745162606113b28f1c2348ba3b6c59f398e6f6e53ba90d601949fd9af49f89c6ec49d5d69a11d9f5147f1ac90d87af8518188ec5ecce68e07e7a32ff736e237deb350b26de476b450fde93ad8e33942596d8af8ed6d8423f3aecf0b07c397c4918d42c0bd79995bd21f57b79f03c11d95af86f93752ba9dccab8bf1822d3c9ac75d9cf202558b1bb3d405f5afb2553b576feffe3722aed6939381b0327210a5e3a2dabff1ed0d4a7650180a9cf2c4020fd09407e79ddc723b5fd2a3c515a426872df96d355a8c6eea05e88decdf71b0fc59fbb39edccb268c2f209150925d5277b224f7347cbbaab0080987a56be5c6753cd15a033f98dd15f5e9f14b4ca580c881b25ff51b511a32fd6c8ae769ec5b8059ac7f636625ef12614adb603c1cb81141824f98b9a91cb6c1a401277c54ee92d7a49defc296418a3fb915138c380e553c0e7070e7f83fd9a494eeafc21a6b97ae56c5e4d3c605fa28a20b9dfaa6adf8f81b09b01199a29976c7d5c46564bb1916045739b782a7365de6e7f068f6feddad9f5575fc11df70f6fa5eb146f96af57a9ad3b0cd3ba75168195b9914c67b52d35d5edd383c159b133d557f5f456c30c01212e21bb64b9724c6f71b4510bea09e3b243587f271a43d6da70d89b2a26f3436af4de99e68f60934c141034ae97113da8ca540522315dc3c1cf0b6953c9b27362522df047c89823384a8f2364d4ebefbe0778381464b467dfed0db11484002eaeb3fc20340a92a342035ec4c7b6c7102c862789d7e404e852f9c62a9768e036a1b71cc5f71ca2928a6ae462a2a4782d91d757da1563c85568bafa9848ef4b4c83ecc0e9e3cbc4247e63193d68b1dee79422c044037408e084a8fc8429393cc597f5f3950aa12cc53bf2abb33b94cedaa1c57764bf20c41331a8d4ad672ed39723ebc2eeff7b4fb3aa9611f58417064d93af5ba5da1c657cf25ba71a46031bc5088c7dae27eef8519afa1a2074e0208beb7f732685e06efed5a5ff7a284f5233e7fb7adb3db7ad7e309fefd9e853500e5684640789f0cc229b0922c14dddb308f1a03202f68303c21d7a19d2e3d3f5a37ca4a1a4e5f3ad921de5eb712204a2c48095a12ac4af917b9851afd0c91981c0bbf6457d2208e1a92ef4cc258fe0528e0635326d2b92d2107d319bb1fea469e38ccc0095463cc89d03ffffe6cb340753e11fbd20af3426b4c0a657596dab2cd9b85a46e6dc1feaff264e138b2f1632b913c1d1541bf850df5da51fe35f9d74eee330e15159d3a061d0dbf53aaade63c19455eb5bbbf7e46a4e409e53b1b7416e4e3f4d522e947da73aa407e5869e43668792f2d9c9cbc254c10f4ad2d400c47e2d975d64f658435f3ee0d78d22503e0edc6efa3913bf9b77256c5921d5cf1424194b4b5e3ea445a6a4f8e7047d2bdeef503d21e265bc83e6e65b4d19bf08246b97826f25b77fe56cf214a9d8028c4916f9177af7697f98f3a6d92925423e539452b2cea844a5f97a1c23233c011a446281994444b922dc506b3db9dc4fafbf5a008d98e679fd1e15549643d877e265c2207abc507be26bef6e6ea1e20ed312531e3e56c8f6de192f04c1f4f85d649bfb623cabe44e498e87e98a3b703b85091b04ec17b6fee06bac9e96b2d9ce106cdd12bb0f64cbcb9e25ad1ab02124fb2aca2ffa305cea98a512ccfefba23f1921dc973e34499e3e158db84cadf0091204c7a4ebe6681038f79edc538c72d7cc3aa3a0491f0e8daac9b3fb18045252c5cf77d28d886d5e3f93cf31669d2d9fd0e9d09cea36df18529b3626c76a0e9690856e654f3bfcfc39001c41910d1678d2094a4885c837c543f20f1d5285292ab4858d929ad094d9303bd12f16570f42713b73199a67d188e5401fa71ffdb4b0197b961d914ce89eb3f9084a7518933a68acaf3c1a539802dcc16239919c99060c3482929e505acdb5868c04f1244caae3f55f3cfee05ff0e935f83d2d47b2c684667eb5792754fe95df7fd4caf04e6be120c27a64ee9984bba290578b322fbcfa66e67225d40645f0a878057b96fdd758fd7fce3975bb2ba9dbf5ae00c9aa1e2f5cda767d3f6de16fc5ccecc5c125df8fe46112014cc955c81c40105ca286777f3fd57b17c5d7dff831675e0c7a0f20c1dd186108d52ce00614579caa8bbe4fc4b64722cd8d3c006e89b1aa61c4f9dcfd7143328ed37dafd31050ee44358bb56902a2737079b450baa86c34ef59a56840ad99f724d7c1aef74cfa891ec63ce1eac3bf96852deb6884173162412b829ab9481d5d9159e9998d759a60ba7b1857d7cdf121e2e6785fded9e99ae2badfd57d594e9ba5549a4945b51953a85c1c444cabd65390c7628085cb3d5976032ba130bda5e9de1987ba85160f312bdf8868abdd54b5d66153d2162c20f010624a071889928f8536b99917c6c8c244808d4d6c38c8cc31921da5705c814267d8d54c6e4f8770c0c07faec12b5a93688f9ad2fef18a9c2f1fcfb1ae2755a7a87212683014f75dd83e5e05732a5e315d9de583f6dcc51bee91082ccbb7e259077f2237dd0d90204430c97d57a8b920dd18113bcf1cdca7c11f06e998180b759699f10203104c956349e58f45a8507caaf6ce5218a981994e4eca5fd404d4dcc60745f3d79fb5be5c41b02c77f1f502e58ca2f77ddfe256da0b2679fdcaff5aebd3d36b3ec10ba102a0981140e55b673d68eb62054cd637e8db7a9172403571c00fb78832de1f55651ba5687253e866543d804b3f040077624163f9a9b31b389db75108395542d981765ef2a3f6269112277365bd3fd4f9f9382cb314514ffd3bb2bb2041ee49cea45dc27022b220a95c4890238db5c51cbabd29b5c1e5b54f17d34b6ae65ee4eaa1d2ad0beeba0aee2a6f3187194e5adeffcbef26e5d8f173a16a90424a27f4f894bb2422932d3841034b6267b8a57629d2e0abdc7f55b16192883726a1a0b16ce404a36a13f30b8e70bd7aebf751e7f0d0f24c4fc4ce00718623e3c920389f600690bb8fa661f4857ac70155dbb9399175f2b6513bd4752d6e3b81098096652b0989a38a4152a55e52f7f003db01a80fc4500551be53114c514201c5a06253d0722fe0c79ba81b3017556002091b86299e8375dfb8fee8ed9dbea09b25596ef2807704ad76299f56ce6f662ec407cd57a82e59c9903e15ccdfb14be30fe184247a4cddb30d6dea6864c1bb3f61c3411d43b553c6fb86a5df1a2c543323a7229405ced218ebebb553b30c8c60ac63658b34dbe48163cf1f0878376b832f0ad41103eca239a8082b63c687d4680f7e4314f4846811872ff4d80d4e6fd0f8ce3177b51a4db6fbed9f3e0eabf097ba18f8da9b3759f2fc2d00cd1ef1eaa5b63f36475b7977df73e6f6380b6ad3a73cbdf85a0738fb5b8d9c6f3ace0ffff2f2505f2769a87e33108a505daa690ce0dff11672d51cc31372db483071c0b1ec0634bf56a59c1481f9f76105d10c214891de9f0e461ddf82b0c6dc41df845203ddeb3fe480b8c57dede227d1bede26ae4466f1a01f2c75f548dcf83752ff33fd17a020ecd1a84234cb7156c1edd6fbfb8f99e1258504b47085b8a7c21f6b93a2f4521504a5190009b4847c4af463b30460c39ce4475bafbfe5aee16557d7096af98d06ae8a47f7080ac2d8851771e02b9db3f9cc43157c103708e5786a8ab8513cf542a24fe27249a8a37db1f4753efa312f5712bce4ac6dd6ccb9d89afda14ec879d8cbf690c565ab09decb96166e6944eb9bbd864779d3e3cda2badac9803ae4b27c0ef7a4e6aa18cf00b6a8ebdb6f97e42c7e22d7b2c47f4eebc8ab0c7bb7b61263858f68cd52fc69cda177dc6743795efb25ad196bf982ac0e731f5555d958e6df02355c8aa3c27128577022527ef08f2bde3fd661618895e823dd97dd2a44ff40033df47819d7e41db980fb0acbdefabe7b99baa2d2be5b74f082f1ae070a4d1fe7f74af80c7fecca7cb4c6def8d0334ae9cd1fe0a4505f9c1796b36c8688b5e561f334db3a45ffa5812977dfa1a0a5b7650c7bcb8a4871d155308cb82c23734b8721a4ab9a8fcdc25fcdae239735b74eae8b8d814bb4c74538c7729c42eea95fd758ac737a6185e15fa84154500ee8290f8136274a2ce0a3d261b0b9957e8fc9728a9e9bd306dbe8c3177faefce561905f48d815f717873ab655834ac962e534c054c30b29baa3ad99257c55ba7ea1d0262ac3988b2bfe3e1e4cfda202ccabf91023f44465bc624b10a5c8fc408f12ad680bb5d892697d717696bdbf2c32d252d91eae6f43ed32c4347bf7aa2d3009da99208ec824aa5d327bf1fc17ff7db2e50b9f6e4d4bb183ba99ffccb6b269b88d6814d3da567f72cfa17083aa88ea8dc1ca52f042ef977ba5125ce46ab0a5476b68562a8f2d4b51229d332234222529b79d80300cce358880e85f78f770b4fae0d8b16f087c78fa882ef81e7880f399ad1a7b78751aa615910a356f6cb11385d19f36d0fe7b0eec8bf872c6159ba391ef916ab7150c870b859c7a33d68988ac712e846a73feed645982cc50a335bf06421a3f628b6ab27c98586460a285ef3d2e2a74c89d563229e88d097500754c7f394aba53b03589e7245bf8e3068929c5880a20bebea919177bf20f2fc76a6e0ff972d66c4eb50a482c8483011133d7f53985f42518821183e907288ac423e5d710b557315603be2dba960c5f45e4d26abb2ff9d66a1e441d2ce5f148f047a7b89c6b0565c44d1d3f8f89b802c8bb93eeb1f2f05c96664af\n  \n    \n      \n      \n        当前文档已加密，请输入密码查看\n      \n      \n        \n        \n      \n    \n  \n\n","categories":["Software","iEPC"],"tags":["Software","iEPC"]},{"title":"楼面和屋面活荷载","url":"/posts/2022/10AW0YR.html","content":"本文为学习楼面和屋面活荷载章节心得总结。\r\n\r\n从属面积\r\n从属面积按梁两侧各延伸 1/2 梁间距的范围实际面积确定。\r\n\r\n\r\nimage-20220325230150155\r\n\r\n注意折减\r\n设计楼面时，要注意折减。折减分以下两个情况分别取值：\r\n\r\n楼面梁\r\n墙、柱和基础\r\n\r\n\r\nHG16#5.1.2\r\n\r\n折减楼层确定：\r\n确定折减楼层时，是以计算截面以上的完整层数来计。比如计算基础顶时，其截面位于\r\n1 层，所以该层不计入折减的楼层数。\r\n无设备区操作荷载\r\n无设备区操作荷载在均布在整个面积上的，不是仅在设备区以外才有。\r\n计算中宽度的正确使用\r\n\r\n求无设备区操作荷载的线荷载\r\n使用有效分布宽度\r\n求设备荷载线荷载\r\n\r\n扣除区域为设备实际区域\r\n求线荷载除以宽度时，使用的是 \\(b_{cy}\\)，力扩散后的宽度\r\n\r\n\r\n其它注意\r\n屋面活载是按照屋面的水平投影面进行计算的。\r\n","categories":["RegisteredStructure","01-建筑结构可靠性设计和作用"],"tags":["一注结构专业","考试"]},{"title":"风荷载","url":"/posts/2022/3YFJNZD.html","content":"本文总结了风荷载相关的计算。\r\n\r\n计算公式\r\n垂直于建筑物表面上的风荷载通用公式为： \\[\r\nw_k = \\mu_z \\cdot \\mu_{z修正} \\cdot \\mu_s \\cdot \\mu_{s干扰} \\cdot\r\n\\beta_z \\cdot  w_0\r\n\\]\r\n\r\n\\(\\mu_z\\)\r\n，风压高度变化系数，通过查《荷规》P31 表8.2.1\r\n得，非表中值按线性插值计算\r\n\\(\\mu_{z修正}\\)，默认为\r\n1，对于山区和远海海面和海岛的建筑，要计算修正系数。\r\n\\(\\mu_s\\)，风荷载体型系数，计算主要受力结构时所用，通过查《荷规》P34\r\n表8.3.1 得。如果是计算围护结构，则 \\(\\mu_{s}\\) 应换成 \\(\\mu_{sl}\\)，即风荷载局部体型系数。按《荷规》8.3.3\r\n条计算。\r\n\\(\\mu_{s干扰}\\)，考虑风力的群体效应的干扰系数，默认为\r\n1。按《荷规》8.2.2 条确定。\r\n\\(\\beta_z\\)，高度 z\r\n处的风振系数，默认为\r\n1。计算主要受力结构时所用，按《荷规》P57 8.4\r\n条确定。如果是计算围护结构，则 \\(\\beta_{z}\\) 应换成 \\(\\beta_{gz}\\)，即高度 z\r\n处的阵风系数。通过查《荷规》P61 表8.6.1 条得。\r\n\r\n注意要点\r\n高度 z 取值\r\n\r\n一般取计算点的高度\r\n如果是面向整体，则取最高点\r\n\r\n风振系数\r\n当满足以下条件之一的，才考虑风振系数：\r\n\r\n\\(h \\gt 30m \\ 且 \\\r\n\\frac{h}{b}&gt;1.5\\) 的房屋\r\n自振周期 \\(T_1 \\gt 0.25s\\)\r\n的各种高耸结构\r\n\r\n特别注意：\r\n当满足以下条件之一时，要按《高钢规》中的风荷载进行取值：\r\n\r\n楼层 \\(\\ge 10\\) 层的住宅\r\n\\(h\\ge28m\\) 的住宅\r\n\\(h\\ge24m\\)\r\n的高层民用建筑钢结构\r\n\r\n参考\r\n\r\n《建筑结构荷载规范》\r\n《高层民用建筑钢结构技术规程》\r\n\r\n","categories":["RegisteredStructure","01-建筑结构可靠性设计和作用"],"tags":["一注结构专业","考试"]},{"title":"判断给定点是否在 CurveVector 上","url":"/posts/2022/37DM65S.html","content":"判断给定点在否在 CurveVector 上可以使用下列方法：\r\n\r\nCurveVector curve;Dpoint3d testPnt;InOutClassification location = curve.PointInOnOutXY(testPnt);// InOutClassification 的定义如下public enum InOutClassification&#123;    Unknown,    In,    Out,    On&#125;\r\n","categories":["Bentley","Develop","Curve"],"tags":["CurveVector"]},{"title":"元素的复制","url":"/posts/2021/2VBGV0Z.html","content":"在使用中，经常需要对 Benlety 中的对象进行克隆，以下进行总结。\r\n\r\nElement 克隆\r\n\r\n\r\n\r\n程序集\r\n命名空间\r\n\r\n\r\n\r\n\r\nBentley.DgnPlatformNET.dll\r\nBentley.DgnPlatformNET\r\n\r\n\r\n\r\n//复制元素using (ElementCopyContext cc = new ElementCopyContext(dgnModel)) &#123;    cc.WriteElements = false;  //调整复制上下文环境不要立即写入元素    Element _cloneEle = cc.DoCopy(_el);    ElementPropertiesSetter eps = new ElementPropertiesSetter();    eps.SetColor(lineColor);    eps.SetWeight(LineWeight);    eps.Apply(_cloneEle); //设置颜色    _cloneEle.AddToModel();    return _cloneEle;&#125;\r\nSolidKernelEntity 克隆\r\n\r\n\r\n\r\n程序集\r\n命名空间\r\n\r\n\r\n\r\n\r\nBentley.DgnDisplayNet.dll\r\nBentley.DgnPlatformNET\r\n\r\n\r\n\r\n// 复制 SolidKernelEntityCopyEntity(out SolidKernelEntity entityOut, SolidKernelEntity entityIn)\r\nCurveVector 克隆\r\n调用对象的 Clone() 方法。\r\n","categories":["Bentley","Develop","Elements"],"tags":["Bentley二次开发"]},{"title":"Microstation EC 编程程序集介绍","url":"/posts/2023/9PQA9Z.html","content":"本文将对 Microstation 中 EC\r\n编程所需要的程序集作一个简要介绍，并推荐一个默认引用配置。\r\n\r\n参考\r\n","categories":["Bentley","Develop","EC"],"tags":["Microstation","EC"]},{"title":"一文带你全面了解 Microstation 中的 Keyin 配置","url":"/posts/2023/2VRVT60.html","content":"本文将详细介绍 Microstation 中 Keyin 的配置，包括 Keyin\r\n命令表的结构、各项参数等等，最后将分享如何通过代码的方式来自动生成\r\ncommand 表。\r\n\r\nAddin 中使用 XML 来定义命令表。\r\n命令表结构\r\nKeyin 命令表结构如下图所示：\r\n\r\n\r\nkeyinCommandStructure\r\n\r\n命令表是一个 xml 文件，每个命令表中有且仅有一个\r\nKeyinTree 根节点，其下由三部分组成，分别为\r\nRootKeyinTable、SubKeyinTables 和\r\nKeyinHandlers，它们分别表示根命令表、子命令表以及命令对应的处理函数映射。\r\ncommand.xml 命令表代码示例如下：\r\n\r\n使用 &lt;!--xxx--&gt; 包含的内容为注释\r\n\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;KeyinTree xmlns=&quot;http://www.bentley.com/schemas/1.0/MicroStation/AddIn/KeyinTree.xsd&quot;&gt;  &lt;!--根命令表,其 ID 为 root--&gt;\t&lt;RootKeyinTable ID=&quot;rootId&quot;&gt;    &lt;!--使用 keyword 定义根命令,通过 SubtableRef 来指向 KeyinTable 的 ID，指定下一级命令。CommandWord 表示命令的单词(不区分大小写)--&gt;\t\t&lt;Keyword SubtableRef=&quot;CommandsId&quot; CommandWord=&quot;fenceExample&quot;&gt;      &lt;!--定义 Keyword 的选项--&gt;\t\t\t&lt;Options Required=&quot;true&quot; /&gt;\t\t&lt;/Keyword&gt;\t&lt;/RootKeyinTable&gt;\t&lt;SubKeyinTables&gt;\t\t&lt;KeyinTable ID=&quot;CommandsId&quot;&gt;\t\t\t&lt;Keyword SubtableRef=&quot;FromCmdId&quot; CommandWord=&quot;from&quot;&gt;\t\t\t\t&lt;Options Required=&quot;true&quot; /&gt;\t\t\t&lt;/Keyword&gt;\t\t\t&lt;Keyword SubtableRef=&quot;ModifyCmdId&quot; CommandWord=&quot;modify&quot;&gt;\t\t\t\t&lt;Options Required=&quot;true&quot; /&gt;\t\t\t&lt;/Keyword&gt;\t\t\t&lt;Keyword CommandWord=&quot;clear&quot;&gt;\t\t\t\t&lt;Options Required=&quot;true&quot; /&gt;\t\t\t&lt;/Keyword&gt;\t\t&lt;/KeyinTable&gt;\t\t&lt;KeyinTable ID=&quot;FromCmdId&quot;&gt;\t\t\t&lt;Keyword CommandWord=&quot;element&quot; /&gt;\t\t\t&lt;Keyword CommandWord=&quot;points&quot; /&gt;\t\t&lt;/KeyinTable&gt;\t\t&lt;KeyinTable ID=&quot;ModifyCmdId&quot;&gt;\t\t\t&lt;Keyword CommandWord=&quot;move&quot;/&gt;\t\t\t&lt;Keyword CommandWord=&quot;clip&quot;/&gt;\t\t\t&lt;Keyword CommandWord=&quot;stretch&quot;/&gt;    &lt;/KeyinTable&gt;\t&lt;/SubKeyinTables&gt;\t&lt;KeyinHandlers&gt;\t\t&lt;KeyinHandler Keyin=&quot;fenceExample from element&quot; Function=&quot;ManagedFenceExample.Keyin.CmdPlaceFenceFromElement&quot;/&gt;\t\t&lt;KeyinHandler Keyin=&quot;fenceExample from points&quot; Function=&quot;ManagedFenceExample.Keyin.CmdPlaceFenceFromPoints&quot;/&gt;\t\t&lt;KeyinHandler Keyin=&quot;fenceExample clear&quot; Function=&quot;ManagedFenceExample.Keyin.CmdClearFence&quot;/&gt;\t\t&lt;KeyinHandler Keyin=&quot;fenceExample modify move&quot; Function=&quot;ManagedFenceExample.Keyin.CmdMoveFenceContents&quot;/&gt;\t\t&lt;KeyinHandler Keyin=&quot;fenceExample modify clip&quot; Function=&quot;ManagedFenceExample.Keyin.CmdClipFenceContents&quot;/&gt;\t\t&lt;KeyinHandler Keyin=&quot;fenceExample modify stretch&quot; Function=&quot;ManagedFenceExample.Keyin.CmdStretchFenceContents&quot;/&gt;\t&lt;/KeyinHandlers&gt;&lt;/KeyinTree&gt;\r\n上例中的代码命令可以表示为：\r\n\r\n\r\nkeyinCommand结构-代码命令示例\r\n\r\n节点标签介绍\r\nKeyinTree 节点包含\r\nRootKeyinTable、SubKeyinTables 和\r\nKeyinHandlers 三个部分。\r\nKeyinTable 中有属性\r\nID，表示该表的名称。命令表的内容由一个或多个Keyword\r\n元素组成，Keyword属性 SubtableRef\r\n指向其下级命令表的\r\nID。这样，通过当前表中Keyword 的\r\nSubtableRef 和下级表中 KeyinTable&gt; 的\r\nID 就能构成一个命令树。\r\nMstn 中的命令由一到五个单词组成，因而，我们在定义自己的 commands.xml\r\n时在 SubKeyinTables 段中最多可以定义四级命令。\r\nKeyword 还必须有属性\r\nCommandWord，这是用户在 Mstn\r\n键入域中可输入的单词。Keyword 中还可以包含\r\nOptions\r\n项，该项是对Keyword的进一步说明，其属性有\r\nRequired、Default、TryParse、Hidden\r\n等。\r\nRootKeyinTable\r\nKeyinTree 中必须包含 RootKeyinTable\r\n标签，且只能有一个标签。\r\nRootKeyinTable 中应至少包含一个 Keyword\r\n标签，用于定义根命令单词。\r\nKeyword\r\nKeyword 标签用于定义命令的单词，它可以在\r\nRootKeyinTable 和 KeyinTable 中使用。\r\nKeyword 有如下属性：\r\n\r\n\r\n\r\n属性名称\r\n默认值\r\n可选\r\n作用\r\n\r\n\r\n\r\n\r\nSubtableRef\r\n-\r\n-\r\n指定下一级命令\r\n\r\n\r\nCommandClass\r\nInherit\r\n是\r\n指定命令类别\r\n\r\n\r\nCommandWord\r\n-\r\n必须\r\n[必须] 用于定义命令单词\r\n\r\n\r\n\r\n其中 CommandClass 属性表示命令的类别，当为\r\nInherit 时，表示继承上一个命令的类型。除了\r\nInherit 外，还有以下类别：\r\nPlacement、Viewing、Fence、Parameters、Locks、MacroCommand、Manipulation、Show、Plot、Newfile、Measure、Input、Celllib、Filedesign、Compress、Reference、Database、Dimension、Locate、Tutorial、WorkingSet、List、Undo、SubProcess、ViewParam、ViewImmediate、WindowManager、DialogManager\r\n在 Keyword 中，可以添加 Option 标签来对\r\nKeyword 进行设置。Option\r\n标签是可选的，它拥有如下属性：\r\n\r\n\r\n\r\n属性名称\r\n默认值\r\n是否可选\r\n\r\n\r\n\r\n\r\nRequired\r\nfalse\r\n是\r\n\r\n\r\nDefault\r\nfalse\r\n是\r\n\r\n\r\nTryParse\r\nfalse\r\n是\r\n\r\n\r\nHidden\r\nfalse\r\n是\r\n\r\n\r\n\r\nRequired=\"true\"\r\n表示该命令字不是最后一个单词，必须有下级子节点；\r\nDefault=\"true\"\r\n表示该命令字为默认，当省略这一级命令字时取该命令字，在同一级别中只能有一个命令字为\r\nDefault 。\r\nTryParse=\"true\"表示该命令字后可跟用户输入的任意字符，这些不在命令表中的字符串将被传递到命令处理函数的\r\nunparsed 参数中。比如 Active Color 命令后可跟 Red、Green、Blue\r\n等，也可以跟一个数字，如 Active Color\r\n245。我们不可能在命令表中列出每个这样的键入，此时可用\r\nTryParse 属性。\r\nHidden=\"true\" 表示该命令隐藏，用户在 Mstn\r\n的命令浏览器中看不到该命令，但该命令仍然有效。这些隐藏的命令往往为程序所用或暂时不想对用户公开。\r\nSubKeyinTables\r\nSubKeyinTables 是可选标签。若命令大于 1 个单词时，需要用\r\nSubKeyinTables 来定义剩余的单词。\r\nSubKeyinTables 最多只能在配置文件中出现 1\r\n次。它下面必须至少有一个 KeyinTable 子节点，每个\r\nKeyinTable 都必须有一个唯一的 ID 属性值。\r\n每个 KeyinTable 中应至少有 1 个 Keyword\r\n子节点。\r\n每个 KeyinTable 中的 Keyword 可以通过\r\nSubtableRef = \"ID\" 的方式来指定到其它的\r\nKeyinTable，从而形成命令链。\r\nKeyinHandlers\r\nKeyinHandlers 标签中只有 KeyinHandler\r\n一种元素。KeyinHandler 中必须拥有 Keyin 和\r\nFunction 两个属性。\r\nKeyinHandler 中的 Keyin\r\n属性表示完整的键入命令字符串， 它的 Function\r\n属性为该键入命令对应的处理函数名，该函数名格式为：命名空间名.类名.函数名(或称方法名)\r\n。换句话说，当用户在 Mstn 中输入 Keyin\r\n中的字符串时，就会调用到 Function 指定的函数。\r\n将命令表嵌入 Addin\r\n若要使命令表能够正确被 Microstsation 识别，需要在项目的工程配置文件\r\n(*.csproj) 中的 Project 节点中增加如下配置：\r\n&lt;ItemGroup&gt;  &lt;EmbeddedResource Include=&quot;填写commands.xml相对于.csproj文件的相对路径&quot;&gt;    &lt;LogicalName&gt;CommandTable.xml&lt;/LogicalName&gt;    &lt;SubType&gt;Designer&lt;/SubType&gt;  &lt;/EmbeddedResource&gt;&lt;/ItemGroup&gt;\r\n快速生成命令表\r\n参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\n\r\n自动检查Addin程序中XML格式命令表语法\r\n- 中国BDN社区-博客 - 中国BDN社区 - Bentley Communities\r\n第4章、给Addins添加命令\r\n- 中国BDN社区-威客 - 中国BDN社区 - Bentley Communities\r\nLearning\r\nMicroStation Addins Step by Step 4 - 中国BDN社区-博客 - 中国BDN社区 -\r\nBentley Communities\r\n\r\n","categories":["Bentley","Develop","Keyin"],"tags":["Bentley","Keyin"]},{"title":"元素间相互转换","url":"/posts/2021/1KH1955.html","content":"本节主要对不同元素间的转换进行总结，以便今后使用。\r\n\r\nElement 转 SolidKernelEntity\r\n\r\n\r\n\r\n程序集\r\n命名空间\r\n\r\n\r\n\r\n\r\nBentley.DgnDisplayNet.dll\r\nBentley.DgnPlatformNET\r\n\r\n\r\n\r\nConvert1.ElementToBody(out SolidKernelEntity entityOut, Element ehIn, bool getSolidIn, bool getSheetIn, bool getWireIn);\r\nElement 转 CurveVector\r\n\r\n\r\n\r\n程序集\r\n命名空间\r\n\r\n\r\n\r\n\r\nBentley.DgnPlatformNET.dll\r\nBentley.DgnPlatformNET.Elements\r\n\r\n\r\n\r\nCurvePathQuery.ElementToCurveVector(ele);\r\nT 转 Element\r\nT\r\n代表的类型有：SolidKernelEntity，SolidPrimitive，CurvePrimitive，CurveVector\r\n\r\n\r\n\r\n程序集\r\n命名空间\r\n\r\n\r\n\r\n\r\nBentley.DgnPlatformNET.dll\r\nBentley.DgnPlatformNET.Elements\r\n\r\n\r\n\r\nvar element = DraftingElementSchema.ToElement(DgnModel dgnModel, T entity, Element templateElement);\r\n","categories":["Bentley","Develop","Elements"],"tags":["Bentley 二次"]},{"title":"如何获取元素的范围","url":"/posts/2023/81FDDJ.html","content":"在 C# 中可以将 Element 转换成 DisplayableElement，然后调用\r\nCalcElementRange 计算其包围盒范围。\r\n\r\nvar displayableElement = x as DisplayableElement;StatusInt status = displayableElement.CalcElementRange(out DRange3d range);\r\n参考：\r\n本文参考以下文章，在此致以诚挚谢意！\r\n[MSCE\r\nC++] 怎样获取Element的Range - ◆ 二次开发(MicroStation编程,\r\nProjectWise编程等) - Bentley 中国优先社区 - Bentley Communities\r\nMSCS\r\nC# 如何获取Element的坐标 - ◆ 二次开发(MicroStation编程,\r\nProjectWise编程等) - Bentley 中国优先社区 - Bentley Communities\r\n","categories":["Bentley","Develop","Elements"],"tags":["Bentley","Elements"]},{"title":"Microstation 中实现非阻塞进度条","url":"/posts/2024/2MEYC7T.html","content":"在进行 Microstation\r\n二开时，若在代码执行耗时任务，则可能会导致界面出现假死的情况，此时窗体无法拖动、进度条也无法更新。\r\n由于 Microstation\r\n的非线程安全问题，代码必须在主线程上执行，但进度条位于主线程上，因此进度必定会卡死，这是一个矛盾的问题。\r\n有两种方法来解决这个问题。\r\n\r\n为什么假死\r\n首先简要解释下，为什么为假死。\r\nWindows 的窗体靠消息循环来更新 UI，UI 位于主线程上。而 Microstation\r\n的 SDK 是非线程安全的，因此所有的任务都是在主线程上执行。\r\n当在主线程执行耗时计算时，主线程将被这个任务给占用，从而导致消息无法被处理，因此造成界面假死的情况。\r\n原生进度条方案\r\n上面提到，卡死是由于窗体无法处理消息循环导致的，因此我们可以在进度变动时，让系统先处理一下消息，然后再继续执行代码。\r\n通过调用 System.Windows.Forms.Application.DoEvents();\r\n来让线程处理窗体消息。\r\n\r\n详细参见：Application.DoEvents\r\n方法 (System.Windows.Forms) | Microsoft Learn\r\n\r\n部分代码如下：\r\n #region P/Invoke /// &lt;summary&gt; /// 打开窗体 /// &lt;/summary&gt; /// &lt;param name=&quot;messageText&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; [DllImport(&quot;ustation.dll&quot;, CharSet = CharSet.Unicode)] public extern static IntPtr mdlDialog_completionBarOpen(string messageText); /// &lt;summary&gt; /// 更新窗体内容 /// &lt;/summary&gt; /// &lt;param name=&quot;dialog&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;messageText&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;percent&quot;&gt;&lt;/param&gt; [DllImport(&quot;ustation.dll&quot;, CharSet = CharSet.Unicode)] public extern static void mdlDialog_completionBarUpdate(IntPtr dialog, string messageText, int percent); /// &lt;summary&gt; /// 显示消息 /// &lt;/summary&gt; /// &lt;param name=&quot;dialog&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;messageText&quot;&gt;&lt;/param&gt; [DllImport(&quot;ustation.dll&quot;, CharSet = CharSet.Unicode)] public extern static void mdlDialog_completionBarDisplayMessage(IntPtr dialog, string messageText); /// &lt;summary&gt; /// 关闭进度条 /// &lt;/summary&gt; /// &lt;param name=&quot;dialog&quot;&gt;&lt;/param&gt; [DllImport(&quot;ustation.dll&quot;, CharSet = CharSet.Unicode)] public extern static void mdlDialog_completionBarClose(IntPtr dialog); #endregion    /// &lt;summary&gt;/// 更新进度条/// 总进度为 100/// &lt;/summary&gt;/// &lt;param name=&quot;message&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;progress&quot;&gt;进度值，默认 0-100&lt;/param&gt;public static void Update(string message, int progress)&#123;    mdlDialog_completionBarUpdate(_dialogPtr, message, progress);    // 让窗体处理消息事件    Application.DoEvents();&#125;\r\n具体效果如下：\r\n\r\n\r\n\r\n虽然很方便，但是也有一些缺点：\r\n\r\n速度慢\r\n可能导致调用混乱无法调试\r\n\r\n参考：\r\n\r\nApplication.DoEvents,\r\nwhen it's necessary and when it's not? - Stack Overflow\r\nApplication.DoEvents()造成的问题\r\n\r\n多线程方案\r\n前面提到，由于进度条位于主线程，才导致它被阻塞，那么若能将其放到另一个线程里，与主线程分离，也就不会出现阻塞的情况了。\r\n要实现将 UI\r\n放到另外的线程，只需要注意一个关键点，就是需要将线程设置成\r\nSTA 模式，代码如下：\r\npublic void StartProgress()&#123;    // 新建一个线程并运行    var thread = new Thread(() =&gt;    &#123;        _window = new ProgressWindow(this);        _window.ShowDialog();    &#125;);\t // 下列设置是关键    thread.SetApartmentState(ApartmentState.STA);    thread.Start();&#125;\r\n效果如下：\r\n\r\n\r\n\r\n\r\nSTA 模式可自行百度了解：什么是单线程单元（STA）什么是多线程单元（MTA）\r\n\r\n源代码\r\n本文示例代码已开源，地址：AwsomeBentley/Examples/CSharpBentley/CSharpMicrostation/ProgressExamples\r\nat master · GalensGan/AwsomeBentley (github.com)\r\n","categories":["Bentley","Develop","Progress"],"tags":["Microstation","Progress"]},{"title":"DgnPrimitiveTool 使用文档","url":"/posts/2022/1FJ4HP4.html","content":"本文主要总结 DgnPrimitiveTool\r\n的触发逻辑，同时介绍其中的参数设置。\r\n\r\n简介\r\nDgnPrimitiveTool 继承自\r\nDgnTool，它增加了动态显示、回退相关的事件回调。\r\n继承关系\r\n\r\n\r\nimage-20220520131412036\r\n\r\n动态显示\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n函数名称\r\n作用\r\n\r\n\r\n\r\n\r\nBeginDynamics\r\n打开动态显示\r\n\r\n\r\nEndDynamics\r\n关闭动态显示\r\n\r\n\r\nOnDynamicFrame\r\n在此处进行动态元素的显示；动态元素显示需要使用\r\nRedrawElems，详见相关文章\r\n\r\n\r\n\r\nCtrl+Z 回退\r\n通过以下步骤方式可以开启 Ctrl+Z 回退回调功能\r\n\r\n在 OnPostInstall 中调用方法\r\nEnableUndoPreviousStep() 打开回退功能\r\n重写 OnUndoPreviousStep 事件\r\n\r\nOnRestartTool\r\n本类中新增一个抽象方法\r\nOnRestartTool，当外部事件可能使当前工具的状态失效时调用。\r\n例如 undo\r\n操作，它可能使对元素的任何引用失效，或者导致引用的绑定/取绑。\r\n在这个事件回调中，需要初始化新实例并调用\r\nInstallTool，或者调用 ExitTool\r\n来退出工具。\r\n单次触发模式\r\nSingle-shot模式的意思就是你执行完一个命令后就会回到系统默认命令，往往是选择工具命令。\r\n当不处于Single-shot模式时，执行完当前命令后仍然保持这个命令。比如你执行了画线命令，画完后仍然可以继续画线而不用再选择画线命令。\r\n这个选项目前已经被废弃。\r\n详见 single-shot\r\nmode\r\n执行流程\r\n\r\n\r\nDgnPrimitiveTool执行流程-schetch\r\n\r\n参考\r\n《Microstation API Document》\r\nDgnTool详细说明文档\r\n","categories":["Bentley","Develop","Tool"],"tags":["Bentley","Bentley二次开发"]},{"title":"DgnPrimitiveTool 详细说明文档","url":"/posts/2022/K0VDR.html","content":"本文主要总结 DgnTool 的触发逻辑，同时介绍其中的参数设置。\r\n它是所有 Tool 的基类，在使用过程中，不能直接派生于它，而是要从\r\nDgnViewTool 和 DgnPrimitiveTool 派生。\r\n\r\n方法分类\r\ndgnTool 中的方法按作用分类，分为：\r\n\r\n事件回调\r\n参数设置\r\n参数设置分为两种，一种是调用型，一种是重写型。\r\n调用型的方法无法重写，使用时需要主动调用；\r\n重写型的方法可以通过重写，来进行设置，工具会自动调用。\r\n工具方法\r\n工具方法分为一般方法、虚方法、静态方法。这些都需要主动调用才产生效果。\r\n\r\nDgnTool 中的方法按功能分类大致可以分为以下几类：\r\n\r\n修饰器\r\n鼠标事件\r\n鼠标滚轮和键盘事件\r\n弹出菜单事件\r\n手势相关\r\n初始化化及资源释放\r\n工具类\r\n\r\n全局设置\r\n在 Tool 中可以打开全局设置，比如启用精确绘图，捕捉等等。\r\n\r\n\r\n\r\n名称\r\n作用\r\n\r\n\r\n\r\n\r\nAccuSnap.SnapEnabled = true\r\n激活动态捕捉\r\n\r\n\r\nAccuDraw.Active = true;\r\n激活精确绘图\r\n\r\n\r\n\r\n\r\n全局设置必须在 Tool 初始化完成后调用，一般在 OnPostInstall\r\n中调用。\r\n\r\n修饰器*\r\n这个功能只有一个函数：DecorateScreen(Viewport vp)，它用于在\r\noverlay 模式下显示非图形元素。\r\n该函数只要鼠标有变动就会触发。\r\n工具类\r\n实例方法\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名称\r\n作用\r\n类型\r\n\r\n\r\n\r\n\r\nGetCurrentDgnButtonEvent\r\n获取代表当前鼠标位置的事件\r\n工具方法\r\n\r\n\r\n*SetAdjustedDataPoint\r\n将调整后的点设置为最后一个数据点位置\r\n工具方法\r\n\r\n\r\nGetModifierKeyTransitionState\r\n获取键盘按键，按键值通过currentQualifierMask参数返回\r\n工具方法\r\n\r\n\r\nSetModifierKeyTransitionState\r\n设置键盘按键\r\n工具方法\r\n\r\n\r\n\r\n静态方法\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名称\r\n作用\r\n类型\r\n\r\n\r\n\r\n\r\nGetActiveViewTool\r\n获取当前的 DgnViewTool 实例\r\n工具方法\r\n\r\n\r\nGetActivePrimitiveTool\r\n获取当前的 DgnPrimitiveTool 实例。有些遗留的工具没有使用\r\nDgnTool，所以返回的会是空\r\n工具方法\r\n\r\n\r\n\r\n鼠标事件\r\n\r\n在 Bentley\r\n中，事件是按数据键和重置键来区分的，对应到鼠标的设备上就是左键和右键，当然这个对应关系可以设置。下方中就用左/右键来分别代表数据/重置键，方便理解。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名称\r\n作用\r\n作用\r\n\r\n\r\n\r\n\r\nOnResetButton\r\n右键单击时触发，默认返回 false\r\n事件回调\r\n\r\n\r\nOnResetButtonUp\r\n右键弹起后触发\r\n事件回调\r\n\r\n\r\nOnDataButton\r\n左键单击时触发，默认返回 false\r\n事件回调\r\n\r\n\r\nOnModelMotion\r\n当鼠标在视图中移动时触发，默认返回 false，移动时，会不断触发\r\n事件回调\r\n\r\n\r\nOnModelNoMotion\r\n当鼠标在视图中静止时触发，默认返回 false，静止后，会不断触发\r\n事件回调\r\n\r\n\r\nOnModelMotionStopped\r\n当鼠标在视图中停止移动后触发，默认返回\r\nfalse，只在停止后触发一次，然后再触发OnModelNoMotion\r\n事件回调\r\n\r\n\r\nOnModelStartDrag\r\n鼠鼠标开始拖拽，默认返回 false\r\n事件回调\r\n\r\n\r\nOnModelEndDrag\r\n鼠标结束拖拽，默认返回 false\r\n事件回调\r\n\r\n\r\n\r\n鼠标滚动和键盘事件\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名称\r\n作用\r\n作用\r\n\r\n\r\n\r\n\r\nOnMouseWheel\r\n鼠标滚动时触发，默认返回 false\r\n事件回调\r\n\r\n\r\nOnModifierKeyTransition\r\n当 Shift、Control 或 Alt 键被按下和释放时都会触发，它们的值分别是\r\n4、8 和 16。返回 true 时会更新视图\r\n事件回调\r\n\r\n\r\n*On3DInputEvent\r\n未知\r\n事件回调\r\n\r\n\r\n\r\n弹出菜单\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名称\r\n作用\r\n类型\r\n\r\n\r\n\r\n\r\nDisableEditAction\r\n在按下右键后，OnResetButton前执行。\r\n用于阻止按下右键时弹出菜单，默认为 false，禁止弹出。\r\n参数设置\r\n\r\n\r\nStatusInt PerformEditAction(int index)\r\n重写右键弹出菜单，index\r\n代表菜单编号，-1代表不显示。当成功设置后，应返回\r\nStatusInt.Success\r\n参数设置\r\n\r\n\r\n\r\n手势相关\r\n手势相关 API 名称中一般包含 Gesture 字符。\r\n手势相关的 API 在日常开发中几乎不使用，此处不进行介绍。\r\n加载与资源释放\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名称\r\n作用\r\n类型\r\n\r\n\r\n\r\n\r\nOnInstall\r\n被 InstallTool 调用，返回 false 时，取消工具初始化。可以用于限制仅在\r\n3d 模型中生效\r\n事件回调\r\n\r\n\r\nGetToolName\r\n设置工具名称\r\n参数设置\r\n\r\n\r\nPopulateToolSettings\r\n生成工具设置窗体。如果为\r\ntrue，由当前工具决定显示内容，表现为不显示。\r\n参数设置\r\n\r\n\r\nOnPostInstall\r\n当工具加载完成后调用\r\n事件回调\r\n\r\n\r\nExitTool\r\n调用后，退出当前工具\r\n工具方法\r\n\r\n\r\nOnCleanup\r\n当前工具结束时调用，不论什么原因结束，最后都会调用\r\n事件回调\r\n\r\n\r\nOnReinitialize\r\n重置工具到初始化状态，是为了方便操作，仅在 DgnElementSetTool\r\n中可以使用。\r\n/\r\n\r\n\r\n\r\n什么是工具设置窗体？\r\n\r\n\r\nimage-20220522072349830\r\n\r\n每次启动一个工具时，都有这么一个窗体弹出，这就是工具的设置窗体。可以通过\r\nPopulateToolSettings 返回 true 来关闭。\r\n流程\r\n由于DgnTool无法单独使用，所以此处不介绍其流程。每一个工具的流程详见子类相关文章。\r\n说明\r\n标记为 * 号的表示未弄明白其用途。\r\n参考\r\n《Microstation API Document》\r\n","categories":["Bentley","Develop","Tool"],"tags":["Bentley","Bentley二次开发"]},{"title":"MS DgnTool 学习（一）","url":"/posts/2019/14CGG7V.html","content":"DgnTool 是在 MS\r\n上二次开发时会经常用到的交互类，重要性便不言而喻了。在此记录自己的学习心得。\r\n\r\n继承关系\r\ngraph BTlocate[LocateSubEntityTool]--&gt;iview[IViewTransients]region[DgnRegionElementTool]--&gt;iviewlocate--&gt;graphic[ElementGraphicsTool]graphic--&gt;eleset[DgnElementSetTool]eleset--&gt;primitive[DgnPrimitiveTool]region--&gt;eleseteleset--&gt;redraw[IRedrawOperation]eleset--&gt;modify[ModifyOp]modify--&gt;imodify[IModifyElement]primitive--&gt;tool[DgnTool]tool--&gt;counted[RefCountedBase]counted--&gt;countedlist[RefCounted &lt; IRefCounted &gt;]countedlist--&gt;icount[IRefCounted]dgnview[DgnViewTool]--&gt;tool\r\nDgnTool\r\nDgnTool 是所有 Tool 类的基类。\r\n应用程序创建的交互类不能从 DgnTool 直接继承，要继承于 DgnViewTool\r\n或者 DgnPrimitiveTool。\r\nDgnViewTool\r\nDgnViewTool 可以用来实现视图命令。\r\n使用 DgnViewTool 将挂起当前活动的原命令，直到它退出。 使用\r\nDgnViewTool 不应该更改文件或任何可能影响活动原命令的内容。\r\n","categories":["Bentley","Develop","Tool"],"tags":["Bentley二次开发","C#","DgnTool"]},{"title":"DgnElementSetTool 使用文档","url":"/posts/2022/9YRV0H.html","content":"本文主要总结 DgnElementSetTool\r\n的触发逻辑，同时介绍其中的参数设置。\r\n\r\n简介\r\nDgnElementSetTool 主要用于实现对元素的修改。\r\n基本的工具操作是从激活的围栅、选择集或用户选择来填充 ElementAgenda。\r\n然后调用 OnElementModify 来处理。\r\n继承关系\r\n\r\n\r\nimage-20220522105109562\r\n\r\n基本概念\r\n什么是 ElementAgenda？\r\nElementAgenda 是 Microstation\r\n从元素源（包含激活的围栅、选择集或用户选择）创建的一个引用集合。\r\n加载和资源释放\r\n本类中重新实现了 OnReinitialize，它将 Tool\r\n的状态重置为初始状态，这样就可以不用重新启动一个新的 Tool。\r\n它在 OnModifyComplete 中被调用。\r\n动态显示\r\n除了 DgnPrimitiveTool\r\n提供的动态显示事件回调外，本类还额外提供了其它函数进行控制。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名称\r\n作用\r\n类型\r\n\r\n\r\n\r\n\r\nWantDynamics\r\n当 ElementAgenda 有值后，判断是否启用动态显示\r\n事件回调\r\n\r\n\r\n\r\n重绘接口实现\r\n重绘接口主要负责元素的重绘显示逻辑，在开发中一般不需要修改，此处不作详细研究。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名称\r\n作用\r\n类型\r\n\r\n\r\n\r\n\r\nOnRedrawInit\r\n重绘初始化：访问元素之前调用，用来设置哪些 Elements 可以被绘制\r\n事件回调\r\n\r\n\r\nOnRedrawOperation\r\n可以修改每个元素的显示\r\n事件回调\r\n\r\n\r\nOnResymbolize\r\n工具可以重写元素显示的符号\r\n事件回调\r\n\r\n\r\nOnRedrawComplete\r\n在重绘结束，访问元素之前调用\r\n事件回调\r\n\r\n\r\n\r\n","categories":["Bentley","Develop","Tool"],"tags":["Bentley","Bentley二次开发"]},{"title":"Microstation 中监听元素修改事件","url":"/posts/2022/1GXJ3PN.html","content":"在进行 Microstation\r\n二次开发时，有时候需要监听元素的修改事件，实现联动修改，可以在 Addin\r\n上注册 ElementChangedEventHander 事件。\r\n\r\n事件有一个\r\nElementChangedEventArgs，从这个参数中可以获取需要的信息。\r\n获取操作\r\n获取是什么操作导致元素被修改，可以通过 ChangeTrackKind\r\n来获取，它的值如下：\r\npublic enum ChangeTrackKind&#123;    Delete = 1,    Add = 2,    Modify = 3,    ModifyFence = 5,    Mark = 7,    ModelAdd = 9,    ModelDelete = 10,    AddXAttribute = 11,    DeleteXAttribute = 12,    ModifyXAttribute = 13,    ReplaceXAttribute = 14&#125;\r\n获取新元素\r\n属性 NewElement 代表新元素。\r\n获取旧元素\r\n参考\r\n\r\n事件API\r\n元素拷贝、移动事件\r\n\r\n","categories":["Bentley","Develop","事件"],"tags":["Bentley","Bentley二次开发"]},{"title":"Bentley中在.NET下监听元素双击事件","url":"/posts/2021/2JZQM2W.html","content":"在用C#进行Bentley二次开发的过程中，我们可能有这个需求：希望获取双击的元素，然后响应修改命令。通过查找相关资料，最终实现方式如下。\r\n\r\n在继承自 Bentley.MstnPlatformNET.AddIn 的类中，重写 Run\r\n方法，并在此处监听 OnSelectionChanged\r\n事件，从事件参数中可以获取 Action，当 Action\r\n为 SelectionChangedEventArgs.ActionKind.DoubleClickElement\r\n时，就代表双击的元素。具体代码如下：\r\n// 该类继承 Bentley.MstnPlatformNET.AddInprotected override int Run(string[] commandLine)&#123;    // 其它操作    // ...        // 监听双击鼠标事件，实现修改    this.SelectionChangedEvent += OnSelectionChanged;    return 0;&#125;private void OnSelectionChanged(object sender, SelectionChangedEventArgs e)&#123;    switch (e.Action)    &#123;        case SelectionChangedEventArgs.ActionKind.DoubleClickElement:            // 通过 FilePosition 获取元素            var elem = GetElementByFilePosition(e.FilePosition);            // 对元素进行其它操作            break;        default:return;    &#125;&#125;// 通过 filePosition 获取 Element// 采用 COM 接口获取 filePosition 对应的 ElementId// 然后通过 elementId 获取.NET下的 Elementprivate Element GetElementByFilePosition (uint filePosition)&#123;    var app = Utilities.ComApp;    var elemCache = app.ActiveModelReference.GraphicalElementCache;    var index = elemCache.IndexFromFilePosition((int)filePosition);    if (elemCache.IsElementValid(index))    &#123;        var elem = elemCache.GetElement(index);        var longId = elem.ID;        return Session.Instance.GetActiveDgnModel().FindElementById((ElementId)eleId);    &#125;    return null;&#125;\r\n\r\n程序使用了 COM 接口，所以需要的引入\r\nBentley.MicroStation.dll，COM接口位于\r\nBentley.MstnPlatformNET.InteropServices 命名空间中。\r\n\r\n","categories":["Bentley","Develop","事件"],"tags":["Bentley二次开发"]},{"title":"MDL入门技术栈","url":"/posts/2020/14RZ2W.html","content":"随着 Bentley 二开的深入，对各种需求的不断增加，面向 .NET 提供的 API\r\n已经有些不能满足需求了，这就迫使我们必须接触 MDL 的开发，利用 Bentley\r\n面向 C++ 提供的丰富接口，达到我们的需求。\r\n本教程基于优先社区的 一步步学习MDL\r\n教程，再根据自己的知识短板，进行其它相关知识的补充以及对教程的深入解读。\r\n\r\n必备条件\r\n\r\nVS2015及以上\r\n安装 Microstation\r\n安装 Microstation SDK\r\n\r\nSDK 目录介绍\r\n\r\nbin文件夹\r\n该文件夹下含有生成最终应用程序所需的执行程序以及启动开发环境的批处理文件。这下面的执行程序主要是负责生成最终应用程序的资源部分的（关于资源的详细介绍请看后续文章），C++代码的编译和链接其实是调用VS2015中的cl.exe和link.exe的。\r\nDocumentation文件夹 该文件夹下会有五个开发帮助文档，其中的\r\nMicroStationApi.chm 就是我们要用到的 MDL C++\r\n帮助文档。其它四个是有关用C#开发Mstn应用程序的帮助文档。\r\nReadme文件夹 网页格式的SDK\r\nReadme。双击其下的index.html文件在浏览器中打开。其中含有各个SDK版本的变化、如何安装SDK以及开发者注意事项等。\r\nMigration文件夹 将V8i升级到CE的一些升级指南。\r\nexamples文件夹 大量的MDL\r\nC++或C#样例代码。其中有一些是老旧的，一些是新写的（比如，在用到写命令工具时，如果是调用的mdlState_xxx类函数的，一定是老旧的例子，用派生于DgnTool类的应该就是比较新的）。最好读新的例子。\r\ninclude文件夹 C++头文件。\r\nlibrary文件夹 C++库文件。\r\nMigrationTools文件夹\r\n帮助您从V8i代码迁移到CE代码的一些工具。主要是通过Python程序对一些关键字做映射。您可以手工修改文件0811to1000Published.remap中的内容来扩展这个映射库。\r\nmki文件夹 制作文件的头文件（make\r\ninclude）。为mke文件服务的一些系统文件。\r\neula.pdf文件 Bentley软件最终用户许可协议（End User License\r\nAgreement）。大量的法律条文说明哪些行为是被法律禁止的。\r\nMicroStationDeveloperShell.bat文件\r\n启动开发环境的批处理文件。\r\n\r\n制作文件 mkefile\r\n因为从未接触，总结稍详细，篇幅较多，转到 MDL开发中如何创建makefile文件\r\n阅读\r\n","categories":["Bentley","Develop","MDL入门"],"tags":["Bentley二次开发","MDL"]},{"title":"MDL开发中如何创建makefile文件","url":"/posts/2020/353AZ4N.html","content":"什么是 makefile ?\r\nmakefile关系到了整个工程的编译规则。一个工程中的源文件不计其数，并且按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。\r\n\r\n因为 windows\r\n集成的开发环境为我们做了上述工作，所以在平时开发的时候，没有太多的感觉。\r\n\r\n\r\nMDL 的开发需要熟悉的几种 mke\r\n语法:\r\n\r\n注释：以#号开头的行为注释行\r\n变量定义（Bentley 的说明中称它为宏，仅此处使用变量一词） 如\r\nappName = HelloWorld 这样的形式。appName\r\n被称为变量，HelloWorld 被当成值赋予给 appName。\r\n也可以对变量赋予多个值,值之间用空格分开，也可以使用 \\\r\n换行，比如：\r\nobjects = main.o kbd.o command.o display.o \\   insert.o search.o files.o utils.o\r\n变量使用：以 $(变量名) 形式，比如\r\n$(appName) 为 HelloWorld\r\n依赖定义 定义格式如下：\r\ntarget... : prerequisites... command1 ... commandN\r\n特别注意的是：command 前面必须是 Tab\r\n上面的参数说明如下：\r\n\r\ntarget 可以是一个 object\r\nfile（目标文件），也可以是一个执行文件，还可以是一个标签（label）。对于标签这种特性，在后续的“伪目标”章节中会有叙述。\r\nprerequisites 生成该 target 所依赖的文件\r\ncommand 该target要执行的命令（任意的shell命令）\r\n坦白说，可以这样理解：\r\n\r\nprerequisites中如果有一个以上的文件比 target\r\n文件要新的话，command 命令就会被执行。\r\n\r\n\r\n\r\n宏\r\n在 makefile 中定义宏\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n形式\r\n描述\r\n\r\n\r\n\r\n\r\nmacro = definition\r\n将 definition 的值赋给 macro。标准赋值方法，用得比较多\r\n\r\n\r\nmacro =% definition\r\n先计算 definition 的值，再赋值给 macro\r\n\r\n\r\nmacro + definition\r\n将 definition 添加到 marco 值后面，和编程中 += 用法颇似\r\n\r\n\r\nmacro +% definition\r\n先计算 definition 的值，然后再追加到 macro 上面\r\n\r\n\r\n\r\n宏的使用\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n形式\r\n描述\r\n\r\n\r\n\r\n\r\n\\((name)|通过迭代替换展开|\r\n|\\){name}\r\n通过迭代替换展开，如果最后一个字符是路径分隔符，则删除它\r\n\r\n\r\n$[name]\r\n展开值;将宏展开成迭代字符串值，且不做任何进一步的替换\r\n\r\n\r\n\r\n保留的宏和其展开值\r\n\r\n\r\n\r\n宏\r\n展开值\r\n\r\n\r\n\r\n\r\n\\(@|当前目标文件| |\\)?\r\n所有比目标文件更新的依赖文件\r\n\r\n\r\n\\(=|最新的依赖文件| |\\)&lt;\r\n当前的依赖文件\r\n\r\n\r\n\\(*|目标文件的基础文件| |\\)%\r\n第一个目标文件的目录\r\n\r\n\r\n\r\n每个操作平台都预定了宏，可以通过 bmake -p 来查看\r\n实例\r\n%if defined (_MakeFilePath) baseDir = $(_MakeFilePath) %elsebaseDir = $(MS)/mdl/examples/basic/%endif\r\n依赖定义规则符号解释\r\n依赖定义规则实例（来自\r\nmdl.mki）\r\n.mt.r: $(msg)&gt; $(o)temp.cmd-o$@%if privateInc-i$(privateInc)%endif&lt;BR&gt; $(rscCompIncs)$(altIncs)-i$(publishInc)-i$(publishIdsInc)-i$(stdlibInc)$%$*.mt$(RTypeCmd) @$(o)temp.cmd&lt;$(RTypeCmd) @$(o)temp.cmd ~time\r\n后记\r\n如果想了解更多 makefile 语法，可以参考：\r\n\r\n概述\r\n— 跟我一起写Makefile 1.0 文档\r\nSDK帮助文档MicroStationApi.chm的Creating a Makefile and Using the\r\nbmake Utility\r\n要想更深入地理解mke文件，还需要您读系统的mki文件，这些文件定义了许多系统内置的宏定义和规则\r\n\r\n","categories":["Bentley","Develop","MDL入门"],"tags":["Bentley二次开发","MDL"]},{"title":"MS Addin 开发常用 DLL 引用配置推荐","url":"/posts/2022/1YQEJF9.html","content":"本文收集了在 MS 二次开发的过程中常用的 DLL\r\n引用配置，方便今后开辟新项目直接拷贝使用，在使用的过程中，会根据需要，逐渐添加。\r\n\r\nCommand 配置\r\n&lt;ItemGroup&gt;  &lt;EmbeddedResource Include=&quot;AddinAndKeyIn\\ExtendedCommands.xml&quot;&gt;    &lt;LogicalName&gt;CommandTable.xml&lt;/LogicalName&gt;    &lt;SubType&gt;Designer&lt;/SubType&gt;  &lt;/EmbeddedResource&gt;&lt;/ItemGroup&gt;\r\nMS 引用列表\r\n&lt;Reference Include=&quot;Bentley.DgnDisplayNet&quot;&gt;  &lt;HintPath&gt;$(Bentley)\\Bentley.DgnDisplayNet.dll&lt;/HintPath&gt;  &lt;private&gt;False&lt;/private&gt;&lt;/Reference&gt;&lt;Reference Include=&quot;Bentley.DgnPlatformNET&quot;&gt;  &lt;HintPath&gt;$(Bentley)\\Bentley.DgnPlatformNET.dll&lt;/HintPath&gt;  &lt;private&gt;False&lt;/private&gt;&lt;/Reference&gt;&lt;Reference Include=&quot;Bentley.EC.Persistence3&quot;&gt;  &lt;HintPath&gt;$(Bentley)\\Assemblies\\ECFramework\\Bentley.EC.Persistence3.dll&lt;/HintPath&gt;  &lt;private&gt;False&lt;/private&gt;&lt;/Reference&gt;&lt;Reference Include=&quot;Bentley.ECObjects.Interop3&quot;&gt;  &lt;HintPath&gt;$(Bentley)\\Assemblies\\ECFramework\\Bentley.ECObjects.Interop3.dll&lt;/HintPath&gt;  &lt;private&gt;False&lt;/private&gt;&lt;/Reference&gt;&lt;Reference Include=&quot;Bentley.ECObjects.MixedMode3&quot;&gt;  &lt;HintPath&gt;$(Bentley)\\Assemblies\\ECFramework\\Bentley.ECObjects.MixedMode3.dll&lt;/HintPath&gt;  &lt;private&gt;False&lt;/private&gt;&lt;/Reference&gt;&lt;Reference Include=&quot;Bentley.ECObjects3&quot;&gt;  &lt;HintPath&gt;$(Bentley)\\Assemblies\\ECFramework\\Bentley.ECObjects3.dll&lt;/HintPath&gt;  &lt;private&gt;False&lt;/private&gt;&lt;/Reference&gt;&lt;Reference Include=&quot;Bentley.ECSystem3&quot;&gt;  &lt;HintPath&gt;$(Bentley)\\Assemblies\\ECFramework\\Bentley.ECSystem3.dll&lt;/HintPath&gt;  &lt;private&gt;False&lt;/private&gt;&lt;/Reference&gt;&lt;Reference Include=&quot;Bentley.General.1.0&quot;&gt;  &lt;HintPath&gt;$(Bentley)\\Assemblies\\ECFramework\\Bentley.General.1.0.dll&lt;/HintPath&gt;  &lt;private&gt;False&lt;/private&gt;&lt;/Reference&gt;&lt;Reference Include=&quot;Bentley.Platform&quot;&gt;  &lt;HintPath&gt;$(Bentley)\\Assemblies\\ECFramework\\Bentley.Platform.dll&lt;/HintPath&gt;  &lt;private&gt;False&lt;/private&gt;&lt;/Reference&gt;&lt;Reference Include=&quot;Bentley.UI&quot;&gt;  &lt;HintPath&gt;$(Bentley)\\Assemblies\\ECFramework\\Bentley.UI.dll&lt;/HintPath&gt;  &lt;private&gt;False&lt;/private&gt;&lt;/Reference&gt;&lt;Reference Include=&quot;Bentley.Windowing&quot;&gt;  &lt;HintPath&gt;$(Bentley)\\Assemblies\\ECFramework\\Bentley.Windowing.dll&lt;/HintPath&gt;  &lt;private&gt;False&lt;/private&gt;&lt;/Reference&gt;&lt;Reference Include=&quot;Bentley.GeometryNET&quot;&gt;  &lt;HintPath&gt;$(Bentley)\\Bentley.GeometryNET.dll&lt;/HintPath&gt;  &lt;private&gt;False&lt;/private&gt;&lt;/Reference&gt;&lt;Reference Include=&quot;Bentley.GeometryNET.Common&quot;&gt;  &lt;HintPath&gt;$(Bentley)\\Bentley.GeometryNET.Common.dll&lt;/HintPath&gt;  &lt;private&gt;False&lt;/private&gt;&lt;/Reference&gt;&lt;Reference Include=&quot;Bentley.GeometryNET.Structs&quot;&gt;  &lt;HintPath&gt;$(Bentley)\\Bentley.GeometryNET.Structs.dll&lt;/HintPath&gt;  &lt;private&gt;False&lt;/private&gt;&lt;/Reference&gt;&lt;Reference Include=&quot;Bentley.Interop.MicroStationDGN&quot;&gt;  &lt;HintPath&gt;$(Bentley)\\Assemblies\\Bentley.Interop.MicroStationDGN.dll&lt;/HintPath&gt;  &lt;private&gt;False&lt;/private&gt;&lt;/Reference&gt;&lt;Reference Include=&quot;Bentley.MicroStation&quot;&gt;  &lt;HintPath&gt;$(Bentley)\\Assemblies\\Bentley.MicroStation.dll&lt;/HintPath&gt;  &lt;private&gt;False&lt;/private&gt;&lt;/Reference&gt;&lt;Reference Include=&quot;Bentley.MicroStation.Interfaces.1.0&quot;&gt;  &lt;HintPath&gt;$(Bentley)\\Assemblies\\Bentley.MicroStation.Interfaces.1.0.dll&lt;/HintPath&gt;  &lt;private&gt;False&lt;/private&gt;&lt;/Reference&gt;&lt;Reference Include=&quot;Bentley.MicroStation.Ribbon&quot;&gt;  &lt;HintPath&gt;$(Bentley)\\Assemblies\\Bentley.MicroStation.Ribbon.dll&lt;/HintPath&gt;  &lt;private&gt;False&lt;/private&gt;&lt;/Reference&gt;&lt;Reference Include=&quot;Bentley.MicroStation.WinForms.Controls&quot;&gt;  &lt;HintPath&gt;$(Bentley)\\Assemblies\\Bentley.MicroStation.WinForms.Controls.dll&lt;/HintPath&gt;  &lt;private&gt;False&lt;/private&gt;&lt;/Reference&gt;&lt;Reference Include=&quot;Bentley.MicroStation.WPF&quot;&gt;  &lt;HintPath&gt;$(Bentley)\\Assemblies\\Bentley.MicroStation.WPF.dll&lt;/HintPath&gt;  &lt;private&gt;False&lt;/private&gt;&lt;/Reference&gt;&lt;Reference Include=&quot;Bentley.MicroStation.WPF&quot;&gt;  &lt;HintPath&gt;$(Bentley)\\Assemblies\\Bentley.MicroStation.WPF.dll&lt;/HintPath&gt;  &lt;private&gt;False&lt;/private&gt;&lt;/Reference&gt;    &lt;Reference Include=&quot;Bentley.PrintAPI&quot;&gt;  &lt;HintPath&gt;$(Bentley)\\Assemblies\\Bentley.PrintAPI.dll&lt;/HintPath&gt;  &lt;private&gt;False&lt;/private&gt;&lt;/Reference&gt;&lt;Reference Include=&quot;Bentley.PrintDefinitions&quot;&gt;  &lt;HintPath&gt;$(Bentley)\\Assemblies\\Bentley.PrintDefinitions.dll&lt;/HintPath&gt;  &lt;private&gt;False&lt;/private&gt;&lt;/Reference&gt;&lt;Reference Include=&quot;Bentley.PrintEngine&quot;&gt;  &lt;HintPath&gt;$(Bentley)\\Assemblies\\Bentley.PrintEngine.dll&lt;/HintPath&gt;  &lt;private&gt;False&lt;/private&gt;&lt;/Reference&gt;&lt;Reference Include=&quot;Bentley.PrinterConfigurationEditor&quot;&gt;  &lt;HintPath&gt;$(Bentley)\\Assemblies\\Bentley.PrinterConfigurationEditor.dll&lt;/HintPath&gt;  &lt;private&gt;False&lt;/private&gt;&lt;/Reference&gt;&lt;Reference Include=&quot;Bentley.PrintFoundation&quot;&gt;  &lt;HintPath&gt;$(Bentley)\\Assemblies\\Bentley.PrintFoundation.dll&lt;/HintPath&gt;  &lt;private&gt;False&lt;/private&gt;&lt;/Reference&gt;&lt;Reference Include=&quot;Bentley.PrintManager&quot;&gt;  &lt;HintPath&gt;$(Bentley)\\Assemblies\\Bentley.PrintManager.dll&lt;/HintPath&gt;  &lt;private&gt;False&lt;/private&gt;&lt;/Reference&gt;&lt;Reference Include=&quot;Bentley.TerrainModelNET&quot;&gt;  &lt;HintPath&gt;$(Bentley)\\Assemblies\\Bentley.TerrainModelNET.dll&lt;/HintPath&gt;  &lt;private&gt;False&lt;/private&gt;&lt;/Reference&gt;&lt;Reference Include=&quot;Bentley.TerrainModelNET.Formats&quot;&gt;  &lt;HintPath&gt;$(Bentley)\\Assemblies\\Bentley.TerrainModelNET.Formats.dll&lt;/HintPath&gt;  &lt;private&gt;False&lt;/private&gt;&lt;/Reference&gt;&lt;Reference Include=&quot;Bentley.TerrainModel.ElementTemplate&quot;&gt;  &lt;HintPath&gt;$(Bentley)\\Assemblies\\Bentley.TerrainModel.ElementTemplate.dll&lt;/HintPath&gt;  &lt;private&gt;False&lt;/private&gt;&lt;/Reference&gt;\t&lt;Reference Include=&quot;ustation&quot;&gt;  &lt;HintPath&gt;$(Bentley)\\ustation.dll&lt;/HintPath&gt;  &lt;private&gt;False&lt;/private&gt;&lt;/Reference&gt;&lt;Reference Include=&quot;Newtonsoft.Json&quot;&gt;  &lt;HintPath&gt;$(Bentley)\\Assemblies\\Newtonsoft.Json.dll&lt;/HintPath&gt;  &lt;private&gt;False&lt;/private&gt;&lt;/Reference&gt;\r\nSw 引用列表\r\n&lt;Reference Include=&quot;SWOpenRoadsSDK&quot;&gt;  &lt;HintPath&gt;$(SWORD)\\sw_Standards\\mdlapps\\SWOpenRoadsSDK.dll&lt;/HintPath&gt;&lt;/Reference&gt;&lt;Reference Include=&quot;SWOrdCPPSDK&quot;&gt;  &lt;HintPath&gt;$(SWORD)\\sw_Standards\\mdlapps\\SWOrdCPPSDK.dll&lt;/HintPath&gt;&lt;/Reference&gt;\r\n测试插件引用\r\n&lt;Reference Include=&quot;MSAddinTest&quot;&gt;  &lt;HintPath&gt;$(Bentley)\\Mdlapps\\MSAddinTest.dll&lt;/HintPath&gt;&lt;/Reference&gt;\r\n","categories":["Bentley","Develop","MDL入门"],"tags":["Bentley","Bentley二次开发"]},{"title":"如何调用 Microstation 的消息管理器","url":"/posts/2022/1NF37FV.html","content":"在进行Bentley二次开发的时候，通常我们需要向用户输出一些信息，比如操作的提示，错误的提示等等，本文特对这些方式进行总结，方便下次随心所欲地使用。\r\n\r\n通知管理器\r\n通过使用 NotificationManager\r\n向用户推送消息。可以用此类来生成提示、错误消息和警报对话框。\r\n\r\n\r\nimage-20220512074020104\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nDLL 名称\r\n命名空间\r\n类名\r\n\r\n\r\n\r\n\r\nBentley.DgnPlatformNET.dll\r\nBentley.DgnPlatformNET\r\nNotificationManager\r\n\r\n\r\n\r\n源码注解\r\n//打开消息弹窗public static MessageBoxValue OpenMessageBox(MessageBoxType mbType, string message, MessageBoxIconType icon);//向MS的底部通知栏写入提示public static StatusInt OutputMessage(NotifyMessageDetails message);public static void OutputPrompt(string prompt);//设置一个标志来分配（value==true时）事件，以便在执行费时算法时，刷新界面，从而不卡顿。public static void SetDispatchEvents(bool value);public enum MessageBoxType&#123;    YesNo = -121,    LargeOk = -119,    YesNoCancel = -113,    MediumAlert = -112,    Ok = -97,    OkCancel = -13,    None = 0&#125;public enum MessageBoxIconType&#123;    NoSymbol = 0,    Information = 1,    Question = 2,    Warning = 3,    Critical = 4&#125;public enum MessageBoxValue&#123;    None = 0,    Apply = 1,    Reset = 2,    Ok = 3,    Cancel = 4,    Default = 5,    Yes = 6,    No = 7,    Retry = 8,    Stop = 9,    Help = 10,    YesToAll = 11,    NoToAll = 12&#125;\r\n使用\r\n\r\nOpenMessageBox方法\r\nprivate void NotificationManagerOpenMessageBox()&#123;      NotificationManager.OpenMessageBox(NotificationManager.MessageBoxType.MediumAlert, &quot;Medium alert&quot;,NotificationManager.MessageBoxIconType.Warning);&#125;\r\nOutputMessage方法\r\nprivate void NotificationManagerOutputMessage()&#123;    OutputMessagePriority outputMessagePriority = OutputMessagePriority.Information;    string briefMsg = &quot;this is a brief msg&quot;;    string detailMsg = &quot;this is a detail msg&quot;;    NotifyTextAttributes notifyTextAttributes = NotifyTextAttributes.AlwaysBeveled;    NotifyMessageDetails notifyMessageDetails = new NotifyMessageDetails(outputMessagePriority,briefMsg,detailMsg,notifyTextAttributes,OutputMessageAlert.Balloon);    NotificationManager.OutputMessage(notifyMessageDetails);    &#125;\r\n\r\n\r\nimage-20220512074152131\r\n\r\nOutputPrompt方法\r\nprivate void NotificationManagerOutputPrompt()&#123;    NotificationManager.OutputPrompt(&quot;this is ouput prompt&quot;);&#125;\r\n\r\n\r\nimage-20220512073913334\r\n\r\n\r\n消息中心（MessageCenter）\r\n在 Bentley.MstnPlatformNET\r\n中也存在与消息管理器一样的类以供调用向用户传递消息。\r\n\r\n\r\n\r\nDLL 名称\r\n命名空间\r\n类名\r\n\r\n\r\n\r\n\r\nustation.dll\r\nBentley.MstnPlatformNET\r\nMessageCenter\r\n\r\n\r\n\r\n// 其内部代码如下public class MessageCenter&#123;    public static MessageCenter Instance &#123; get; &#125;    public string StatusWarning &#123; set; &#125;    public string StatusMessage &#123; set; &#125;    public string StatusPrompt &#123; set; &#125;    public string StatusCommand &#123; get; set; &#125;    public static string GetStringFromMessageListResource(int listId, int stringId);    public void ShowDebugMessage(string briefMessage, string detailedMessage, bool openAlertBox);    public void ShowDebugMessage(string briefMessage, string detailedMessage, MessageAlert alertType);    public void ShowErrorMessage(string briefMessage, string detailedMessage, bool openAlertBox);    public void ShowErrorMessage(string briefMessage, string detailedMessage, MessageAlert alertType);    public void ShowInfoMessage(string briefMessage, string detailedMessage, bool openAlertBox);    public void ShowInfoMessage(string briefMessage, string detailedMessage, MessageAlert alertType);    public void ShowMessage(MessageType messageType, string briefMessage, string detailedMessage, MessageAlert alertType);&#125;\r\n在使用时，通过单例来调用其中的实例方法：MessageCenter.Instance.xxx\r\n测试代码\r\n最后，附上 Notification Manager 测试代码的链接。\r\n加载编译之后的 ArticleSourceCode.dll，调用\r\nKey-in：test message manager，此时会弹出一个操作窗体，通过选择不同选项，即可查看相应方法的效果。\r\n\r\n\r\nimage-20220512073946491\r\n\r\n&gt;\r\nGitHub源代码\r\n","categories":["Bentley","Develop","消息中心"],"tags":["Bentley","Bentley二次开发"]},{"title":"C# 中如何向 Microstation 输出调试信息","url":"/posts/2022/38K28WD.html","content":"在进行 MS 开发时，有时候需要输出调试信息，方便查看，主要有 4\r\n种方式：\r\n\r\n通过 P/Invoke 技术调用\r\nvoid mdlDialog_dmsgsPrint(byte[] wMsg) 方法来输出\r\n通过 MS\r\n消息管理器 来输出，但是这种是输出是模态的，不太方便\r\n通过现有的 Log 库，比如 Log4net 来进行输出，在 MS 中无法打开 console\r\n进行输出，所以使用起来有些不方便\r\n自己写一个输出窗体，来显示调试信息\r\n\r\n本文介绍最简单的方式，即调用原生的消息输出窗体来展示。\r\n\r\n代码\r\nusing System.Text;using System.Runtime.InteropServices;namespace Utils.Message&#123;    /// &lt;summary&gt;    /// MS 中的输出窗体    /// &lt;/summary&gt;    public class Console    &#123;        [DllImport(&quot;ustation.dll&quot;)]        public static extern void mdlDialog_dmsgsPrint(byte[] wMsg);        public static void WriteLine(string message)        &#123;            mdlDialog_dmsgsPrint(Encoding.Unicode.GetBytes(message));        &#125;    &#125;&#125;\r\n使用效果：\r\n\r\n\r\nimage-20220519085734183\r\n\r\n参考\r\n请问mdlDialog_dmsgsPrint对应C#什么方法？\r\n","categories":["Bentley","Develop","消息中心"],"tags":["Bentley","Bentley二次开发","uyoufu"]},{"title":"Bentley 程序集学习","url":"/posts/2022/5X1QK2.html","content":"今天起要开始研究 Bentley 二开中常用的程序集内容了。\r\n\r\n为什么会突然有这个想法呢？\r\n是因为我发现，如果在开发的过程中，如果对 SDK\r\n了解太少的话，会导致思路闭塞，会大大降低了编程的效率。\r\n虽然搞开发已经 4\r\n年了，但是积累的东西还是不够，但是我坚信，日积跬步，终至千里。\r\n所以，谨以此文记录本人学习之决心，以此为序，迈上大神之路。\r\n","categories":["Bentley","Develop","程序集"],"tags":["Bentley","Bentley程序集学习"]},{"title":"Bentley工程属性入门","url":"/posts/2022/33P3D91.html","content":"本文主要介绍在 Bentley 平台上进行二次开发时，如何向 dgn\r\n保存自己的数据。\r\n\r\n序\r\n对于工程信息，主要分为几何数据与工程数据两个部分，对于几何数据，Bentley采用模型来表达。而工程数据，起初\r\nBentley 采用 XAttribute 的方式在 dgn\r\n文件中开辟一个特定空间存储非几何数据，但是在由于没有统一数据存储的方式和格式，导致不同专业软件之间的信息无法交流。最后，Bentley\r\n经过大量的摸索和借鉴形成了一套系统的数据解决方案系统 ECFramework\r\n(Engineering Content Framework )，通过这套方案\r\nBentley真正实现各个专业软件之间数据的无损流动和互动。\r\n对于仅需要向 dgn 保存自己工具所产生的数据，可以有如下三种方式：\r\n\r\nEC\r\nItemType\r\nXAttribute\r\n\r\nEC\r\n查询所有 ECInstance\r\n查询特定 ECInstance\r\nItemType\r\nXAttribute\r\n参考\r\nBentley\r\n软件开发教程 C#语言\r\n工程信息数据开发API(EC框架)\r\nMicroStation二次开发基础教学（七）\r\n","categories":["Bentley","Develop","数据存储"],"tags":["Bentley","EC"]},{"title":"给元素添加自定义数据的几种方式","url":"/posts/2023/283FNHQ.html","content":"参考：Addin给元素添加自定义Linkage数据\r\n","categories":["Bentley","Develop","数据存储"],"tags":["Bentley"]},{"title":"MS 关于 Fraction 的使用说明","url":"/posts/2020/4JEF7M.html","content":"在利用 MS 二开的时候，我们经常会等分线段，通常我们会用到 fraction\r\n来操作，在此记录下 MS 中 fraction 小坑，以作提醒。\r\n\r\n原理介绍\r\nfraction 对于 B样条曲线 来说不是各段长度相等的等分点。\r\nfraction 在开始时总是 0，然后结束时总是 1。\r\nfraction 只有在下列基础类型时，才是线性增加的\r\n\r\nline segment，线段\r\ncircular arc，圆或者圆弧\r\ntransition spirals，螺旋线\r\n\r\n而在其它复杂类型的曲线中， fraction\r\n的含义与曲线类型的内部参数化有关。\r\n\r\n对于有N个线段（即N+1个点）的线串 (Linestring)，各个顶点的 fraction\r\n分别为 0，1/N，2/N，…1。\r\n对于bspline 曲线，fraction 表示节点范围的分数。\r\n对于椭圆弧（elliptic arc），fraction 与角度变化成正比，公式为：X =\r\ncenter + vector0 * cos(theta) + vector90 * sin (theta)\r\n\r\n源代码\r\n在此，分享一个等分线段的算法，若有不足之处，还请指教。\r\n/// &lt;summary&gt;/// 用 fraction 获取 curve 上的点/// 该方法将全局 fraction 换算到每根线上的 fraction 来进行计算/// &lt;/summary&gt;/// &lt;param name=&quot;curve&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;globalFraction&quot;&gt;值在 [0,1] 之间，如果不在该区间，则会向外延伸&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static DPoint3d GlobalFraction2Point(this CurveVector curve, double globalFraction, out DVector3d vectorAtFraction)&#123;    // 如果 &lt;=0,按切线反向延长获取点    if (globalFraction &lt;= 0)    &#123;        curve.GetStartEnd(out DPoint3d pa, out _, out DVector3d ua, out _);        double length = curve.SumOfLengths();        DPoint3d pnt = pa + ua * length * globalFraction;        vectorAtFraction = ua;        return pnt;    &#125;    // 正向切线延长    else if (globalFraction &gt;= 1)    &#123;        curve.GetStartEnd(out _, out DPoint3d pb, out _, out DVector3d ub);        double length = curve.SumOfLengths();        DPoint3d pnt = pb + ub * length * (globalFraction - 1);        vectorAtFraction = ub;        return pnt;    &#125;    // 按 fraction 返回    double totalLength = 0;    double targetLength = globalFraction * curve.SumOfLengths();    foreach (var cp in curve)    &#123;        cp.Length(out var length);        totalLength += length;        if(totalLength &gt;= targetLength)        &#123;            // 说明位于当前分段上            var distance = targetLength - totalLength;            var curveDetail = cp.PointAtSignedDistanceFromFraction(1, distance, false);            cp.FractionToPoint(curveDetail.Fraction, out DPoint3d point, out vectorAtFraction);            return point;        &#125;    &#125;    vectorAtFraction = DVector3d.Zero;    return DPoint3d.Zero;&#125;\r\n参考\r\nCurveLocationDetail的fraction总是得不到正确结果\r\n","categories":["Bentley","Develop","几何变换"],"tags":["Bentley二次开发"]},{"title":"CurveVector 相关实现笔记","url":"/posts/2020/6W94V6.html","content":"判断 CurveVector\r\n是否在一个平面\r\n// C#cv.IsPlanar(out DTransform3d localToWorld, out DTransform3d worldToLocal, out DRange3d range3D);// 转到 xy 平面cv.Transform(worldToLocal);\r\n\r\n返回的第一个参数为 localToWorld，该坐标系是 curve\r\n的局部坐标第，曲线位于局部坐标系的 xy 平面。如果要将其变成世界坐标系的\r\nxy，则要将左乘 localToWorld 的逆矩阵，即\r\nworldToLocal。\r\n\r\n创建线串\r\nCurveVector静态\r\n// CurveVector 类中public static CurveVector CreateLinear(IList&lt;DPoint3d&gt; points, BoundaryType boundaryType, bool forceXYOrientation);\r\n\r\n最后一个参数在使用中经常会让人误解，当它为 true\r\n时，将强制生成的曲线外部和内部循环具有正确的(CCW/CW)顺序。\r\n\r\nCurvePrimitive静态\r\n判断点与曲线的关系\r\n// CurveVector 类中public InOutClassification PointInOnOutXY([In] DPoint3d xyz);\r\n","categories":["Bentley","Develop","几何变换"],"tags":["CurveVector","BentleySDK"]},{"title":"DTranform3d和DMatrix理解","url":"/posts/2021/17DF183.html","content":"DTransform3d 是 Bentley\r\n中几何变换的类，通过它可以快速生成变换矩阵。\r\n\r\n\r\n\r\n\r\n程序集\r\n命名空间\r\n\r\n\r\n\r\n\r\nBentley.GeometryNET.Structs.dll\r\nBentley.GeometryNET\r\n\r\n\r\n\r\nDPoint3d\r\n代表点，点也可以看成是从原点开始的向量\r\nDVector3d\r\n代表向量\r\nDMatrix\r\n它的类型的是 Struct，代表方阵，有\r\nDMatrix2d、DMatrix3d、DMatrix4d，是基本的数学几何表达。\r\nDTransform3d\r\nDTransform3d 是齐次表达式型矩阵的一种封装，有 DTransform2d 和\r\nDTransform3d，分别代表 2x3 和 3x4 阶矩阵。\r\n它内部的一些变换使用到了 DMatrix，因为 DMatrix\r\n是结构体，运行在栈上，执行效率高。\r\nBentley 中使用 DTransform3d\r\n来实现三维变换，它使用三维矩阵加上一个平移矩阵的方式来表达齐次矩阵。\r\nBentley 在进行三维仿射时，其原理是先将 DTransform3d\r\n中的数据转成一个三维齐次矩阵，然后再对图形左乘变换矩阵进行变换。\r\n左乘\r\n要对图形进行仿射变换，需要左乘矩阵，同时，变换的顺序是从右向左的。\r\nBentley\r\n中很多对象重载了运算符，可以方便进行仿射变换，在使用的过程中，直接使用\r\n* 号即可。\r\n例如: 对 DVector3d 进行变换，可以使用：\r\nDVector3d vector = DVector3d.UnitZ;DTransform3d trans = DTransform3d.Identity;DVector3d result = trans * vector;\r\n关于矩阵的理解\r\n矩阵的通用表达式为： \\[\r\nM_{local} \\cdot P_{local} = M_{world} \\cdot P_{world} = I \\cdot P\r\n\\] 从上面的表达式中，我们可以理解为：\r\n\r\n对象的真实坐标为 \\(P\\)\r\nP 在世界坐标系中是 \\(P_{world}\\)\r\nP 在局部坐标系中是 \\(P_{local}\\)\r\n\r\n所以，如果要将一个坐标系转换到另一个坐标系，可以先将该坐标系中的点转换到真实坐标，然后再通过真实坐标转换到另一个坐标系中。\r\n假设有坐标系： \\[\r\n\\begin{align}\r\nM_1 \\cdot P_1 = M \\cdot P \\\\\r\nM_2 \\cdot P_2 = M \\cdot P\r\n\\end{align}\r\n\\] 如果要将 \\(P_1\\) 变成 \\(P_2\\),则可以： \\[\r\nM_1 \\cdot P_1 = M_2 \\cdot P_2 =&gt; P_2 = M_2^{-1} \\cdot M_1 \\cdot P_1\r\n\\]\r\n要转换到某个坐标系，就要左乘该坐标系的逆矩阵。\r\n混淆概念解析\r\n在使用 DTranform3 时，经常会有 worldToLocal 和\r\nlocalToWorld，它们的关系如下： \\[\r\n\\begin{align}\r\nP_{world} = M_{localToWorld} \\cdot P_{local} \\\\\r\nM_{worldToLocal} = M_{localToWorld}^{-1}\r\n\\end{align}\r\n\\]\r\n\r\nworldToLocal\r\n将世界坐标系转换到局部坐标系，从而获取局部坐标，即是局部坐标系矩阵的逆矩阵。\r\n对于元素来说，就是将世界坐标系中的元素旋转到自己定义的坐标系下\r\nlocalToWorld\r\nworldToLocal的逆矩阵\r\n\r\n求逆变换\r\n逆矩阵\r\n在 DTransform3d 的实例上，有一个\r\nTryInvert，调用该方法可以获取一个变换的逆变换。因为一个矩阵，不一定是可逆的，所以\r\nTryInvert 不一定会获取到逆变换，需要根据返回值来确定。\r\n// 使用代码片段DTransform3d trans = new DTransform3d(cursorLocation.ViewRotation);trans.TryInvert(out DTransform3d invertTras);\r\n伪逆\r\n一个矩阵不一定有逆矩阵，但是一定有伪逆。所以可以通过下列方法求得：\r\n// DTransform 中包含静态 FromPseudoInverse，直接调用即可public static DTransform3d FromPseudoInverse(DTransform3d transform)&#123;    // 先转置    DMatrix3d matrix = new DMatrix3d(transform).Transpose();    DVector3d vector = DMatrix3d.Multiply(matrix,-transform.coffxw,-transform.coffyw,-transform.coffzw);    // 对转置进行平移    return FromMatrixAndTranslation(matrix, vector);&#125;\r\n参考\r\n\r\n几何变换/坐标变换/矩阵变换\r\n等基础概念和代码应用\r\n计算机中 堆\r\n、栈、\r\n\r\n","categories":["Bentley","Develop","几何变换"],"tags":["Bentley二次开发","DTransform3d"]},{"title":"SolidKernelEntity 如何进行矩阵变换","url":"/posts/2021/F3GB3M.html","content":"一般元素在进行矩阵变换时，直接使用\r\nApplyTransform(TransformInfo transInfo) 即可进行变化，但\r\nSolidKernelEntity 在进行矩阵变换时，操作有所不同。\r\n\r\n步骤：\r\n\r\n获取 SolidKernelEntity 原来的矩阵\r\n用变换矩阵左乘原来的矩阵\r\n对 SolidKernelEntity 设置新的矩阵\r\n\r\nWhy？\r\n因为从 Element 向 SolidKernelEntity 转换时内部已经针对 Design\r\nCoordinate System 到 ParaSolid coordinate system做了transform了，而\r\nSolidKernelEntity 的变换使用的是\r\nSetEntityTransform(ref DTransform3d transform)\r\n，该方法是覆盖原来的矩阵，所以要将原变换矩阵左乘变换矩阵，然后赋给\r\nSolidKernelEntity。\r\n代码\r\nSolidKernelEntity solidKernelEntity = null;// 新变换DTransform3d targetTrans = DTransform3d.Identity;// 原变换DTransform3d existTrans = solidKernelEntity.GetEntityTransform();// 最终变换DTransform3d finallyTrans = targetTrans * existTrans;solidKernelEntity.SetEntityTransform(ref finallyTrans);\r\n","categories":["Bentley","Develop","几何变换"],"tags":["BentleySDK","SolidKernelEntity","矩阵变换"]},{"title":"图形变换","url":"/posts/2020/XDTNKH.html","content":"在利用 MS\r\n二开的时候，图形变换经常用到，下面对图形变换相关知识进行简要总结。如果想更加深入地学习，可以阅读《计算机图形学》\r\n\r\n二维几何变换\r\n基本变换\r\n平移\r\n\r\n将 P 移到 P' 点，代数表达为： \\[\r\n\\begin{align}\r\nx&#39;=x+t_x \\\\\\\\\r\ny&#39;=y+t_y\r\n\\end{align}\r\n\\] 转化成矩阵表达为： \\[\r\n\\displaylines{\r\nP&#39;= P+T \\\\\r\nP&#39;= \\begin{bmatrix}\r\n   x&#39; \\\\\r\n   y&#39; \\\\\r\n  \\end{bmatrix},\r\nP= \\begin{bmatrix}\r\n   x \\\\\r\n   y \\\\\r\n  \\end{bmatrix},\r\nT= \\begin{bmatrix}\r\n   t_x \\\\\r\n   t_y \\\\\r\n  \\end{bmatrix}\r\n}\r\n\\]\r\n旋转\r\n\r\n将 (x,y) 绕 (0,0) 旋转 θ 角，代数表达为： \\[\r\n\\begin{aligned}\r\nx&#39;=xcos\\theta-ysin\\theta \\\\\r\ny&#39; =xsin\\theta+ycos\\theta\r\n\\end{aligned}\r\n\\]\r\n\r\n通过极坐标来推导\r\n\r\n转化为矩阵表达为： \\[\r\n\\begin{align}\r\nP&#39;=R \\cdot P \\\\\r\nR= \\begin{bmatrix}\r\n   cos\\theta &amp; -sin\\theta \\\\\r\n   sin\\theta &amp; cos\\theta \\\\\r\n  \\end{bmatrix}\r\n\\end{align}\r\n\\]\r\n\r\n对于绕任意点的旋转，可以将任意点先平移到原点，旋转之后，再反向平移，其矩阵表达式见齐次坐标章节。\r\n\r\n缩放\r\n绽放的代数表达为： \\[\r\n\\begin{align}\r\nx&#39;=S_x\\cdot x \\\\\r\ny&#39;=S_y\\cdot y\r\n\\end{align}\r\n\\] 转化为矩阵表达为： \\[\r\n\\begin{align}\r\nP&#39;=S \\cdot P \\\\\r\nS= \\begin{bmatrix}\r\n   S_x \\\\\r\n   S_y \\\\\r\n  \\end{bmatrix}\r\n\\end{align}\r\n\\]\r\n齐次坐标\r\n从上面的基本变换中，我们可以看出，每个基本变换都可以表示为普通矩阵形式：\r\n\\[\r\nP&#39; = M_1 \\cdot P + M_2\r\n\\]\r\n\r\n对于平移\r\n\\(M_1\\) 为单位矩阵，\\(M_2\\) 为平移的参数\r\n对于旋转和缩放\r\n\\(M_1\\)\r\n为以原点为基准的旋转缩放矩阵，\\(M_2\\)\r\n为实际基准点的平移参数\r\n\r\n所以，为了利用这个公式产生先缩放，再旋转，后平移这样的变换顺序，必须一步一步地计算变换的坐标，不仅不方便使用，且效率低下。为了解决这个问题，将\r\n2x2 的矩阵扩充为 3x3 矩阵，从而将所有的变化组合成单一矩阵来表示。\r\n齐次坐标\r\n将二维坐标表示 (x,y) 扩充到三维表示 (\\(x_w,y_w,w\\)) ,称为齐次坐标\r\n(homogeneous coordinate) ，齐次坐标 (homogeneous\r\ncoordinates) 或投影坐标 (projective coordinates)\r\n是指一个用于投影几何里的坐标系统，如同用于欧氏几何里的笛卡儿坐标一般。\r\n齐次坐标的引入\r\n在欧式空间里，两条公面的平行线无法相交，但是在投影空间(Projective\r\nSpace)里不是这样。一个直观的表示如下：两条轨道的间距随着视线变远而逐渐变小，直到在无限远处相交。\r\n\r\n\r\nimg\r\n\r\n在欧式空间里采用\\((x, y,\r\nz)\\)表示一个三维点，但是无穷远点\\((\\infty, \\infty,\r\n\\infty)\\)在欧式空间里是没有意义的，在投影空间中进行图形和几何运算并不是一个简单的问题，为了解决这个问题，数学家　August\r\nFerdinand Möbius　提出了齐次坐标系，使用 N+1 个量来表示　N\r\n维坐标。例如在二维齐次坐标系中，我们引入一个量w，将一个二维点\\((x, y)\\)重新表示为\\((X, Y, w)\\)的形式，其中转换关系为： \\[\r\n\\begin{align}\r\nx = \\frac{X}{w} \\\\\r\ny = \\frac{Y}{w}\r\n\\end{align}\r\n\\]\r\n例如，欧式坐标中的一个二维点\\((1,\r\n2)\\)可以在齐次坐标中表示为\\((1, 2,\r\n1)\\)，如果点逐渐移动向无穷远处，其欧式坐标变为\\((\\infty, \\infty,\r\n\\infty)\\)，齐次坐标变为\\((1, 2,\r\n0)\\)。其中齐次坐标在表示无穷远处的点时不需要用到\\(\\infty\\)。\r\n\r\n其中齐次坐标\\((1, 2,\r\n1)\\)等价于齐次坐标\\((2, 4,\r\n2)\\)…即\\((k, 2k, k)，k \\in\r\nR\\)，此处这些点具有尺度不变性，是齐性的（结构相似的），所以称为齐次坐标\r\n\r\n平行线相交的不太严格的证明\r\n欧式空间中假设有如下两条平行线: \\[\r\n\\begin{align}\r\nAx + By + C = 0 \\\\\r\nAx + By + D = 0\r\n\\end{align}\r\n\\] 上面两条先在欧式空间中除非 \\(C =\r\nD\\)，否则不相交。使用 \\(\\frac{x}{w},\r\n\\frac{y}{w}\\) 替换 \\(x, y\\)\r\n(正如前文提到的使用\\(N+1\\)个量表示 N\r\n维坐标，这里增加了一个量 w)，可以得到： \\[\r\n\\begin{align}\r\nAx + By + Cw = 0 \\\\\r\nAx + By + Dw = 0\r\n\\end{align}\r\n\\] 上式可以得到解\\((x, y,\r\n0)\\)，即两条平行线的齐次坐标表示在\\((x,\r\ny, 0)\\)也就是无穷点处相遇\r\n\r\n当然这只是一个不严格不严谨的表示，齐次坐标真正的作用在于下文。\r\n\r\n齐次坐标可以区分点与向量\r\n以二维空间为例，\\((a, b)\\)\r\n这样的表示既可以是一个坐标表示，也可以是一个向量表示。假设这个坐标系\r\n\\(xOy\\) 中两个基向量为 \\(\\vec{x}, \\vec{y}\\)，坐标原点为\r\no，则其中\r\n\r\n表示向量 \\(\\vec{v}\\) 时，代表 \\(\\vec{v} = a\\vec{x} + b\\vec{y}\\)\r\n表示一个点 p 时，代表 $ p - o = a + b $\r\n\r\n如果没有附加说明，我们不能区别 \\((a,\r\nb)\\)\r\n表示的是向量还是点。用三个量来表示的话，我们可以明确的区分向量和点\r\n\r\n齐次点 \\((a, b, 1)\\)\r\n取 \\(w=1\\)\r\n是为了方便与欧拉坐标进行对应\r\n齐次向量 \\((a, b, 0)\\)\r\n欧拉坐标系中，向量是一个射向无穷远的射线，所以用 \\(w=0\\) 来表示。\r\n\r\n基于齐次坐标的矩阵表示\r\n通过基本变换，可以很容易得到下列矩阵：\r\n平移\r\n矩阵表达： \\[\r\n\\begin{bmatrix}\r\n   x&#39; \\\\\r\n   y&#39; \\\\\r\n   1 \\\\\r\n  \\end{bmatrix} = \\begin{bmatrix}\r\n  1 &amp; 0 &amp; t_x \\\\\r\n  0 &amp; 1 &amp; t_y \\\\\r\n  0 &amp; 0 &amp; 1\r\n  \\end{bmatrix} \\cdot \\begin{bmatrix}\r\n  x \\\\\r\n  y \\\\\r\n  1\r\n  \\end{bmatrix}\r\n\\] 简写为： \\[\r\nP&#39;=T_{(t_x,t_y)} \\cdot P\r\n\\]\r\n逆平移变换为： \\[\r\nT_{(t_x,t_y)}^{-1} = \\begin{bmatrix}\r\n  1 &amp; 0 &amp; -t_x \\\\\r\n  0 &amp; 1 &amp; -t_y \\\\\r\n  0 &amp; 0 &amp; 1\r\n  \\end{bmatrix}\r\n\\]\r\n旋转\r\n矩阵表达： \\[\r\n\\begin{bmatrix}\r\n   x&#39; \\\\\r\n   y&#39; \\\\\r\n   1 \\\\\r\n  \\end{bmatrix} = \\begin{bmatrix}\r\n  cos \\theta &amp; -sin \\theta &amp; 0 \\\\\r\n  sin \\theta &amp; cos \\theta  &amp; 0 \\\\\r\n  0 &amp; 0 &amp; 1\r\n  \\end{bmatrix} \\cdot \\begin{bmatrix}\r\n  x \\\\\r\n  y \\\\\r\n  1\r\n  \\end{bmatrix}\r\n\\]\r\n简写为： \\[\r\nP&#39;=R_{(\\theta)} \\cdot P\r\n\\]\r\n逆旋转变换为： \\[\r\nR_{(\\theta)}^{-1} = \\begin{bmatrix}\r\n  cos (-\\theta) &amp; -sin (-\\theta) &amp; 0 \\\\\r\n  sin (-\\theta) &amp; cos (-\\theta)  &amp; 0 \\\\\r\n  0 &amp; 0 &amp; 1\r\n  \\end{bmatrix} = \\begin{bmatrix}\r\n   cos \\theta &amp; sin \\theta &amp; 0 \\\\\r\n  -sin \\theta &amp; cos \\theta &amp; 0 \\\\\r\n  0 &amp; 0 &amp; 1\r\n  \\end{bmatrix}\r\n\\]\r\n缩放\r\n矩阵表达： \\[\r\n\\begin{bmatrix}\r\n   x&#39; \\\\\r\n   y&#39; \\\\\r\n   1 \\\\\r\n  \\end{bmatrix} = \\begin{bmatrix}\r\n  S_x &amp; 0 &amp; 0 \\\\\r\n  0 &amp; S_y &amp; 0 \\\\\r\n  0 &amp; 0   &amp; 1\r\n  \\end{bmatrix} \\cdot \\begin{bmatrix}\r\n  x \\\\\r\n  y \\\\\r\n  1\r\n  \\end{bmatrix}\r\n\\] 简写为： \\[\r\nP&#39;=S_{(S_x,S_y)} \\cdot P\r\n\\] 逆绽放矩阵为： \\[\r\nS_{(S_X,X_Y)}^{-1} = \\begin{bmatrix}\r\n  \\frac{1}{S_x} &amp; 0 &amp; 0 \\\\\r\n  0 &amp; \\frac{1}{S_y} &amp; 0 \\\\\r\n  0 &amp; 0   &amp; 1\r\n  \\end{bmatrix}\r\n\\]\r\n反射（镜像）\r\n\r\n关于 x 轴镜像\r\n\\[\r\n\\begin{bmatrix}\r\n   x&#39; \\\\\r\n   y&#39; \\\\\r\n   1 \\\\\r\n  \\end{bmatrix} = \\begin{bmatrix}\r\n  1 &amp; 0 &amp; 0 \\\\\r\n  0 &amp; -1 &amp; 0 \\\\\r\n  0 &amp; 0   &amp; 1\r\n  \\end{bmatrix} \\cdot \\begin{bmatrix}\r\n  x \\\\\r\n  y \\\\\r\n  1\r\n  \\end{bmatrix}\r\n\\]\r\n关于 y 轴镜像\r\n\\[\r\n\\begin{bmatrix}\r\n   x&#39; \\\\\r\n   y&#39; \\\\\r\n   1 \\\\\r\n  \\end{bmatrix} = \\begin{bmatrix}\r\n  -1 &amp; 0 &amp; 0 \\\\\r\n   0 &amp; 1 &amp; 0 \\\\\r\n   0 &amp; 0 &amp; 1\r\n  \\end{bmatrix} \\cdot \\begin{bmatrix}\r\n  x \\\\\r\n  y \\\\\r\n  1\r\n  \\end{bmatrix}\r\n\\]\r\n绕任意轴镜像\r\n可以先将任意轴旋转到 x 或 y 轴上，然后再应用上述镜像矩阵。\r\n错切\r\n\r\n相对于 x 轴的 x 方向错切\r\n\\[\r\n\\begin{bmatrix}\r\n   x&#39; \\\\\r\n   y&#39; \\\\\r\n   1 \\\\\r\n  \\end{bmatrix} = \\begin{bmatrix}\r\n  1 &amp; sh_x &amp; 0 \\\\\r\n  0 &amp; 1 &amp; 0 \\\\\r\n  0 &amp; 0 &amp; 1\r\n  \\end{bmatrix} \\cdot \\begin{bmatrix}\r\n  x \\\\\r\n  y \\\\\r\n  1\r\n  \\end{bmatrix}\r\n\\]\r\n该矩阵将坐标转换成： \\[\r\nx&#39;=x+sh_x \\cdot y \\\\\r\ny&#39;=y\r\n\\]\r\n相对于 y 轴的 y 方向错切\r\n\\[\r\n\\begin{bmatrix}\r\n   x&#39; \\\\\r\n   y&#39; \\\\\r\n   1 \\\\\r\n  \\end{bmatrix} = \\begin{bmatrix}\r\n  1 &amp; 0 &amp; 0 \\\\\r\n  sh_y &amp; 1 &amp; 0 \\\\\r\n  0 &amp; 0 &amp; 1\r\n  \\end{bmatrix} \\cdot \\begin{bmatrix}\r\n  x \\\\\r\n  y \\\\\r\n  1\r\n  \\end{bmatrix}\r\n\\]\r\n该矩阵将坐标转换成： \\[\r\n\\begin{align}\r\nx&#39;=x \\\\\r\ny&#39;=y+sh_y \\cdot y\r\n\\end{align}\r\n\\]\r\n逆变换\r\n将经过矩阵变换的点再逆反到原来的位置，需要对点进行逆变换。逆变换其实就是对原矩阵求逆。\r\n\\[\r\n\\begin{align}\r\nP&#39; &amp;= M \\cdot P \\\\\r\nM^{-1} \\cdot P&#39; &amp;= M ^{-1} \\cdot M \\cdot P \\\\\r\n所以: P &amp;= M^{-1} \\cdot P&#39;\r\n\\end{align}\r\n\\] 怎么求逆矩阵呢？\r\n一般通过初等变换法求取矩阵的逆，详见《代数》。\r\n二维复合变换\r\n利用矩阵表达式，可以将各个矩阵变换相乘，把任意的变换序列组合成一个复合的变换矩阵，提高计算效率。通过复合矩阵，可以实现图形的任意变化。\r\n\r\n复合变换矩阵是从右向左变换的。\r\n\r\n复合二维平移\r\n\\[\r\n\\begin{bmatrix}\r\n  1 &amp; 0 &amp; t_{x2} \\\\\r\n  0 &amp; 1 &amp; t_{y2} \\\\\r\n  0 &amp; 0 &amp; 1\r\n  \\end{bmatrix}\r\n\\cdot   \r\n\\begin{bmatrix}\r\n  1 &amp; 0 &amp; t_{x1} \\\\\r\n  0 &amp; 1 &amp; t_{y1} \\\\\r\n  0 &amp; 0 &amp; 1\r\n  \\end{bmatrix} =\r\n\\cdot\r\n\\begin{bmatrix}\r\n  1 &amp; 0 &amp; t_{x1}+t_{x2} \\\\\r\n  0 &amp; 1 &amp; t_{y1}+t_{y2} \\\\\r\n  0 &amp; 0 &amp; 1\r\n  \\end{bmatrix}\r\n\\]\r\n复合二维旋转\r\n\\[\r\nR_{(\\theta 2)} \\cdot R_{(\\theta 1)} = R_{(\\theta1+\\theta2)}\r\n\\]\r\n复合二维缩放\r\n\\[\r\n\\begin{bmatrix}\r\n  S_{x2} &amp; 0 &amp; 0 \\\\\r\n  0 &amp; S_{y2} &amp; 0 \\\\\r\n  0 &amp; 0   &amp; 1\r\n  \\end{bmatrix} \\cdot\r\n\\begin{bmatrix}\r\n  S_{x1} &amp; 0 &amp; 0 \\\\\r\n  0 &amp; S_{y1} &amp; 0 \\\\\r\n  0 &amp; 0   &amp; 1\r\n  \\end{bmatrix} =\r\n\\begin{bmatrix}\r\n  S_{x1} \\cdot S_{x2} &amp; 0 &amp; 0 \\\\\r\n  0 &amp; S_{y1} \\cdot S_{y2} &amp; 0 \\\\\r\n  0 &amp; 0   &amp; 1\r\n  \\end{bmatrix}\r\n\\]\r\n通用二维基准点旋转\r\n假设需要绕 \\((x_r,y_r)\\)\r\n进行旋转，可以采用如下步骤实现：\r\n\r\n平移对象使基准点位置移动到坐标原点\r\n将对象绕坐标原点进行旋转\r\n将对象平移回原位置\r\n\r\n\\[\r\n\\begin{bmatrix}\r\n  1 &amp; 0 &amp; x_r \\\\\r\n  0 &amp; 1 &amp; y_r \\\\\r\n  0 &amp; 0 &amp; 1\r\n  \\end{bmatrix} \\cdot\r\n\\begin{bmatrix}\r\n  cos \\theta &amp; -sin \\theta &amp; 0 \\\\\r\n  sin \\theta &amp; cos \\theta  &amp; 0 \\\\\r\n  0 &amp; 0 &amp; 1\r\n  \\end{bmatrix} \\cdot\r\n\\begin{bmatrix}\r\n  1 &amp; 0 &amp; -x_r \\\\\r\n  0 &amp; 1 &amp; -y_r \\\\\r\n  0 &amp; 0 &amp; 1\r\n  \\end{bmatrix}\r\n\\]\r\n通用二维基准点缩放\r\n假设需要绕 \\((x_s,y_s)\\)\r\n进行缩放，可以采用如下步骤实现：\r\n\r\n平移对象使旋转点与坐标原点重合\r\n将对象基于坐标原点进行缩放\r\n将对象平移回原位置\r\n\r\n\\[\r\n\\begin{bmatrix}\r\n  1 &amp; 0 &amp; x_s \\\\\r\n  0 &amp; 1 &amp; y_s \\\\\r\n  0 &amp; 0 &amp; 1\r\n  \\end{bmatrix} \\cdot\r\n\\begin{bmatrix}\r\n  S_x &amp; 0 &amp; 0 \\\\\r\n0 &amp; S_y  &amp; 0 \\\\\r\n  0 &amp; 0 &amp; 1\r\n  \\end{bmatrix} \\cdot\r\n\\begin{bmatrix}\r\n  1 &amp; 0 &amp; -x_s \\\\\r\n  0 &amp; 1 &amp; -y_s \\\\\r\n  0 &amp; 0 &amp; 1\r\n  \\end{bmatrix}\r\n\\]\r\n通用二维定向缩放\r\n\r\n先将定向缩放方向旋转至与 x 或 y 轴重合\r\n利用参数 \\(S_x\\) 或 \\(S_y\\) 进行缩放\r\n最后将对象旋转回原位置\r\n\r\n矩阵的理解\r\n齐次矩阵各个分量的含义： $$\r\n\\[\\begin{bmatrix}\r\n  a_{11}(x方向的缩放) &amp; a_{12}(x相对于y的变化量) &amp;\r\na_{13}(x的平移值) \\\\\r\n  a_{21}(y相对于x的变化量) &amp; a_{22}(y方向的缩放) &amp;\r\na_{23}(y的平移值) \\\\\r\n  0 &amp; 0 &amp; 1 \\\\\r\n  \\end{bmatrix}\\]\r\n\\[\\begin{align}\r\n&amp;--x 影响因子 \\\\\r\n&amp;--y影响因子 \\\\\r\n&amp;--齐次因子\r\n  \\end{align}\\] $$\r\n复合矩阵复合顺序：\r\n在进行矩阵的复合时，一定下一个矩阵左乘上一个矩阵，千万不能弄反了。在变换时，是从右向左变换的。\r\n二维坐标系间的变换\r\n\r\n在进行图形处理时，经常需要将对象从一个坐标系变换到另一个坐标系中，比如从对象的局部坐标系切换到世界坐标。\r\n如上图所示，为了将 P 的 xy 坐标变换到 x'y' 坐标，必须将 x'y' 轴叠加到\r\nxy 轴上，需要分两步进行：\r\n\r\n将 x'y' 系统的坐标原点 \\((x_0,y_0)\\) 平移到 xy 系统的原点 \\((0,0)\\)\r\n将 x' 轴旋转到 x 轴上（顺时针旋转 \\(\\theta\\) ）\r\n\r\n\\[\r\n\\begin{bmatrix}\r\n  const \\theta &amp; -sin(-\\theta) &amp; 0 \\\\\r\n  sin(-\\theta) &amp; const \\theta &amp; 0 \\\\\r\n  0 &amp; 0 &amp; 1\r\n  \\end{bmatrix} \\cdot  \r\n\\begin{bmatrix}\r\n  1 &amp; 0 &amp; -x_0 \\\\\r\n  0 &amp; 1 &amp; -y_0 \\\\\r\n  0 &amp; 0 &amp; 1\r\n  \\end{bmatrix}\r\n\\]\r\n三维几何变换\r\n三维几何变换的方法是在二维的基础上扩充了 Z 坐标而得到的。\r\n三维平移\r\n\\[\r\n\\begin{bmatrix}\r\nx&#39; \\\\\r\ny&#39; \\\\\r\nz&#39; \\\\\r\n1\r\n\\end{bmatrix} =\r\n\\begin{bmatrix}\r\n1 &amp; 0 &amp; 0 &amp; t_x \\\\\r\n0 &amp; 1 &amp; 0 &amp; t_y \\\\\r\n0 &amp; 0 &amp; 1 &amp; t_z \\\\\r\n0 &amp; 0 &amp; 0 &amp; 1\r\n\\end{bmatrix} \\cdot\r\n\\begin{bmatrix}\r\nx \\\\\r\ny \\\\\r\nz \\\\\r\n1\r\n\\end{bmatrix}\r\n\\]\r\n三维旋转\r\n在三维空间中，图形对象可以绕任意轴进行旋转，但绕平行于坐标轴旋转是容易处理的。所以，我们通过适当的平移旋转，使得旋转轴与坐标轴对齐，然后再构建基于坐标轴的旋转矩阵，最后将上述矩阵复合成一个空间中的旋转矩阵。\r\n\r\n如果沿着坐标轴正半轴观察原点时，绕坐标轴的正向旋转方向是逆时针方向。\r\n绕 z 轴旋转\r\n\\[\r\n\\begin{bmatrix}\r\n   x&#39; \\\\\r\n   y&#39; \\\\\r\n   z&#39; \\\\\r\n   1 \\\\\r\n  \\end{bmatrix} = \\begin{bmatrix}\r\n  cos \\theta &amp; -sin \\theta &amp; 0 &amp; 0\\\\\r\n  sin \\theta &amp; cos \\theta  &amp; 0 &amp; 0 \\\\\r\n  0 &amp; 0 &amp; 1 &amp; 0 \\\\\r\n  0 &amp; 0 &amp; 0 &amp; 1\r\n  \\end{bmatrix} \\cdot \\begin{bmatrix}\r\n  x \\\\\r\n  y \\\\\r\n  z \\\\\r\n  1\r\n  \\end{bmatrix}\r\n\\]\r\n绕 x 轴旋转\r\n将 x 替换成 y，y 替换成 z，z 替换成 x 即可得到。 \\[\r\n\\begin{bmatrix}\r\n   y&#39; \\\\\r\n   z&#39; \\\\\r\n   x&#39; \\\\\r\n   1 \\\\\r\n  \\end{bmatrix} = \\begin{bmatrix}\r\n  cos \\theta &amp; -sin \\theta &amp; 0 &amp; 0\\\\\r\n  sin \\theta &amp; cos \\theta  &amp; 0 &amp; 0 \\\\\r\n  0 &amp; 0 &amp; 1 &amp; 0 \\\\\r\n  0 &amp; 0 &amp; 0 &amp; 1\r\n  \\end{bmatrix} \\cdot \\begin{bmatrix}\r\n  y \\\\\r\n  z \\\\\r\n  x \\\\\r\n  1\r\n  \\end{bmatrix}\r\n\\]\r\n标准形式： \\[\r\n\\begin{bmatrix}\r\n   x&#39; \\\\\r\n   y&#39; \\\\\r\n   z&#39; \\\\\r\n   1 \\\\\r\n\\end{bmatrix} =  \r\n\\begin{bmatrix}\r\n  1 &amp; 0 &amp; 0 &amp; 0\\\\\r\n  0 &amp; cos \\theta  &amp; -sin \\theta &amp; 0 \\\\\r\n  0 &amp; sin \\theta  &amp; cos \\theta &amp; 0 \\\\\r\n  0 &amp; 0 &amp; 0 &amp; 1\r\n  \\end{bmatrix} \\cdot  \r\n\\begin{bmatrix}\r\n   x \\\\\r\n   y \\\\\r\n   z \\\\\r\n   1 \\\\\r\n\\end{bmatrix}\r\n\\]\r\n绕 y 轴旋转\r\n在上式中，将 x 替换成 y，y 替换成 z，z 替换成 x 即可得到。 \\[\r\n\\begin{bmatrix}\r\n   z&#39; \\\\\r\n   x&#39; \\\\\r\n   y&#39; \\\\\r\n   1 \\\\\r\n  \\end{bmatrix} = \\begin{bmatrix}\r\n  cos \\theta &amp; -sin \\theta &amp; 0 &amp; 0\\\\\r\n  sin \\theta &amp; cos \\theta  &amp; 0 &amp; 0 \\\\\r\n  0 &amp; 0 &amp; 1 &amp; 0 \\\\\r\n  0 &amp; 0 &amp; 0 &amp; 1\r\n  \\end{bmatrix} \\cdot \\begin{bmatrix}\r\n  z \\\\\r\n  x \\\\\r\n  y \\\\\r\n  1\r\n  \\end{bmatrix}\r\n\\]\r\n标准矩阵为： \\[\r\n\\begin{bmatrix}\r\n   x \\\\\r\n   y \\\\\r\n   z \\\\\r\n   1 \\\\\r\n  \\end{bmatrix} = \\begin{bmatrix}\r\n  cos \\theta &amp; 0 &amp; sin \\theta &amp; 0\\\\\r\n  0 &amp; 1 &amp; 0 &amp; 0 \\\\\r\n  -sin \\theta &amp; 0 &amp; cos \\theta &amp; 0 \\\\\r\n  0 &amp; 0 &amp; 0 &amp; 1\r\n  \\end{bmatrix} \\cdot \\begin{bmatrix}\r\n  x \\\\\r\n  y \\\\\r\n  z \\\\\r\n  1\r\n  \\end{bmatrix}\r\n\\]\r\n绕任意轴旋转\r\n\r\n平移对象，使得旋转轴通过坐标原点\r\n旋转对象使得旋转轴与某一坐标轴重合\r\n绕该坐标轴完成指定的旋转\r\n利用逆旋转使旋转轴回到其原始方向\r\n利用逆平移使旋转轴回到其原始位置\r\n\r\n\r\n三维缩放\r\n缩放矩阵： \\[\r\n\\begin{bmatrix}\r\nS_x &amp; 0 &amp; 0 &amp; 0 \\\\\r\n0   &amp; S_y &amp; 0 &amp; 0 \\\\\r\n0 &amp; 0 &amp; S_z &amp; 0 \\\\\r\n0 &amp; 0 &amp; 0 &amp; 1\r\n\\end{bmatrix}\r\n\\] 相对于任意点 \\((x_s,y_s,z_s)\\) 的缩放步骤：\r\n\r\n平移给定点到原点\r\n使用上述矩阵相对于坐标原点进行缩放\r\n平移给定点回到原始位置\r\n\r\n三维反射（镜像）\r\n\\[\r\n\\begin{bmatrix}\r\nR_x &amp; 0 &amp; 0 &amp; 0 \\\\\r\n0   &amp; R_y &amp; 0 &amp; 0 \\\\\r\n0 &amp; 0 &amp; R_z &amp; 0 \\\\\r\n0 &amp; 0 &amp; 0 &amp; 1\r\n\\end{bmatrix}\r\n\\]\r\n反射矩阵是缩放矩阵的特例，即缩放因子小于0时，就变成了反射。\r\n投影到平面\r\n当某一个轴的缩放因子为0时，代表向另外两个轴形成的平面进行投影。比如下列矩阵代表向\r\n\\(z=t_z\\) 平面投影。 \\[\r\n\\begin{bmatrix}\r\nR_x &amp; 0 &amp; 0 &amp; 0 \\\\\r\n0   &amp; R_y &amp; 0 &amp; 0 \\\\\r\n0 &amp; 0 &amp; 0 &amp; t_z \\\\\r\n0 &amp; 0 &amp; 0 &amp; 1\r\n\\end{bmatrix}\r\n\\]\r\n对于绕任意平面的投影，可以将投影平面旋转到标准平面，然后再进行标准投影变换。\r\n三维错切\r\n三维错切与二维错切类似，不过前者较后者在每个方向上多一个影响变量。比如，影响\r\nx 方向的错切有 y 和 z 两个方向。\r\n三维观察\r\n二维观察显示流程\r\n\r\n使用建模坐标 (MC) 变换构造世界坐标 (WC) 系场景\r\n将世界坐标转换为观察坐标 (VC)\r\n将观察坐标 (VC) 转换为规范化设备坐标 (NC)\r\n将规范化设备坐标 (NC) 映射到设备坐标 (DC)\r\n\r\n三维观察显示流程\r\n三维场景视图的计算机生成步骤有点类似于拍一张照片的过程。\r\n\r\n安放相机，即在场景中确定一个观察位置\r\n确定相机方向，即照相机朝哪个方向照及如果绕视线旋转照相机以确定相片的向上方向\r\n按照相机的 “裁剪窗口”（镜头）\r\n来修剪场景，让光线从可视表面投影到照相机的胶片上\r\n\r\n三维观察实际流程：\r\n\r\n建模变换\r\n观察变换\r\n投影变换\r\n规范化变换和裁剪\r\n视口变换\r\n\r\n局部坐标\r\n局部坐标系中的坐标称之为局部坐标，在使用中，我们经常需要获取局部坐标，那么如何获取呢？\r\n这里再引用一下《飞出个未来》里的一句话：\r\n\r\n引擎推动的不是飞船而是宇宙。飞船压根就没动过。\r\n\r\n仔细想想，计算机中摄像机的原理也是相通的。如果想换个角度观察一座山，您可以移动摄像机也可以……移动山。后者在实际中不可行，但在计算机图形学中却十分方便。\r\n所以，在计算机图形变换过程中，我们操作的永远是图形。\r\n可以这样理解：局部坐标是将图形的局部坐标系通过平移、旋转、缩放等矩阵变换后，使得图形的局部坐标系与世界坐标系重合，这个时候，获得的世界坐标其它就是局部坐标。\r\n此时，你可能会有疑问：在实际的三维软件里，定义了 ACS\r\n后，图形相对于世界坐标系的位置一直没变，为什么会说变换的是图形呢？\r\n这个就涉及到图形的变换与显示了，图形坐标系的变换公式为： \\[\r\nP&#39; =M_{local}^{-1} \\cdot M_{world} \\cdot P\r\n\\] \\(P&#39;\\)\r\n表示局部坐标，\\(P\\)\r\n表示世界坐标，从上面的公式里可以看到，坐标的变化都是通过矩阵变换得到的，原坐标\r\n\\(P\\) 一直没变。\r\n局部坐标与世界坐标互转\r\n在空间中，任意点的局部坐标系与世界坐标系的关系如下： \\[\r\nM_{local} \\cdot P&#39; = M_{world} \\cdot P\r\n\\] 通常情况下，世界坐标系 \\(M_{world} =\r\nI\\)，即为单位矩阵。\r\n所以，局部坐标可由正式求得： \\[\r\nP&#39; = M_{local}^{-1} \\cdot P\r\n\\]\r\n在实际的坐标变换中，如果想将世界坐标转换为局部坐标，我们可以：\r\n\r\n构建局部坐标系矩阵 \\(M_{local}\\)\r\n对局部坐标系求逆得 \\(M_{local}^{-1}\\)\r\n用局部坐标系的逆矩阵左乘世界坐标系的矩阵\r\n\r\n\r\n从上面可以看出，要将对象从坐标系 A 转换到坐标系 B，只需要在 A\r\n的度量矩阵上左乘坐标系 B 的度量矩阵的逆变换即可。\r\n\r\n即： \\[\r\nP_B = M_B^{-1} \\cdot M_A \\cdot P_A\r\n\\]\r\n如何构建坐标系的度量矩阵\r\n构建某个坐标系的矩阵其原理是将世界坐标系矩阵（单位矩阵）进行平移旋转。\r\n比如已知局部坐标系的原点为 \\(P(x,y,z)\\) 和三个基向量分别为\\(V_1\\), \\(V_2\\), \\(V_3\\)，其度量矩阵为： \\[\r\nM = \\begin{bmatrix}\r\nV_1.x &amp; V_2.x &amp; V_3.x &amp; P.x \\\\\r\nV_1.y &amp; V_2.y &amp; V_3.y &amp; P.y \\\\\r\nV_1.z &amp; V_2.z &amp; V_3.z &amp; P.z \\\\\r\n0 &amp; 0 &amp; 0 &amp; 1\r\n\\end{bmatrix}\r\n\\]\r\n从上面的公式中，可以推导得到世界坐标系的度量矩阵为： \\[\r\nM = \\begin{bmatrix}\r\n1 &amp; 0 &amp; 0 &amp; 0 \\\\\r\n0 &amp; 1 &amp; 0 &amp; 0 \\\\\r\n0 &amp; 0 &amp; 1 &amp; 0 \\\\\r\n0 &amp; 0 &amp; 0 &amp; 1\r\n\\end{bmatrix}\r\n\\]\r\n扩充阅读\r\n\r\n矩阵\r\n矩阵的乘积/复合变换\r\n\r\n","categories":["Bentley","Develop","几何变换"],"tags":["Bentley二次开发"]},{"title":"Bentley中的坐标系理解","url":"/posts/2021/2HTB36N.html","content":"本节主要阐述 Bentley 平台的坐标系系统。\r\n\r\n模型变换概念\r\n在进行模型变换过程中，有时候对模型与坐标系理解不通透，会导致变换过程变得很艰辛，因此将其关键概念总结如下：\r\n\r\n所有的模型都是存储在全局世界坐标系下的\r\n我们在视图中观察到的模型，是程序将原模型左乘一个视图旋转矩阵，然后左乘一个投影矩阵投影到屏幕上产生的\r\n当将一个模型变换到局部坐标系后，再\r\nAddToModel，最后在世界坐标系中显示出来的模型就是局部坐标系的样子。\r\n引擎推动的不是飞船而是宇宙。飞船压根就没动过。\r\n引擎代表坐标系，图形中，坐标系只有一个世界坐标系，其它的局部坐标系是为了方便理解而产生出来的。坐标系的变换就是对模型的变换。\r\n所以在理解第 3\r\n条时，不能理解成将局部坐标系与世界坐标系对齐，而应理解成将世界坐标系与局部坐标系对齐（换言之，就是对模型进行仿射变换）\r\n变换完成后，在视图中显示的就是局部坐标系下的状态了\r\n\r\n世界坐标系\r\n模型中，所有点的坐标都是依赖于世界坐标系的。\r\n视图坐标系\r\n视图坐标系遵循右手定则，其中 Z 轴朝向屏幕外，X 轴水平向右，Y\r\n轴竖直向上。\r\n因此，要获取垂直于屏幕的向量（在世界坐标系下的表达），可以通过如下步骤获取：\r\n\r\n获取视图的旋转矩阵 \\(R\\)\r\n对旋转矩阵求逆 \\(R^{-1}\\)\r\n然后将点 \\(V_{local}\\)（0,0,1）应用\r\n\\(R^{-1}\\) 变换\r\n\r\n\r\n因为 \\(V_{local} = R \\cdot\r\nV_{world}\\)\r\n所以 \\(R^{-1} \\cdot V_{local} =\r\nV_{wold}\\)\r\n\r\n任意坐标系\r\n任意坐标系的度量矩阵是通过对单位矩阵的旋转平移后得到的。可以通过\r\nDTranform3d 中的一些静态方法生成。\r\n如果想将任意坐标系下的元素变换到世界坐标系中，需要左乘度量矩阵的逆。\r\n","categories":["Bentley","Develop","几何变换"],"tags":["Bentley二次开发"]},{"title":"DgnButtonEvent 中 RawPoint,Point,ViewPoint 的区别","url":"/posts/2022/192YQY2.html","content":"DgnButtonEvent 有三个成员，分别是\r\nRawPoint、Point和ViewPoin，它们的区别如下：\r\n\r\n正文\r\n\r\nRawPoint（原始点，未经加工过的点），即用户点的点坐标\r\nPoint，经过 Snap 等手段修正后捕捉到元素上的点坐标\r\nViewPoint，点在视图坐标系（视图窗口）中的坐标。\r\n\r\n其中，RawPoint 和 Point\r\n都是在设计坐标系中的点坐标。\r\nViewPoint 一般在视图窗口中定位。\r\n在平常的使用中，通常使用 Point。\r\n参考\r\nDgnButtonEvent的成员含义\r\n","categories":["Bentley","Develop","几何变换"],"tags":["Bentley"]},{"title":"Bentley 中几何变换实例","url":"/posts/2022/38A8BYH.html","content":"本文总结了一些常用的几何变换实例，以便后续开发。\r\n\r\nDVector3d 变换\r\n使用 DTranform*DVector3d 即可进行变换。\r\nDVector3d screenZ = new DVector3d(0, 0, 1);// 将屏幕 z 转到世界坐标系中// cursorLocation 是自定义的类，此处传入当前视图的旋转矩阵即可DTransform3d trans = new DTransform3d(cursorLocation.ViewRotation);trans.TryInvert(out DTransform3d invertTrans);var screenZInWorld = invertTrans * screenZ;\r\n","categories":["Bentley","Develop","几何变换"],"tags":["Bentley","几何变换"]},{"title":"几何继承关系层次图","url":"/posts/2022/1C9ATGS.html","content":"\n\n  \n\n\r\n\r\n参考\r\n几何继承关系层次图\r\n查看。\r\n","categories":["Bentley","Develop","几何变换"],"tags":["NexT","Bentley"]},{"title":"求解矩阵的逆","url":"/posts/2022/3MW6BH0.html","content":"在进行 MS\r\n二次开发时，往往需要将图形转到一个平面去处理，处理完成后，需要再转回到原位置，这个时候就会需要求转换矩阵的逆，虽然\r\nMS 中的 SDK 有提供求逆方法，但是深入原理会用得更加得心应手。\r\n\r\n定义\r\n逆矩阵（inverse matrix），又称乘法反方阵、反矩阵。\r\n在线性代数中，给定一个 n 阶方阵 \\(A\\)，若存在一 n 阶方阵 \\(B\\)，使得 \\(AB=BA=I_{n}\\)，其中 \\(I_n\\) 为 n 阶单位矩阵，则称 \\(A\\) 是可逆的，且 \\(B\\) 是 \\(A\\) 的逆矩阵，记作 \\(A^{-1}\\)。\r\n只有方阵（n×n 的矩阵）才可能有逆矩阵。若方阵 \\(A\\) 的逆矩阵存在，则称 \\(A\\) 为非奇异方阵或可逆方阵。\r\n与行列式类似，逆矩阵一般用于求解联立方程组。\r\n求法\r\n伴随矩阵法\r\n初等变换法\r\n广义逆矩阵\r\n广义逆阵（Generalized\r\ninverse）又称伪逆，是对逆阵的推广。一般所说的伪逆是指摩尔－彭若斯广义逆，它是由E.\r\nH. Moore和Roger Penrose分别独立提出的。伪逆在求解线性最小二乘问题中有重要应用。\r\n参考\r\n逆矩阵-wiki\r\n","categories":["Bentley","Develop","几何变换"],"tags":["Bentley","Bentley二次开发"]},{"title":"向量点乘与叉乘","url":"/posts/2022/3HJTYAD.html","content":"在几何开发中，如何能够了解几何相关的知识，可以帮助我们快速解决问题，减少对现有\r\nSDK 的依赖。本文总结了向量点乘和叉乘的区别及一些应用场景。\r\n\r\n点乘（Dot Product）\r\n定义\r\n\r\n\r\nDot_Product\r\n\r\n从代数上讲，点积是两个数列中对应项的乘积的和。\r\n假设有两个向量 \\(\\vec{a}=[a_1,a_2,...,a_n]\\)、\\(\\vec{b}=[b_1,b2,...,b_n]\\)，则有 \\[\r\n\\vec{a} \\cdot \\vec{b} = \\sum_{i=1}^n{a_ib_i}=a_1b_1+a_2b_2+...+a_nb_n\r\n\\]\r\n从几何上讲，它是两个向量在欧几里空间里的长度值和它们夹角的余弦值的乘积。\r\n\\[\r\n\\vec a \\cdot \\vec b = |\\vec a|\\cdot |\\vec b| cos \\theta\r\n\\]\r\n\r\n点乘又叫内积、数量积、投影积\r\n\r\n特点\r\n\r\n交换律\r\n\\(\\vec a \\cdot \\vec b = \\vec b \\cdot \\vec\r\na\\)\r\n分布律\r\n\\(\\vec a \\cdot (\\vec b + \\vec c) = \\vec a\r\n\\cdot \\vec b + \\vec a \\cdot \\vec c\\)\r\n双线性\r\n\\(\\vec a \\cdot (\\gamma \\vec b + \\vec c) =\r\n\\gamma(\\vec a \\cdot \\vec b) +(\\vec a \\cdot \\vec c)\\)\r\n标量相乘\r\n\\((c_1\\vec a)\\cdot (c_2\\vec b)=c_1c_2(\\vec\r\na \\cdot \\vec b)\\)\r\n不满足结合律\r\n\\(\\vec a \\cdot (\\vec b \\vec c) \\neq (\\vec a\r\n\\vec b)\\cdot \\vec c \\iff \\vec a \\cdot \\gamma \\neq \\beta \\cdot \\vec\r\nc\\)\r\n由于向量 \\(\\vec a \\neq \\vec\r\nc\\)，从上式中可以看出，向量内积不满足结合律。\r\n正交性\r\n当两个非零向量垂直时，它们的内积为 0。\r\n不满足消除律\r\n在代数中，当 \\(a\\cdot b = a \\cdot\r\nc\\) 时，一定有 \\(b=c\\)，但是在向量中不满足这个规律。\r\n当 \\(\\vec a \\cdot \\vec b = \\vec a \\cdot\r\n\\vec c\\) 且 \\(\\vec a \\neq \\vec\r\n0\\) 时，通过分布律有 \\(\\vec a \\cdot\r\n(\\vec b- \\vec c) = 0\\)，只需要满足 \\(\\vec a\\) 垂直于 \\(\\vec b - \\vec c\\) 即可，而不一定非要求\r\n\\(\\vec b - \\vec c = \\vec 0\\)\r\n乘积律\r\n当向量 \\(\\vec a\\) 和 \\(\\vec b\\) 可微，则有 \\((\\vec a \\cdot \\vec b)^{&#39;}=\\vec a ^{&#39;}\r\n\\cdot \\vec b + \\vec a \\cdot \\vec b ^{&#39;}\\)\r\n\r\n实际应用\r\n\r\n判断两个向量是否垂直\r\n内积为 0\r\n判断两个向量同向还是反向\r\n同向内积为下，返回为负\r\n用于求两个向量的夹角\r\n\\(cos \\theta = \\frac{\\vec a \\cdot \\vec\r\nb}{|\\vec a|\\cdot |\\vec b|}\\)\r\n\r\n叉乘（Cross Product）\r\n定义\r\n\r\n假设有两个向量 \\(\\vec a\\) 和 \\(\\vec b\\)，它们的叉乘表达如下： \\[\r\n\\vec a \\times \\vec b = |\\vec a| \\cdot |\\vec b| \\cdot sin \\theta \\cdot\r\n\\vec n\r\n\\]\r\n\r\n\\(\\theta\\)\r\n是两个向量的夹角\r\n\\(\\vec n\\) 是同时包含向量 \\(\\vec a\\) 和 \\(\\vec b\\) 的平面的单位法向量\r\n当两个向量平行时，其值为 \\(\\vec\r\n0\\)\r\n向量的叉乘满足右手定律\r\n\r\n\r\n\r\n叉乘又叫外积\r\n\r\n几何意义\r\n两个向量叉乘的模代表分别以两个向量为边的四边形的面积。 \\[\r\nS= |\\vec a \\times \\vec b | = |\\vec a|\\cdot |\\vec b| \\cdot sin \\theta\r\n\\] \r\n混合积\r\n向量的混合积代表以这三个向量为边的六面体的体积。 \\[\r\n\\begin{align}\r\n\\vec a \\cdot (\\vec b \\times \\vec c) = b \\cdot (\\vec c \\times \\vec a) = c\r\n\\cdot (\\vec a \\times \\vec b)\r\n\\\\\r\nV= |\\vec a \\cdot (\\vec b \\times \\vec c)|\r\n\\end{align}\r\n\\] \r\n参考\r\n\r\nDot\r\nproduct-wiku\r\nCross\r\nproduct\r\n点乘和叉乘的区别是什么\r\n\r\n","categories":["Bentley","Develop","几何变换"],"tags":["Bentley","Bentley二次开发"]},{"title":"Microstation 中坐标变换","url":"/posts/2024/1EMPAND.html","content":"在进行矩阵转换时，谨记如下公式： \\[\r\n\\begin{aligned}\r\nM_{world} \\cdot P_{world} &amp;= M_{local} \\cdot P_{local} \\\\\r\n\\because M_{world} &amp;= E \\\\\r\n\\therefore P_{world} &amp;= M_{local} \\cdot P_{local} \\\\\r\n\\end{aligned}\r\n\\] \\(M\\)\r\n可以叫做坐标系的度量矩阵，将某个坐标系统转到另一个坐标系，是在原坐标系的值上左乘新坐标系度量矩阵的逆。\r\n在理解 MS 中各个对象返回的 DTransform\r\n含义时，先弄明白谁是度量矩阵，另一个是它的逆，就很好理解了。\r\n\r\n度量矩阵\r\n度量矩阵_百度百科\r\n(baidu.com) 是指欧氏空间的一组基之间的内积作为元素构成的矩阵。\r\n在三维空间中，假设 3 组基向量分别为 \\(\\vec{X}=(xx,xy,xz)\\)、\\(\\vec{Y}=(yx,yy,yz)\\)、\\(\\vec{Z} = (zx,zy,zz)\\)；原点为 \\(O=(wx,wy,wz)\\)；\r\n则度量矩阵表示为： \\[\r\nM = \\begin{bmatrix}\r\nxx &amp; yx &amp; zx &amp; wx \\\\\r\nxy &amp; yy &amp; zy &amp; wy \\\\\r\nxz &amp; yz &amp; zz &amp; wz \\\\\r\n0 &amp; 0 &amp; 0 &amp; 1\r\n\\end{bmatrix}\r\n\\] \\(M\\)\r\n为非奇异矩阵，添加最后一行是为了构成方阵，使得矩阵的秩为满秩。方便程序进行计算。\r\n矩阵生成\r\n在 Microstation 中，主要有两种方式表示矩阵，分别为\r\nDMatrix 系列和 DTransform\r\n系列。DMatrix 系列有\r\nDMatrix2d/DMatrix3d/DMtrix4d，它是 Microstation\r\n提供的最基础的矩阵操作结构体，其提供的功能有限，在实际的开发中一般使用\r\nDTransform 系列。\r\nDTransform 系列有\r\nDTransform2d/DTransform3d。 三维开发中使用\r\nDTransform3d。\r\n下面将介绍经常使用的矩阵创建方式。\r\n直接构造法\r\n通过\r\npublic DTransform3d(double axx, double axy, double axz, double axw, double ayx, double ayy, double ayz, double ayw, double azx, double azy, double azz, double azw)\r\n这个构造函数直接生成 DTransform3d\r\n例：\r\n/// &lt;summary&gt;/// 向 xy 平面投影/// 默认 z=0/// &lt;/summary&gt;/// &lt;param name=&quot;xPlane&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static DTransform3d ProjectToXY(double zValue = 0)&#123;    return new DTransform3d(        1, 0, 0, 0,        0, 1, 0, 0,        0, 0, 0, zValue);&#125;\r\n构造函数与上述度量矩阵参数的对应关系为：\\((axx,axy,axz) = (xx,xy,xz)\\)、\\((ayx,ayy,ayz)=(yx,yy,yz)\\)、\\((azx,azy,azz)=(zx,zy,zz)\\)、\\((axw,ayw,azw)=(wx,wy,wz)\\)\r\n通过 DTransform3d 生成\r\nDTransform3d 提供了一些静态方法来快速创建实例\r\n比如下面这个方法：\r\n// origin 代表的是平移值public static DTransform3d FromOriginAndColumns(DPoint3d origin, DVector3d xVector, DVector3d yVector, DVector3d zVector)\r\n上述静态方法通过局部坐标系（原点和三个方向）来生成一个矩阵，这个矩阵是该坐标系度量矩阵的逆，所以如果想要将模型变换到该坐标系下，直接左乘该矩阵即可。\r\n通过 DPlane3d 生成\r\n通过 DPlane3d 提供的\r\npublic DPlane3d(DPoint3d origin, DVector3d normal)\r\n构造函数生成。\r\nvar plane = new DPlane3d(origin,normal);plane.GetTransforms(out DTransform3d planeToWorld, out DTransform3d worldToPlane)\r\n基中，planeToWorld 是 plane 坐标系的度量矩阵，worldToPlane 是\r\nplaneToWorld 的逆。\r\n\r\n这种方式无法很好地控制 \\(\\vec {X}\\)\r\n和 \\(\\vec {Y}\\) 基向量的方向\r\n\r\n常用转换示例\r\n局部坐标转到世界坐标\r\n\\[\r\n\\begin{aligned}\r\nP_{world} = M_{local}*P_{local}\r\n\\end{aligned}\r\n\\]\r\n\r\n\\(P_{world}\\)\r\n为世界坐标系中的坐标\r\n\\(M_{local}\\)\r\n为局部坐标系的度量矩阵\r\n\\(P_{local}\\)\r\n为局部坐标系中的坐标\r\n\r\n\r\n相当于将局部坐标转换成世界坐标\r\n\r\n世界坐标系到局部坐标\r\n\\[\r\n\\begin{aligned}\r\nP_{local} = M_{local}^{-1}*P_{world}\r\n\\end{aligned}\r\n\\]\r\n\r\n\\(M_{local}^{-1}\\)\r\n为局部坐标系的度量矩阵的逆\r\n\r\n\r\n相当于将世界坐标转换成局部坐标\r\n局部坐标可以看成是原点位于 (0,0,0) 的世界坐标\r\n\r\n世界坐标由坐标系 A\r\n变换到坐标系 B\r\n若已知坐标系 A 和 B 的度量矩阵，求由 A 变化到 B 的变换矩阵？ \\[\r\n\\begin{aligned}\r\n假设: M_{A-&gt;B} \\cdot M_{A} &amp;= M_{B} \\\\\r\n则: M_{A-&gt;B} &amp;= M_{B} \\cdot M_{A}^{-1}\r\n\\end{aligned}\r\n\\]\r\n\r\n\\(M_{A-&gt;B}\\) 从坐标系 A 变换 B\r\n的变换矩阵\r\n\r\n所以最终公式为： \\[\r\n\\begin{aligned}\r\nP&#39;= M_{B} \\cdot M_{A}^{-1} \\cdot P\r\n\\end{aligned}\r\n\\]\r\n测试用例\r\n待补充......\r\n","categories":["Bentley","Develop","几何变换"],"tags":["Bentley","二次开发"]},{"title":"LiteDB中id的理解与使用","url":"/posts/2021/2NDY00Q.html","content":"在使用 LiteDB 中，它 Id\r\n规则有些复杂，为了更好地理解，将其总结如下，不足之处，欢迎斧正。\r\n\r\nLiteDB 的集合（collection）在存储文档（document）时，文档必需有\r\n_id\r\n字段，因为数据库使用这个字段作为主键，在进行文档更新的时候，也是通过\r\n_id 去匹配更新对象。\r\n在使用中，我们要如何定义 _id 呢？\r\n使用默认 _id\r\n如果在定义类的时候，没有 ID 字段，程序就会自动添加一个\r\n_id，这个 _id 的类型是\r\nObjectId。\r\n此处要注意： ObjectId 在进行 json\r\n序列化时，并不会序列化成字符串，而是序列化为一个 ObjectId\r\n对象，如果将其传到前端，前端对这个 _id\r\n就会非常不方便使用，所以我们一般会指定 _id 字段。\r\n使用 BsonId 定义\r\n我们可以在类中的任意字段添加 BsonId 特性来指定其为\r\n_id，如下例：\r\npublic class User&#123;    [BsonId]    public string userId &#123; get; set; &#125;    public string password &#123; get; set; &#125;    public DateTime createDate &#123; get; set; &#125;    public string avatar &#123; get; set; &#125;&#125;\r\n\r\nC# 读者请不要在意属性的命名规范问题，本人采用的是 js\r\n的命名风格，方便与 js 前端交互。\r\n\r\n上面的定义中，我们在 userId 属性上添加\r\nBsonId 特性，标记该字段作为 User 对象的\r\n_id。数据存储的时候，它会将 userId 保存为\r\n_id 而不是 userId，这一点要特别注意。\r\n截取了实际中的一个对象，其保存的形式如下：\r\n&#123;  &quot;_id&quot;: &quot;admin&quot;,  &quot;password&quot;: &quot;123456&quot;,  &quot;createDate&quot;: &#123;&quot;$date&quot;: &quot;2021-08-21T13:04:36.6340000Z&quot;&#125;&#125;\r\n所以，在使用 BsonExpression 的时候，去匹配\r\nuserId 需要写成\r\n_id。为了使代码更易理解，建议在类中定义 Id\r\n时，若没有明确的 Id 时，直接命名为 _id。\r\n定义递增的 int32 Id\r\n鉴于 ObjecId 对 json\r\n序列化不友好的支持，所以我们希望有一种\r\n_id，它既可以自动添加，又可以 json\r\n序列化成一个字段，而不是像 ObjectId 那样。\r\n这样的 _id 是存在的，就用用 BsonId\r\n对指定一个 int 型的字段，并在任何时候，保证该字段的值为\r\n0。如下所示：\r\npublic class User&#123;    [BsonId]    public int _id &#123; get; set; &#125;    public string userId &#123; get; set; &#125;    public string password &#123; get; set; &#125;    public DateTime createDate &#123; get; set; &#125;    public string avatar &#123; get; set; &#125;&#125;\r\n此处要注意：\r\n\r\n_id 的值必须是 0\r\n在实例 User 时，不要对它赋值\r\n\r\n这样定义的 _id 就会随着每次 insert\r\n操作而自动增加。即使中间删除了某些数据，它也不会去补充删除的数据，而是在上一条数据的基础上自动增加。\r\n但是，用 int 类型作为 _id\r\n也有一个弊端，因为 int32 的最大值为\r\n65535，集合中的文档总数会有限制。\r\n所以，一般使用下列方式定义：\r\npublic class User&#123;    public User()    &#123;    \t_id = ObjectId.NewObjectId().ToString();        &#125;        [BsonId]    public string _id &#123; get; set; &#125;    public string userId &#123; get; set; &#125;    public string password &#123; get; set; &#125;    public DateTime createDate &#123; get; set; &#125;    public string avatar &#123; get; set; &#125;&#125;\r\n","categories":["Develop","Database","LiteDB"],"tags":["C#","LiteDB"]},{"title":"MySql 匹配集合中的数据","url":"/posts/2019/1BADZMH.html","content":"在进行表查询的时候，有时需要在列表（集合）中进行匹配查询，这个时候一般可以用三种方法实现，分别是：\r\nLIKE, IN，FIND_IN_SET()。\r\n\r\nLIKE 用法\r\nLIKE 运算符用于 WHERE\r\n表达式中，以搜索匹配字段中的指定内容，语法如下：\r\n\r\nWHERE field LIKE pattern\r\nWHERE field NOT LIKE pattern\r\n\r\n在LIKE全面加上 NOT 运算符时，表示与 LIKE 相反的意思，即选择 column\r\n不包含 pattern 的数据记录\r\nLIKE 通常与通配符%一起使用，% 表示通配 pattern\r\n中出现的内容，而不加通配符 % 的 LIKE\r\n语法，表示精确匹配，其实际效果等同于 = 等于运算符\r\nCREATE TABLE `test` (    `id` int(8) NOT NULL auto_increment,    `name` varchar(255) NOT NULL,    `list` varchar(255) NOT NULL,    PRIMARY KEY  (`id`))INSERT INTO `test` VALUES (1, &#x27;names1&#x27;, &#x27;daodao,xiaohu,xiaoqin&#x27;);  INSERT INTO `test` VALUES (2, &#x27;names2&#x27;, &#x27;xiaohu,daodao,xiaoqin&#x27;);  INSERT INTO `test` VALUES (3, &#x27;names3&#x27;, &#x27;xiaoqin,daodao,xiaohu&#x27;); -- LIKE 用法SELECT * FROM test WHERE list LIKE &#x27;%daodao%&#x27;\r\nIN 用法\r\nIN 常用于 WHERE\r\n表达式中，其作用是查询某个常量范围内的数据。用法如下：\r\n\r\nWHERE field IN (value1,value2,value3,…)\r\nWHERE field NOT IN (value1,value2,value3,…)\r\n\r\nIN 后面的括号内为常量集合，且各个关键词之间用英文的逗号隔开。\r\nFIND_IN_SET() 用法\r\nFIND_IN_SET 常用于 WHERE\r\n表达式中，其作用是查询某个范围（常量或者字段）内的数据。用法如下：\r\n\r\nWHERE FIND_IN_SET(str,strlist)\r\nWHERE NOT FIND_IN_SET(str,strlist)\r\n\r\nstr 既可以是字段，也可以是常量\r\nstrlist\r\n既可以是常量集合，也可以是字段，每个关键字之间用英文逗号隔开\r\n-- 在字段集合中查找SELECT * FROM test WHERE FIND_IN_SET(&#x27;daodao&#x27;,list)-- 在常量集合中查找SELECT * FROM test WHERE FIND_IN_SET(&#x27;daodao&#x27;,&#x27;daodao,xiaohu,qiaoqin&#x27;)-- 查找值是字段SELECT * FROM test WHERE FIND_IN_SET(name,&#x27;names1,mameother&#x27;)\r\n最佳实践\r\n\r\n如果待查询的条件是常量那就使用 IN，是变量则使用 FIND_IN_SET。IN\r\n可以使用索引。\r\n如果使用 IN 和 FIND_IN_SET 都能满足条件，则最好使用\r\nIN，理由同上，特别是查询字段为主键时或有索引时。\r\n\r\n","categories":["Develop","Database","MySql"],"tags":["MySql"]},{"title":"由浅入深地理解样条曲线","url":"/posts/2022/1CPW2GG.html","content":"本文简要介绍计算机图图形学中的常用的各个样条曲线，同时梳理他们的之间的关系。\r\n\r\n前言\r\n在阅读本文之前，请先静下心来，一步一步理解公式，不要因公式复杂而望而却步。如果慢慢理解，它其实也挺简单。\r\n对于下列形式的公式说明： \\[\r\n\\begin{equation}\r\nP(t) = \\sum_{i=0}^{n}P_iB_{i}(t)\r\n\\end{equation}\r\n\\] 上述公式表示 \\(P_t\\)\r\n是通过将多个点乘以一个函数 \\(B_i(t)\\)相加求得，这个公式的可以理解成曲线上的每个点\r\n\\(P_t\\) 是 n 维线性空间中的点，\\(B_i(t)\\) 是线性空间中的基函数。\r\nn 维线性空间不是指笛卡尔坐标系下的 n\r\n维，而是线性代数上的维度，如果对这个概念不是很清楚，可以查阅相关书籍，当然，上述的这个理解方式也可以忽略。\r\n贝塞尔曲线（Bézier curve）\r\n\r\n定义\r\n\\[\r\n\\begin{split}\r\nP(t) &amp;= \\sum_{i=0}^{n}P_i \\cdot B_{i,n}(t),t \\in [0,1] \\\\\r\nB_{i,n}(t) &amp;=\r\nC_n^it^i(1-t)^{n-i}=\\frac{n!}{i!(n-i)!}t^i(1-t)^{n-i},i\r\n\\in[0,1,\\cdot\\cdot\\cdot,n]\r\n\\end{split}\r\n\\] ### 理解\r\n参数说明\r\n\r\n\\(t\\)\r\n参数 \\(t\\) 是隐函数 \\(P(t)\\) 的参数，它的值域是\r\n[0,1]，在计算机中，通过将 \\(t\\) 从 0\r\n递增到 1，来生成贝塞尔曲线上的点，因此 \\(t\\) 的步长越短，其生成的曲线越光滑\r\n\\(P_i\\)\r\n\\(P_i\\) 是由用户给定的控制点，下标\r\n\\(i\\) 代表点的顺序\r\n\\(C_n^i\\)\r\n\\(C_n^i\\) 称为二项式系数。\r\n二项式展开定义如下： \\[\r\n\\begin{split}\r\n(a+b)^n = \\sum_i^n C_n^i a^{n-i} b^i\r\n\\end{split} = \\sum_i^n \\frac{n!}{i!(n-i)!}\\cdot a^{n-i} \\cdot b^i\r\n\\]\r\n\\(B_{i,n}(t)\\)\r\n这个叫做贝塞尔曲线的基函数，它的计算公式见上面的公式。\\(\\sum_i^n B_{i,n}(t)\\) 是二项式 \\((t+(1-t))^n\\) 的展开公式。\r\n\\(i\\) 代表点的序号，从 0 开始；\\(n\\) 叫次数（degree）。\r\n如果点的数量为 p，则 \\(n\\) 与 \\(p\\) 的关系为 \\(n=p-1\\)。\r\n\r\n其它说明\r\n\r\n一条贝塞尔曲线是由多个控制点共同决定的，n（次数）决定了生成一条曲线需要使用多少个控制点。\r\n复杂形状通常要将多条贝塞尔曲线拼接在一起表达。\r\n\r\n线性贝塞尔曲线\r\n线性曲线的次数为1，其所需要的控制点为 2 个，假设为 \\(P_0,P_1\\) \\[\r\n\\begin{split}\r\nP(t) &amp;= \\sum_{i=0}^{n}P_iB_{i,n}(t)=P_0 B_{0,1}(t)+P_1 B_{1,1}(t) \\\\\r\n\\therefore P_t &amp;= P_0 \\cdot \\frac{1!}{0!(1-0)!}t^0(1-t)^{1-0}+\r\nP_1 \\cdot \\frac{1!}{1!(1-1)!}t^1(1-t)^{1-1} \\\\\r\n&amp; 又 \\because 0! = 1 \\\\\r\n\\therefore P_t &amp;= P_0 \\cdot (1-t)+P1\\cdot t = P_0+t\\cdot(P_1-P_0)\r\n\\end{split}\r\n\\]\r\n异形曲线\r\n为了能够表达复杂的异形曲线，我们将多条贝塞尔曲线连接在一起，在连接处保证其几何连续，这样就形成了一条复杂的贝塞尔曲线了。\r\n性质\r\n\r\n各项系数之和为1 这个很好理解,因为系数 \\(\\sum_i^n B_{i,n}(t)\\) 是二项式 \\((t+(1-t))^n\\) 的展开，所以其值始终为\r\n1\r\n对称性 第 \\(i\\) 项系数和倒数第\r\n\\(i\\) 项系数（即 \\(n-i\\) 项）相同\r\n递归性 递归性指其系数满足下式： \\[\r\nB{i,n}(t) = (1-t)B_{i,n-1}(t)+tB_{i-1,n-1}(t),i \\in\r\n[0,1,\\cdot\\cdot\\cdot,n]\r\n\\]\r\n凸包性质\r\n贝塞尔曲线始终会在包含了所有控制点的最小凸多边形中，不是按照控制点的顺序围成的最小多边形。这点大家一定注意。\r\n这一点的是很关键的，也就是说可以通过控制点的凸包来限制规划曲线的范围，在路径规划是很需要的一个性质。\r\n端点性质\r\n第一个控制点和最后一个控制点，恰好是曲线的起始点和终点。这一点可以套用二项式展开来理解，ｔ＝１或者０的时候，相乘二项式的系数，除了初始点或者末尾点，其余的都是０。\r\n一阶导数性质\r\n\r\nB样条曲线（B-Spline）\r\n贝塞尔曲线有很多优点，但也有几个不足之处：\r\n（1）一旦确定了特征多边形的顶点数，就决定了曲线的阶数。当数据点的数量太多时，计算量急剧增加。\r\n（2）由于光滑性很高，反而导致拼接比较复杂。\r\n（3）无法做局部修改，这是一个很大的局限性，牵一发而动全身。\r\n1972年，在贝塞尔提出他的方法十年后，Gordon和Riesenfeld等人又提出了B样条方法，在保留了贝塞尔方法的全部优点的同时，克服了以上三大缺点。\r\nB样条曲线有如下性质：\r\n\r\n可以指定阶次\r\n移动控制点仅仅改变曲线的部分形状，而不是整体\r\n\r\n定义\r\nb 样条曲线有很多种定义方式，相对简单的表达是 de Boor-Cox\r\n递归公式，其定义如下：\r\n$$\r\n\\[\\begin{split}\r\nP(t) &amp;= \\sum_{i=0}^{n}P_i \\cdot N_{i,k}(t),t \\in [t_{k-1},t_{n+1}]\r\n\\\\\r\n\r\nN_{i,1}(t) &amp;= \\left\\{\r\n\\begin{array}{left}\r\n1 \\ ,t_i&lt;t&lt;t_{i+1} \\\\\r\n0 \\ ,Otherwise\r\n\\end{array}\r\n\\right.  ，注意，N_{i,1}(t) 中的 1 代表阶\\\\\r\n\r\nN_{i,k}(t) &amp;=\\frac{t-t_i}{t_{i+k-1}-t_i}\\cdot\r\nN_{i,k-1}(t)+\\frac{t_{i+k}-t}{t_{i+k}-t_{i+1}}\\cdot N_{i+1,k-1}(t) \\\\\r\n\r\n&amp; 同时约定: \\frac{0}{0} = 0\r\n\\end{split}\\]\r\n$$\r\n理解\r\n参数\r\n\r\n\\(P(t)\\)\r\n曲线上的点\r\nt\r\n隐式方程的参数，与贝塞尔曲线的 t 相同\r\n\\(P(i)\\)\r\n用户给定的控制点\r\nn\r\n控制点数组中下标的最大值，其值等于控制点的总数减 1\r\ni\r\n每一个控制点的下标\r\nk\r\n代表 b 样条曲线的阶数。\r\n阶数的表达的意义是：\r\n\r\nb 样条必须有 k 个基函数才有意义\r\n每个基函数的定义域跨越了 k 个区间\r\n\r\n特别注意，上面的表达式中用的是阶，而在有的文章里面，是用次来表示的，阶与次都是同一个概念，只是它们的值不一样，阶(order)=次(degree)+1。\r\n为什么会出现阶和次两种表达方式呢？\r\n在图形学中，有两个很著名的教授，一个叫 G Farin，一个叫 Les\r\nPiegl，他们分别是 Computer Aided Geometric Design 和 Computer Aided\r\nDesign 杂志的主编。这两位主编分别写了一本书，G Farin 叫 k 阶 b\r\n样条曲线，Les Piegl 叫 k 次 b 样条曲线。\r\n这两个概念大家都在用，所以就导致了这种不同名称的定义。\r\n\\(N_{i,k}(t)\\)\r\n表示第 \\(i\\) 个 \\(k\\)\r\n阶（order）B样条基函数。它是由节点向量（knot vector）唯一决定的。\r\n特别注意，上面的分段函数是 \\(N_{i,1}(t)\\)\r\n通过 \\(N_{i,k}(t)\\)\r\n的公式，我们可以作如下推导： \\[\r\n\\begin{split}\r\nN_{i,k}(t) &amp;=\\frac{t-t_i}{t_{i+k-1}-t_i}\\cdot\r\nN_{i,k-1}(t)+\\frac{t_{i+k}-t}{t_{i+k}-t_{i+1}}\\cdot N_{i+1,k-1}(t)\r\n\\\\\r\n&amp;= \\frac{t-t_i}{t_{i+(k-1)}-t_i}\\cdot N_{i,k-1}(t) +\r\n\\frac{t_{(i+1)+(k-1)}-t}{t_{(i+1)+(k-1)}-t_{i+1}}\\cdot N_{i+1,k-1}(t)\r\n\\end{split}\r\n\\] 通过上式，可以知 \\(N_{i,k}(t)\\) 其实是 \\(N_{i,k-1}(t)\\) 在区间 \\([t_i,t_{i+k-1}]\\) 上的插值加上 \\(N_{i+1,k-1}(t)\\) 在区间 \\([t_{i+1},t_{i+1+k-1}]\\) 上的插值。\r\n更通俗地讲就是，第 i 个 k 阶基函数是第 i 和 i+1 个 k-1\r\n阶基函数的线性插值。\r\n节点向量\r\n设 T 是 m+ 1 个非递减数的集合，\\(t_0 &lt;=\r\nt_1 &lt;= t_2&lt;= ... &lt;= t_m\\)。\\(t_i\\)称为节点（knots）,\r\n集合 T 称为节点向量（knot vector）, 半开区间 \\([t_i,t_{i+1}]\\) 是第 i\r\n个节点区间（knot span）\r\n节点向量本质就是一组非减的实数序列，一般取 [0,1]。\r\n看到此处，可能会很疑惑，为什么需要定义节点向量，节点向量有什么作用呢？后文将会一一道来。\r\n重复度\r\n在节点向量（节点数组）中，如果某一个节点连续出现 m\r\n次，则称该节点的重复度为 m。\r\n\r\n示例\r\n为了方便理解 b样条曲线，我们先计算一些低阶曲线。\r\n\r\n第 0 个 1 阶基函数 \\(N_{0,1}（i=0,k=1）\\)\r\n当 \\(t_i&lt;t&lt;t_{i+1}\\) 时，即\r\n\\(t_i\\) 在区间 \\([t_0,t1]\\) 上时，有：\r\n\r\n\\[\r\n\\begin{equation}\r\nN_{0,1}(t) = \\left\\{\r\n\\begin{array}{left}\r\n1 \\ ,t_0&lt;t&lt;t_{1} \\\\\r\n0 \\ ,Otherwise\r\n\\end{array}\r\n\\right.\r\n\\end{equation}\r\n\\]\r\n\r\n第 1 个 1 阶基函数 \\(N_{1,1}（i=1,k=1）\\) \\[\r\n\\begin{equation}\r\nN_{1,1}(t) = \\left\\{\r\n\\begin{array}{left}\r\n1 \\ ,t_1&lt;t&lt;t_{2} \\\\\r\n0 \\ ,Otherwise\r\n\\end{array}\r\n\\right.\r\n\\end{equation}\r\n\\]\r\n第 0 个 2 阶基函数 \\(N_{0,2}（i=0,k=2）\\) \\[\r\n\\begin{split}\r\nN_{0,2}(t) = \\frac{t-t_0}{t_1-t_0}\\cdot N_{0,1}(t) +\r\n\\frac{t_2-t}{t_2-t_1}\\cdot N_{0,1}(t)\r\n\\end{split}\r\n\\]\r\n\r\n节点向量的作用\r\n首先抛出一个定义，节点向量是对 \\(t\\)\r\n定义域的一个划分。\r\n因为节点向量是是分段的，基函数在仅在某些段上有值，所以公式 \\(P(t) = \\sum_{i=0}^{n}P_i \\cdot N_{i,k}(t)\\)\r\n中实际参与组合的点并不是全部（实际上只有 k 个，文会详细解释）。\r\n因此，节点区间通过控制基函数是否为 0，来确定计算 b\r\n样条曲线上的点时，采用哪些控制点。\r\n在生成曲线的时候，将 t\r\n从小到大变化，从而得到曲线上的一系列点，它的详细步骤如下：\r\n\r\n根据 t，确定 t 所在的节点区间 \\(T_i\\)\r\n通过迭代公式，求出每个点在该区间（\\(T_i\\)）上的基函数\r\n将每个基函数与对应的控制点相乘取和，得到曲线上实际的点\r\n\r\n节点向量的取值\r\n上文讲到节点向量是一组非减实数序列，从插值公式中可以知道，向量中的每个节点大小不会影响结果，影响结果的是两个节点的步长。\r\n因此，节点向量可以是任意实数序列。\r\n那么步长怎么确定呢？\r\n节点向量的步长取值\r\n上面一节讲到，b\r\n样条上每个点只与节点向量的步长有关，因此，根据设置不同的步长，b\r\n样条就会产生不同的效果。\r\n如果节点向量没有任何特别的结构，那么产生的曲线不会与控制折线（polyline）的第一边（leg）和最后一边（leg）接触，如下面图所示。\r\n\r\n\r\nopen\r\n\r\n这种类型的B-样条曲线称为开（open ）b\r\n样条曲线。\r\n我们可能想强制曲线使得它分别与第一个控制点和最后一个控制点的第一边和最后一边相切，像贝塞尔曲线那样。为了做到这些，第一个节点和最后一个节点必须是重复度为\r\n\\(k(代表阶数)\\)。这就产生了所谓的\r\nclamped b 样条曲线。参见下图。\r\n\r\n\r\nclamped\r\n\r\n通过重复某些节点和控制点，产生的曲线会是闭（closed）曲线。\r\n这种情况，产生的曲线的开始和结尾连接在一起形成了一个闭环如下图所示。\r\n\r\n\r\nclose\r\n\r\n节点的个数确定\r\n从公式定义中，可以得知，第 i 个 k 阶 b 样条曲线的基函数等于第 i 个\r\nk-1 阶基函数和第 i+1 个 k-1\r\n阶基函数的线性插值。它们的关系可以用下图来表示。\r\n\r\n从上图中，我们可以看到，如果要求第 0 个 5 阶 b 样条函数基函数，则需要\r\n5 个 1 阶基函数，需要 6 个节点。由此，可以得到如下结论： \\[\r\n结点数量(KnotsCount) = 控制点数量(PointCount)+阶数k(order)\r\n\\]\r\n有效定义区间\r\n上面在解释 k 这个符号的时候，提到了 k 阶的概念。\r\n一个 k 阶 b 样条，它必须有 k 个基函数才有意义，所以，一个 b\r\n样条曲线的有效定义区间必须包含 k 个 基函数定义。\r\n从公式 \\[\r\n\\begin{split}\r\n   P(t) = \\sum_{i=0}^{n}P_i \\cdot N_{i,k}(t),t \\in [t_{k-1},t_{n+1}]\r\n   \\end{split}\r\n\\]\r\n可以看出，曲线上的点是通过每个点乘以其基函数然后进行相加，从3.6节的计算图中我们可以看到，每个点的基函数的计算仅使用了有限个区间，比如\r\n\\(N_{0,2}(t)\\) 使用的区间为 \\([t_0,t_2)\\)。\r\n因此，我们可以将一个高阶基函数用 1 阶基函数来表示： \\[\r\n\\begin{split}\r\n   N_{i,k}(t) &amp;= \\sum_{i}^{i+k-1}C_i(t) \\cdot N_{i,1}(t), \\ t \\in\r\n[t_i,t_{i+k}) \\\\\r\n  C_{i}(t) &amp;-一阶基函数系数\r\n   \\end{split}\r\n\\]\r\n从上式可以看出，k 阶基函数跨越了 \\((i+k)-i\r\n= k\\) 个区间。\r\n假设一个 4 阶 b 样条有 5\r\n个控制点，其基函数的区间可以用下图来表示：\r\n\r\n\r\nimage-20220707124032974\r\n\r\n从图中我们发现，仅在 \\([t_3,t_5]\\)\r\n区间上存在 4 个基函数，所以仅在该区间上，b 样条曲线才有定义。\r\n推而广之，我们就得到，一个有 (n+1) 个控制点的 k 阶 b\r\n样条曲线的有效定义区间为 \\([t_{k-1},t_{n+1}]\\)。\r\nb 样条本质\r\nb 样条曲线的本质是由多个 k-1 次多项式组合而成，这些分段曲线之间 k-2\r\n次连续。\r\n假设一个 4 阶 b 样条有 5 个控制点，任意点公式可以写成： \\[\r\n\\begin{split}\r\n   P(t) =\r\nN_{0,k}(t)P_0+N_{1,k}(t)P_1+N_{2,k}(t)P_2+N_{3,k}(t)P_3+N_{4,k}(t)P_4\r\n\\end{split}\r\n\\] 由于是 4 阶 5 点，所以有 9 个节点，8\r\n个节点区间，因此可以画出基函数的有效区间图如下：\r\n\r\n\r\nimage-20220707124032974\r\n\r\n所以，可以得到下列分段函数\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n区间序号\r\n定义域\r\n公式\r\n有效性\r\n\r\n\r\n\r\n\r\n1\r\n\\([t_0,t_1)\\)\r\n\\(P(t) = N_{0,k}(t)P_0\\)\r\n无效\r\n\r\n\r\n2\r\n\\([t_1,t_2)\\)\r\n\\(P(t) =\r\nN_{0,k}(t)P_0+N_{1,k}(t)P_1\\)\r\n无效\r\n\r\n\r\n3\r\n\\([t_2,t_3)\\)\r\n\\(P(t) =\r\nN_{0,k}(t)P_0+N_{1,k}(t)P_1+N_{2,k}(t)P_2\\)\r\n无效\r\n\r\n\r\n4\r\n\\([t_3,t_4)\\)\r\n\\(P(t) =\r\nN_{0,k}(t)P_0+N_{1,k}(t)P_1+N_{2,k}(t)P_2+N_{3,k}(t)P_3\\)\r\n有效\r\n\r\n\r\n5\r\n\\([t_4,t_5)\\)\r\n\\(P(t) =\r\nN_{1,k}(t)P_1+N_{2,k}(t)P_2+N_{3,k}(t)P_3+N_{4,k}(t)P_4\\)\r\n有效\r\n\r\n\r\n6\r\n\\([t_5,t_6)\\)\r\n\\(P(t) =\r\nN_{3,k}(t)P_3+N_{4,k}(t)P_4\\)\r\n无效\r\n\r\n\r\n7\r\n\\([t_6,t_7)\\)\r\n\\(P(t) =\r\nN_{3,k}(t)P_3+N_{4,k}(t)P_4\\)\r\n无效\r\n\r\n\r\n8\r\n\\([t_7,t_8)\\)\r\n\\(P(t) = N_{4,k}(t)P_4\\)\r\n无效\r\n\r\n\r\n\r\n从表中可以看出，5个控制点的 4 阶 b样条曲线仅在第 4 和 5\r\n个节点区间上生成曲线。\r\n性质\r\n\r\n非负性\r\n\\(N_{i,k}(t)\\) 是非负的\r\n局部支持性\r\n\r\n区间 \\([t_i,t_i+1]\\)\r\n上的曲线仅至多由 k 个控制\r\n\r\n\r\n\r\n\\(P_j,j \\in [i-k+1,...,i]\\)\r\n决定\r\n\\(P_i\\) 只影响在区间 \\([t_i,t_i+k)\\) 上的曲线。\r\n\r\n\r\n归一性\r\n区间 \\([t_{k-1},t_{n+1}]\\) 上的所有\r\nk 阶分段非零基函数的和为 1 \\[\r\n\\sum_i^n N_{i,k}(t) = 1,\\ t \\in [t_{k-1},t_{n+1}]\r\n\\]\r\n可求导 \\[\r\nN_{i,k}^{&#39;}(t) = \\frac{k-1}{t_{i+k-1}-t_i}\\cdot\r\nN_{i,k-1}(t)+\\frac{k-1}{t_{i+k}-t_{i+1}} \\cdot N_{i+1,k-1}(t)\r\n\\] 为什么分子是 k-1 呢？\r\n因为 k 阶基函数是一个 k-1\r\n次函数，在对其求导的时，其次数作为导数的系数，所以是 k-1\r\n连续性\r\n\\(P(t)\\) 在每一个重复度为 r\r\n的节点上具有 \\(C^{k-1+r}\\) 的连续性\r\n\\(C^{k-1+r}\\) 表示具有 \\(k-1+r\\) 次（degree）连续。C 是 Continue\r\n的首字母。\r\n凸包性\r\n一个 b 样条曲线被包围在其控制顶点的凸包内部。更精确地，对区间\r\n$[t_i,t_{i+1}],k-1 i n $ 上的任何 t，\\(P(t)\\) 都在控制点 \\(P_{i-k+1},...,P_i\\) 的凸包内部。\r\n分段多项式性质\r\n在任何一个由相邻结点确定的节点区间（knot span）上，\\(P(t)\\) 是一个关于 t 的次数不超过 k\r\n的多项式。\r\n变差缩减性（Variation Diminishing Property）\r\n任何曲一条直线与 B 样条曲线的交点数量不会超过该直线与 B\r\n样条曲线的控制多边形的交点的数量。\r\n几何不变性\r\n曲线的形状和相对于控制点的位置不取决于坐标系的选择。\r\n仿射不变性\r\n将仿射变换作用于等式两边，等式依然成立 \\[\r\nA[P(t)]= \\sum_i^nA[P_i]N_{i,k}(t),t \\in [t_{k-1},t_{n+1}]\r\n\\]\r\n直线保持性\r\n如果控制多边形退货成为一条直线，那么 B\r\n样条曲线依然在这条直线上。\r\n\r\n分类\r\n根据起起终点是否重合，可分为:\r\n\r\n开曲线\r\n起终点不重合的曲线\r\n闭曲线\r\n起终点重合的曲线\r\n\r\n根据节点向量的分布，又可为分为：\r\n\r\n均匀 b 样条曲线\r\n非均匀 b 样条曲线\r\n分段 Bezier 曲线\r\n非均匀无理 b 样条曲线\r\n\r\n均匀（uniform） b 样条曲线\r\n当节点成等差数列均匀排列时，这样形成的 b 样条曲线就叫均匀 b\r\n样条曲线。\r\n例如：\\(\\vec{T} =\r\n[0,1,2,3,4,5,6,7]\\)\r\n均匀 b 样条曲线有一个非常重要的特点，先上图：\r\n\r\n均匀 b 样条曲线的起点位于 B 点垂直于AC两个点连线的 1/3 处，方向为\r\n\\(\\vec{AC}\\)，终点位于 D 点垂直于 CE\r\n两个点连线的 1/3，方向为 \\(\\vec{CE}\\)。\r\n均匀 b 样条的一个特点是：\r\n均匀 b 样条曲线一定通过非端点垂直于它前后两个点连线的 1/3\r\n处，且其方向与前后两个点的连线相切。\r\n准均匀（quasi-uniform） b\r\n样条曲线\r\nk 阶准均匀 b 样条曲线有以下特点：\r\n\r\n它的起终点分别为控制点的起终点\r\n起始节点与终止节点都有 k 个重复度\r\n\r\n\r\n\r\n小提示：\r\n如果想让 b 样条曲线经过起终点，可以让起始节点都具有 k 个重复度\r\n\r\n分段 Bezier 曲线\r\n当 b 样条曲线具有如下特点时，它就是分段 Bezier 曲线：\r\n\r\n起终节点具有 k 个重复度\r\n所有其它节点具有 k-1 个重复度\r\n\r\n曲线包含线段\r\n如果需要在样条曲线中包含一条线段，只需要指定 k(阶数)\r\n个控制顶点共线。\r\n如果要保证插入的直线在控制点范围内是一条直线，还必须保证线段的首尾点分别具有\r\n1 个重复度。\r\n\r\n\r\nimage-20220709181500332\r\n\r\n左图是仅 3 个点共线，右图是 3 个点共线且共线的首尾点重复 1 次。\r\n曲线经过控制点\r\n通过均匀 b 样条的特点可以知，如果 3 个点相同（这种重复3次的点，叫做 3\r\n重点），则曲线经过该点。\r\n因为 3 个点相同，所以它们的连线与垂线都位于这个点上。\r\n曲线与某直线L相切\r\n如果希望某段曲线与某直线 L 相切，需满足以下条件：\r\n\r\n\\(P_i,P_{i+1},P_{i+2}\\)\r\n都在直线上\r\n\\(t_{i+3}\\) 重复度小于 2\r\n\r\n因此，如果想要曲线与两个控制点的连线相切，可以通过添加一个相同的控制点，将两个点变成\r\n3 个点，因为有一个点是重复的，所以 3\r\n个点必然在一条直线上，这样就达到了曲线与直线相切的条件了。\r\n闭曲线\r\n构件闭曲线的方式有很多种，此处只介绍一种简单的方法：重复起始节点法。\r\n假设我们想要构建一个由 n+1 个控制点 \\([P_0,P1,...,P_n]\\) 定义的 k 次闭 B 样条曲线\r\n\\(C_t\\)。构建过程如下：\r\n\r\n增加一个新控制点 \\(P_{n+1}=P_0\\)，因此控制点的数目是 \\(n+2\\)。\r\n按开曲线方式，增加 n+k+1 个节点 \\([t_0,t_1,...,t_{n+k}]\\)。这些节点可以不需要是均匀的。\r\n将前 p-1 节点复制到节点序列末尾，最终结果为：\\(t_0,t_1,...,t_n+k,t_0,t_1,...,t_{k-1}]\\)\r\n\r\n通过对比开闭曲线，我们可以得到如下规律：\r\n\r\n开曲线：节点数量=控制点数量+阶数\r\n闭曲线：节点数量=控制点数量+2x阶数\r\n\r\n\r\n小提示：在 Microstation\r\n软件中，生成闭曲线时不需要在末尾增加第一个点\r\n\r\n非均匀有理B样条曲线（NURBS）\r\nOrder（阶数）\r\nNURBS曲线的 order 定义了影响曲线上任何给定点附近的控制点的数量。\r\n这条曲线用比 order 小 1 次的多项式表示。 因此，order 为 2\r\n时表示线性曲线，order 为 3 时表示二次曲线。\r\n\r\n控制点的个数必须大于或等于曲线的 order。\r\n\r\n在实践中，三次曲线是最常用的曲线。\r\n五阶和六阶曲线有时是有用的，特别是对于获得连续的高阶导数，但高阶曲线实际上从未使用过，因为它们会导致内部数值问题，往往需要大量的计算时间。\r\nControl Point 与 Knot\r\n这两个概念与 b 样条的概念是一样的\r\nWeight\r\nnurbs 还有一个特殊的参数权重（weight），权重范围是\r\n[0，100]，正常权重是 1，值越大，控制点对曲线影响越在，越靠近点，值为 0\r\n值，控制点对曲线没有影响，相当于没有这个控制点。\r\nBézier、B-Spline、NURBS 区别\r\nBezier\r\n曲线中的每个控制点都会影响整个曲线的形状，而B样条中的控制点只会影响整个曲线的一部分，显然\r\nB样条提供了更多的灵活性\r\nBezier和B样条都是多项式参数曲线，不能表示一些基本的曲线，比如圆，所以引入了\r\nNURBS，即非均匀有理B样条来解决这个问题\r\nBezier 曲线只是 B样条的一个特例而已，而 B样条又是 NURBS\r\n的一个特例，它们的关系可以图示为：\r\n\r\n\r\nrelationshipAmongCurves\r\n\r\nMSBsplineCurve（Microstation中的对象）\r\n它是一条非均匀有理B样条曲线，简称（NURBS）。\r\n\r\nMSBsplineCurve is a \"Non uniform, rational Bspline curve\".\r\n\r\nPole and knot counts\r\n\r\n\r\n\r\n曲线类型\r\n关系\r\n\r\n\r\n\r\n\r\nOpen curve （非闭合曲线）\r\nknots = poles + order\r\n\r\n\r\nClosed (periodc) curve （闭合线）\r\nknots = poles + 2 * order - 1\r\n\r\n\r\n\r\nB样条曲线上的参数化位置\r\n有两种方法来确定 B 样条曲线的位置，分别是通过 Fraction 和 Knot\r\n点。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nConvention\r\nstart value\r\nend value\r\nremarks\r\n\r\n\r\n\r\n\r\nFraction position\r\n一直是 0.0\r\n一直是 1.0\r\n这个值不是沿曲线线性变化的。如果想要获取等分点，需要先通过FractionAtSignedDistance\r\n获取 Fraction，然后再通过 Fraction 去获取点。\r\n\r\n\r\nKnot postion\r\n第一个激活的 Knot\r\n最后一个激活的 Knot\r\n“激活”的意思是除去(order-1)开头和结尾的Knot后剩余的中间 Knot\r\n\r\n\r\n\r\nThe word Fraction or Knot in a method name indicates how the\r\narguments for that method are interpreted.\r\n通过控制点的 b 样条曲线\r\nMicrostation 中可以通过控制点创建 b\r\n样条曲线，这个实现目前没有找到相关资料，今后发现了之后再更新本节。\r\n源代码\r\n本文使用的一些代码示例（基于 Microstation 平台）位于ArticleSourceCode-Bspline\r\n中。\r\n参考\r\n计算机图形学 13\r\n和 14 - B 样条曲线-bilibili (建议先看完)\r\n怎么理解贝塞尔曲线？\r\n非均匀有理B样条-Wikipedia\r\nFun With Geometry\r\nNURBS-非均匀有理B样条\r\nIntroduction\r\nto Computing with Geometry Notes\r\nB-样条曲线入门\r\nB-样条曲线：系数计算\r\n深入理解B样条曲线（上）\r\nB-spline\r\nCurves: Closed Curves\r\n","categories":["Bentley","Develop","几何变换"],"tags":["Bentley","Bentley二次开发"]},{"title":"MySql 三种注释写法","url":"/posts/2019/25CC488.html","content":"\r\n单行注释\r\n\r\n在行前面加上 # 号：\r\n# 这是单行注释\r\n在行前面加上 --空格\r\n-- 这是单行注释\r\n\r\n多行注释\r\n用一对/* */ 包围\r\n/**这是多行注释*/\r\n","categories":["Develop","Database","MySql"],"tags":["MySql"]},{"title":"MySql scoop 安装","url":"/posts/2020/2EA0GRR.html","content":"为了方便今后安装 mysql，特对 scoop 安装 MySql 的流程记录一下。\r\n\r\n安装程序\r\nscoop install mysql\r\n配置服务\r\n根据 scoop 提示，运行 mysqld 命令\r\nmysqld --install MySQL --defaults-file=&quot;D:\\scoop\\apps\\mysql\\current\\my.ini&quot;\r\n运行服务\r\n用管理员方式启动命令行窗口，在里面输入：\r\nnet start MySQL\r\n修改密码\r\n打开命令行，输入\r\nmysql -u root\r\n然后再设置密码\r\nSET PASSWORD FOR &#x27;root&#x27;@&#x27;localhost&#x27; = &#x27;auth_string&#x27;;\r\n","categories":["Develop","Database","MySql"],"tags":["MySql"]},{"title":"关于mongoose返回的对象无法修改的原因以及解决方法","url":"/posts/2020/2GK4675.html","content":"我们在使用 Mongoose的时候，或许大家都会发现回调返回的\r\nresult 无法进行修改，Google\r\n了一下，现在把方法做一个总结，方便今后搜索。\r\n\r\n原因\r\n实际上 mongoose 返回的数据并不是\r\nobject，虽然通过 typeof 判断类型是\r\nObject，但其实 mongoose 自己封装的一个对象（Mongoose\r\nDocument），这个对象的原型里面挂载了很多方法，并且这个对象会对数据进行实时查询以保证其符合预定义的\r\nmodel，而无论添加删除model都不会改变，所以设置无效。\r\n\r\n聚合查询出来的结果不需要转换\r\n\r\n解决办法\r\ntoObject()\r\n在返回的 result 对象调用 toObject() 或\r\ntoJSON() 方法，则可以对它进行修改。\r\n\r\n本质上使用toObject和toJSON都是可以的，其实这两个方法一般来说是没区别的，而如果要讲究区别的话，那就是如果使用toJSON的话，对生成的对象用JSON.stringify，此时用的是这个对象本身的toJSON方法来序列化，而不是原生对象Object的方法。\r\n\r\n.lean()\r\n可以通过使用 lean 将结果转成纯 javascript 对象。\r\n启用 lean 选项的查询返回的文档是纯 javascript 对象，而不是 Mongoose\r\n文档。它们没有 save 方法、getter/setter、virtuals 或其他 Mongoose\r\n特性。\r\nnew Query().lean() // truenew Query().lean(true)new Query().lean(false)const docs = await Model.find().lean();docs[0] instanceof mongoose.Document; // false\r\n参考\r\n\r\n关于mongoose返回的数据无法修改的原因以及解决方法\r\nMongoose返回数据修改中遇到的坑\r\nhttps://mongoosejs.com/docs/api/query.html#query_Query-lean\r\n\r\n","categories":["Develop","Database","Mongoose"],"tags":["MongoDB","Mongoose","Javascript"]},{"title":"MySql从入门到精通","url":"/posts/2020/P0HE12.html","content":"MySql 从入门到精通教程\r\n\r\n1. 数据库是什么\r\n本节介绍数据库的基本概念，包括数据库存储方式、数据库技术的发展历史、数据库的存储结构以及数据库在开发中的作用。\r\n数据存储方式\r\n计算机数据（Data）的存储一般以硬盘为数据存储空间资源，从而保证计算机内的数据能够持续保存。对于数据的处理，一般会采用数据库相关的技术进行处理，从而保证数据处理的高效性。\r\n什么是数据库\r\n数据库是数据管理的有效技术，是由一批数据构成的有序集合，这些数据被存放在结构化的数据表里。数据表之间相互关联，反映客观事物间的本质联系。数据库能有效地帮助一个组织或企业科学地管理各类信息资源。\r\n数据库的存储结构\r\n数据库的存储结构是指数据库中的物理数据和逻辑数据的表示形式、物理数据和逻辑数据之间关系映射方式的描述。在数据库技术中，可以使用两种形式描述客观现实的数据：物理数据描述和逻辑数据描述。物理数据和逻辑数据之间的转换通过数据库管理系统实现。\r\n物理数据描述\r\n物理数据描述是指数据在存储设备上的存储方式，物理数据是实际存放在存储设备上的数据，这些数据也称为物理记录。根据物理记录存储的位置，又可以分为有序存储和无序存储。\r\n\r\n位（bit）：二进制的一个单位称为位，位只能取 1 或 0。\r\n字节（byte）：8 个位称为一个字节，可以存放对应 ASCII\r\n码的一个字符。\r\n字（word）：若干个字节组成一个字。一个字所含的二进制的位数称为字长，许多计算机的字长是不同的，例如计算机的字长可以是\r\n8 位、16 位、24 位、32 位等。\r\n块（block）：内存储器和外存储器交换信息的最小单位，又称为物理块或物理记录，每块的大小通常为\r\n256 字节、512 字节、1024 字节等。\r\n卷（volume）：一台输入输出设备所能装载的全部有用信息，例如磁带机的一盘磁带即为一卷，磁盘设备的一个盘组也是一卷。\r\n无序存储（unordered）：数据记录按照插入的顺序进行存储。\r\n\r\n逻辑数据描述\r\n逻辑数据描述是指用户或程序员用于操作的数据形式，逻辑数据是一种抽象的概念，是对客观现实世界的反映和记录，这些数据也可以称为逻辑记录。\r\n\r\n实体（entity）：客观现实存在的东西使用实体来描述。实体既可以是具体的、有形的对象，也可以是抽象的、无形的对象。例如，一本书是一个有形对象，一次借书过程则是一个无形的对象。\r\n实体集（entities）：特性完全相同的同类实体的集合称为实体集。例如，一个图书馆所有的书籍是一个实体集，该图书馆的所有借书过程也是一个实体集。\r\n属性（attribute）：实体的特性称为属性。每个属性都有一个值域，这些值域可以是整数类型、浮点数类型、字符类型或日期类型等。例如，实体书的属性包括书名、书号、出版日期、页数、价格以及出版社等，这些属性对应的值域分别为字符类型、字符类型、日期类型、整数类型、浮点数类型和字符类型等。\r\n标识符（identifier）：能够唯一地标识每个实体的属性或属性集。例如，书的书号属性是实体书的标识符，借书过程实体的标识符包括借书证号、书号两个属性。\r\n\r\n这些逻辑数据最终要通过数据库管理系统来转换成物理数据。在数据库管理系统中，描述逻辑数据的术语包括哪些呢？\r\n\r\n数据项（data\r\nitem）：也称为字段（field），标记实体属性的可以命名的最小信息单位，数据项的命名一般采用属性的描述性名称。这些名称可以是中文、英文或汉语拼音。\r\n元组（tuple）：也称为记录（record），数据项的集合称为元组。一个元组表示一个具体的实体。\r\n关系（relation）：在关系型数据库系统中，同一类元组所在的集合称为关系。关系适用于描述实体集，它包括一个实体集的所有元组。例如，所有的图书可以组成一个\r\nbooks 关系。\r\n键码（key）：在关系型数据库系统中，能够唯一地标识关系中每个元组的数据项或数据项的组合称为关系的键码。\r\n\r\n客观实体经过两层逻辑数据的描述，最后转变成实际存储的物理数据。\r\n从数据库系统应用角度来看，数据库系统常见的运行与应用结构有：客户端/服务器结构、浏览器/服务器结构。\r\n2. 数据库涉及到哪些技术？\r\n本节主要介绍数据库涉及到的技术，包括数据库系统、SQL\r\n语言和数据库访问技术。\r\n数据库系统\r\n数据库管理系统（Database Management\r\nSystem，DBMS）是位于操作系统与用户之间的一种操纵和管理数据库的软件，按照一定的数据模型科学地组织和存储数据，同时可以提供数据高效地获取和维护。\r\n1) 数据定义功能\r\nDBMS 提供数据定义语言（Data Definition\r\nLanguage，DDL），用户通过它可以方便地对数据库中的数据对象进行定义。\r\n2) 数据操纵功能\r\nDBMS 还提供数据操纵语言（Data Manipulation\r\nLanguage，DML），用户可以使用 DML\r\n操作数据，实现对数据库的基本操作，如查询、插入、删除和修改等。\r\n3) 数据库的运行管理\r\n数据库在建立、运用和维护时由数据库管理系统统一管理、统一控制，以保证数据的安全性、完整性、多用户对数据的并发使用及发生故障后的系统恢复。例如：\r\n\r\n数据的完整性检查功能保证用户输入的数据应满足相应的约束条件；\r\n数据库的安全保护功能保证只有赋予权限的用户才能访问数据库中的数据；\r\n数据库的并发控制功能使多个用户可以在同一时刻并发地访问数据库的数据；\r\n数据库系统的故障恢复功能使数据库运行出现故障时可以进行数据库恢复，以保证数据库可靠地运行。\r\n\r\n4)\r\n提供方便、有效地存取数据库信息的接口和工具\r\n编程人员可通过编程语言与数据库之间的接口进行数据库应用程序的开发。数据库管理员（Database\r\nAdministrator，DBA）可通过提供的工具对数据库进行管理。\r\n5) 数据库的建立和维护功能\r\n数据库功能包括数据库初始数据的输入、转换功能，数据库的转储、恢复功能，数据库的重组织功能和性能监控、分析功能等。这些功能通常由一些使用程序来完成。\r\n\r\n\r\n完整的数据库系统结构关系\r\n\r\n了解SQL语言\r\nMySQL\r\n服务器正确安装以后，就已经完成了一个完整的 DBMS\r\n的搭建，可以通过命令行管理工具或者图形化的管理工具对 MySQL\r\n数据库进行操作。这种操作实质上是通过结构化查询语言（Structured Query\r\nLanguage，SQL）来实现的，SQL 语言是各种数据库交互方式的基础。\r\nSQL\r\n是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。与其他程序设计语言（如C、Java等）不同的是，SQL\r\n由很少的关键字组成，每个 SQL 语句通过一个或多个关键字构成。\r\nSQL具有如下优点。\r\n\r\n一体化：SQL集数据定义、数据操作和数据控制于一体，可以完成数据库中的全部工作。\r\n使用方式灵活：SQL具有两种使用方式，可以直接以命令方式交互使用；也可以嵌入使用，嵌入C、C++、Fortran、COBOL、Java等语言中使用。\r\n非过程化：只提操作要求，不必描述操作步骤，也不需要导航。使用时只需要告诉计算机“做什么”，而不需要告诉它“怎么做”。\r\n语言简洁、语法简单、好学好用：在ANSI标准中，只包含94个英文单词，核心功能只用6个动词，语法接近英语口语。\r\n\r\n\r\n注意：SQL 语句不区分大小写，许多 SQL 开发人员习惯对 SQL\r\n本身的关键字进行大写，而对表或者列的名称使用小写，这样可以提高代码的可阅读性和可维护性。本教程也按照这种方式组织\r\nSQL 语句。大多数数据库都支持通用的 SQL\r\n语句，同时不同的数据库具有各自特有的 SQL 语言特性。\r\n\r\n数据库访问技术\r\n数据库访问技术包括 ODBC、DAO、OLE DB 和 ADO。\r\nODBC\r\nODBC（Open Database\r\nConnectivity，开放数据库互连）是微软公司开放服务结构（Windows Open\r\nServices\r\nArchitecture，WOSA）中有关数据库的一个组成部分，它建立了一组规范，并提供了一组对数据库访问的标准\r\nAPI（应用程序编程接口）。这些 API 利用 SQL 来完成其大部分任务。\r\nDAO\r\nDAO（Data Access Object，数据访问对象集）是 Microsoft\r\n提供的基于一个数据库对象集合的访问技术，可以独立于 DBMS\r\n进行数据库的访问。\r\nOLE DB\r\nOLE DB（Object Linking and Embedding\r\nDatabase，对象连接与嵌入）是微软战略性的通向不同数据源的低级应用程序接口。OLE\r\nDB\r\n不仅包括微软资助的标准数据接口，开放数据库连通性（ODBC）的结构化查询语言（SQL）能力，还具有面向其他非\r\nSQL 数据类型的通路。\r\nADO\r\nADO（ActiveX Data Objects）是一个用于存取数据源的 COM\r\n组件，提供了编程语言和统一数据访问方式 OLE DB\r\n的一个中间层，允许开发人员编写访问数据的代码而不用关心数据库是如何实现的，只用关心到数据库的连接。\r\n致谢\r\n本文来源于：C 语言中文网\r\n","categories":["Develop","Database","MySql"],"tags":["MySql"]},{"title":"monoose返回对象无法比较ObjectId","url":"/posts/2021/35VQS80.html","content":"在使用 mongoose 时遇到这样一个坑，Schema\r\n定义如下：\r\n&#123;    // id    _id: &#123;      type: mongoose.Types.ObjectId,      required: true,    &#125;,    // 部门名称    departmentName: &#123;      type: String,      trim: true,      required: true,    &#125;,    // 描述    description: String,    // 排序    order: Number,    // 上一级部门    parentId: &#123;      type: mongoose.Types.ObjectId,      required: true,    &#125;,&#125;;\r\n当我使用===比较集合中两个 ObjectId 时，始终为\r\nfalse 。\r\n\r\n这是我的比较语句的主要部分：\r\nconst departments = await this.ctx.mode(&#x27;Department&#x27;).find(&#123;&#125;)const firstDp = departments[0]const parentDp = departments.find(dp=&gt;dp._id===firstDp.parentId)console.log(&quot;result:&quot;,parentDp===null)// result:true\r\n在查找第一个部门的父部门时，始终找不到（父部门是存在的）。\r\n后面通过排查，才发现，原来通过 find() 查找出来的对象是\r\nmongoose 自己的包装过的对象，上面的 _id 和\r\nparentId 也是一个ObjectId对象，所以直接用\r\n=== 比较时，始终返回\r\nfalse，导致不能找到结果。\r\n找到问题的原因后，直接将 ObjectId\r\n转成字符串比较就可以了。\r\nconst parentDp = departments.find(dp=&gt;dp._id.toString()===firstDp.parentId.toString())console.log(&quot;result:&quot;,parentDp===null)// result:false\r\n","categories":["Develop","Database","Mongoose"],"tags":["MongoDB","Mongoose","Javascript"]},{"title":"monoose返回对象无法比较ObjectId","url":"/posts/2021/35VQS80.html","content":"在使用 mongoose 时遇到这样一个坑，Schema\r\n定义如下：\r\n&#123;    // id    _id: &#123;      type: mongoose.Types.ObjectId,      required: true,    &#125;,    // 部门名称    departmentName: &#123;      type: String,      trim: true,      required: true,    &#125;,    // 描述    description: String,    // 排序    order: Number,    // 上一级部门    parentId: &#123;      type: mongoose.Types.ObjectId,      required: true,    &#125;,&#125;;\r\n当我使用===比较集合中两个 ObjectId 时，始终为\r\nfalse 。\r\n\r\n这是我的比较语句的主要部分：\r\nconst departments = await this.ctx.mode(&#x27;Department&#x27;).find(&#123;&#125;)const firstDp = departments[0]const parentDp = departments.find(dp=&gt;dp._id===firstDp.parentId)console.log(&quot;result:&quot;,parentDp===null)// result:true\r\n在查找第一个部门的父部门时，始终找不到（父部门是存在的）。\r\n后面通过排查，才发现，原来通过 find() 查找出来的对象是\r\nmongoose 自己的包装过的对象，上面的 _id 和\r\nparentId 也是一个ObjectId对象，所以直接用\r\n=== 比较时，始终返回\r\nfalse，导致不能找到结果。\r\n找到问题的原因后，直接将 ObjectId\r\n转成字符串比较就可以了。\r\nconst parentDp = departments.find(dp=&gt;dp._id.toString()===firstDp.parentId.toString())console.log(&quot;result:&quot;,parentDp===null)// result:false\r\n","categories":["Develop","Database","Mongoose"],"tags":["MongoDB","Mongoose","Javascript"]},{"title":"mongoose中嵌套内容修改后save失效","url":"/posts/2021/3M6QG1T.html","content":"今天遇到这样一个问题，我有一个字段\r\nelments，它是一个数组，数组里面是对象。当我修改数组中某个对象的某个字段后，再调用\r\ndocument.save() 想保存修改，却发现无法保存修改后的值。\r\n&#123;  // 模型名称  name: &#123;    type: String,    trim: true,    required: true,  &#125;,  // 里面元素的属性  elements: Array,&#125;\r\n\r\n示例代码，基于eggjs 框架：\r\nawait this.ctx.model.ModelFile.insert(&#123;    name: &#x27;test&#x27;,    elements:[        &#123;            name: &#x27;circle&#x27;,            area: &#x27;200&#x27;,        &#125;,        &#123;            name: &#x27;rectangle&#x27;,            area: &#x27;300&#x27;        &#125;    ]&#125;)\r\n\r\n修改非嵌套字段时可以正常保存\r\n\r\nconst doc = await this.ctx.model.ModelFile.findOne(&#123;name:&#x27;test&#x27;&#125;)doc.name = &#x27;test1&#x27;await doc.save()// name 修改为了 test1\r\n\r\n整体修改嵌套字段时，也可以正常保存\r\n\r\nconst doc = await this.ctx.model.ModelFile.findOne(&#123;name:&#x27;test&#x27;&#125;)const rectangleElements = doc.elements[1]rectangleElements.area = 400doc.elements = [doc.elements[0],rectangleElements]await doc.save()// elements 中的 rectangle 面积被修改为了 400\r\n\r\n单独修改引用对应的值时，保存不生效\r\n\r\nconst doc = await this.ctx.model.ModelFile.findOne(&#123;name:&#x27;test&#x27;&#125;)const rectangleElements = doc.elements[1]rectangleElements.area = 400await doc.save()// elements 中的 rectangle 面积还是 300\r\n针对第 3 种情况，由于 elements\r\n里面的元素没有特定的约束，可以随意修改，为了在修改后可以调用\r\nsave()，需要在保存之前调用\r\nmarkModified()。\r\n改成如下形式就可以了：\r\nconst doc = await this.ctx.model.ModelFile.findOne(&#123;name:&#x27;test&#x27;&#125;)const rectangleElements = doc.elements[1]rectangleElements.area = 400doc.markModified(&quot;elements&quot;)await doc.save()// elements 中的 rectangle 面积被修改为了 400\r\n","categories":["Develop","Database","Mongoose"],"tags":["MongoDB","Mongoose","Javascript"]},{"title":"monggose嵌套对象中添加ObjectId","url":"/posts/2021/10XS5HK.html","content":"如何在 Mongoose 的定义中，定义一个包含 ObjectId 的嵌套定义呢？\r\n\r\n正确的定义方式如下：\r\n// 嵌套定义const nestedSchema = new Schema(&#123;  fileTypeId: mongoose.Types.ObjectId,  type: String,  // 代表不生成_id项，否则会在对象中生成额外的_id字段  _id: false&#125;)// 定义const UserSchema = new Schema(&#123;  name: &#123;    type: String,    required: true  &#125;,    nestedData: &#123;    // 类型为    type: nestedSchema  &#125;&#125;)\r\n错误的定义：\r\nconst UserSchema = new Schema(&#123;  name: &#123;    type: String,    required: true  &#125;,    extra: &#123;    fileTypeId: mongoose.Types.ObjectId,    type: String,  &#125;&#125;)\r\n这种定义如果传入的 fileTypeId\r\n是一个字符串的话，不会自动转成 ObjectId，会使得 Mongoose\r\n报错。\r\n","categories":["Develop","Database","Mongoose"],"tags":["Mongoose"]},{"title":"mongoose使用findOneAndUpdate不能更新默认值","url":"/posts/2021/3Z62NZ0.html","content":"今天遇到这样一个问题，当我使用 findOneAndUpdate\r\n来更新或新建文档时，发现如果文档是新建的，则定义的默认值居然为空。\r\n经过查阅相关文档，在查询时添加 setDefaultsOnInsert: true\r\n可以解决这个问题。\r\n&#123;  upsert: true,  new: true,  // 在插入时设置默认值  setDefaultsOnInsert: true,&#125;\r\n","categories":["Develop","Database","Mongoose"],"tags":["MongoDB","Mongoose","Javascript"]},{"title":"Mongoose 中特殊类型的等价字符串表达形式","url":"/posts/2022/HSPJ12.html","content":"后端开放了一个通用的聚合查询，传入聚合语句即可获取结果，但是一些特殊类型无法通过\r\nbody 传到后端，比如\r\nObjectId，Regexp\r\n等。本文对这些特殊类型的等价表达方式进行了总结，以飨读者。\r\n\r\nObjectId\r\n&#123;    $toObjectId: &#x27;$jobPositionId&#x27;&#125;\r\nRegexp\r\n&#123;  $regex: &#x27;filter&#x27;,  $options: &#x27;gi&#x27;&#125;\r\n","categories":["Develop","Database","Mongoose"],"tags":["MongoDB","Mongoose","Javascript"]},{"title":"mongoose子文档","url":"/posts/2021/1QN39SQ.html","content":"子文档是在一个 Schema 中嵌入另一个\r\nSchema，它的形式主要有两种：\r\n\r\n子文档是数组\r\n子文档是对象\r\n\r\n注意，子文档是对象的情况只适用于 4.2.0 及以上的版本\r\n\r\n\r\n\r\n什么是子文档？\r\n子文档和顶层的文档具有相同的特性，它们唯一的区别是子文档不是单独存储的，它与顶层文档存储在一起。\r\n由于子文档的特性，虽然子文档也具有 save()\r\n方法，但是调用它却不会保存修改，如果想要保存修改，需要在顶层文档调用\r\nsave() 方法。\r\n顶层文档与子文档的 pre('save') 和\r\npre('validate') 中间件执行顺序\r\ngraph LRps[父save]pv[父validate]cs[子save]cv[子validate]pv--&gt;cv--&gt;cs--&gt;ps\r\n子文档的定义\r\n它们的定义如下：\r\nconst childSchema = new Schema(&#123; name: &#x27;string&#x27; &#125;);const parentSchema = new Schema(&#123;  // Array of subdocuments  // 数组子文档  children: [childSchema],  // Single nested subdocuments. Caveat: single nested subdocs only work  // in mongoose &gt;= 4.2.0  // 对象子文档  child: childSchema&#125;);\r\n数组子文档的其它定义形式\r\n如果创建一个对象数组，Mongoose 会自动将其转换成 Schema 定义\r\nconst parentSchema = new Schema(&#123;  children: [&#123; name: &#x27;string&#x27; &#125;]&#125;);// Equivalentconst parentSchema = new Schema(&#123;  children: [new Schema(&#123; name: &#x27;string&#x27; &#125;)]&#125;);\r\n对象子文档的其它定义形式\r\n如果创建的是一个嵌套对象，则不会转换成 Schema\r\n定义，它是一个嵌套路径\r\n// 定义const schema = new Schema(&#123;  nested: &#123;    prop: String  &#125;&#125;);const schema = new Schema(&#123;  nested: &#123;    // Do not do this! This makes `nested` a mixed path in Mongoose 5    type: &#123; prop: String &#125;,    required: true  &#125;&#125;);const schema = new Schema(&#123;  nested: &#123;    // This works correctly    type: new Schema(&#123; prop: String &#125;),    required: true  &#125;&#125;);\r\n取消子文档中的 _id\r\n// disabled _idconst childSchema = new Schema(&#123; name: String &#125;, &#123; _id: false &#125;);const parentSchema = new Schema(&#123; children: [childSchema] &#125;);\r\n\r\n_id 设置只能用于子文档中\r\n\r\n子文档与嵌套路径\r\n两者的定义如下:\r\n// Subdocument// 子文档const subdocumentSchema = new mongoose.Schema(&#123;  child: new mongoose.Schema(&#123; name: String, age: Number &#125;)&#125;);const Subdoc = mongoose.model(&#x27;Subdoc&#x27;, subdocumentSchema);// Nested path// 嵌套路径const nestedSchema = new mongoose.Schema(&#123;  child: &#123; name: String, age: Number &#125;&#125;);const Nested = mongoose.model(&#x27;Nested&#x27;, nestedSchema);\r\n区别：\r\n子文档的 child 没有值时为 undefined，而嵌套路径则不是：\r\nconst doc1 = new Subdoc(&#123;&#125;);doc1.child === undefined; // truedoc1.child.name = &#x27;test&#x27;; // Throws TypeError: cannot read property...const doc2 = new Nested(&#123;&#125;);doc2.child === undefined; // falseconsole.log(doc2.child); // Prints &#x27;MongooseDocument &#123; undefined &#125;&#x27;doc2.child.name = &#x27;test&#x27;; // Works\r\n子文档默认值\r\n\r\n默认值为 undefined\r\n如果设置一个非空值，比如\r\n{}，则会给子文档赋予默认值\r\n\r\n子文档查询\r\n每一个子文档都有一个 _id，可以通过 id()\r\n方法来查询子文档\r\nconst doc = parent.children.id(_id);\r\n向子文档数组中插入新值\r\n可以使用 push, unshift,\r\naddToSet 等方法添加：\r\nconst Parent = mongoose.model(&#x27;Parent&#x27;);const parent = new Parent;// create a commentparent.children.push(&#123; name: &#x27;Liesl&#x27; &#125;);const subdoc = parent.children[0];console.log(subdoc) // &#123; _id: &#x27;501d86090d371bab2c0341c5&#x27;, name: &#x27;Liesl&#x27; &#125;subdoc.isNew; // trueparent.save(function (err) &#123;  if (err) return handleError(err)  console.log(&#x27;Success!&#x27;);&#125;);\r\n也可以使用 create 直接创建：\r\nconst newdoc = parent.children.create(&#123; name: &#x27;Aaron&#x27; &#125;);\r\n移除子文档\r\n// 移除方式1parent.children.id(_id).remove();// 移除方式2parent.children.pull(_id)// 整体移除1parent.child.remove();// 整体移除2parent.child = null\r\n获取子文档的父级\r\n通过 parent() 方法获取父级：\r\nconst schema = new Schema(&#123;  docArr: [&#123; name: String &#125;],  singleNested: new Schema(&#123; name: String &#125;)&#125;);const Model = mongoose.model(&#x27;Test&#x27;, schema);const doc = new Model(&#123;  docArr: [&#123; name: &#x27;foo&#x27; &#125;],  singleNested: &#123; name: &#x27;bar&#x27; &#125;&#125;);// 子文档是对象doc.singleNested.parent() === doc; // true// 子文档是数组doc.docArr[0].parent() === doc; // true\r\n如果是多级嵌套，可以使用 ownerDocument()\r\n来获取根文档。\r\n致谢\r\n本文参考以下文章，在此致以诚挚感谢！\r\n\r\n官方文档:\r\nSubdocuments\r\nMongoose\r\nv6.2.9: Schemas (mongoosejs.com)\r\n\r\n","categories":["Develop","Database","Mongoose"],"tags":["Mongoose"]},{"title":"Mongoose 默认值使用时必须知道的几个要点","url":"/posts/2022/3PMMZVC.html","content":"Mongoose 的文档中对 default\r\n的介绍不多，导致在使用中可能会遇到一些bug，因此做一个总结。\r\n\r\n设置 default\r\n假设我们需要对某个字段赋予默认值，可以通过如下方式进行定义：\r\nconst schema = new Schema(&#123;  title: String,  date: &#123;    type: Date,    // `Date.now()` returns the current unix timestamp as a number    // 此处必须是 function 才能实时更新时间    default: Date.now  &#125;&#125;);\r\ndefault 定义有如下特点：\r\n\r\ndefault 可以是值，也可以是 function\r\ndefault 当是值类型时，会被 mongoose 缓存\r\nmongoose 在 model\r\n初始化后，会缓存默认默认值，所以，如果默认时是一些实时的数据，比如时间，则要将\r\ndefault 赋值为 function。\r\n\r\n更新 default\r\n当在 update() 和 findOneAndUpdate() 中使用\r\nupsert 选项时，Mongoose\r\n会给没有值的默认字段设置默认值。\r\n如果发现没更新默认值，可以传入参数setDefaultsOnInsert: true\r\n来触发。\r\ndefault 函数中的 this\r\ndefault 函数中的 this\r\n默认指向当前文档，因此可以在定义中通过自身参数来返回不同的默认值，比如：\r\nconst schema = new Schema(&#123;  title: String,  released: Boolean,  releaseDate: &#123;    type: Date,    default: function() &#123;      if (this.released) &#123;        return Date.now();      &#125;      return null;    &#125;  &#125;&#125;);\r\n参考\r\n\r\nDefaults-Mongoose\r\ndefault\r\ndate remains the same as the date of the process startup if\r\nindexed\r\n\r\n","categories":["Develop","Database","Mongoose"],"tags":["Mongoose"]},{"title":"Mongoose中的 ObjectId 什么情况下与字符串 id 等价","url":"/posts/2022/3A2KFYY.html","content":"经验证，在使用 Mongoose 包来进行 MongoDB\r\n查询时，在非聚合（aggregate）语句中，可以直接使用字符串型 ObjectId\r\n进行匹配查找和赋值，比如：create、find、findOne、findByIdAndDelete、$in\r\n等方法中都可以使用字符串型 ObjectId。\r\n例如：\r\nmodel.find(&#123;  _id: &#x27;5f68710c4da61820f461e0c0&#x27;&#125;)model.find(&#123;  _id:&#123;$in:[&#x27;5f68710c4da61820f461e0c0&#x27;]&#125;&#125;)model.updateMany(&#123;  _id:&#123;$in:[&#x27;5f68710c4da61820f461e0c0&#x27;]&#125;&#125;,&#123;  // 也可以用字符串id数组赋值给 ObjectId 数组字段  ids: [&#x27;5f68710c4da61820f461e0c0&#x27;] &#125;)\r\n上面的这种字符串 id 去匹配 ObjectId\r\n机制，在聚合中不支持，在聚合中使用时，需要将字符串的 Id\r\n转成 ObjectId。\r\n","categories":["Develop","Database","Mongoose"],"tags":["MongoDB","Mongoose"]},{"title":"用命令行安装mongodb指南","url":"/posts/2020/35KNZY8.html","content":"在用 scoop 安装 mongodb\r\n后，没有像直接使用安装包那样，会将数据库服务一次安装到位，而是需要使用命令行来进行安装。\r\n网上虽然有很多的教程，但是参差不齐，每次想找到一个能使用，还是会浪费一些时间，于是根据自己的需要，进行了总结。\r\n\r\n小提示\r\n不知从什么版本开始，用 scoop 安装的 mongodb\r\n没有安装导入导出这些工具了，如果有需要，可以单独安装：scoop install mongodb-database-tools\r\n初始配置\r\n我的 mongodb 是安装在 E:\\scoop\\apps\\mongodb\\current\\bin\r\n位置\r\n\r\n打开 E:\\scoop\\apps\\mongodb\\current\\bin\\mongod.cfg\r\n文件，配置相关参数。\r\n# Where and how to store data.storage  dbPath: D:\\Applications\\Scoop\\apps\\mongodb\\4.2.7\\data  journal:    enabled: true#  engine:#  mmapv1:#  wiredTiger:# where to write logging data.systemLog:  destination: file  logAppend: true  path:  D:\\Applications\\Scoop\\apps\\mongodb\\4.2.7\\log\\mongod.log# network interfacesnet:  port: 27017  bindIp: 127.0.0.1\r\ndbPath 设置数据保存的路径\r\nsystemLog:path 设置日志的保存路径\r\n以管理员身份打开 cmd 窗口。\r\n输入 cd E:\\scoop\\apps\\mongodb\\current\\bin 进入到 scoop\r\n目录 E:\\scoop\\apps\\mongodb\\current\\bin 中\r\n在命令行中输入下面的命令安装 mogodb\r\nmongod --config &quot;E:\\scoop\\apps\\mongodb\\current\\bin\\mongod.cfg&quot; --install\r\n可以使用 --serviceName 和\r\n--serviceDisplayName 指定服务名，从而可以安装多个 mogodb\r\n实例\r\n启动 mongodb 服务\r\nnet start mongodb\r\n\r\n设置用户名和密码\r\n设置超级管理员\r\n\r\n在命令行中输入 mongo 进入mongodb的交互界面\r\n在 admin 库中添加 admin 角色\r\nuse admin  db.createUser(&#123;  user: &#x27;admin&#x27;,  // 用户名  pwd: &#x27;123456&#x27;,  // 密码  roles:[&#123;    role: &#x27;root&#x27;,  // 角色    db: &#x27;admin&#x27;  // 数据库  &#125;]&#125;)\r\n设置完成，可以输入 show users\r\n查看是否设置成功。\r\n开启验证\r\n找到 MongoDB 安装目录，打开\r\nmongod.cfg文件，找到以下这句：\r\n将\r\n#security:\r\n改为\r\nsecurity:  authorization: enabled\r\n重启 mongodb\r\n在cmd窗口中\r\nnet stop mongodbnet start mongodb\r\n也可以在任务管理器中找到相应的服务，然后重新启动\r\n登陆数据库\r\n// 方式一mongouse admindb.auth(&#x27;admin&#x27;, &#x27;123456&#x27;)// 方式二mongo admin -u admin -p 123456\r\n这时候我们就可以正常访问和操作数据了。\r\n\r\n添加数据库用户\r\n我们除了可以设置数据库的超级管理员以外，还可以给每个数据库设置单独的管理员。其只有操作单独数据的一定权限。\r\nuse test  // 跳转到需要添加用户的数据库db.createUser(&#123;  user: &#x27;fooadmin&#x27;,  // 用户名  pwd: &#x27;123456&#x27;,  // 密码  roles:[&#123;    role: &#x27;readWrite&#x27;,  // 角色    db: &#x27;test&#x27;  // 数据库名  &#125;]&#125;)\r\n常用命令\r\nshow users  // 查看当前库下的用户db.dropUser(&#x27;testadmin&#x27;)  // 删除用户db.updateUser(&#x27;admin&#x27;, &#123;pwd: &#x27;654321&#x27;&#125;)  // 修改用户密码db.auth(&#x27;admin&#x27;, &#x27;654321&#x27;)  // 密码认证\r\nMongoDB 数据库默认角色\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n分类\r\nrole(角色)\r\n简要说明\r\n\r\n\r\n\r\n\r\n数据库用户角色(DB User Roles)\r\nread\r\nreadWrite\r\n为某个数据库创建一个用户,\r\n分配该数据库的读写权力\r\n\r\n\r\n数据库管理员角色(DB Admin Roles)\r\ndbAdmin dbOwner\r\nuserAdmin\r\n拥有创建数据库, 和创建用户的权力\r\n\r\n\r\n集群管理角色(Culster Administration\r\nRoles)\r\nclusterAdmin\r\nclusterManager clusterMonitor\r\nhostManager\r\n管理员组, 针对整个系统进行管理\r\n\r\n\r\n备份还原角色(Backup and Restoration\r\nRoles)\r\nbackup\r\nrestore\r\n备份数据库, 还原数据库\r\n\r\n\r\n所有数据库角色(All-Database Roles)\r\nreadAnyDatabase\r\nreadWriteAnyDatabase userAdminAnyDatabase\r\ndbAdminAnyDatabase\r\n拥有对admin操作的权限\r\n\r\n\r\nSuperuser Roles(超级管理员)\r\nroot\r\ndbOwner\r\nuserAdmin\r\nuserAdminAnyDatabase这几个角色角色提供了任何数据任何用户的任何权限的能力，拥有这个角色的用户可以在任何数据库上定义它们自己的权限\r\n\r\n\r\n\r\n","categories":["Develop","Database","Mongodb"],"tags":["MongoDB"]},{"title":"mongodb 配置副本集","url":"/posts/2021/28R2YWM.html","content":"什么是MongoDB副本集\r\n副本集是一组mongod维护相同数据集的实例。\r\n\r\n\r\n它提供了数据的冗余备份，并在多个服务器上存储数据副本，提高了数据的可用性，\r\n并可以保证数据的安全性；还允许您从硬件故障和服务中断中恢复数据；实现自动故障转移，还可以采用分布式方式读取数据。\r\n副本集的原理\r\nmongodb的复制至少需要两个节点。其中一个是主节点，负责处理客户端请求，其余的都是从节点，负责复制主节点上的数据。mongodb各个节点常见的搭配方式为：一主一从、一主多从。\r\n主节点记录在其上的所有操作oplog，从节点定期轮询主节点获取这些操作，然后对自己的数据副本执行这些操作，从而保证从节点的数据与主节点一致。\r\n通过在不同数据库服务器上提供多个数据副本，复制可提供一定级别的容错功能，以防止丢失单个数据库服务器。\r\n配置流程\r\n新建目录\r\n新建一个副本集数据目录。可以将下面的内容保存为 .bat 文件\r\ncd D:\\Scoop\\persist\\mongodb\\current\\data# 创建副本集目录mkdir replicaSetcd replicaSet# 创建分级目录mkdir -p confs,key,log,replSet1,replSet2,replSet3\r\n生成密钥\r\n利用 openssl 生成密钥。可以使用 scoop 安装 openssl。\r\ncd keyopenssl rand -base64 756 &gt; rs-key\r\n修改配置文件\r\n在 confs 目录新建下列文件：\r\ncd ../confs// 新建下列 3 个文件echo &quot;# mongodb config&quot; &gt; mongodb27018.confecho &quot;# mongodb config&quot; &gt; mongodb27019.confecho &quot;# mongodb config&quot; &gt; mongodb27020.conf\r\n以下列文件内容为模板，分别修改其副本集配置：\r\n# mongod.conf# for documentation of all options, see:# http://docs.mongodb.org/manual/reference/configuration-options/# Where and how to store data.storage:  dbPath: D:\\Program Files\\Scoop\\apps\\mongodb\\current\\data\\rs\\replSet1  journal:    enabled: true#  engine:#  mmapv1:#  wiredTiger:# where to write logging data.systemLog:  destination: file  logAppend: true  path:  D:\\Program Files\\Scoop\\apps\\mongodb\\current\\data\\rs\\log\\replSet1.log# network interfacesnet:  port: 27018  bindIp: 127.0.0.1# 如果需要局域网访问，上述 bindIp 应为 0.0.0.0#processManagement:#security:security:  authorization: enabled  keyFile: D:\\Program Files\\Scoop\\apps\\mongodb\\current\\data\\rs\\key\\rs-key#operationProfiling:#replication:replication:  oplogSizeMB: 2048  replSetName: rs_auth#sharding:## Enterprise-Only Options:#auditLog:#snmp:\r\n安装服务\r\n使用管理员打开 PowerShell，运行如下指令：\r\n# 进入到目录cd ..\\..\\..\\bin\\./mongod.exe --config &quot;D:\\Program Files\\Scoop\\apps\\mongodb\\current\\data\\rs\\confs\\mongodb27018.conf&quot; --serviceName mongodb27018 --install./mongod.exe --config &quot;D:\\Program Files\\Scoop\\apps\\mongodb\\current\\data\\rs\\confs\\mongodb27019.conf&quot; --serviceName mongodb27019 --install./mongod.exe --config &quot;D:\\Program Files\\Scoop\\apps\\mongodb\\current\\data\\rs\\confs\\mongodb27020.conf&quot; --serviceName mongodb27020 --install\r\n\r\n注意：\r\n\r\n要用管理员身份运行命令\r\n提示\r\nError parsing command line:  Multiple occurrences of option \"--config\r\n错误\r\n这种情况是使用了 mongod 命令导致的，一定要跳转到\r\nmongod.exe 目录执行 mongod 命令\r\n--config 后面的路径要全路径\r\n在命令行中，路径中有空格时，一定要加引号\r\n\r\n\r\n启动服务\r\nnet start mongodb27018net start mongodb27019net start mongodb27020\r\n\r\n若三个服务不能启动，请检查配置文件中的 dbPath\r\n是否重复\r\n\r\n初始化副本集\r\n使用 PowerShell 连接 mongoDB，连接任意一个端口即可。\r\nmongo --host 127.0.0.1 --port 27018# 切换到 adminuse admin# 定义配置文件# 配置中的 host 必须是本机的 ip，不能是 127.0.0.1，否则局域网无法访问# 如果要通过域名访问，则必须是域名rsconf = &#123;  _id: &quot;rs_share&quot;,  members: [    &#123;      _id: 0,      host: &quot;192.168.23.1:27018&quot;    &#125;,    &#123;      _id: 1,      host: &quot;192.168.23.1:27019&quot;    &#125;,    &#123;      _id: 2,      host: &quot;192.168.23.1:27020&quot;    &#125;  ]&#125;# 初始化副本集rs.initiate(rsconf)\r\n当出现如下提示时，说明成功了：\r\n&#123; &quot;ok&quot; : 1 &#125;rs_auth:SECONDARY&gt;\r\n新建用户\r\n继上述 Shell 进行操作，新建用户：\r\ndb.createUser(&#123;user:&quot;root&quot;,pwd:&quot;root8888&quot;,roles:[&#123;role:&quot;userAdminAnyDatabase&quot;,db:&quot;admin&quot;&#125;]&#125;)\r\n如果需要改密码，可以:\r\nmongo --host 127.0.0.1 --port 27018 -u root -p root8888use admindb.changeUserPassword(&#x27;root&#x27;,&#x27;newpassword&#x27;)# 检验密码修改情况db.auth(&#x27;username&#x27;,&#x27;password&#x27;)\r\n新建账号后，需要重新连接 mongo：\r\nexit# 重新连接mongo --host 127.0.0.1 --port 27018 -u root -p root8888use admindb.grantRolesToUser(&quot;root&quot;, [&quot;clusterAdmin&quot;])# 将数据库 mongodbshare 权限赋予 rootdb.grantRolesToUser(&quot;root&quot;, [&#123;role: &quot;read&quot;, db: &#x27;mongodbshare&#x27;&#125;])db.grantRolesToUser(&quot;root&quot;, [&#123;role: &quot;root&quot;, db: &#x27;admin&#x27;&#125;])\r\n事务超时设置\r\n这种方式在数据库重启后，会重置设置，需要在配置文件中定义。\r\ndb.adminCommand( &#123; getParameter: 1, transactionLifetimeLimitSeconds: 1 &#125; )  # 默认是60db.adminCommand( &#123; getParameter: 1, maxTransactionLockRequestTimeoutMillis: 1 &#125; ) # 默认是5db.adminCommand( &#123; setParameter: 1, transactionLifetimeLimitSeconds: 300 &#125; ) # 修改事务超时时间为5分钟开启事务支持db.adminCommand( &#123; setParameter: 1, maxTransactionLockRequestTimeoutMillis: 20 &#125; ) # 修改事务获取锁的等待时间20毫秒\r\n\r\n操作时，要连接主节点\r\n\r\nMongoose 连接副本集\r\nmongoose 中 url 的连接语句如下：\r\n&#123;    url: &#x27;mongodb://root:root8888@127.0.0.1:27026,127.0.0.1:27027,127.0.0.1:27028/iepAuth?authSource=admin&amp;replicaSet=rs_auth&#x27;,&#125;\r\n备份与还原\r\n备份与还原需要 mongodump 程序，该程序可由\r\nscoop 安装。\r\ndump:\r\nmongodump -h localhost:27017 -d databaseName -u test -p testpwd -o D:\\dump --authenticationDatabase admin\r\n\r\n-h 地址\r\n-d 数据库名称\r\n-u 用户名\r\n-p 密码\r\n-o 输出地址\r\n--authenticationDatabase admin 验证账户的数据库\r\n\r\nrestore:\r\nmongorestore -h localhost:27018 -u root -p whfy8888 --authenticationDatabase admin --objcheck --nsInclude=swcooperation.* --dir D:\\dump\r\n修改 rs 中的 config\r\n假如要修改 rs 中 config 里面第一个 mongodb 实例的 host\r\n值，配置方式如下：\r\n# 进入数据库mongo --host 127.0.0.1 --port 27018 -u root -p root8888use adminvar config = rs.config()config.members[0].host = &quot;yourdomain.com&quot;rs.reconfig(config)\r\n修改密码\r\n# 进入数据库mongo --host 127.0.0.1 --port 27018 -u root -p root8888# 切换到 adminuse admin# 修改密码db.changeUserPassword(&quot;root&quot;,&quot;newPassword&quot;)\r\n参考\r\n\r\nMongoDB\r\n逻辑还原工具mongorestore\r\nHow\r\nto manage users and authentication in MongoDB\r\n\r\n","categories":["Develop","Database","Mongodb"],"tags":["MongoDB"]},{"title":"mongodb实用技巧总结","url":"/posts/2020/1TF781D.html","content":"后端使用mongodb作为数据库，有时候会面对各种需求，google\r\n太费时间，所以将自己使用过的一些技巧总结出来。\r\n\r\n增\r\n删\r\n查\r\n批量更新文档中数组对象里面的某个字段\r\n\r\n文档示例\r\n&#123;    _id: ObjectId(&#x27;5f68710c4da61820f461e0b8&#x27;)    name: &#x27;zhangsan&#x27;,    freinds:[        &#123;name:&#x27;lisi&#x27;,age:18&#125;,        &#123;name:&#x27;xiaowang&#x27;,age:20&#125;,    ]&#125;\r\n目标\r\n文档如上，假如现在我们需要更新 freinds\r\n中小王（xiaowang）的年龄，但是同时，我们也不知道小王这个元素位于数组的下标索引。\r\n查询\r\nconst person = await collection.findById(&#x27;5f68710c4da61820f461e0b8&#x27;);const index = person.freinds.findIndex(f=&gt;f.name===&#x27;xiaowang&#x27;);const freind = person.freinds[index];freind.age = 22; // 修改年龄// 如果是修改 freind 中原有的字段，这句可以不要// 如果是新增字段，这句就必须加上，否则 save 会失效person.freinds.splice(index,1,freind);person.save();\r\n\r\n改\r\n疑问解答\r\n","categories":["Develop","Database","Mongodb"],"tags":["MongoDB"]},{"title":"mongodb 删除服务","url":"/posts/2021/BSGCK7.html","content":"MongoDB 安装的服务不能使用 sc delete serviceName\r\n来进行删除，需使用 mongod 命令。\r\n\r\n删除代码：mongod --remove --serviceName serviceName\r\n","categories":["Develop","Database","Mongodb"],"tags":["MongoDB"]},{"title":"mongodb对自定义字段排序后limit为乱序","url":"/posts/2021/1K2Y9FK.html","content":"在使用 mongodb\r\n中，遇到这样一个问题：在对集合进行聚合查询的过程中，通过\r\n$project 添加了一个新字段，然后根据这个新字段进行\r\n$sort 排序，最后再使用 $limit\r\n获取数据，在这个过程中，当 $limit\r\n的值不一样的时候，获取的数据虽然排序了，但是取出的顺序却还是不一样。\r\n\r\n例如有如下数据：\r\n// students 集合[&#123;    name: &#x27;name-1&#x27;    age: 18&#125;,&#123;\tname: &#x27;name-2&#x27;,    age: 19&#125;,&#123;    name: &#x27;name-3&#x27;,    age: 18&#125;,&#123;    name: &#x27;name-4&#x27;,    age: 18&#125;,&#123;    name: &#x27;name-5&#x27;,    age: 18&#125;,]\r\n使用 aggrergate 查询：\r\ndb.students.aggregate([    &#123;        $sort:&#123;            age: 1        &#125;    &#125;,    &#123;        $limit: 2    &#125;])\r\n在上述查询中，不同的 $limit\r\n值，查询出来的结果的顺序不是一致的。\r\n经查，这是由于 $sort\r\n字段的值相同导致的，通过查看官方文档 Version\r\n5.0 文档，其中对于 `$sort 一致性的说明如下：\r\n\r\nMongoDB does not store documents in a collection in a particular\r\norder. When sorting on a field which contains duplicate values,\r\ndocuments containing those values may be returned in any order.\r\nIf consistent sort order is desired, include at least one field in\r\nyour sort that contains unique values. The easiest way to guarantee this\r\nis to include the _id field in your sort query.\r\nMongoDB\r\n在集合中存储文档的顺序是不定的，当对一个有重复值的字段排序时，包含这些值的文档可能会以任意顺序返回。\r\n如果想要保持顺序的一致性，在 sort\r\n语句中应至少保证有一个字段是唯一的。最方便的方式就是在 sort 中包含 _id\r\n字段。\r\n\r\n最后，将上述聚合查询改成如下便可恢复正常：\r\ndb.students.aggregate([    &#123;        // 先按 age 排序，再按 _id 排序        $sort:&#123;            age: 1,            _id: 1,        &#125;    &#125;,    &#123;        $limit: 2    &#125;])\r\n","categories":["Develop","Database","Mongodb"],"tags":["MongoDB"]},{"title":"mongodb 数组求和问题","url":"/posts/2021/3HKW9DE.html","content":"mongodb 中求和有两种方法可以进行数组求和，一种是分组求和，一种是\r\nreduce 求和，但是前者在与 $unwind\r\n联合使用的时候，会出现一些意想不到的问题，推荐使用第二种方式\r\n\r\n假设\r\n假设分别有如下集合：\r\n\r\nstudent，学生表\r\n[    &#123;        name: &#x27;user1&#x27;,        age: 18,    &#125;,    &#123;        name: &#x27;user2&#x27;,        age: 19,    &#125;,    &#123;        name: &#x27;user3&#x27;,        age: 18,    &#125;]\r\nachievement，成绩表\r\n[    &#123;\t\tname: &#x27;user1&#x27;,\t\tcourseName:&#x27;语文&#x27;,\t\tscore: &#x27;99&#x27;    &#125;,\t&#123;\t\tname: &#x27;user1&#x27;,\t\tcourseName:&#x27;数学&#x27;,\t\tscore: &#x27;98&#x27;    &#125;,    &#123;\t\tname: &#x27;user2&#x27;,\t\tcourseName:&#x27;语文&#x27;,\t\tscore: &#x27;100&#x27;    &#125;,\t&#123;\t\tname: &#x27;user2&#x27;,\t\tcourseName:&#x27;数学&#x27;,\t\tscore: &#x27;100&#x27;    &#125;,]\r\n\r\n需求\r\n\r\n求学生的平均年龄\r\n求每个学生的总分数\r\n\r\n解决方法\r\n\r\n针对第一种需求，直接一个聚合就搞定\r\ndb.aggregate([&#123;    $group:&#123;        _id:null,        studentsCount: &#123; $sum: 1 &#125;        studentsAge: &#123; $sum: &#x27;$age&#x27; &#125;    &#125;&#125;])// 结果[    &#123;        studentsCount: 3,        studentsAge: 55    &#125;]\r\n对第二种需求，就要分步讨论了。\r\n\r\nachievement 集合中，每个学生都有分数录入\r\n\r\ndb.aggregate([    &#123;        $lookup:&#123;            from: &#x27;achievement&#x27;,            localField: &#x27;name&#x27;,            foreignField: &#x27;name&#x27;,            as: &#x27;achievements&#x27;        &#125;    &#125;,    &#123;        $unwind:&#x27;$achievements&#x27;    &#125;,    &#123;        $group:&#123;        _id:null,        name: &#x27;$name&#x27;,        totalScore: &#123; $sum: &#x27;$achievements.score&#x27; &#125;    \t&#125;    &#125;])\r\n\r\n像上面记录那样，user3 的分数还没有录入\r\n\r\n在 user3\r\n还没有分数记录的时候，如果上面的聚合查询，由于使用了\r\n$unwind，这就会导致一个问题，输出的成果里面，我们会发现，user3\r\n丢失了。\r\n这是由于 $unwind 的特性导致的。官方的解释如下：\r\nDeconstructs an array field from the input documents to output a document for each element. Each output document is the input document with the value of the array field replaced by the element.解构数组的每个元素。输入文档的数组字段的值被数组元素替换后生成输出文档。\r\n所以，从上面可以知道，因为 $lookup\r\n后，user3 的 achievements\r\n为空，导致解析时，就会丢失 user3，而我们想要的是，每一个\r\nuser 都有一个 totalScore，如果数组为空，就显示 0。\r\n所以，上述的分组求和不能满足我们的需求，我们可以采用\r\n$project 来解决这个问题，代码如下：\r\ndb.aggregate([    &#123;        $lookup:&#123;            from: &#x27;achievement&#x27;,            localField: &#x27;name&#x27;,            foreignField: &#x27;name&#x27;,            as: &#x27;achievements&#x27;        &#125;   &#125;,   &#123;       $project:&#123;           name: 1,           totalScore:&#123;               // 使用方法见：https://docs.mongodb.com/manual/reference/operator/aggregation/reduce/               $reduce:&#123;                   input: &#x27;$achievements&#x27;,                   initialValue: 0,                   in: &#123;                     $add: [&quot;$$value&quot;, &quot;$$this.score&quot;],                   &#125;,               &#125;           &#125;       &#125;   &#125;])\r\n\r\n","categories":["Develop","Database","Mongodb"],"tags":["MongoDB"]},{"title":"mongodb 事务的使用及注意事项","url":"/posts/2022/KBYMHE.html","content":"会话 Session\r\nSession 是 MongoDB 3.6 之后引入的概念，在以前的版本中，Mongod\r\n进程中的每一个请求会创建一个上下文（OperationContext），可以理解为一个单行事务，这个单行事务中对于数据、索引、oplog\r\n的修改都是原子性的。\r\nMongoDB 3.6 之后的 Session 本质上也是一个上下文，在这个 Session\r\n会话中多个请求共享一个上下文，为多文档事务实现提供了基础。\r\n\r\n事务函数\r\n\r\nstartTransaction()\r\n开启一个新的事务，之后即可进行 CRUD 操作。\r\ncommitTransaction()\r\n提交事务保存数据，在提交之前事务中的变更的数据对外是不可见的。\r\nabortTransaction()\r\n事务回滚，例如，一部分数据更新失败，对已修改过的数据也进行回滚。\r\nendSession()\r\n结束本次会话。\r\n\r\nNodejs 中事务实例\r\nconst db = require(&#x27;./db&#x27;);const testTransaction = async (goodId) =&gt; &#123;  const client = await db.dbInstance();  const transactionOptions = &#123;    readConcern: &#123; level: &#x27;majority&#x27; &#125;,    writeConcern: &#123; w: &#x27;majority&#x27; &#125;,    readPreference: &#x27;primary&#x27;,  &#125;;  const session = client.startSession();  console.log(&#x27;事务状态：&#x27;, session.transaction.state);  try &#123;    session.startTransaction(transactionOptions);    console.log(&#x27;事务状态：&#x27;, session.transaction.state);    const goodsColl = await client.db(&#x27;test&#x27;).collection(&#x27;goods&#x27;);    const orderGoodsColl = await client.db(&#x27;test&#x27;).collection(&#x27;order_goods&#x27;);    const &#123; stock, price &#125; = await goodsColl.findOne(&#123; goodId &#125;, &#123; session &#125;);        console.log(&#x27;事务状态：&#x27;, session.transaction.state);        if (stock &lt;= 0) &#123;        throw new Error(&#x27;库存不足&#x27;);    &#125;    await goodsColl.updateOne(&#123; goodId &#125;, &#123;        $inc: &#123; stock: -1 &#125; // 库存减 1    &#125;)    await orderGoodsColl.insertOne(&#123; id: Math.floor(Math.random() * 1000),  goodId, price  &#125;, &#123; session &#125;);    await session.commitTransaction();  &#125; catch(err) &#123;    console.log(`[MongoDB transaction] ERROR: $&#123;err&#125;`);    await session.abortTransaction();  &#125; finally &#123;    await session.endSession();    console.log(&#x27;事务状态：&#x27;, session.transaction.state);  &#125;&#125;testTransaction(&#x27;g1000&#x27;)\r\n运行测试结果：\r\nnode index事务状态： NO_TRANSACTION事务状态： STARTING_TRANSACTION事务状态： TRANSACTION_IN_PROGRESS事务状态： TRANSACTION_COMMITTED\r\nmogoose 中支持事务的方法\r\n\r\n\r\n\r\n说明\r\n方法名\r\n备注\r\n\r\n\r\n\r\n\r\n新建文档\r\ncreate(docs,options)\r\n一定要传入数组，使用它的重载方法\r\n\r\n\r\n\r\n注意事项\r\n\r\n在事务中，只能使用事务语句进行操作，不能与普通语句混用\r\n\r\n","categories":["Develop","Database","Mongodb"],"tags":["MongoDB","Database"]},{"title":"mongodb 中查询嵌入或多级文档","url":"/posts/2022/YNTT64.html","content":"本文总结了如何在 mongoDB 中查询嵌入或多级文档（Embedded/Nested\r\nDocument）。\r\n\r\n集合数据\r\n假设有如下文档，集合名称为 inventory\r\ndb.collection(&#x27;inventory&#x27;).insertMany([  &#123;    item: &#x27;journal&#x27;,    qty: 25,    size: &#123; h: 14, w: 21, uom: &#x27;cm&#x27; &#125;,    status: &#x27;A&#x27;  &#125;,  &#123;    item: &#x27;notebook&#x27;,    qty: 50,    size: &#123; h: 8.5, w: 11, uom: &#x27;in&#x27; &#125;,    status: &#x27;A&#x27;  &#125;,  &#123;    item: &#x27;paper&#x27;,    qty: 100,    size: &#123; h: 8.5, w: 11, uom: &#x27;in&#x27; &#125;,    status: &#x27;D&#x27;  &#125;,  &#123;    item: &#x27;planner&#x27;,    qty: 75,    size: &#123; h: 22.85, w: 30, uom: &#x27;cm&#x27; &#125;,    status: &#x27;D&#x27;  &#125;,  &#123;    item: &#x27;postcard&#x27;,    qty: 45,    size: &#123; h: 10, w: 15.25, uom: &#x27;cm&#x27; &#125;,    status: &#x27;A&#x27;  &#125;]);\r\n匹配整个子文档\r\n使用 query\r\nfilter document { &lt;field&gt;: &lt;value&gt; }\r\n来匹配子文档。\r\n例：\r\n// 查询db.inventory.find(&#123;    // size 只有整个对象完全匹配时，才返回，不支持多级嵌套匹配\tsize: &#123; h: 14, w: 21, uom: &#x27;cm&#x27; &#125;&#125;)// 结果&#123;    &quot;_id&quot;: ObjectId(&quot;6245387e951c0000ea00145b&quot;),    &quot;item&quot;: &quot;journal&quot;,    &quot;qty&quot;: 25,    &quot;size&quot;: &#123;        &quot;h&quot;: 14,        &quot;w&quot;: 21,        &quot;uom&quot;: &quot;cm&quot;    &#125;,    &quot;status&quot;: &quot;A&quot;&#125;\r\n注意：\r\n查询不支持多级嵌套匹配。size\r\n只有整个对象完全匹配时，才返回。下面的查询的结果为空：\r\ndb.inventory.find(&#123;\tsize: &#123; h: 8.5 &#125;&#125;)\r\n匹配嵌套字段\r\n使用 dot\r\nnotation field.nestedField 来进行嵌套匹配查询。\r\ndb.inventory.find(&#123;  &quot;size.h&quot;: 10&#125;)// 返回结果&#123;    &quot;_id&quot;: ObjectId(&quot;6245387e951c0000ea00145f&quot;),    &quot;item&quot;: &quot;postcard&quot;,    &quot;qty&quot;: 45,    &quot;size&quot;: &#123;        &quot;h&quot;: 10,        &quot;w&quot;: 15.25,        &quot;uom&quot;: &quot;cm&quot;    &#125;,    &quot;status&quot;: &quot;A&quot;&#125;\r\n使用查询操作符匹配\r\n在使用 query filter document 时，可以使用 query\r\noperators 来进行更复杂的查询。\r\n格式：\r\n&#123; &lt;field1&gt;: &#123; &lt;operator1&gt;: &lt;value1&gt; &#125;, ... &#125;\r\n查询示例：\r\ndb.inventory.find(&#123;  &#x27;size.h&#x27;: &#123; $lt: 15 &#125;,  &#x27;size.uom&#x27;: &#x27;in&#x27;,  status: &#x27;D&#x27;&#125;)\r\n其它\r\n本文中提供的示例代码运行平台为 Navicat。在 nodejs 中也同样适用。\r\n参考\r\n\r\nQuery\r\non Embedded/Nested Documents\r\nQuery\r\nand Projection Operators — MongoDB Manual\r\nDot\r\nNotation\r\n\r\n","categories":["Develop","Database","Mongodb"],"tags":["MongoDB"]},{"title":"mongodb 基本数组查询","url":"/posts/2022/3S2R3P0.html","content":"本文总结了如何在 mongoDB\r\n中对基本数组（数组中包含基本类型的元素）进行查询。\r\n\r\n集合数据\r\n假设有如下文档，集合名为 inventory。\r\ndb.collection(&#x27;inventory&#x27;).insertMany([  &#123;    item: &#x27;journal&#x27;,    qty: 25,    tags: [&#x27;blank&#x27;, &#x27;red&#x27;],    dim_cm: [14, 21]  &#125;,  &#123;    item: &#x27;notebook&#x27;,    qty: 50,    tags: [&#x27;red&#x27;, &#x27;blank&#x27;],    dim_cm: [14, 21]  &#125;,  &#123;    item: &#x27;paper&#x27;,    qty: 100,    tags: [&#x27;red&#x27;, &#x27;blank&#x27;, &#x27;plain&#x27;],    dim_cm: [14, 21]  &#125;,  &#123;    item: &#x27;planner&#x27;,    qty: 75,    tags: [&#x27;blank&#x27;, &#x27;red&#x27;],    dim_cm: [22.85, 30]  &#125;,  &#123;    item: &#x27;postcard&#x27;,    qty: 45,    tags: [&#x27;blue&#x27;],    dim_cm: [10, 15.25]  &#125;]);\r\n数组的精确匹配\r\n使用查询文档 { &lt;field&gt;: &lt;value&gt; }\r\n来进行集合的精确匹配。&lt;value&gt;\r\n是一个数组或者操作。\r\n// 仅当 tags 为 [&#x27;red&#x27;, &#x27;blank&#x27;] 时才返回值db.collection(&#x27;inventory&#x27;).find(&#123;  tags: [&#x27;red&#x27;, &#x27;blank&#x27;]&#125;)// 如果只保证元素一致，而不要求元素顺序时，可以用 $all 操作符进行查询db.collection(&#x27;inventory&#x27;).find(&#123;  tags: &#123; $all: [&#x27;red&#x27;, &#x27;blank&#x27;] &#125;&#125;)\r\n匹配数组中的某个元素\r\n如果要查询数组中至少有一个元素匹配给定值时，可以使用\r\n{ &lt;field&gt;: &lt;value&gt; }\r\n样式的查询文档来查询。&lt;value&gt; 是一个值。\r\n// 返回 tags 中包含 &#x27;red&#x27; 的文档db.collection(&#x27;inventory&#x27;).find(&#123;  tags: &#x27;red&#x27;&#125;)\r\nvalue 也可以是查询过滤文档\r\n(query filter document):\r\ndb.collection(&#x27;inventory&#x27;).find(&#123;  dim_cm: &#123; $gt: 25 &#125;&#125;);\r\n\r\n这种情况下的查询，可以将数组直接看成一个值就可以。\r\n\r\n对数组中的某个元素进行多条件匹配\r\n数组中多个元素共同满足一组条件\r\n下列查询中，当满足以下情况之一时，会有返回值：\r\n\r\ndim_cm 中一个元素满足\r\n$lt: 15，另一个元素满足$gt: 20\r\ndim_cm 中一个元素同时满足条件\r\n\r\ndb.collection(&#x27;inventory&#x27;).find(&#123;  dim_cm: &#123; $lt: 15, $gt: 20 &#125;&#125;,&#123; item:1,dim_cm:1&#125;)// 返回// 1&#123;    &quot;_id&quot;: ObjectId(&quot;6245ad716c0b0000c00070a3&quot;),    &quot;item&quot;: &quot;journal&quot;,    &quot;dim_cm&quot;: [        14,        21    ]&#125;// 2&#123;    &quot;_id&quot;: ObjectId(&quot;6245ad716c0b0000c00070a4&quot;),    &quot;item&quot;: &quot;notebook&quot;,    &quot;dim_cm&quot;: [        14,        21    ]&#125;// 3&#123;    &quot;_id&quot;: ObjectId(&quot;6245ad716c0b0000c00070a5&quot;),    &quot;item&quot;: &quot;paper&quot;,    &quot;dim_cm&quot;: [        14,        21    ]&#125;\r\n数组中任一个元素同时满足一组条件\r\ndb.collection(&#x27;inventory&#x27;).find(&#123;  // dim_cm 中每一个元素都必须同时满足下列条件时才返回  dim_cm: &#123; $elemMatch: &#123; $gt: 22, $lt: 30 &#125; &#125;&#125;)\r\n匹配数组中特定序号的元素\r\n可以通过 . 点来匹配数组下标，下标从 0 开始。\r\n// 查询第二个元素是否满足条件db.collection(&#x27;inventory&#x27;).find(&#123;  &#x27;dim_cm.1&#x27;: &#123; $gt: 25 &#125;&#125;);\r\n匹配特定长度的数组\r\n// 返回 tags 中有 3 个元素的文档db.collection(&#x27;inventory&#x27;).find(&#123;  tags: &#123; $size: 3 &#125;&#125;);\r\n参考\r\n\r\nQuery\r\nan Array\r\n\r\n","categories":["Develop","Database","Mongodb"],"tags":["MongoDB"]},{"title":"mongodb 对象数组查询","url":"/posts/2022/SDER9X.html","content":"本文总结了如何在 mongoDB\r\n中对对象数组（数组中包含的元素类型是对象）进行查询。\r\n\r\n集合数据\r\n假设有如下文档，集合名为 ventory。\r\ndb.collection(&#x27;inventory&#x27;).insertMany([  &#123;    item: &#x27;journal&#x27;,    instock: [      &#123; warehouse: &#x27;A&#x27;, qty: 5 &#125;,      &#123; warehouse: &#x27;C&#x27;, qty: 15 &#125;    ]  &#125;,  &#123;    item: &#x27;notebook&#x27;,    instock: [&#123; warehouse: &#x27;C&#x27;, qty: 5 &#125;]  &#125;,  &#123;    item: &#x27;paper&#x27;,    instock: [      &#123; warehouse: &#x27;A&#x27;, qty: 60 &#125;,      &#123; warehouse: &#x27;B&#x27;, qty: 15 &#125;    ]  &#125;,  &#123;    item: &#x27;planner&#x27;,    instock: [      &#123; warehouse: &#x27;A&#x27;, qty: 40 &#125;,      &#123; warehouse: &#x27;B&#x27;, qty: 5 &#125;    ]  &#125;,  &#123;    item: &#x27;postcard&#x27;,    instock: [      &#123; warehouse: &#x27;B&#x27;, qty: 15 &#125;,      &#123; warehouse: &#x27;C&#x27;, qty: 35 &#125;    ]  &#125;]);\r\n在集合中精确匹配一个完整的嵌套文档\r\n// 仅当 instock 中有元素为 &#123; warehouse: &#x27;A&#x27;, qty: 5 &#125; 时才返回db.collection(&#x27;inventory&#x27;).find(&#123;  instock: &#123; warehouse: &#x27;A&#x27;, qty: 5 &#125;&#125;)// 结果// 1&#123;    &quot;_id&quot;: ObjectId(&quot;6245b2876c0b0000c00070a8&quot;),    &quot;item&quot;: &quot;journal&quot;,    &quot;instock&quot;: [        &#123;            &quot;warehouse&quot;: &quot;A&quot;,            &quot;qty&quot;: 5        &#125;,        &#123;            &quot;warehouse&quot;: &quot;C&quot;,            &quot;qty&quot;: 15        &#125;    ]&#125;\r\n该查询同匹配数组中的某个基本元素一样的原理。\r\n对数组中文档的某个字段按条件匹配\r\n按数组中对象的某个字段匹配\r\n// 只要数组中有一个元素的 qty 满足条件就返回值db.collection(&#x27;inventory&#x27;).find(&#123;  &#x27;instock.qty&#x27;: &#123; $lte: 20 &#125;&#125;)\r\n按数组中特定位置对象的某个字段匹配\r\n数组中元素的索引从 0 开始。\r\n// 当 instock 数组中第 1 个元素的 qty 满足条件时返回db.collection(&#x27;inventory&#x27;).find(&#123;  &#x27;instock.0.qty&#x27;: &#123; $lte: 20 &#125;&#125;);\r\n对数组中的文档进行多条件匹配\r\n数组中多个元素共同满足一组条件\r\n下列查询中，当满足以下情况之一时，会有返回值：\r\n\r\ninstock 中的一个元素有字段 qty 且满足\r\n$gt: 15，另一个元素也有字段 qty\r\n且满足$lte: 20\r\ninstock 中的一个元素有字段 qty\r\n且同时满足匹配条件\r\n\r\ndb.collection(&#x27;inventory&#x27;).find(&#123;  &#x27;instock.qty&#x27;: &#123; $gt: 10, $lte: 20 &#125;&#125;);\r\n下列查询中，当满足以下情况之一时，会有返回值：\r\n\r\ninstock 中的一个元素有字段 qty 且值为\r\n5，另一个元素有字段 warehouse 且值为\r\nA\r\ninstock 中的一个元素有字段 qty 且值为\r\n5，该元素同时有字段 warehouse 且值为\r\nA\r\n\r\ndb.collection(&#x27;inventory&#x27;).find(&#123;  &#x27;instock.qty&#x27;: 5,  &#x27;instock.warehouse&#x27;: &#x27;A&#x27;&#125;)\r\n\r\n这种匹配机制概括为：\r\n只要条件被数组中的元素共同满足后，就会返回。就像工作中分配任务一样，只要任务被完成，具体的完成人有几个可以不用关心。\r\n\r\n数组中任一个元素同时满足一组条件\r\ndb.collection(&#x27;inventory&#x27;).find(&#123;  instock: &#123; $elemMatch: &#123; qty: 5, warehouse: &#x27;A&#x27; &#125; &#125;&#125;)// 结果// 1&#123;    &quot;_id&quot;: ObjectId(&quot;6245b2876c0b0000c00070a8&quot;),    &quot;item&quot;: &quot;journal&quot;,    &quot;instock&quot;: [        &#123;            &quot;warehouse&quot;: &quot;A&quot;,            &quot;qty&quot;: 5        &#125;,        &#123;            &quot;warehouse&quot;: &quot;C&quot;,            &quot;qty&quot;: 15        &#125;    ]&#125;\r\n参考\r\n\r\nQuery\r\nan Array of Embedded Documents\r\n\r\n","categories":["Develop","Database","Mongodb"],"tags":["MongoDB"]},{"title":"mongodb 中 project 时取数组的最后一个值","url":"/posts/2022/N9NB2K.html","content":"在 mongodb 中进行 project\r\n时，可以通过如下方法来获取数组中的最后一个值。\r\n\r\n正文\r\n$arrayElemAt (aggregation)\r\n语法：\r\n&#123; $arrayElemAt: [ &lt;array&gt;, &lt;idx&gt; ] &#125;\r\n\r\nidx 计数从 0 开始\r\n为正时，从前向后遍历\r\n为负时，从后向前遍历\r\n\r\n示例:\r\n&#123; $arrayElemAt: [ &lt;array&gt;, -1 ] &#125;\r\n\r\nv3.2 新增\r\n\r\n$last\r\n语法：\r\n&#123; $last: &lt;expression&gt; &#125;\r\n该语法是\r\n{ $arrayElemAt: [ &lt;array expression&gt;, -1 ] }\r\n的语法糖\r\n\r\nv4.4 新增\r\n\r\n$slice\r\n语法：\r\n&#123; $slice: [ &lt;array&gt;, &lt;position&gt;, &lt;n&gt; ] &#125;\r\n示例：\r\n&#123; $arrayElemAt: [ &lt;array&gt;, -1,1 ] &#125;\r\n参考\r\nAggregation\r\nPipeline Operators — MongoDB Manual\r\n","categories":["Develop","Database","Mongodb"],"tags":["MongoDB"]},{"title":"读mongodb使用手册笔记","url":"/posts/2020/PWMVCG.html","content":"使用mongodb已经有一段时间了，入门是从mongodb\r\n菜鸟教程入的门，工作中遇到问题就 google 或者 baidu,\r\n但是发现这样太累了，对于知识的掌握不系统，于是计划将 mongodb\r\n的官方手册读一遍，梳理一下自己对于 mongodb 的使用。\r\n\r\n聚合\r\n更新\r\n形式\r\nbulkWrite(operations, options,\r\ncallback){Promise}\r\n使用方法\r\n&#123; insertOne: &#123; document: &#123; a: 1 &#125; &#125; &#125;&#123; updateOne: &#123; filter: &#123;a:2&#125;, update: &#123;$set: &#123;a:2&#125;&#125;, upsert:true &#125; &#125;&#123; updateMany: &#123; filter: &#123;a:2&#125;, update: &#123;$set: &#123;a:2&#125;&#125;, upsert:true &#125; &#125;&#123; updateMany: &#123; filter: &#123;&#125;, update: &#123;$set: &#123;&quot;a.$[i].x&quot;: 5&#125;&#125;, arrayFilters: [&#123; &quot;i.x&quot;: 5 &#125;]&#125; &#125;&#123; deleteOne: &#123; filter: &#123;c:1&#125; &#125; &#125;&#123; deleteMany: &#123; filter: &#123;c:1&#125; &#125; &#125;&#123; replaceOne: &#123; filter: &#123;c:3&#125;, replacement: &#123;c:4&#125;, upsert:true&#125;&#125;\r\n\r\ndocument, filter, update, replacement 是描述语言\r\n比如：\r\n{ insertOne: { document: { a: 1 } } } 实际形式应为:\r\ninsertOne({a: 1})\r\n\r\n查找\r\n仅查找\r\nfind(query, options){Cursor}\r\n获取数量\r\n形式\r\n\r\ncountDocuments(query, options,\r\ncallback){Promise}\r\nestimatedDocumentCount(options,\r\ncallback){Promise}\r\n\r\n区别\r\n第一个方法速度较慢，但是获取的数量很准确。第二个方法则相反。\r\n获取某个字段的非重复值\r\ndistinct(key, query, options, callback){Promise}\r\n\r\nkey 是一个 string，不是 object\r\n\r\n索引\r\n创建索引\r\n形式\r\n\r\ncreateIndex(fieldOrSpec, options,\r\ncallback){Promise}\r\ncreateIndexes(indexSpecs, options,\r\ncallback){Promise}\r\n\r\n删除索引\r\n\r\ndropIndex(indexName, options,\r\ncallback){Promise}\r\ndropIndexes(options, callback){Promise}\r\ndropAllIndexes(callback){Promise}\r\n\r\n检测索引\r\nensureIndex(fieldOrSpec, options,\r\ncallback){Promise}\r\n判断索引是否存在，如果不存在，则新建\r\n集合\r\n删除集合\r\ndrop(options, callback){Promise}\r\n参考\r\nNode.js\r\nMongoDB Driver API\r\n","categories":["Develop","Database","Mongodb"],"tags":["MongoDB"]},{"title":"mongodb 中必须了解的关于 ObjectId 的知识","url":"/posts/2022/35RJHX8.html","content":"\r\n\r\nimage-20220426140319090\r\n\r\n\r\nObjectId 的构成\r\nObjectId 的值由 12 个字节组成，其中：\r\n\r\n4个字节表示时间戳（自 Unix\r\n纪元以来的秒数），记录创建时间；\r\n3个字节表示机器标识符，保证不同主机产生不同的 ObjectId 值；\r\n2个字节表示进程 ID，保证在同一台主机不同 MongoDB 进程产生不同的\r\nObjectId 值；\r\n3个字节表示自增计数器（以随机值开头），保证同一主机同一进程同一秒内产生\r\nObjectId 的唯一性。\r\n\r\nObjectId = 时间戳（4字节） + 机器标识码（3字节） + 进程 ID（2字节） +\r\n计数器（3字节）\r\n\r\n\r\n\r\n1\r\n\r\n\r\n2\r\n\r\n\r\n3\r\n\r\n\r\n4\r\n\r\n\r\n5\r\n\r\n\r\n6\r\n\r\n\r\n7\r\n\r\n\r\n8\r\n\r\n\r\n9\r\n\r\n\r\n10\r\n\r\n\r\n11\r\n\r\n\r\n12\r\n\r\n\r\n\r\n\r\n时间戳\r\n\r\n\r\n机器标识码\r\n\r\n\r\n进程 ID\r\n\r\n\r\n计数器\r\n\r\n\r\n\r\n\r\n机器随机数\r\n\r\n\r\n\r\n每个字节的值为 1~254，ObjectId\r\n转换成字符串后，是用十六进制表示，所以，字符串型 ObjectId 有 24\r\n个字符。\r\nObjectId\r\n的值无法保证生成顺序\r\nObjectId 前 4 个字节存的是时间戳，而时间是递增的，所以 ObjectId\r\n总体保证递增的顺序。\r\n存储的时间戳只精确到秒，在同一台机器不同的 MongoDB\r\n进程，同一秒内生成的 ObjectId，进程 ID\r\n小的会排在大的前面。存在这种情况，进程 ID 大 的先生成\r\nObjectId，但还是会排在进程 ID 小的后面。所以 ObjectId\r\n递增不是绝对的。\r\nObjectId\r\n在一秒内生成的数量上限\r\n3 个字节所能表达的最大的整数：\\(2^{24}-1\\)。所以一个 MongoDB\r\n进程，在一秒内最多能生成 \\(2^{24}-1\\)\r\n个ObjectId。\r\n从目前机器的性能来看，要超过这个限制几乎是不可能的。\r\nObjectId 的唯一性\r\nObjectId 近似唯一，理论上会出现很小概率 \\(\\frac{1}{2^{24}-1}\\) 的重复情况，这取决于\r\nMongoDB 驱动实现 ObjectId 方式。\r\n以 C# 官方驱动来说，构成 ObjectId 的计数器，C# 使用了\r\nInterlocked.Increment 实现，保证了同一MongoDB 进程在同一秒内生成的多个\r\nObjectId 的计数器是累加的，从而保证了生成的 ObjectId 是唯一的。\r\n不过，有些版本的驱动是使用了随机数作为计数器，这种情况下并不能保证生成的\r\nObjectId 是唯一的。\r\n所以，除非你使用的是一个非常老的版本，或者很小众的驱动，否则都不需要为重复的\r\nObjectId 担心。\r\n可以使用表达查询 ObjectId\r\ndb.comments.find(&#123;_id: &#123;$gt: ObjectId(&quot;5272e0f00000000000000000&quot;)&#125;&#125;)\r\nObjectId 无法修改\r\n文档一旦写入到集合中，则其 _id\r\n将不允许改变。如果需要更改某个文档的\r\n_id，可以将文档删除后重新添加到集合中。\r\n参考\r\n\r\nhttps://www.jianshu.com/p/7c4bfa516acf\r\nObjectId\r\n— MongoDB Manual\r\nMongoDB ObjectId to\r\nTimestamp Converter\r\n\r\n","categories":["Develop","Database","Mongodb"],"tags":["MongoDB"]},{"title":"MongoDB 中 $in 的效率用法","url":"/posts/2022/2V5ECSD.html","content":"MongDB 中 $in\r\n查询操作符是非常强大的，但是在使用中有可能受 Mysql\r\n的使用习惯所影响，导致忽略了 $in\r\n的一些高级用法，比如对数组字段也可以使用 $in。\r\n本文对 $in 的使用进行详细的总结。\r\n\r\n语法\r\n&#123; field: &#123; $in: [&lt;value1&gt;, &lt;value2&gt;, ... &lt;valueN&gt; ] &#125; &#125;\r\n非数组 $in 数组\r\n如果 field\r\n是一个非数组，则会对遍历数组中的所有元素来进行匹配。因此，如果\r\n$in 后面的数组过大，会导致性能问题。\r\n可能对 field 来建立索引提高匹配速度\r\n数组 $in 数组\r\nfield 的值也可以是一个数组，当 field\r\n数组中至少有一个元素位于 $in\r\n后面的数组中时，就匹配成功。\r\n正则匹配\r\n$in 后面的数组中的值可以是正则表达式，形式为\r\n/pattern/。但是不能使用 $regex\r\n操作表达式。\r\n例：\r\ndb.inventory.find( &#123; tags: &#123; $in: [ /^be/, /^st/ ] &#125; &#125; )\r\n参考\r\nMongoDB-$in\r\n","categories":["Develop","Database","Mongodb"],"tags":["MongoDB"]},{"title":"mongodb 中数据比较或排序机制","url":"/posts/2022/17HZQ95.html","content":"查询与排序是数据库常用的两个操作，如果能理解 Mongodb\r\n中比较的机制，那么在使用中将会变得更加得心应手。\r\n因此，本文对这些机制进行总结。\r\n\r\n不同 BsonType 之间的比较顺序\r\n每一个 bsonType 都有一个 order，当使用不同的 bsonType\r\n进行排序比较时，它们的顺序由低到高为：\r\n\r\nMinKey (internal type)\r\nNull\r\nNumbers (ints, longs, doubles, decimals)\r\nArray\r\nSymbol, String\r\nObject\r\nBinData\r\nObjectId\r\nBoolean\r\nDate\r\nTimestamp\r\nRegular Expression\r\nMaxKey (internal type)\r\n\r\n\r\n\r\nimage-20220829220828067\r\n\r\n数字类型比较\r\nMongodb 将 int、long、\r\ndouble、decimal\r\n都视作一个类型，在进行比较时，会对它们进行转换。\r\n字符串类型比较\r\n二进制\r\n默认使用二进制来比较字符串\r\n规则（collation）\r\n也可以使用特定语言规则来进行比较。参考 Collaction\r\n数组比较\r\n\r\n小于比较或升序排序，先对数组中的元素进行排序(不同的 bsonType 按上述顺序进行排序)，然后比较数组中的最小元素\r\n大于大于或降序排序，比较数组的最大元素。\r\n将其值为单元素数组(例如[ 1 ])的字段与非数组字段(例如2)进行比较时，实际比较的是\r\n1 和2。\r\n比较空数组(例如[ ])会将空数组视为小于null或缺少字段。\r\n\r\n对象比较\r\n对象比较按以下步骤进行：\r\n\r\n按键值对在 BsonObject 中出现的顺序进行比较\r\n先比较键值（字段值）的类型，如果是不同的 bsonType\r\n的键值按开篇中的顺序进行比较\r\n如果类型相等，则比较键值\r\n如果键值相等，则比较键名（字段名）\r\n如果上述都相等，则继续比较下一个键值对。\r\n如果键值对存在于对象 A，而不存在于对象 B 中，则 A 大于 B\r\n\r\n时间（Date）与时间戳（Timestamp）比较\r\nDate 在 Timestamp 之前排序。\r\n不存在的字段比较\r\n字段为 null 的对象视作对象不存在该字段，例如\r\n{} 与 {a: null} 是相等的。\r\n二进制比较\r\n二进制按如下顺序进行比较：\r\n\r\n先比较数据长度\r\n然后比较一个字节的 bsonType 类型\r\n最后再一个字节一个字节的比较\r\n\r\n参考\r\nComparison/Sort\r\nOrder\r\nComparison/Sort\r\nOrder 中文\r\nCollaction\r\n","categories":["Develop","Database","Mongodb"],"tags":["MongoDB"]},{"title":"MongoDB 使用 Docker 配置多节点副本集","url":"/posts/2023/39J2472.html","content":"本文介绍如何在 Linux 系统中通过 docker-compose 创建 MongoDB\r\n副本集，若是 Windows，可以进入到 WSL 中进行部署。\r\n\r\n生成 KeyFile\r\n\r\nMongoDB 使用 KeyFile 认证，副本集中的每个 mongodb 实例使用 KeyFile\r\n内容作为认证其他成员的共享密码mongod实例只有拥有正确的keyfile才可以加入副本集\r\nKeyFile 的内容必须是 6~1024 个字符的长度，且副本集所有成员的 KeyFile\r\n内容必须相同。\r\nKeyFile 应允许所有者读取，权限可以设置为 400\r\n可以使用任意方法生成 KeyFile。例如，如下操作使用 openssl\r\n生成复杂的随机的1024个字符串。\r\n\r\nmkdir data &amp;&amp; cd dataopenssl rand -base64 800 &gt; mongodb.key\r\n详细的docker-compose.yml\r\n# docker-compose# 最新版本的 docker-compose 会自动识别 version# version: &quot;3.9&quot;services:  # mongodb 服务  # 节点1  mongodb27018:    hostname: mongodb27018    container_name: mongodb27018    image: mongo:latest    expose:      - 27018    ports:      - 27018:27017    restart: always    environment:      - TZ:&#x27;Asia/Shanghai&#x27;      - MONGO_INITDB_ROOT_USERNAME=root      - MONGO_INITDB_ROOT_PASSWORD=yourPassword    command: mongod --bind_ip_all --replSet rs_share --keyFile /data/mongodb.key    volumes:      - ./data/rs1/db:/data/db      - ./data/rs1/configdb:/data/configdb      - ./data/mongodb.key:/data/mongodb.key    networks:      - mongodb_network    entrypoint:      - bash      - -c      - |        chmod 400 /data/mongodb.key        chown 999:999 /data/mongodb.key        exec docker-entrypoint.sh $$@  # 副节点  mongodb27019:    hostname: mongodb27019    container_name: mongodb27019    image: mongo:latest    expose:      - 27019    ports:      - 27019:27017    restart: always    environment:      - TZ:&#x27;Asia/Shanghai&#x27;      - MONGO_INITDB_ROOT_USERNAME=root      - MONGO_INITDB_ROOT_PASSWORD=yourPassword    command: mongod --bind_ip_all --replSet rs_share --keyFile /data/mongodb.key    volumes:      - ./data/rs2/db:/data/db      - ./data/rs2/configdb:/data/configdb      - ./data/mongodb.key:/data/mongodb.key    networks:      - mongodb_network    entrypoint:      - bash      - -c      - |        chmod 400 /data/mongodb.key        chown 999:999 /data/mongodb.key        exec docker-entrypoint.sh $$@    depends_on:      - mongodb27018  mongodb27020:    # Host name = Container name    hostname: mongodb27020    container_name: mongodb27020    image: mongo:latest    expose:      - 27020    ports:      - 27020:27017    restart: always    environment:      - TZ:&#x27;Asia/Shanghai&#x27;      - MONGO_INITDB_ROOT_USERNAME=root      - MONGO_INITDB_ROOT_PASSWORD=yourPassword    command: mongod --bind_ip_all --replSet rs_share --keyFile /data/mongodb.key    volumes:      - ./data/rs3/db:/data/db      - ./data/rs3/configdb:/data/configdb      - ./data/mongodb.key:/data/mongodb.key    networks:      - mongodb_network    entrypoint:      - bash      - -c      - |        chmod 400 /data/mongodb.key            chown 999:999 /data/mongodb.key           exec docker-entrypoint.sh $$@    depends_on:      - mongodb27019networks:  # 设置 mongodb_network, 默认为 bridge 模式，参考：https://zhuanlan.zhihu.com/p/212772001  mongodb_network:\r\n创建挂载目录\r\n# 进入到 data 目录mkdir &#123;rs1,rs2,rs3&#125;# 将 mongodb.key 复制到 rs* 目录中cp mongodb.key ./rs1/ &amp;&amp; cp mongodb.key ./rs2/ &amp;&amp; cp mongodb.key ./rs3/\r\n部署容器\r\n进入到 docker-compose.yml 目录，终端中执行\r\ndocker compose up -d 或者 docker-compose up -d\r\n来部署容器。\r\n\r\n\r\nimage-20230416124522790\r\n\r\n错误处理\r\n错误 1：error during connect: in the default daemon\r\nconfiguration on Windows, the docker client must be run with elevated\r\nprivileges to connect\r\n\r\ndocker desktop 没有启动，先启动，再运行\r\n\r\n错误 2: Location5579201: Unable to acquire security\r\nkey[s]\r\nkeyFile 权限错误，docker compose down\r\n后，清理挂载的所有文件，重新运行一次。\r\n配置副本集\r\n进入 mongodb\r\n#进入 mongodb27018 的容器内docker exec -it mongodb27018 bash# 进入mongo shell# MongoDB 之前使用 mongo,之后使用 mongoshmongosh -u root -p yourPassword\r\n\r\nThe mongo\r\nshell is removed from MongoDB 6.0. The replacement is mongosh.\r\n\r\n初始化副本集\r\n# 切换到 adminuse admin# 进行授权认证# 返回 &#123; ok: 1 &#125; 表示成功db.auth(&quot;root&quot;,&quot;yourPassword&quot;)# 定义配置文件# 配置中的 host 必须是本机实际的 ip，不能是 127.0.0.1，否则局域网内无法访问# 如果要通过域名访问，则必须是域名rsconf = &#123;  _id: &quot;rs_share&quot;,  members: [    &#123;      _id: 0,      host: &quot;192.168.3.240:27018&quot;    &#125;,    &#123;      _id: 1,      host: &quot;192.168.3.240:27019&quot;    &#125;,    &#123;      _id: 2,      host: &quot;192.168.3.240:27020&quot;    &#125;  ]&#125;# 初始化副本集rs.initiate(rsconf)\r\n\r\n若是只有一个节点，则只需要执行：rs.initiate()\r\n\r\n当出现如下提示时，说明成功了：\r\n&#123; &quot;ok&quot; : 1 &#125;rs_auth:SECONDARY&gt;\r\n\r\n单主机模式部署 3副本集\r\n添加节点必须使用宿主机IP+PORT，使用容器内部IP的情况下代码层面连接到\r\nmongodb-cluster 集群，获取到的集群地址信息为\r\ndocker 容器内部 IP，若业务代码没有部署在\r\nmongodb 主机则无法访问\r\n\r\n修改副本集配置\r\n若是更换了主机 IP，则需要重新修改副本集中的\r\nhost，可以采用下列方式修改：\r\n先按 进入 mongodb 登陆到\r\nmongodb，然后使用\r\nrs.status().members.find(x=&gt;x.stateStr === &#x27;PRIMARY&#x27;)\r\n来查找主节点。\r\n若当前实例不是主节点，则退出重新登陆到主节点中\r\n修改配置：\r\n# 切换到 adminuse admin# 进行授权认证# 返回 &#123; ok: 1 &#125; 表示成功db.auth(&quot;root&quot;,&quot;yourPassword&quot;)# 获取当前的副本集配置config = rs.conf();# 修改配置config.members[0].host = &quot;newhost:27017&quot;;# 应用新的配置rs.reconfig(config);\r\n你的 MongoDB 版本是 4.2 或更高版本，可以使用\r\nrs.reconfig() 方法的 force\r\n参数来强制应用新的配置，即使新的配置和当前的配置不兼容：\r\n# 这个操作可能会导致数据丢失,谨慎使用rs.reconfig(config, &#123; force: true &#125;);\r\n\r\nrs.reconfig()\r\n方法会导致副本集的所有成员（包括主节点）重新启动\r\n\r\n参考\r\nMongoDB 3\r\n副本集群（Docker-compose部署）（单机模式）\r\n","categories":["Develop","Database","Mongodb"],"tags":["Docker","MongoDB"]},{"title":"Mongodb 数据库备份与还原","url":"/posts/2023/2ZVSC2C.html","content":"MongoDB 中使用 mongodump 来对整个数据库进行备份，使用\r\nmongorestore 来将数据从备份中还原。\r\n本文介绍一种常用的备份还原的参数设置，可以在实际工作中直接使用\r\n\r\n功能安装\r\nmongodump 与 mongorestore 是\r\nmongodb-database-tools 中提供的命令行工具，使用这两个命令，需要先安装\r\nmongodb-database-tools。\r\nscoop 安装方法：\r\nscoop install mongodb-database-tools\r\n手动安装：\r\n从 Try\r\nMongoDB Tools Free 下载 MongoDB\r\nCommand Line Database Tools Download 安装包进行安装。\r\n备份\r\nmongodump -h localhost:27017 -d databaseName -u test -p testpwd --authenticationDatabase admin --gzip --archive=C:\\Users\\%username%\\Desktop\\dump\\databaseName.gzip\r\n\r\n-h / --host\r\nMongoDB\r\n所在服务器地址，也可以同时指定端口号：127.0.0.1:27017\r\n-d / --db\r\n指定数据库名称\r\n-u / --username\r\n用于授权验证的用户名\r\n-p / --password\r\n用于授权验证的密码\r\n--authenticationDatabase\r\n验证授权的数据库名，一般是 admin\r\n-o / --out\r\n指定导出目录，如果不指定\r\n-archive，会在该目录中导出多个文件，每个集合有两个文件。\r\n--gzip\r\n导出时使用 gzip 压缩\r\n--archive\r\n导出成单个文件\r\n\r\n还原\r\nmongorestore -h localhost:27018 -u test -p testpwd --authenticationDatabase admin --gzip --objcheck --drop --noIndexRestore --nsInclude=databaseName.*  --nsFrom=databaseName.* --nsTo=newDatabaseName.* --archive=C:\\Users\\%username%\\Desktop\\dump\\databaseName.gzip\r\n\r\n如果不需要重命名数据库，去掉 --nsFrom 和\r\n--nsTo 参数即可\r\n\r\n\r\n--drop\r\n删除已经存在的集合\r\n--noIndexRestore\r\n禁止恢复索引\r\n--nsInclude\r\n包含的命名空间(namespace)，databaseName.* 表示数据库\r\ndatabaseName 下的所有集合\r\n--nsFrom\r\n指定重命名前的数据库命名空间\r\n--nsTo\r\n指定重命名后的数据库命名空间\r\n\r\n副本集中备份与还原\r\n如果 MongoDB 配置了副本集，上述中的 -h\r\n需要使用主节点的 IP 地址和端口。\r\n通过以下方法查看主节点：\r\n# 进入到 mongodb 的任意节点中mongosh --host 127.0.0.1 --port 27018 -u yourUsername -p yourPassword --eval &quot;db.isMaster().ismaster&quot; | Out-String\r\n\r\nThe mongo\r\nshell is removed from MongoDB 6.0. The replacement is mongosh.\r\nMongoDB 6.0 以后 mongo 命令取消了，改用\r\nmongosh，mongosh 需要手动安装，可以使用 scoop\r\n安装：scoop install mongosh\r\n\r\n可以看到如下结果：\r\nCurrent Mongosh Log ID: 681b03953208c3b2e1b66c55Connecting to:          mongodb://&lt;credentials&gt;@192.168.23.11:27018/?directConnection=true&amp;authSource=admin&amp;appName=mongosh+1.8.0Using MongoDB:          4.2.7Using Mongosh:          1.8.0For mongosh info see: https://docs.mongodb.com/mongodb-shell/------   The server generated these startup warnings when booting   2025-04-28T06:50:51.065+0800:   2025-04-28T06:50:51.065+0800: ** WARNING: Access control is not enabled for the database.   2025-04-28T06:50:51.065+0800: **          Read and write access to data and configuration is unrestricted.   2025-04-28T06:50:51.065+0800:   2025-04-28T06:50:51.065+0800:   2025-04-28T06:50:51.066+0800: ** WARNING: You are running on a NUMA machine.   2025-04-28T06:50:51.066+0800: **          We suggest disabling NUMA in the machine BIOS   2025-04-28T06:50:51.066+0800: **          by enabling interleaving to avoid performance problems.   2025-04-28T06:50:51.066+0800: **          See your BIOS documentation for more information.   2025-04-28T06:50:51.066+0800:------------   Enable MongoDB&#x27;s free cloud-based monitoring service, which will then receive and display   metrics about your deployment (disk utilization, CPU, operation statistics, etc).   The monitoring data will be available on a MongoDB website with a unique URL accessible to you   and anyone you share the URL with. MongoDB may use this information to make product   improvements and to suggest MongoDB products and deployment options to you.   To enable free monitoring, run the following command: db.enableFreeMonitoring()   To permanently disable this reminder, run the following command: db.disableFreeMonitoring()------true\r\n在上述结果中，最终输出 true 时，表示为主节点。\r\n在对副本集数据库进行恢复时，若数据过大，节点过多，会导致磁盘的读写飙升到100%，从而无法完成数据库恢复。此时可以减少副本节点，建议只使用\r\n2 个。\r\n参考\r\nTry\r\nMongoDB Tools Free\r\nThe\r\nMongoDB Database Tools Documentation\r\nmongod,\r\nmongo, mongosh, mongos, what now?\r\n","categories":["Develop","Database","Mongodb"],"tags":["MongoDB"]},{"title":"MongoDB使用 Docker 配置单节点副本集","url":"/posts/2024/M96VZZ.html","content":"为了快速搭建 MongoDB 副本集开发环境，可以使用 Docker\r\n快速启动一个单节点副本集。\r\n实现方式有两种：\r\n\r\n直接使用 docker-compose 完成\r\n手动配置\r\n\r\n\r\ndocker-compose 方案\r\ndocker-compose 内容如下：\r\nservices:  mongodb27017:    hostname: mongodb27017    container_name: mongodb27017    image: mongo:6.0    ports:      - 27018:27017    restart: always    environment:      - MONGO_INITDB_ROOT_USERNAME=root      - MONGO_INITDB_ROOT_PASSWORD=yourpassword    command: mongod --bind_ip_all --replSet rs_0 --keyFile /data/mongodb.key    volumes:      - ./data/mongodb/data:/data/db      # - ./data/mongodb/configdb:/data/configdb    networks:      - mongodb-net    entrypoint:      - bash      - -c      - |        openssl rand -base64 128 &gt; /data/mongodb.key        chmod 666 /data/mongodb.key        chown 999:999 /data/mongodb.key        echo &#x27;const isInited = rs.status().ok === 1        if(!isInited)&#123;          rs.initiate(&#123;              _id: &quot;rs_0&quot;,              members: [                  &#123; _id: 0, host: &quot;192.168.128.240:27018&quot; &#125;              ]          &#125;)        &#125;&#x27; &gt; /data/initReplicaSet.js        # 启动MongoDB服务        exec docker-entrypoint.sh &quot;$$@&quot;        # 等待MongoDB服务启动        until mongosh -u root -p whfy8888 --authenticationDatabase admin --eval &quot;print(&#x27;waited for connection&#x27;)&quot; &gt; /dev/null 2&gt;&amp;1; do          echo &quot;Waiting for MongoDB to start...&quot;          sleep 2        done        # 等待MongoDB完全启动        sleep 2        # 执行初始化副本集的脚本        mongosh -u root -p whfy8888 --authenticationDatabase admin /data/initReplicaSet.js        # 等待docker-entrypoint.sh脚本执行的MongoDB服务进程        wait $$!\r\n使用时，直接 docker compose up -d 即可。\r\n\r\n这种方式有一个bug，当关闭连接后，再连接时，就无法连接，需要等一会儿，目前未定位到原因\r\n\r\n手动配置\r\n","categories":["Develop","Database","Mongodb"],"tags":["Docker","MongoDB"]},{"title":"数据库中实现数据继承的设计方法","url":"/posts/2023/2608835.html","content":"遇到这么一个场景：需要根据分类树层级，使每个分类中定义的数据（以下简称：变量）可以像继承一样传递给子分类，而每个分类又可以单独对继承的变量进行设置，有的设置是专属的，有的设置又可以继续继承。\r\n\r\n方案选型\r\n为了通过数据库保存继承关系，开发之前研究了两种方式：\r\n\r\n在变量的定义中保存继承关系\r\n每次发生继承后，都复制一个变量副本，然后在变量的副本中，保存继承对象的\r\nid。但这有一个很严重的问题，每当分类树结构变动时，都要去维护继承关系，这是一个繁杂易错的操作。\r\n通过分类树来确定继承关系\r\n变量仅属于定义它的分类，通过分类的树形结构来自动确定继承关系，然后新建一个设置表，记录分类与变量对应的设置。\r\n\r\n实现\r\n数据表结构\r\ncategory 表：\r\n&#123;    _id: &#x27;&#x27;,    parentId:&#x27;&#x27;,   \tname: &#x27;&#x27;&#125;\r\nvariable 表：\r\n&#123;    _id:&#x27;&#x27;,    name:&#x27;&#x27;,    categoryId:&#x27;&#x27;,    privateSettings:&#123;        color:&#x27;&#x27;    &#125;&#125;\r\nsetting 表：\r\n只有当变量在某个分类中展示时，设置才会生效\r\n&#123;    _id:&#x27;&#x27;,    categoryId:&#x27;&#x27;,    variableId:&#x27;&#x27;,    publicSettings:&#123;        hidden:false    &#125;&#125;\r\n查询继承的变量\r\n由于通过 category\r\n树来确定继承关系，因此，要查询一个分类中对应的所有变量，应：\r\n\r\n先找到分类对应的所有父分类，即继承链上所有的\r\ncategoryId\r\n通过 categoryId 来查找变量\r\n\r\n设置的继承\r\n通过如下方式实现设置的继承：\r\n\r\n先通过 variableId 找到所有的设置\r\n求解每个变量的设置继承链\r\n根据 category 树，将变量对应的设置组装成一个链表形式的数据，如：\r\n&#123;    categoryId:&#x27;&#x27;,    publicSettings:&#123;&#125;,    parent:&#123;        categoryId:&#x27;&#x27;,        publicSettings:&#123;&#125;,        parent:&#123;...&#125;    &#125;&#125;\r\n\r\n在使用时，写一个方法去递归这个设置继承链，就可以获得需要的设置参数。\r\n\r\n当数据传递到前端后，前端可以将多个设置通过原型链连接在一起，使用时直接通过\r\nobj.name 的方式读取。就不需要专门的方法去获取设置了。\r\n\r\n参考\r\n\r\n类的继承关系如何在关系型数据库体现\r\nHow to\r\nModel Inheritance in a Database\r\n\r\n","categories":["Develop","Database","数据库设计"],"tags":["Database","数据库设计"]},{"title":"moment 中日期跨年月加减后结果测试","url":"/posts/2022/25J6BC2.html","content":"在使用 moment\r\n进行日期加减处理时，有些担心其天数会变动，比如：\r\n\r\n2月 28号加一个月是否为 3 月 31 号？\r\n3月 31号减一个月是否为 2 月 28 号？\r\n\r\n\r\n现在直接上代码进行测试：\r\nconst moment0 = moment(&#x27;2022-03-31&#x27;)console.log(&#x27;moment0:&#x27;,moment0.format(&#x27;YYYY-MM-DD&#x27;))const subMoment = moment0.subtract(1,&#x27;month&#x27;)console.log(&#x27;subMoment:&#x27;,subMoment.format(&#x27;YYYY-MM-DD&#x27;))const addMoment = moment0.add(1,&#x27;month&#x27;)console.log(&#x27;addMoment:&#x27;,addMoment.format(&#x27;YYYY-MM-DD&#x27;))const subMoment2 = moment0.subtract(1,&#x27;month&#x27;)console.log(&#x27;subMoment2:&#x27;,subMoment2.format(&#x27;YYYY-MM-DD&#x27;))// 输出结果&quot;moment0:&quot; &quot;2022-03-31&quot;&quot;subMoment:&quot; &quot;2022-02-28&quot;&quot;addMoment:&quot; &quot;2022-03-28&quot;&quot;subMoment2:&quot; &quot;2022-02-28&quot;\r\n代码实现如下：\r\n\r\nSee the Pen \r\ntestMomentAddSubtract by GALENS\r\n(@galensgan) on\r\nCodePen.\r\n\r\n","categories":["Develop","Javascript","Date"],"tags":["Javascript","Moment","Date"]},{"title":"eggjs 启动和停止报错","url":"/posts/2021/2P3NVEN.html","content":"在 eggjs 在进行生产环境部署的时候，执行 npm start 和\r\nnpm stop 报错，特作记录。\r\n\r\n启动报错\r\n如果运行 npm start\r\n报错，但是又不提示具体原因，此时可以改用 git\r\n来执行，它会将错误提示到命令行窗口上。\r\n停止报错\r\neggjs 启动后，如果运行 npm stop 报错，提示未能找到名\r\n‘’node.exe“ 的 processId。\r\n这种情况下，是因为系统的 wmic 未添加到环境变量，将\r\nC:\\Windows\\System32\\wbem 添加到 path\r\n环境变量后，重启终端即可。\r\n","categories":["Develop","Javascript","Eggjs"],"tags":["eggjs"]},{"title":"echarts各个配置项概念","url":"/posts/2022/C57H56.html","content":"echarts\r\n是百度开源的一个绘制图表库，号称是百度最良心的作品。本文将主要介绍\r\necharts 配置的相关概念，在使用时，可以按需去查找相关 api。\r\n\r\n安装\r\nnpm install echarts --save\r\n使用\r\n在 vue 中使用时示例如下：\r\n&lt;template&gt;  &lt;div id=&quot;main&quot; :style=&quot;height: 200px; width: 200px&quot; /&gt;&lt;/template&gt;&lt;script&gt;import * as echarts from &#x27;echarts&#x27;export default &#123;  mounted() &#123;    this.initChart()  &#125;,  beforeDestroy() &#123;    if (!this.chart) &#123;      return    &#125;    this.chart.dispose()    this.chart = null  &#125;,  methods: &#123;    initChart() &#123;      // 参数      const option = &#123;        legend: &#123;          right: &#x27;0&#x27;,          orient: &#x27;vertical&#x27;        &#125;,        series: [          &#123;            name: &#x27;Nightingale Chart&#x27;,            type: &#x27;pie&#x27;,            radius: [50, 94],            center: [&#x27;50%&#x27;, &#x27;50%&#x27;],            roseType: &#x27;area&#x27;,            itemStyle: &#123;              borderRadius: 8            &#125;,            data: [              &#123; value: 40, name: &#x27;rose 1&#x27; &#125;,              &#123; value: 38, name: &#x27;rose 2&#x27; &#125;,              &#123; value: 32, name: &#x27;rose 3&#x27; &#125;,              &#123; value: 30, name: &#x27;rose 4&#x27; &#125;,              &#123; value: 28, name: &#x27;rose 5&#x27; &#125;,              &#123; value: 26, name: &#x27;rose 6&#x27; &#125;,              &#123; value: 22, name: &#x27;rose 7&#x27; &#125;,              &#123; value: 18, name: &#x27;rose 8&#x27; &#125;            ]          &#125;        ]      &#125;      // 基于准备好的dom，初始化echarts实例      var myChart = echarts.init(document.getElementById(&#x27;main&#x27;))      // 绘制图表      myChart.setOption(option)    &#125;  &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;\r\n\r\n参考：获取\r\nApache ECharts\r\n\r\n图表容器大小\r\n如上例所示，在定义 &lt;div&gt; 节点的时候，通过 CSS\r\n使得该节点具有宽度和高度。初始化的时候，传入该节点，图表的大小默认即为该节点的大小（推荐）。也可以通过配置\r\noption.width 或 option.height 将其覆盖。\r\n响应容器大小的变化\r\n可以监听页面的 window.onresize\r\n事件获取浏览器大小改变的事件，然后调用 echartsInstance.resize\r\n改变图表的大小。\r\n该方法仅在窗口大小改变时，才会触发\r\nresize，具有一定的局限性。\r\n样式\r\n颜色主题\r\n系统除了默认外，内置了 dark\r\n主题，在初始化时，传入的第二个参数即为主题的名称。\r\nvar chart = echarts.init(dom, &#x27;dark&#x27;);\r\n自动注册和加载主题\r\n// 假设主题名称是 &quot;vintage&quot;$.getJSON(&#x27;xxx/xxx/vintage.json&#x27;, function(themeJSON) &#123;  echarts.registerTheme(&#x27;vintage&#x27;, JSON.parse(themeJSON));  var chart = echarts.init(dom, &#x27;vintage&#x27;);&#125;);\r\n调色盘\r\n可以在 option.color 中设置全局调色盘，color\r\n是一个颜色数组，也可以在 series 中单独设置调色盘颜色。\r\n直接样式设置\r\n直接的样式设置是比较常用设置方式。纵观 ECharts 的 option\r\n中，很多地方可以设置 itemStyle、lineStyle、areaStyle、label\r\n等等。这些的地方可以直接设置图形元素的颜色、线宽、点的大小、标签的文字、标签的样式等等。\r\n数据集\r\n数据集（dataset）是专门用来管理数据的组件。虽然每个系列都可以在\r\nseries.data 中设置数据，但是从 ECharts4 支持\r\n数据集 开始，更推荐使用 数据集\r\n来管理数据。因为这样，数据可以被多个组件复用，也方便进行\r\n“数据和其他配置”\r\n分离的配置风格。毕竟，在运行时，数据是最常改变的，而其他配置大多并不会改变。\r\n\r\n本文未完待续...\r\n\r\n参考\r\n\r\necharts文档\r\necharts\r\n各个类的定义\r\necharts\r\n实例setupOption配置\r\n\r\n","categories":["Develop","Javascript","Echarts"],"tags":["echarts"]},{"title":"egg-redis 常用操作","url":"/posts/2022/2JXSX6J.html","content":"本文总结了 egg-redis 的一些参数设置和常用用法，方便开发食用。\r\n\r\n存单个值\r\nredis.set(key, value, expiryMode, time )\r\nexpiryMode\r\n\r\nEX 过期时间单位是秒\r\nPX 过期时间单位是分钟\r\n\r\n修改过期时间\r\nredis.expire(&#x27;name&#x27;, 20); // 秒\r\n设置 key 在指定时间过期\r\nawait redis.expireat(key,timestamp); // timestamp 时间戳 秒await redis.pexpireat(key,timestamp); // timestamp 时间戳 毫秒\r\n存数组\r\nawait this.app.redis.sadd(&#x27;setList&#x27;, &#x27;张三&#x27;,&#x27;李四&#x27;,&#x27;赵六&#x27;)返回值：[&#x27;张三&#x27;, &#x27;李四&#x27;, &#x27;赵六&#x27;]\r\n向数组结尾添加元素\r\nawait this.app.redis.rpush(&#x27;userList&#x27;,&#x27;张三&#x27;)await this.app.redis.rpush(&#x27;userList&#x27;,&#x27;李四&#x27;)await this.app.redis.rpush(&#x27;userList&#x27;, &#x27;王五&#x27;)返回一个数组 [&#x27;张三&#x27;,&#x27;李四&#x27;, &#x27;王五&#x27;]\r\n向数组开始位置添加元素\r\nawait this.app.redis.lpush(&#x27;userList&#x27;, &#x27;数组左边新增的&#x27;)[    &quot;数组左边新增的&quot;,    &quot;张三&quot;,    &quot;张三&quot;,]\r\n存对象\r\nawait this.app.redis.hmset(&#x27;userInfo&#x27;,&#x27;name&#x27;,&#x27;张三&#x27;,&#x27;age&#x27;,18,&#x27;address&#x27;,&#x27;回龙观&#x27;)\r\n向对象中添加属性\r\nawait this.app.redis.hset(&#x27;loginUser&#x27;, &#x27;id&#x27;, 1)await this.app.redis.hset(&#x27;loginUser&#x27;, &#x27;uname&#x27;, &#x27;张三&#x27;)await this.app.redis.hset(&#x27;loginUser&#x27;, &#x27;phone&#x27;, &#x27;18888888888&#x27;)await this.app.redis.hset(&#x27;loginUser&#x27;, &#x27;address&#x27;, &#x27;北京市朝阳区&#x27;)&#123;    &quot;id&quot;: &quot;1&quot;,    &quot;uname&quot;: &quot;张三&quot;,    &quot;phone&quot;: &quot;18888888888&quot;,    &quot;address&quot;: &quot;北京市朝阳区&quot;&#125;\r\n获取普通值\r\n// 获取key 为 gender 的数据await this.app.redis.get(&#x27;gender&#x27;)\r\n获取值得数据类型\r\nctx.body = await this.app.redis.type(&#x27;name&#x27;)返回 string\r\n获取数组中所有元素\r\n// 表示获取数组中所有的值 0 ，-1ctx.body = await this.app.redis.lrange(&#x27;userList&#x27;,0,-1)[    &quot;张三&quot;,    &quot;张三&quot;,    &quot;李四&quot;,]\r\n获取集合中的所有数据\r\nawait this.app.redis.smembers(&#x27;setList&#x27;)[    &quot;张三&quot;,    &quot;李四&quot;,    &quot;赵六&quot;]\r\n获取对象中的所有数据\r\nctx.body = await this.app.redis.hgetall(&#x27;loginUser&#x27;)&#123;    &quot;id&quot;: &quot;1&quot;,    &quot;uname&quot;: &quot;张三&quot;,    &quot;phone&quot;: &quot;18888888888&quot;,    &quot;address&quot;: &quot;北京市朝阳区&quot;&#125;\r\n获取对象中的指定属性\r\nawait this.app.redis.hget(&#x27;loginUser&#x27;, &#x27;address&#x27;)\r\n一次性获取对象中的多个属性\r\nawait this.app.redis.hmget(&#x27;userInfo&#x27;, &#x27;name&#x27;,&#x27;age&#x27;,&#x27;address&#x27;)[    &quot;张三&quot;,    &quot;18&quot;,    &quot;回龙观&quot;]\r\n获取指定 key 的过期时间\r\nawait redis.ttl(key); // 单位秒await redis.pttl(key); // 单位毫秒\r\n删除指定 key 的过期时间\r\nawait redis.persist(key)\r\n删除指定的key\r\nawait this.app.redis.del(&#x27;name&#x27;)\r\n删除redis中所有数据\r\nawait this.app.redis.flushall()\r\n从数组最左边删除一项\r\nawait this.app.redis.lpop(&#x27;userList&#x27;)\r\n从数组最右边删除一项\r\nawait this.app.redis.rpop(&#x27;userList&#x27;)\r\n参考\r\n本文参考以下文章，在此表示感谢！\r\n\r\negg-redis常用api\r\n官方文档\r\n\r\n","categories":["Develop","Javascript","Eggjs"],"tags":["eggjs","Javascript"]},{"title":"eggjs 给路径添加别名并实现智能提示","url":"/posts/2022/3M46N6F.html","content":"本文介绍了如何在 eggjs 中给路径添加别名并实现 vscode 的智能提示。\r\n\r\n配置别名\r\n安装依赖\r\nnpm i --save module-alias# 或者yarn add module-alias\r\n配置 package.json 文件\r\n// Aliases&quot;_moduleAliases&quot;: &#123;  &quot;@&quot;: &quot;./app&quot;, //  . represent application&#x27;s root&#125;\r\n加载配置\r\n// app.js，若没有，则新建configWillLoad() &#123;  // 此时 config 文件已经被读取并合并，但是还并未生效  // 这是应用层修改配置的最后时机  // 注意：此函数只支持同步调用      require(&#x27;module-alias/register&#x27;)&#125;\r\n\r\n注意：\r\n因为需要将该代码放置在所有使用路径别名代码的前面，因此在这里将此引用放置在app.js中，当然，也可以在所需的地方进行单独引用（不推荐）\r\n\r\n使用\r\nconst utils = require(&#x27;@/utils/index.js&#x27;)\r\nIED 实现对别名的智能提示\r\n在根目录中创建 jsconfig.json\r\n文件，里面添加如下内容：\r\n// 此处是根，如果已经存在配置，则去掉外层大括号&#123;    &quot;compilerOptions&quot;: &#123;        &quot;baseUrl&quot;: &quot;./&quot;,        &quot;paths&quot;: &#123;            &quot;@/*&quot;: [                &quot;app/*&quot;            ]        &#125;    &#125;&#125;\r\n至此，vscode 即可智能提示了。\r\n\r\n\r\nimage-20220315151928119\r\n\r\n参考\r\n\r\nmodule-alias\r\negg.js\r\n路径别名配置 module-alias\r\n\r\n","categories":["Develop","Javascript","Eggjs"],"tags":["eggjs"]},{"title":"eggjs 实现文件下载","url":"/posts/2022/198SKHP.html","content":"本文 介绍了在 eggjs\r\n中如何编写下载模块供其它终端进行文件下载的方法。\r\n\r\nEggjs 官方方法\r\nasync index() &#123;  this.ctx.body = [    &#x27;&lt;a download href=&quot;/download&quot;&gt;download&lt;/a&gt;&#x27;,    &#x27;&lt;br&gt;&#x27;,    &#x27;&lt;a download href=&quot;/download-image&quot;&gt;download image&lt;/a&gt;&#x27;,  ].join(&#x27;&#x27;);&#125;// 向下传递流async download() &#123;  const filePath = path.resolve(this.app.config.static.dir, &#x27;hello.txt&#x27;);  this.ctx.attachment(&#x27;hello.txt&#x27;);  this.ctx.set(&#x27;Content-Type&#x27;, &#x27;application/octet-stream&#x27;);  this.ctx.body = fs.createReadStream(filePath);&#125;// 从其它地方转存下载文件async downloadImage() &#123;  const url = &#x27;http://cdn2.ettoday.net/images/1200/1200526.jpg&#x27;;  const res = await this.ctx.curl(url, &#123;    streaming: true,  &#125;);  this.ctx.type = &#x27;jpg&#x27;;  this.ctx.body = res.res;&#125;\r\n支持进度条和剩余时间(Content-Length)\r\n为了支持进度条，需要在 HTTP 返回头里设置\r\nContent-Length\r\nconst fs = require(&#x27;fs&#x27;)const util = require(&#x27;util&#x27;)...async download() &#123;  const filePath = &#x27;/path/to/file&#x27;;  const fileSize = (await util.promisify(fs.stat)(filePath)).size.toString();  this.ctx.attachment(filePath);  this.ctx.set(&#x27;Content-Length&#x27;, fileSize);  this.ctx.set(&#x27;Content-Type&#x27;, &#x27;application/octet-stream&#x27;);  this.ctx.body = fs.createReadStream(filePath);&#125;\r\n分段下载\r\n未完成。\r\n参考\r\n\r\nhttps://github.com/eggjs/examples/blob/master/download/app/controller/index.js\r\neggjs怎么实现文件下载？\r\n\r\n","categories":["Develop","Javascript","Eggjs"],"tags":["eggjs","文件下载"]},{"title":"Lodash 中一些让人喜出望外的函数","url":"/posts/2022/071MK6.html","content":"为什么选择 Lodash ？\r\nLodash 通过降低 array、number、objects、string 等等的使用难度从而让\r\nJavaScript 变得更简单。 Lodash 的模块化方法 非常适用于：\r\n\r\n遍历 array、object 和 string\r\n对值进行操作和检测\r\n创建符合功能的函数\r\n\r\n下面是本人在阅读文档时，对遇到的一些让人觉得非常好用的函数的整理。\r\n\r\n文档版本：4.17.15\r\n\r\n\r\nArray\r\n_.difference系列\r\n返回第一个数组中与第二个数组不同的值。\r\n当在 vue 中 watch 的是一个数组时，找到变化的值非常有用。\r\n_.uniq 系列\r\n返回数组中所有第一次出现的值。\r\n用于去重很有用。\r\nFunction\r\n_.throttle\r\n节流函数，在一定时间内仅会执行一次。\r\n可以用于更新上传或下载的进度。\r\nNumber\r\n_.clamp\r\n传入一个值下界和上界，返回在这个界限内的值。\r\nObject\r\n_.at\r\n通过传入属性路径来获取值，属性路径是字符串，同时路径支持函数\r\n_.default\r\n对于是undefined的属性赋予初值\r\n_.get\r\n同 _.at，但可以传入一个未找到时的默认值\r\n_.invoke\r\n通过字符串路径来调用对象中原生的方法\r\n_.pick\r\n通过给定的字符串路径来重新构建一个对象\r\n参考\r\n本文参考以下文章，在此表示诚挚感谢！\r\n\r\nLodash中文文档\r\nLodash英文文档\r\n\r\n","categories":["Develop","Javascript","Lodash"],"tags":["Javascript","lodash"]},{"title":"EggJS 异步获取流时可能导致进程堵塞","url":"/posts/2025/2PHGC5W.html","content":"在 eggjs\r\n中异步向其它服务请求文件流时，出现异步始终等待，导致请求阻塞问题。通过排查，发现是由于\r\nawait\r\n请求后，流无法被消费，流没有消费完，请求会继续等待，从而陷入了逻辑循环。\r\n\r\n源代码\r\nconst &#123; PassThrough,pipeline &#125; = require(&#x27;stream&#x27;)const fs = require(&#x27;fs&#x27;)async convert_html_to_pdf(template, content, resultFileName, printOptions = &#123;&#125;) &#123;  const writeStream = new PassThrough()  await this.curlPython(`/api/html/pdf-stream`, &#123;    writeStream,    method: &#x27;POST&#x27;,    timeout: 30000,    data: &#123;      template,      html: content,      filename: resultFileName,      printOptions    &#125;  &#125;)  return writeStream&#125;// 其它文件中使用const fileStream = await convert_html_to_pdf(...params)const writeStream = fs.createWriteStream(tempFileFullPath)pipeline(fileStream, writeStream)\r\n其中, this.curlPython 是对 this.curl\r\n的封装，在此处可以直接理解成 this.curl。\r\n该方法的作用是请求 python 服务将 html 转换成\r\npdf，对方返回一个文件流。代码中使用 PassThrough\r\n中转流到其它地方进行消费。\r\n问题分析\r\n上述代码在本机环境表现一切正常，但是在生产环境总是发生阻塞。\r\n通过查看 eggjs 的 curl 的参数介绍，发现其中提到：\r\nexport interface RequestOptions &#123;  /**   * A writable stream to be piped by the response stream.   * Responding data will be write to this stream and callback   * will be called with data set null after finished writing.   */  writeStream?: Writable;  /** consume the writeStream, invoke the callback after writeStream close. */  consumeWriteStream?: boolean;&#125;\r\n\r\n当流结束之后，才会以一个 null data 进行回调\r\n\r\n所以这就导致在本文开头所讲的情况：\r\nawait\r\n请求后，流无法被消费，流没有消费完，请求会继续等待，从而陷入了逻辑循环。\r\n所以，遇到这种情况时，只需要去掉 await 直接返回\r\nPassThrough 让程序对流进行消费即可，即代码为：\r\nawait this.curlPython(`/api/html/pdf-stream`, &#123;  writeStream,  method: &#x27;POST&#x27;,  timeout: 30000,  data: &#123;    template,    html: content,    filename: resultFileName,    printOptions  &#125;&#125;)\r\n残留问题\r\n为什么在本机测试时是正常，但是到生产环境总是发生阻塞呢？这个问题我也一直没想明白。\r\n通过问 AI，猜测可能原因是：python\r\n服务器的响应是流式的，但没有正确发送结束信号（EOF），writeStream\r\n可能不会触发 'close' 事件，导致 Promise 永不 resolve，从而\r\nawait 阻塞，无法执行后续代码。\r\n欢迎大家在下面留言讨论，提前为大家的解惑致以感谢！\r\n","categories":["Develop","Javascript","Nodejs"],"tags":["EggJS","NodeJS"]},{"title":"创建 npm 工具库","url":"/posts/2022/2VDPVDM.html","content":"打包工具的选择\r\n如果我们需要构建一个简单的小型应用并让它快速运行起来，可以使用\r\nParcel；如果需要构建一个类库只需要导入很少第三方库，可以使用\r\nRollup；如果需要构建一个复杂的应用，需要集成很多第三方库，并且需要代码分拆、HMR等功能，推荐使用\r\nWebpack [3]。\r\n所以，在开发工具库时，我们选择 rollup 作为打包工具。\r\n\r\n初始化\r\nmkdir wow-toolcd wow-toolnpm init -y# 添加src目录mkdir src# 添加 index.js 入口文件New-Item src/index.js# 修改入口文件位置# package.json 中 exports 修改为如下值，使其支持浏览器和 nodejs&#123;  &quot;exports&quot;:&#123;     &quot;require&quot;: &quot;./dist/yourPackageName.cjs.js&quot;,    &quot;import&quot;: &quot;./dist/yourPackageName.esm.js&quot;   &#125;,&#125;\r\n安装 rollup\r\n将 rollup 安装为本地开发依赖\r\n# npmnpm install rollup --save-dev# yarnyarn add rollup --dev\r\n安装 rollup 插件\r\n先安装如下rollup插件：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n插件包名\r\n作用\r\n\r\n\r\n\r\n\r\n@rollup/plugin-node-resolve\r\n使用 nodejs的解析算法，使得可以在 node_modules 中使用第三方包\r\n\r\n\r\n@rollup/plugin-commonjs\r\n将 CommonJS 模块转成 ES 模块\r\n\r\n\r\n@rollup/plugin-alias\r\n在打包的时候创建别名\r\n\r\n\r\n@rollup/plugin-replace\r\n在打包时替换目标字符串\r\n\r\n\r\n@rollup/plugin-eslint\r\n代码规范化\r\n\r\n\r\n@rollup/plugin-babel\r\n与 babel 无缝集成，将 ES6 代码转换成 ES5\r\n\r\n\r\nrollup-plugin-terser\r\n通过使用 terser 引擎，缩减打包后的大小\r\n\r\n\r\nrollup-plugin-clear\r\n在编译前清空输出目录\r\n\r\n\r\n@rollup/plugin-json\r\n将 json 文件转成 ES 模块\r\n\r\n\r\nrollup-plugin-serve\r\n创建开发服务\r\n\r\n\r\nrollup-plugin-livereload\r\n实时重载代码修改\r\n\r\n\r\nrollup-plugin-filesize\r\n在终端中显示包文件的大小\r\n\r\n\r\n\r\n安装命令如下：\r\n# npmnpm install @rollup/plugin-node-resolve @rollup/plugin-commonjs @rollup/plugin-alias @rollup/plugin-replace @rollup/plugin-eslint @rollup/plugin-babel rollup-plugin-terser rollup-plugin-clear @rollup/plugin-json rollup-plugin-serve rollup-plugin-livereload rollup-plugin-filesize --save-dev# yarn# yarn 安装开发依赖的命令如下yarn add &lt;package-name&gt; --dev\r\n插件的具体作用参考：rollup官方插件库\r\n配置 rollup\r\n\r\n根据开发环境区分不同的配置\r\n设置对应的 npm script\r\n输出不同规范的产物：umd、umd.min、cjs、esm\r\n兼容 jest 不支持 es module的问题\r\n\r\nmkdir configcd configNew-Item rollup.config.base.jsNew-Item rollup.config.dev.jsNew-Item rollup.config.prod.js\r\nrollup.config.base.js\r\nimport &#123; nodeResolve &#125; from &#x27;@rollup/plugin-node-resolve&#x27; // 解析 node_modules 中的模块import commonjs from &#x27;@rollup/plugin-commonjs&#x27; // cjs =&gt; esmimport alias from &#x27;@rollup/plugin-alias&#x27; // alias 和 reslove 功能import replace from &#x27;@rollup/plugin-replace&#x27;import eslint from &#x27;@rollup/plugin-eslint&#x27;import &#123; babel &#125; from &#x27;@rollup/plugin-babel&#x27;import &#123; terser &#125; from &#x27;rollup-plugin-terser&#x27;import clear from &#x27;rollup-plugin-clear&#x27;import json from &#x27;@rollup/plugin-json&#x27; // 支持在源码中直接引入json文件，不影响下面的import &#123; name, version, author &#125; from &#x27;../package.json&#x27;// 此处 pkgName 要修改成自己的包名const pkgName = &#x27;vtools&#x27;const banner =&#x27;/*!\\n&#x27; +` * $&#123;name&#125; v$&#123;version&#125;\\n` +` * (c) 2014-$&#123;new Date().getFullYear()&#125; $&#123;author&#125;\\n` +&#x27; * Released under the MIT License.\\n&#x27; +&#x27; */&#x27;export default &#123;  input: &#x27;src/index.js&#x27;,  // 同时打包多种规范的产物  output: [    &#123;      file: `dist/$&#123;pkgName&#125;.umd.js`,      format: &#x27;umd&#x27;,      name: pkgName,      banner    &#125;,    &#123;      file: `dist/$&#123;pkgName&#125;.umd.min.js`,      format: &#x27;umd&#x27;,      name: pkgName,      banner,      plugins: [terser()]    &#125;,    &#123;      file: `dist/$&#123;pkgName&#125;.cjs.js`,      format: &#x27;cjs&#x27;,      name: pkgName,      banner    &#125;,    &#123;      file: `dist/$&#123;pkgName&#125;.esm.js`,      format: &#x27;es&#x27;,      banner    &#125;  ],  // 注意 plugin 的使用顺序  plugins: [    json(),    clear(&#123;      targets: [&#x27;dist&#x27;]    &#125;),    alias(),    replace(&#123;      &#x27;process.env.NODE_ENV&#x27;: JSON.stringify(process.env.NODE_ENV || &#x27;development&#x27;),      preventAssignment: true    &#125;),    nodeResolve(),    commonjs(&#123;      include: &#x27;node_modules/**&#x27;    &#125;),    eslint(&#123;      throwOnError: true, // 抛出异常并阻止打包      include: [&#x27;src/**&#x27;],      exclude: [&#x27;node_modules/**&#x27;]    &#125;),    babel(&#123; babelHelpers: &#x27;bundled&#x27; &#125;)  ]&#125;\r\n修改包名：\r\n// 此处 pkgName 要修改成自己的包名const pkgName = &#x27;vtools&#x27;\r\nrollup.config.dev.js\r\nimport baseConfig from &#x27;./rollup.config.base&#x27;import serve from &#x27;rollup-plugin-serve&#x27;import livereload from &#x27;rollup-plugin-livereload&#x27;export default &#123;  ...baseConfig,  plugins: [    ...baseConfig.plugins,    serve(&#123;      port: 8080,      contentBase: [&#x27;dist&#x27;, &#x27;examples/brower&#x27;],      openPage: &#x27;index.html&#x27;,    &#125;),    livereload(&#123;      watch: &#x27;examples/brower&#x27;,    &#125;)  ]&#125;\r\nrollup.config.prod.js\r\nimport baseConfig from &#x27;./rollup.config.base&#x27;import filesize from &#x27;rollup-plugin-filesize&#x27;export default &#123;  ...baseConfig,  plugins: [    ...baseConfig.plugins,    filesize()  ]&#125;\r\n配置 prettier\r\nprettier 主要用于代码格式校验和修正。\r\n# --save-exact 添加准确的版本号，例如：&quot;webpack&quot;: &quot;^5.1.3&quot;，添加--save-exact后将没有 ^ 号# npmnpm install --save-dev --save-exact prettier# yarnyarn add --dev --exact prettier# 添加配置文件New-Item .prettierrc.js# 添加下列内容module.exports = &#123;  printWidth: 80,  tabWidth: 2,  useTabs: false,  singleQuote: true,  proseWrap: &#x27;preserve&#x27;,  arrowParens: &#x27;avoid&#x27;,  bracketSpacing: true,  disableLanguages: [&#x27;vue&#x27;],  endOfLine: &#x27;auto&#x27;,  eslintIntegration: false,  htmlWhitespaceSensitivity: &#x27;ignore&#x27;,  ignorePath: &#x27;.prettierignore&#x27;,  jsxBracketSameLine: false,  jsxSingleQuote: true,  parser: &#x27;babel&#x27;,  requireConfig: false,  stylelintIntegration: false,  trailingComma: &#x27;none&#x27;,  tslintIntegration: true,  &#x27;workbench.iconTheme&#x27;: &#x27;vscode-icons&#x27;,  &#x27;editor.minimap.enabled&#x27;: false,  &#x27;editor.renderWhitespace&#x27;: &#x27;none&#x27;,  &#x27;editor.renderControlCharacters&#x27;: false,  semi: false&#125;# 添加忽略文件New-Item .prettierignore.js -value build`ncoverage\r\n配置 eslint\r\neslint 主要用于代码质量的校验。\r\n安装\r\n// 在开发环境中安装 esLintnpm i eslint -D// 生成配置文件npx eslint --init// 开发中使用 eslit 检查语法，用 prettier 检查格式// 1.选择 To check syntax and find problems// 2.选择用 javaScript modules 开发\r\n安装插件并配置\r\n// 使用 standard 规范npm install --save-dev eslint-config-standard eslint-config-prettier eslint-plugin-promise eslint-plugin-import eslint-plugin-node// .eslintrc.js 配置module.exports = &#123;  root: true,  env: &#123;    browser: true,    es2021: true,    jest: true // 支持jest  &#125;,  extends: [&#x27;standard&#x27;, &#x27;prettier&#x27;],  parserOptions: &#123;    ecmaVersion: 12,    sourceType: &#x27;module&#x27;  &#125;&#125;// .eslintignore 配置忽略 dist, 防止校验打包的产物New-Item .eslintignore.js -value dist\r\n\r\n如果有更复杂的需求，可以安装 eslint-config-prettier 来禁用 eslint 与\r\nprettier 之间冲突的配置。\r\n\r\n配置 babel\r\nnpm i -D @babel/core @babel/preset-env babel-plugin-transform-async-to-promisesNew-Item .babelrc.js// .babelrc.jsmodule.exports = &#123;  presets: [    [&#x27;@babel/preset-env&#x27;, &#123;      // rollupjs 会处理模块，所以设置成 false      modules: false    &#125;]  ],  plugins: [    // 避免 babel 将 async/await 转成 Generator    // 这样兼容性更好    &#x27;transform-async-to-promises&#x27;  ]&#125;\r\n单元测试\r\ntest 目录下创建 xxx.test.js（xxx 和 源码中的文件名保持一致）\r\n\r\n选用 jest 做单元测试\r\n配置 eslint 的 jest 环境\r\n解决 jest 不支持 es module 的问题\r\n\r\nnpm i -D jest# 支持 `es module`npm i -D rollup-jest # 添加测试目录mkdir test# package.json 中设置 &quot;jest&quot;: &#123;    &quot;preset&quot;: &quot;rollup-jest&quot;&#125;# 执行测试npx jest # 测试覆盖率npx jest --coverage\r\n更新忽略文件\r\n.gitignore\r\n# `n 代表换行# 如果是用 git 仓库管理来作为包服务的话，dist 不能忽略New-Item .gitignore -value node_modules`ndist`ncoverage`n\r\n.npmignore\r\n# 新建文件New-Item .npmignore# 添加内容node_modulestestsrc.babelrc.js.eslintrc.jsscriptscoveragedocs.czrc.eslintignore.huskyrc.commitlint.config.js.commitlint.config\r\nREADME.md\r\n添加徽标\r\n\r\nGitHub徽标官网是shields.io\r\n普通徽标\r\n\r\nhttps://img.shields.io/badge/&#123;徽标标题&#125;-&#123;徽标内容&#125;-&#123;徽标颜色&#125;.svg// eg![build](https://img.shields.io/badge/build-passing-success.svg)复制代码\r\n\r\n动态徽标\r\n\r\nhttps://img.shields.io/github/issues/&#123;github用户名&#125;/&#123;仓库名&#125;.svghttps://img.shields.io/github/forks/&#123;github用户名&#125;/&#123;仓库名&#125;.svghttps://img.shields.io/github/stars/&#123;github用户名&#125;/&#123;仓库名&#125;.svghttps://img.shields.io/github/license/&#123;github用户名&#125;/&#123;仓库名&#125;.svg\r\ngit 提交校验\r\n安装下列包：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n包名\r\n作用\r\n\r\n\r\n\r\n\r\nhusky\r\n关联git的hook与项目，可以实现在提交时校验提交信息的规范性\r\n\r\n\r\n@commitlint/config-conventional\r\n代码提交 message 规范校验格式库\r\n\r\n\r\n@commitlint/cli\r\n代码提交 message 规范校验\r\n\r\n\r\ncommitizen\r\n代码交互提交\r\n\r\n\r\ncz-conventional\r\n\r\n\r\n\r\n\r\n完整安装及配置：\r\nnpm install --save-dev husky @commitlint/config-conventional @commitlint/cli commitizen cz-conventional-changelog# commitlint.configecho &quot;module.exports = &#123;extends: [&#x27;@commitlint/config-conventional&#x27;]&#125;&quot; &gt; commitlint.config.js# 初始化 gitgit init# commitlint 使用 husky 的消息钩子npx husky install# 注意，-- commitlint 之间有一个空格npx husky add .husky/commit-msg &#x27;npx --no -- commitlint --edit &quot;$1&quot;&#x27;# .czrcNew-Item .czrc# 内容&#123; &quot;path&quot;: &quot;cz-conventional-changelog&quot; &#125;# package.json# commitizen 快捷命令&#123;  &quot;scripts&quot;: &#123;    &quot;commit&quot;: &quot;cz&quot;  &#125;&#125;\r\n常用的commitlint type类别：\r\n\r\nbuild：发布\r\nchore：构建过程或辅助工具的变动\r\nci：合并其它贡献者的代码变化（continuous integration）\r\ndocs：文档（documentation）\r\nfeat：新功能（feature）\r\nfix：修补bug\r\nperf：\r\nrefactor：重构（即不是新增功能，也不是修改bug的代码变动）\r\nstyle： 格式（不影响代码运行的变动）\r\ntest：增加测试\r\n\r\n\r\n例：\r\ngit commit -m 'feat: 增加 xxx 功能' git commit -m 'bug: 修复 xxx\r\n功能'\r\n\r\n配置package.json\r\n经过上述配置，我们还需要配置一些 npm 脚本来运行，如下：\r\n&quot;scripts&quot;: &#123;    &quot;dev&quot;: &quot;npx rollup -w --environment NODE_ENV:development -c config/rollup.config.dev.js&quot;,    &quot;build&quot;: &quot;npx rollup --environment NODE_ENV:production -c config/rollup.config.prod.js&quot;,    &quot;x&quot;: &quot;npm --no-git-tag-version version major&quot;,    &quot;y&quot;: &quot;npm --no-git-tag-version version minor&quot;,    &quot;z&quot;: &quot;npm --no-git-tag-version version patch&quot;,    &quot;lint&quot;: &quot;eslint src&quot;,    &quot;fix&quot;: &quot;npm run lint --fix&quot;,    &quot;commit&quot;: &quot;git-cz&quot;,    &quot;test&quot;: &quot;jest&quot;,    &quot;test:c&quot;: &quot;jest --coverage&quot;,    &quot;prepublish&quot;: &quot;npm run build&quot;,    &quot;pub&quot;: &quot;npm publish --access=public&quot;,    &quot;pub:x&quot;: &quot;npm run x &amp;&amp; npm publish --access=public&quot;,    &quot;pub:y&quot;: &quot;npm run y &amp;&amp; npm publish --access=public&quot;,    &quot;pub:z&quot;: &quot;npm run z &amp;&amp; npm publish --access=public&quot;&#125;\r\n完整版：\r\n&#123;  &quot;name&quot;: &quot;wow-tool&quot;,  &quot;version&quot;: &quot;0.0.1&quot;,  &quot;author&quot;: &quot;&quot;,  &quot;description&quot;: &quot;provide some usefull uities for javascript&quot;,  &quot;main&quot;: &quot;src/index.js&quot;,  // main,module,broser 分别代表不同环境下的入口文件  &quot;main&quot;: &quot;dst/sw-utils.cjs.js&quot;,  &quot;module&quot;: &quot;dst/sw-utils.esm.js&quot;,  &quot;scripts&quot;: &#123;     &quot;dev&quot;: &quot;npx rollup -w --environment NODE_ENV:development -c config/rollup.config.dev.js&quot;,    &quot;build&quot;: &quot;npx rollup --environment NODE_ENV:production -c config/rollup.config.prod.js&quot;,    &quot;x&quot;: &quot;npm --no-git-tag-version version major&quot;,    &quot;y&quot;: &quot;npm --no-git-tag-version version minor&quot;,    &quot;z&quot;: &quot;npm --no-git-tag-version version patch&quot;,    &quot;lint&quot;: &quot;eslint src&quot;,    &quot;fix&quot;: &quot;npm run lint --fix&quot;,    &quot;commit&quot;: &quot;git-cz&quot;,    &quot;test&quot;: &quot;jest&quot;,    &quot;test:c&quot;: &quot;jest --coverage&quot;,    &quot;prepublish&quot;: &quot;npm run build&quot;,    &quot;pub&quot;: &quot;npm publish --access=public&quot;,    &quot;pub:x&quot;: &quot;npm run x &amp;&amp; npm publish --access=public&quot;,    &quot;pub:y&quot;: &quot;npm run y &amp;&amp; npm publish --access=public&quot;,    &quot;pub:z&quot;: &quot;npm run z &amp;&amp; npm publish --access=public&quot;  &#125;,  &quot;jest&quot;: &#123;    &quot;preset&quot;: &quot;rollup-jest&quot;  &#125;,  &quot;repository&quot;: &#123;    &quot;type&quot;: &quot;git&quot;,    &quot;url&quot;: &quot;https://gitee.com/noctiflorous/wow-tool.git&quot;  &#125;,  &quot;keywords&quot;: [],  &quot;license&quot;: &quot;ISC&quot;,  &quot;bugs&quot;: &#123;    &quot;url&quot;: &quot;https://gitee.com/noctiflorous/wow-tool.git/issues&quot;  &#125;,  &quot;homepage&quot;: &quot;https://gitee.com/noctiflorous/wow-tool.git#readme&quot;,  // 开发依赖（作为npm包被install时，开发依赖不会被下载进node_modules）  &quot;devDependencies&quot;: &#123;    &quot;@babel/core&quot;: &quot;^7.16.7&quot;,    &quot;@babel/preset-env&quot;: &quot;^7.16.7&quot;,    &quot;@commitlint/cli&quot;: &quot;^16.0.2&quot;,    &quot;@commitlint/config-conventional&quot;: &quot;^16.0.0&quot;,    &quot;@rollup/plugin-alias&quot;: &quot;^3.1.9&quot;,    &quot;@rollup/plugin-babel&quot;: &quot;^5.3.0&quot;,    &quot;@rollup/plugin-commonjs&quot;: &quot;^21.0.1&quot;,    &quot;@rollup/plugin-eslint&quot;: &quot;^8.0.1&quot;,    &quot;@rollup/plugin-json&quot;: &quot;^4.1.0&quot;,    &quot;@rollup/plugin-node-resolve&quot;: &quot;^13.1.3&quot;,    &quot;@rollup/plugin-replace&quot;: &quot;^3.0.1&quot;,    &quot;commitizen&quot;: &quot;^4.2.4&quot;,    &quot;cz-conventional-changelog&quot;: &quot;^3.3.0&quot;,    &quot;eslint&quot;: &quot;^7.32.0&quot;,    &quot;eslint-config-standard&quot;: &quot;^16.0.3&quot;,    &quot;eslint-plugin-import&quot;: &quot;^2.25.4&quot;,    &quot;eslint-plugin-node&quot;: &quot;^11.1.0&quot;,    &quot;eslint-plugin-promise&quot;: &quot;^5.2.0&quot;,    &quot;husky&quot;: &quot;^7.0.4&quot;,    &quot;jest&quot;: &quot;^27.4.7&quot;,    &quot;rollup&quot;: &quot;^2.63.0&quot;,    &quot;rollup-jest&quot;: &quot;^1.1.3&quot;,    &quot;rollup-plugin-clear&quot;: &quot;^2.0.7&quot;,    &quot;rollup-plugin-filesize&quot;: &quot;^9.1.1&quot;,    &quot;rollup-plugin-livereload&quot;: &quot;^2.0.5&quot;,    &quot;rollup-plugin-serve&quot;: &quot;^1.1.0&quot;,    &quot;rollup-plugin-terser&quot;: &quot;^7.0.2&quot;  &#125;,  // 依赖（作为npm包被install时，依赖会被下载进node_modules）  &quot;dependencies&quot;: &#123;&#125;,&#125;\r\n编写功能\r\n上述配置完成后，就可以开始编写功能了。\r\n入口函数为 src/index.js ，该入口在\r\nrollup.config.base.js 中定义的。\r\n// src/index.jsconst units = [&#x27;B&#x27;, &#x27;KB&#x27;, &#x27;MB&#x27;, &#x27;GB&#x27;, &#x27;TB&#x27;, &#x27;PB&#x27;]/** * 字节转存储大小 * @param &#123;*&#125; bytes * @returns */export function humanStorageSize(bytes) &#123;  let u = 0  while (parseInt(bytes, 10) &gt;= 1024 &amp;&amp; u &lt; units.length - 1) &#123;    bytes /= 1024    ++u  &#125;  return `$&#123;bytes.toFixed(1)&#125;$&#123;units[u]&#125;`&#125;\r\n编写测试\r\n针对上述的 humanStorageSize\r\n方法编写一个单元测试，单元编写参考：rollup-jest 、jest\r\n使用示例：\r\nimport path from &#x27;path&#x27;test(&#x27;parses extname&#x27;, () =&gt; &#123;  expect(path.extname(&#x27;foo.md&#x27;)).toBe(&#x27;.md&#x27;)&#125;)\r\nhumanStorageSize 测试示例：\r\n// 新建文件New-Item test/humanStorageSize.test.js// 添加如下内容import &#123; humanStorageSize &#125; from &#x27;../src/index&#x27;test(&#x27;test humanStorageSize&#x27;, () =&gt; &#123;  expect(humanStorageSize(1024)).toBe(&#x27;1.0KB&#x27;)&#125;)\r\n执行测试：\r\n// 运行测试npx jest test/humanStorageSize\r\n测试结果：\r\n\r\n\r\nimage-20220407181351999\r\n\r\n通过 Git 管理包\r\n如果公司没有私有包服务器，同时也不想将包发到 npm 上，可以发布到私有\r\nGit 仓库里，然后直接从 Git 安装包。&gt;&gt; 用\r\ngit 管理私有包\r\n发布到 npm\r\n发布到 verdaccio\r\n参考\r\n本文主要参考以下文章，在此致以诚挚谢意！\r\n\r\n详解从零创建自己的NPM包\r\n开发一个规范的\r\nnpm 包\r\n深入对比Webpack、Parcel、Rollup打包工具\r\nNode.js\r\n如何处理 ES6 模块 - 阮一峰的网络日志 (ruanyifeng.com)\r\npackage.json\r\n中 你还不清楚的 browser，module，main 字段优先级\r\nPackage\r\nexports | webpack\r\nES6和commonJs模块化规范的混用\r\n\r\n","categories":["Develop","Javascript","Package"],"tags":["npm","uyoufu"]},{"title":"npm镜像源管理工具nrm使用","url":"/posts/2022/W1573T.html","content":"通过 nrm(npmregistry manager) 可以很方面的管理和切换 npm\r\n的镜像源。\r\n\r\n安装\r\nnpm install -g nrm\r\n使用\r\n查看可用源列表：\r\nnrm ls\r\n\r\n结果中带 * 号的为当前使用的源\r\n\r\n快速切换：\r\nnrm use xxx\r\n增加镜像源：\r\n如果我们需要增加特定的源，比如自己的私有源，可以执行以下命令进行添加，其中\r\nreigstry为源名，url为源的路径。\r\nnrm add &lt;registry&gt; &lt;url&gt;\r\n删除：\r\nnrm del &lt;registry&gt;\r\n测试某个源的速度：\r\nnrm test xxx\r\n","categories":["Develop","Javascript","Package"],"tags":["npm","pakage","nrm"]},{"title":"npm包开发建议","url":"/posts/2022/31N5JWW.html","content":"技术选型\r\n\r\n建议根据所开发的npm包功能，选择更加快速且合理的打包方案。如果开发的是一个\r\ntools 这样的工具库，显然更适合用 rollup\r\n打包。如果是开发的是一个业务组件（vue），则更加适合采用\r\n@vue/cli 的 lib 模式来构建。\r\n\r\n为什么一定要选择打包工具来开发 npm 包?\r\n\r\n不一定非要使用构建工具来开发，使用构建工具主要是为了使用它强大的生态系统。比如代码风格检测、本地服务、同时构建多种规范的产物等等，方便我们的开发\r\n\r\n为什么是 rollup 而不是 webpack?\r\n\r\n随着 rollup 和 webpack\r\n的版本更新，二者之间的差异性特性越来越小\r\nrollup\r\n配置简单，支持同时打包输出多种规范的产物（iife、cjs、umd、esm、amd、system）\r\nwebpack\r\n功能强大社区丰富，更加适合大型应用；不支持打包输出为es module，而且产物不是很纯净\r\n构建App应用时，webpack比较合适；如果是类库（纯js项目），rollup更加适合。\r\n\r\n\r\n完整的开发流程\r\n\r\n初始化项目\r\n创建合理的目录结构\r\n配置 eslint 统一代码风格\r\n配置 typescript 开发环境\r\n配置 babel\r\n配置 git 提交的校验钩子\r\n开始编写代码\r\nwatch 模式开发(本地服务)\r\n添加单元测试，编写测试示例\r\n完善 package.json 必要字段\r\n配置合适的 npm script\r\n本地测试开发的 npm 包\r\n发布包到 npm\r\n提交代码到 git 仓库\r\n\r\n合理的包结构\r\n├── bin  // 用于存放可执行二进制文件的目录├── dist(lib)  // 产物输出目录├── docs // 文档说明├── examples // 示例├── package.json├── README.md // 包说明，会在npm展示├── scripts // 脚本├── src(packages) // 源码├── test // 单元测试└── ...  // 一些配置文件（eg: eslint、babel）\r\n致谢\r\n本文摘抄于以下文章，在此致以诚挚谢意！\r\n\r\n开发一个规范的\r\nnpm 包\r\n\r\n","categories":["Develop","Javascript","Package"],"tags":["npm包"]},{"title":"yarn 常用命令","url":"/posts/2022/AKDK4Z.html","content":"yarn 的常用命令如下：\r\n\r\n添加\r\n本地安装：\r\nyarn add &lt;package&gt;[@&lt;version&gt;]\r\n\r\n&lt;&gt; 代表名称\r\n[] 中内容代表可选\r\n\r\n安装为开发依赖：\r\nyarn add &lt;package&gt;[@&lt;version&gt;] -D// 或yarn add &lt;package&gt;[@&lt;version&gt;] --dev\r\n全局安装：\r\nyarn global add &lt;package&gt;[@&lt;version&gt;]\r\n\r\n注意 global 的顺序，位于 add 之前\r\n\r\n移除\r\nyarn remove &lt;package&gt;\r\n\r\n运行 yarn remove foo 会从你的直接依赖里移除名为\r\nfoo 的包，在此期间会更新你的 package.json 和\r\nyarn.lock 文件\r\n\r\n运行\r\nyarn run [script][&lt;args&gt;]\r\n缓存\r\n查看缓存位置：\r\nyarn cache dir\r\n清空缓存：\r\nyarn cache clean\r\n","categories":["Develop","Javascript","Package"],"tags":["yarn","package"]},{"title":"yarn镜像源管理工具yrm使用","url":"/posts/2022/QRGC5D.html","content":"通过 yrm(yarn registry manager) 可以很方面的管理和切换\r\nyarn的镜像源。\r\n\r\n安装\r\nnpm install -g yrm\r\n使用\r\n查看可用源列表：\r\nyrm ls\r\n\r\n结果中带 * 号的为当前使用的源\r\n\r\n快速切换：\r\nyrm use xxx\r\n增加镜像源：\r\n如果我们需要增加特定的源，比如自己的私有源，可以执行以下命令进行添加，其中\r\nreigstry为源名，url为源的路径。\r\nyrm add &lt;registry&gt; &lt;url&gt;\r\n删除：\r\nyrm del &lt;registry&gt;\r\n测试某个源的速度：\r\nyrm test xxx\r\n","categories":["Develop","Javascript","Package"],"tags":["npm","pakage","nrm"]},{"title":"向 verdaccio 新建用户并发布包","url":"/posts/2022/GZ1MBS.html","content":"本文记录了如何向私有镜像管理器（verdaccio）中新建用户并发布本地包的方法。\r\n\r\nverdaccio 没有用户注册管理界面，一切需要在终端利用 npm 操作。\r\n登陆用户\r\nnpm adduser --registry https://yourdomain.cn/\r\n发布包\r\nnpm publish --registry https://yourdomain.cn/\r\n","categories":["Develop","Javascript","Package"],"tags":["npm","verdaccio"]},{"title":"用 git 管理私有包","url":"/posts/2022/3TYQ1H6.html","content":"在实际的开发中，有时候 npm\r\n上的包可能不满足使用要求，需要在其基础上进行修改，然后发布自己的包。在程序体量不大的情况下，可以采用\r\nGit 来进行包管理。\r\n\r\n下文以 Quasar 组件为例。\r\n下载包\r\n使用 npm 或 yarn 将包更新到自己需要的版本。以后基于该版本进行修改\r\nyarn add quasar@1.18.9\r\n新建 Git\r\n\r\n复制包的内容到新目录，然后运行 git init\r\n初始化包\r\n按需修改组件，新增一个 tag\r\n\r\ngit remote add origin xxx(仓库地址)# ...省略分支推送# 新建tag git tag v1.18.9.1# 推送taggit push origin v1.18.9.1\r\n更新标签\r\n标签无法更新，只有先删除再重新创建。\r\n删除代码如下：\r\n# 删除本地taggit tag -d [tag]# 删除远程taggit push origin :refs/tags/[tagName]\r\n使用\r\nyarn 格式:\r\nyarn add &lt;git remote url&gt;#&lt;branch/commit/tag&gt;\r\nnpm 格式:\r\nnpm install -s &lt;git remote url&gt;#&lt;branch/commit/tag&gt;\r\n参考\r\nyarn\r\nAdding dependencies\r\n","categories":["Develop","Javascript","Package"],"tags":["package","git"]},{"title":"The unauthenticated git protocol on port 9418 is no longer supported","url":"/posts/2022/Q9EGFQ.html","content":"在使用 npm install 或 yarn insatll\r\n时，报错：\r\nerror Command failed.Exit code: 128Command: gitArguments: ls-remote --tags --heads git://github.com/adobe-webplatform/eve.gitDirectory: E:\\galensShare\\Develop\\swToolsFrontEndOutput:fatal: remote error:  The unauthenticated git protocol on port 9418 is no longer supported.Please see https://github.blog/2021-09-01-improving-git-protocol-security-github/ for more information.info Visit https://yarnpkg.com/en/docs/cli/install for documentation about this command.\r\n\r\n原因分析：\r\n这是由于某些依赖包是通过 Git 来进行安装的，并且其安装链接为 SSH，而\r\nGithub 现已不支持 SSH 安装，所以会报错。\r\n解决办法：\r\n搜索 .gitconfig 文件\r\n\r\n\r\nimage-20220408162030125\r\n\r\n在里面添加如下内容，来告诉 git 在遇到它时使用 https 而不是 SSH。\r\n[url &quot;https://&quot;]    insteadOf = ssh://[url &quot;https://&quot;]    insteadOf = git://\r\n","categories":["Develop","Javascript","Package"],"tags":["npm"]},{"title":"如何优雅地在本地测试 npm 包","url":"/posts/2022/2151DJJ.html","content":"需要发布 my-package，想在 my-project\r\n项目内测试 my-package，可以通过下列 3 种方式。\r\n\r\nmy-package 是包名，my-project\r\n是测试项目名\r\n\r\n\r\nyalc 模拟仓库\r\n全局安装：\r\nnpm i yalc -g# 或者yarn global add yalc\r\nmy-npm build 后， 执行 yalc public，在 my-project 中\r\nyalc add my-package\r\n参考\r\nyalc\r\n如何优雅地在本地测试\r\nnpm 包\r\n","categories":["Develop","Javascript","Package"],"tags":["Javascript","npm"]},{"title":"在 rollup 中配置别名","url":"/posts/2022/3JD7WCR.html","content":"在 rollup 中配置别名需要用到 @rollup/plugin-alias\r\n包。\r\n\r\n安装\r\nnpm install @rollup/plugin-alias --save-dev# oryarn add -D @rollup/plugin-alias\r\n使用\r\n在 rollup.config.js 配置文件\r\n中导入下列配置\r\nimport alias from &#x27;@rollup/plugin-alias&#x27;;import path from &#x27;path&#x27;module.exports = &#123;  plugins: [    alias(&#123;      entries: [        &#123; find: &#x27;utils&#x27;, replacement: &#x27;../../../utils&#x27; &#125;,        &#123; find: &#x27;batman-1.0.0&#x27;, replacement: &#x27;./joker-1.5.0&#x27; &#125;,        // __dirName 是 config 所在的目录        &#123; find: &#x27;@&#x27;, replacement: path.resolve(path.dirname(__dirname), &#x27;src&#x27;) &#125;      ]    &#125;)  ]&#125;\r\n\r\n__dirname\r\n代表根目录，说明参见：http://nodejs.cn/api/globals.html#__dirname\r\n\r\njest 中配置别名\r\n为了使别名支持jest 单元测试，需要对 jest 配置 moduleNameMapper\r\n在 package.json 文件中添加如下配置\r\n// package 根&#123;  &quot;jest&quot;:&#123;    &quot;moduleNameMapper&quot;:&#123;      &quot;^@/(.*)&quot;:&quot;&lt;rootDir&gt;/src/$1&quot;    &#125;   &#125;&#125;\r\nvscode 中别名智能识别\r\n在根目录中创建 jsconfig.json\r\n文件，里面添加如下内容：\r\n// 此处是根，如果已经存在配置，则去掉外层大括号&#123;    &quot;compilerOptions&quot;: &#123;        &quot;baseUrl&quot;: &quot;./&quot;,        &quot;paths&quot;: &#123;            &quot;@/*&quot;: [                &quot;app/*&quot;            ]        &#125;    &#125;&#125;\r\n参考\r\nhttps://www.npmjs.com/package/@rollup/plugin-alias\r\nhttps://medium.com/@justintulk/solve-module-import-aliasing-for-webpack-jest-and-vscode-74007ce4adc9\r\n","categories":["Develop","Javascript","Package"],"tags":["Rollup","Package"]},{"title":"js对象获取属性的几种方法","url":"/posts/2020/1T9E994.html","content":"js 对象获取属性有多种方法。\r\n\r\n通过 . 方式获取属性值\r\nkey是静态的。\r\nconst person = &#123;name: &quot;zhang&quot;, age: 18&#125;;console.log(person.name);\r\n通过 [] 获取属性值\r\nkey是动态的，可以是字符串，或者数字的形式。\r\nconst fruits = &#123;&quot;apple&quot;: 3, &quot;pear&quot;: 2&#125;const person = &#123;name: &quot;zhang&quot;, age: 18&#125;;console.log(fruits[&quot;apple&quot;]);console.log(person[1]);  // 注意这里的写法跟数组容易混淆，cc仍是对象，不是数组\r\n通过使用这种方式，可以在属性名定义和使用上实现解耦。\r\nObject.keys()方式\r\n这是对象内置属性方法:\r\nObject.keys()；该方法返回一个数组，数组内包括\r\n对象内可枚举属性以及方法名称\r\nconst fruits = &#123;&quot;apple&quot;: 3, &quot;pear&quot;: 2&#125;const keys= Object.keys(fruits);console.log(keys); // 输出 keys [&quot;apple&quot;, &quot;pear&quot;]\r\nObject.getOwnPropertyNames()\r\n方法返回一个 指定对象\r\n所有自身属性的属性名（包括不可枚举属性, 但不包括 Symbol\r\n值作为名称的属性）组成的数组.（不可枚举:\r\n比如属性是一个js方法）\r\nconst fruits = &#123;&quot;apple&quot;: 3, &quot;pear&quot;: 2&#125;const keys = Object.getOwnPropertyNames(fruits);console.log(keys);　　// 输出 keys [&quot;apple&quot;, &quot;pear&quot;]\r\nfor...in\r\n最原始的 for...in 循环\r\nconst fruits = &#123;&quot;apple&quot;: 3, &quot;pear&quot;: 2&#125;const keys =[];  for(var i in fruits)&#123;    keys.push(i);  &#125;console.log(keys);   // 输出 keys [&quot;apple&quot;, &quot;pear&quot;]\r\n致谢\r\n\r\nJS获取对象“属性”的方法\r\njs对象获取属性的方法(.和[]方式)\r\n\r\n","categories":["Develop","Javascript","JSLanguage"],"tags":["Javascript"]},{"title":"js代码简化的几种方式","url":"/posts/2020/1C38P4H.html","content":"splice 的缺陷\r\n为了在编写 JS\r\n代码过程，更加的简洁和优雅，总结了一些简化语句的使用方法。\r\n\r\n传统 switch 改写\r\n// 改动前if(result&gt;1 &amp;&amp; result&lt;10) &#123;    return 0&#125;elseif(result&gt;10 &amp;&amp; result&lt;20)&#123;    return 1&#125;else&#123;    return 10&#125;// 改动后switch(true)&#123;case (result&gt;1 &amp;&amp; result&lt;10):    return 0case (result&gt;10 &amp;&amp; result&lt;20):    return 0default:    return 10&#125;\r\n三元运算符替换\r\n// 修改前if(bool)&#123;    val = 1&#125;else&#123;    val = 2&#125;// 改动后val = bool ? 1 : 2\r\n逻辑判断改写\r\nif(bool)&#123;    val = test()&#125;// 改动后bool &amp;&amp; (val = test())if(!bool)&#123;    val = test()&#125;// 改动后bool || (val = test())\r\n对象属性改写\r\nif(result==1)&#123;    return &#x27;one&#x27;&#125;elseif(result=2)&#123;    return &#x27;two&#x27;&#125;elseif(result=3)&#123;    return &#x27;three&#x27;&#125;else&#123;    return &#x27;&#x27;&#125;// 改动后result_info = &#123;1:&#x27;one&#x27;,2:&#x27;two&#x27;,3:&#x27;three&#x27;&#125;return result_info[result] ? result_info[result] : &#x27;&#x27;\r\n致谢\r\n\r\njs减少if语句的技巧\r\n\r\n","categories":["Develop","Javascript","JSLanguage"],"tags":["Javascript"]},{"title":"js中this的粗暴简单理解","url":"/posts/2020/2EFJQ9T.html","content":"从 C# 转到 JS, 感觉 各种帖子中的对于 JS 中的 this\r\n指向描述得复杂无比，本来好好简单的事情，害得我花了好久的时间才理解。于是将自己的拙见分享出来。\r\n\r\n要理解 this 的指向，只需要记住：\r\nthis\r\n指向执行时所在的上下文，即被调用函数所在的对象。\r\n一般情况\r\n那么究竟要怎么确定 this\r\n对象呢？我们只需要一级一级向上，遇到的第一个对象就是我们要的 this\r\n对象。\r\n下面举例说明：\r\nfunction fun()&#123;    console.log(this.s);&#125;var obj = &#123;    s:&#x27;1&#x27;,    f:fun&#125;var s = &#x27;2&#x27;;// 例1obj.f(); //1// 例2fun(); //2\r\n例 1 中，从 obj.f() 向上级搜索，找到的第一个对象就是\r\nobj ,所以例 1 中的 this 是 obj。\r\n例 2 中，从 f() 开始向上搜索，找到的第一个对象是当前\r\nmodel。\r\n下面再来一个例子：\r\nvar A = &#123;    name: &#x27;张三&#x27;,    f: function () &#123;        console.log(&#x27;姓名：&#x27; + this.name);    &#125;&#125;;var B = &#123;    name: &#x27;李四&#x27;&#125;;B.f = A.f;// 例3B.f()   // 姓名：李四// 例4A.f()   // 姓名：张三\r\n例 3 中，B 对象中的 f() 函数是由\r\nA 传递给它的，因为函数在内存中是一个单独的地址，所以\r\nA 在将 f 赋给 B\r\n的过程中，并不会将 A\r\n的作用域也一并传递过去，所以，B 中 f()\r\n的上一级就是 B。\r\n匿名函数\r\n上面的规则，不适用于匿名函数。匿名函数是在哪儿声明，它的\r\nthis 就指向声明位置处函数的上下文中的\r\nthis。\r\n特殊情况\r\nJS 提供了一些可以修改 this\r\n指向的函数。它们分别是call()、apply()、bind()。这些方法会指定里面 this\r\n的指向。\r\n具体区别请见 JavaScript\r\n中 call()、apply()、bind() 的用法。\r\n","categories":["Develop","Javascript","JSLanguage"],"tags":["Javascript","this"]},{"title":"exports、module.exports 和 export、export default 到底是咋回事？","url":"/posts/2020/1PNK91Q.html","content":"前言\r\n最近使用 node 和 vue 一起编程，想到 ES6 各种 export 、export\r\ndefault。阿西吧，头都大了....\r\n头大完了，那我们坐下先理理他们的使用范围。\r\nrequire:  node 支持的引入module.exports / exports: 只有 node 支持的导出export / import : 只有es6 支持的导出引入\r\n这一刻起，我觉得是时候要把它们之间的关系都给捋清楚了，不然我得混乱死。话不多少，咱们开干！！\r\n\r\nnode模块\r\n理解\r\nNode里面的模块系统遵循的是 CommonJS 规范。\r\n那问题又来了，什么是CommonJS规范呢？\r\n由于js以前比较混乱，各写各的代码，没有一个模块的概念，而这个规范出来其实就是对模块的一个定义。\r\nCommonJS定义的模块分为: 模块标识(module)、模块定义(exports)\r\n、模块引用(require)\r\n先解释 exports 和 module.exports\r\n在一个 node 执行一个文件时，会给这个文件内生成一个 exports 和 module\r\n对象， 而 module 又有一个 exports\r\n属性。他们都指向一块{}内存区域，关系如下图。\r\nexports = module.exports = &#123;&#125;;\r\n\r\n那下面我们来看看代码的吧。\r\n//utils.jslet a = 100;console.log(module.exports); //能打印出结果为：&#123;&#125;console.log(exports); //能打印出结果为：&#123;&#125;exports.a = 200; //这里辛苦劳作帮 module.exports 的内容给改成 &#123;a : 200&#125;exports.a = 100; //修改内存里面的值为100exports = &#x27;指向其他内存区&#x27;; //这里把exports的指向指走\r\n//test.jsvar a = require(&#x27;/utils&#x27;);console.log(a) // 打印为 &#123;a : 100&#125; \r\n从上面可以看出，其实 require 导出的内容是 module.exports\r\n的指向的内存块内容，并不是exports 的。\r\n简而言之，区分他们之间的区别就是 exports 只是 module.exports\r\n的引用，辅助后者添加内容用的。下面的摘抄nodejs官方的代码：\r\nfunction require(/* ... */) &#123;  const module = &#123; exports: &#123;&#125; &#125;;  ((module, exports) =&gt; &#123;    // Module code here. In this example, define a function.    function someFunc() &#123;&#125;    exports = someFunc;    // At this point, exports is no longer a shortcut to module.exports, and    // this module will still export an empty default object.    module.exports = someFunc;    // At this point, the module will now export someFunc, instead of the    // default object.  &#125;)(module, module.exports);  return module.exports;&#125;\r\n用白话讲就是，exports 只辅助 module.exports\r\n操作内存中的数据，辛辛苦苦各种操作数据完，累得要死，结果到最后真正被\r\nrequire 出去的内容还是 module.exports 的，真是好苦逼啊。\r\n其实大家用内存块的概念去理解，就会很清楚了。\r\n然后呢，为了避免糊涂，尽量都用 module.exports 导出，然后用 require\r\n导入。\r\nnode 模块的导出方式\r\n上面讲了 exports, module.exports 的区别\r\n接下来总结一下使用 CommonJS 规范时，有哪些导出形式\r\n导出函数\r\n// 定义模块// user.jsconst getName = () =&gt; &#123;  return &#x27;Jim&#x27;;&#125;;exports.getName = getName;\r\n// 使用模块// index.jsconst user = require(&#x27;./user&#x27;);console.log(`User: $&#123;user.getName()&#125;`);\r\n// 结果User: Jim\r\n导出多个函数和值\r\n// 定义// user.jsconst getName = () =&gt; &#123;  return &#x27;Jim&#x27;;&#125;;const getLocation = () =&gt; &#123;  return &#x27;Munich&#x27;;&#125;;const dateOfBirth = &#x27;12.01.1982&#x27;;exports.getName = getName;exports.getLocation = getLocation;exports.dob = dateOfBirth;\r\n// 使用// index.jsconst user = require(&#x27;./user&#x27;);console.log(  `$&#123;user.getName()&#125; lives in $&#123;user.getLocation()&#125; and was born on $&#123;user.dob&#125;.`);\r\n// 结果Jim lives in Munich and was born on 12.01.1982.\r\n在导出的过程中，可以与原变量有不同的名字\r\n语法变化\r\n我们可以在文件的任何地方导出方法或者值:\r\nexports.getName = () =&gt; &#123;  return &#x27;Jim&#x27;;&#125;;exports.getLocation = () =&gt; &#123;  return &#x27;Munich&#x27;;&#125;;exports.dob = &#x27;12.01.1982&#x27;;\r\n导出默认值\r\n上面的方式是对函数和值进行分别导出，这种方式适合于帮助类。但当你只想导出一个对象的时候，可以使用\r\nmodule.exports:\r\nclass User &#123;  constructor(name, age, email) &#123;    this.name = name;    this.age = age;    this.email = email;  &#125;  getUserStats() &#123;    return `      Name: $&#123;this.name&#125;      Age: $&#123;this.age&#125;      Email: $&#123;this.email&#125;    `;  &#125;&#125;// 此处直接将类赋值给 module.exportsmodule.exports = User;\r\nES6 中的模块导出导入\r\n说实话，在 es\r\n中的模块，就非常清晰了。不过也有一些细节的东西需要搞清楚。\r\n比如 export 和 export default，还有 导入的时候，import a from ..,\r\nimport {a} from ..，总之也有点乱，那么下面我们就开始把它们捋清楚吧。\r\nexport 和 export default\r\n首先我们讲这两个导出，下面我们讲讲它们的区别：\r\n\r\nexport 与 export default\r\n均可用于导出常量、函数、文件、模块等\r\n在一个文件或模块中，export、import 可以有多个，export default\r\n仅有一个\r\n通过 export 方式导出，在导入时要加{ name }，export default\r\n则不需要\r\nexport 导入时，只能使用定义时的名称，而 export default\r\n导入时，可以是任意名称\r\nexport 能直接导出变量表达式，export default 不行\r\n\r\n上面的两种方式，export 适合于一个模块中有 0 个或者多个 export\r\n的情况；export default 则只能有一个。\r\n// 导出独立的特征// Exporting individual featuresexport let name1, name2, …, nameN; // also var, constexport let name1 = …, name2 = …, …, nameN; // also var, constexport function functionName()&#123;...&#125;export class ClassName &#123;...&#125;// 导出列表// Export listexport &#123; name1, name2, …, nameN &#125;;// 导出时重命名// Renaming exportsexport &#123; variable1 as name1, variable2 as name2, …, nameN &#125;;// 导出时解构并重命名// Exporting destructured assignments with renamingexport const &#123; name1, name2: bar &#125; = o;// Default exportsexport default expression;export default function (…) &#123; … &#125; // also class, function*export default function name1(…) &#123; … &#125; // also class, function*export &#123; name1 as default, … &#125;;// 聚合模块：用于聚合其它模块并在当前模块导出// Aggregating modulesexport * from …; // does not set the default export export * as name1 from …; // Draft ECMAScript® 2O21export &#123; name1, name2, …, nameN &#125; from …;export &#123; import1 as name1, import2 as name2, …, nameN &#125; from …;export &#123; default &#125; from …;\r\n总结\r\n\r\n在 node 中使用 module.exports exports 和 require\r\n在 ES6 中使用 export export default 和 import\r\n\r\n致谢\r\n\r\nexports、module.exports\r\n和 export、export default 到底是咋回事\r\nUnderstanding\r\nmodule.exports and exports in Node.js\r\nMDN\r\nexport\r\n\r\n","categories":["Develop","Javascript","JSLanguage"],"tags":["Javascript"]},{"title":"js中对象的创建及理解","url":"/posts/2020/ZWWE36.html","content":"初学 JavalScrip\r\n时，它的自由让人很不适应，特别是对于对象的创建，很是疑惑：它没有类的概念（初学时了解的水平），也没有构造函数,\r\n而更不能理解的是，它的实例是通过 new\r\n函数得到的。直到看了《JavaScrip高级程序设计》之后，才恍然大悟，特此总结，希望能给那些初学者一点解惑之光，若有不足之处，还请斧正。\r\n\r\n用 C# 创建对象\r\n首先，我们看一下，在 C# 中怎么创建一个对象\r\n\r\n定义类\r\n// 类的定义public class Person&#123;    // 定义属性    public String Name &#123;get;set;&#125;    public int Age &#123;get;set;&#125;        // 构造函数 \tpublic Person(string name,int age)    &#123;        this.Name = name;        this.Age = age;    &#125;&#125;\r\n创建C#对象\r\nPerson person = new Person(&#x27;zhangsan&#x27;,18);\r\n上面就是 C# 创建对象的过程\r\n\r\n用 js 创建对象\r\n现在我们再来看一下 js 中如何创建对象（ES5中构造函数方式）\r\n\r\n定义函数\r\nfuction Person(name,age)&#123;    this.name = name;    this.age = age;&#125;\r\n创建 js 对象\r\n// const ES6 中的声明const person = new Person(&#x27;lisi&#x27;,19);\r\n\r\njs 创建对象原理分析\r\n要理解 js 中创建对象为什么可以 new\r\n函数得到，我们需要追本溯源，一步一步了解 js 中创建对象的演变\r\n\r\n最开始是 new Object 形式\r\nvar person = new Object();person.name = &#x27;lisi&#x27;;person.age = 19// 或者var person = &#123;    name: &#x27;lisi&#x27;,    age: 19&#125;\r\n然后是工厂模式\r\nfunction createPerson(name, age)&#123;\tvar o = new Object();\to.name = name;\to.age = age;\treturn o;&#125;\r\n随着演变，出现了构造函数模式\r\n// 定义构造函数时，首字母建议大写，用于区别一般函数function Person(name, age)&#123;\tthis.name = name;\tthis.age = age;&#125;\r\n分析\r\n对比工厂模式和构造函数模式，我们可以看到有如下区别\r\n\r\n后者没有显式地创建对象\r\n直接将属性和方法赋给了 this 对象\r\n没有 return 语句\r\n创建新实例的时候，必须用 new\r\n\r\n构造函数在创建对象的时候，其实经过了下面步骤：\r\n\r\n创建一个新对象\r\n将构造函数的作用域赋给新对象（因此 this 指向了新的对象）\r\n执行构造函数的代码（为这个新对象添加属性）\r\n返回新对象\r\n\r\n\r\n通过上面分析，我们就很容易地理解了，为什么 new\r\n一个函数可以创建对象\r\n将构造函数当作函数\r\n构造函数与其他函数的唯一区别，就在于调用它们的方式不同。不过，构造函数毕竟也是函数，不存在定义构造函数的特殊语法。任何函数，只要通过\r\nnew 操作符来调用，那它就可以作为构造函数；而任何函数，如果不通过 new\r\n操作符来调用，那它跟普通函数也不会有什么两样。不过直接调用的时候，它就是向上下文的\r\nthis 添加字段。\r\n构造函数方式的问题\r\n使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。\r\n例如有如下构造函数\r\nfunction Person(name, age, job)&#123;\tthis.name = name;\tthis.age = age;\tthis.job = job;\tthis.sayName = function()&#123;\t\talert(this.name);\t&#125;;&#125;\r\n当实例化多个 Person 后，每个实例中的 sayName\r\n不是同一个，上面的定义可以等价为：\r\nfunction Person(name, age, job)&#123;\tthis.name = name;\tthis.age = age;\tthis.job = job;\tthis.sayName = new Function(&quot;alert(this.name)&quot;); // 与声明函数在逻辑上是等价的&#125;\r\n然而，创建两个完成同样任务的 Function 实例的确没有必要；况且有 this\r\n对象在，根本不用在执行代码前就把函数绑定到特定对象上面。因此，大可像下面这样，通过把函数定义转移到构造函数外部来解决这个问题。\r\nfunction Person(name, age, job)&#123;\tthis.name = name;\tthis.age = age;\tthis.job = job;\tthis.sayName = sayName;&#125;function sayName()&#123;\talert(this.name);&#125;\r\n我们把\r\nsayName()函数的定义转移到了构造函数外部。而在构造函数内部，我们将\r\nsayName 属性设置成等于全局的 sayName 函数。这样一来，由于 sayName\r\n包含的是一个指向函数的指针。\r\n最优的对象声明方式\r\n既然分析了 js\r\n创建对象的原理，那么现在就必须要分享一下，什么是最优的对象声明方式了。原理部分直接省略，此处只给出最终的答案——动态原型模式：\r\nfunction Person(name, age, job)&#123;    // 属性    this.name = name;    this.age = age;    this.job = job;    // 方法: 在原型上声明    if (typeof this.sayName != &quot;function&quot;)&#123;        Person.prototype.sayName = function()&#123;            alert(this.name);            &#125;;    &#125;&#125;\r\n","categories":["Develop","Javascript","JSLanguage"],"tags":["Javascript","js对象"]},{"title":"promise的理解与实践","url":"/posts/2020/MV7E84.html","content":"Promise 的使用是 js\r\n编程中必须要掌握的技能，而且，它确实使用起来很方便，下面整理一下相关的知识点，以免今后遗忘，同时，节约查询的时间。\r\n\r\n原理学习\r\n我认为孔家少爷的知乎解释最透彻，该系列文章由浅入深逐步实现\r\nPromise，并结合流程图、实例以及动画进行演示，达到深刻理解 Promise\r\n用法的目的。链接如下：\r\n\r\n图解 Promise\r\n实现原理（一）—— 基础实现\r\n图解 Promise\r\n实现原理（二）—— Promise 链式调用\r\n图解 Promise\r\n实现原理（三）—— Promise 原型方法实现\r\n图解 Promise\r\n实现原理（四）—— Promise 静态方法实现\r\n\r\n在 new Promise(fn)时，fn会立即执行\r\n使用总结\r\n有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。\r\nPromise也有一些缺点。\r\n\r\n首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。\r\n其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。\r\n第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。\r\n\r\n如果某些事件不断地反复发生，一般来说，使用 Stream\r\n模式是比部署Promise更好的选择。\r\n基本用法\r\nconst promise = new Promise(function(resolve, reject) &#123;  // ... some code  if (/* 异步操作成功 */)&#123;    resolve(value);  &#125; else &#123;    reject(error);  &#125;&#125;);promise.then(function(value) &#123;  // success&#125;, function(error) &#123;  // failure&#125;);\r\n例1：\r\nPromise 新建后就会立即执行。\r\nlet promise = new Promise(function(resolve, reject) &#123;  console.log(&#x27;Promise&#x27;);  resolve();&#125;);promise.then(function() &#123;  console.log(&#x27;resolved.&#x27;);&#125;);console.log(&#x27;Hi!&#x27;);// Promise// Hi!// resolved\r\n上面代码中，Promise\r\n新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。\r\n例2:\r\nresolve函数的参数除了正常的值以外，还可能是另一个\r\nPromise 实例，比如像下面这样。\r\nconst p1 = new Promise(function (resolve, reject) &#123;  // ...&#125;);const p2 = new Promise(function (resolve, reject) &#123;  // ...  resolve(p1);&#125;)\r\n上面代码中，p1和p2都是 Promise\r\n的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。\r\n注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。\r\nconst p1 = new Promise(function (resolve, reject) &#123;  setTimeout(() =&gt; reject(new Error(&#x27;fail&#x27;)), 3000)&#125;)const p2 = new Promise(function (resolve, reject) &#123;  setTimeout(() =&gt; resolve(p1), 1000)&#125;)p2  .then(result =&gt; console.log(result))  .catch(error =&gt; console.log(error))// Error: fail\r\n上面代码中，p1是一个 Promise，3\r\n秒之后变为rejected。p2的状态在 1\r\n秒之后改变，resolve方法返回的是p1。由于p2返回的是另一个\r\nPromise，导致p2自己的状态无效了，由p1的状态决定p2的状态。所以，后面的then语句都变成针对后者（p1）。又过了\r\n2\r\n秒，p1变为rejected，导致触发catch方法指定的回调函数。\r\n注意，调用resolve或reject并不会终结 Promise\r\n的参数函数的执行。\r\nnew Promise((resolve, reject) =&gt; &#123;  resolve(1);  console.log(2);&#125;).then(r =&gt; &#123;  console.log(r);&#125;);// 2// 1\r\n上面代码中，调用resolve(1)以后，后面的console.log(2)还是会执行，并且会首先打印出来。这是因为立即\r\nresolved 的 Promise\r\n是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。\r\n一般来说，调用resolve或reject以后，Promise\r\n的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。\r\nnew Promise((resolve, reject) =&gt; &#123;  return resolve(1);  // 后面的语句不会执行  console.log(2);&#125;)\r\n原型函数\r\nPromise.prototype.then() §\r\n⇧\r\ngetJSON(&quot;/post/1.json&quot;).then(  post =&gt; getJSON(post.commentURL)).then(  comments =&gt; console.log(&quot;resolved: &quot;, comments),  err =&gt; console.log(&quot;rejected: &quot;, err));\r\n其中，err 是可以省略的\r\nPromise.prototype.catch() §\r\n⇧\r\nPromise.prototype.catch()方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。\r\ngetJSON(&#x27;/posts.json&#x27;).then(function(posts) &#123;  // ...&#125;).catch(function(error) &#123;  // 处理 getJSON 和 前一个回调函数运行时发生的错误  console.log(&#x27;发生错误！&#x27;, error);&#125;);\r\nPromise.prototype.finally() §\r\n⇧\r\nfinally()方法用于指定不管 Promise\r\n对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。\r\npromise.then(result =&gt; &#123;···&#125;).catch(error =&gt; &#123;···&#125;).finally(() =&gt; &#123;···&#125;);\r\n上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。\r\nPromise.all() § ⇧\r\nPromise.all()方法用于将多个 Promise 实例，包装成一个新的\r\nPromise 实例。\r\nconst p = Promise.all([p1, p2, p3]);\r\n上面代码中，Promise.all()方法接受一个数组作为参数，p1、p2、p3都是\r\nPromise\r\n实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为\r\nPromise\r\n实例，再进一步处理。另外，Promise.all()方法的参数可以不是数组，但必须具有\r\nIterator 接口，且返回的每个成员都是 Promise 实例。\r\np的状态由p1、p2、p3决定，分成两种情况。\r\n（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。\r\n（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。\r\n下面是一个具体的例子。\r\n// 生成一个Promise对象的数组const promises = [2, 3, 5, 7, 11, 13].map(function (id) &#123;  return getJSON(&#x27;/post/&#x27; + id + &quot;.json&quot;);&#125;);Promise.all(promises).then(function (posts) &#123;  // ...&#125;).catch(function(reason)&#123;  // ...&#125;);\r\n上面代码中，promises是包含 6 个 Promise\r\n实例的数组，只有这 6\r\n个实例的状态都变成fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数。\r\nPromise.race() § ⇧\r\nPromise.race()方法同样是将多个 Promise\r\n实例，包装成一个新的 Promise 实例。\r\nconst p = Promise.race([p1, p2, p3]);\r\n上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的\r\nPromise 实例的返回值，就传递给p的回调函数。\r\nPromise.race()方法的参数与Promise.all()方法一样，如果不是\r\nPromise\r\n实例，就会先调用下面讲到的Promise.resolve()方法，将参数转为\r\nPromise 实例，再进一步处理。\r\nPromise.allSettled() §\r\n⇧\r\nPromise.allSettled()方法接受一组 Promise\r\n实例作为参数，包装成一个新的 Promise\r\n实例。只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束。该方法由\r\nES2020\r\n引入。\r\nPromise.any() § ⇧\r\nPromise.any()方法接受一组 Promise\r\n实例作为参数，包装成一个新的 Promise\r\n实例。只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。该方法目前是一个第三阶段的提案 。\r\nPromise.any()跟Promise.race()方法很像，只有一点不同，就是不会因为某个\r\nPromise 变成rejected状态而结束。\r\nPromise.resolve() § ⇧\r\n有时需要将现有对象转为 Promise\r\n对象，Promise.resolve()方法就起到这个作用。\r\nconst jsPromise = Promise.resolve($.ajax(&#x27;/whatever.json&#x27;));\r\n上面代码将 jQuery 生成的deferred对象，转为一个新的\r\nPromise 对象。\r\nPromise.resolve()等价于下面的写法。\r\nPromise.resolve(&#x27;foo&#x27;)// 等价于new Promise(resolve =&gt; resolve(&#x27;foo&#x27;))\r\n需要注意的是，立即resolve()的 Promise\r\n对象，是在本轮“事件循环”（event\r\nloop）的结束时执行，而不是在下一轮“事件循环”的开始时。\r\nPromise.reject() § ⇧\r\nPromise.reject(reason)方法也会返回一个新的 Promise\r\n实例，该实例的状态为rejected。\r\nconst p = Promise.reject(&#x27;出错了&#x27;);// 等同于const p = new Promise((resolve, reject) =&gt; reject(&#x27;出错了&#x27;))p.then(null, function (s) &#123;  console.log(s)&#125;);// 出错了\r\n上面代码生成一个 Promise\r\n对象的实例p，状态为rejected，回调函数会立即执行。\r\n注意，Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。这一点与Promise.resolve方法不一致。\r\nPromise.try() § ⇧\r\n实际开发中，经常遇到一种情况：不知道或者不想区分，函数f是同步函数还是异步操作，但是想用\r\nPromise\r\n来处理它。因为这样就可以不管f是否包含异步操作，都用then方法指定下一步流程，用catch方法处理f抛出的错误。一般就会采用下面的写法。\r\nPromise.resolve().then(f)\r\n上面的写法有一个缺点，就是如果f是同步函数，那么它会在本轮事件循环的末尾执行。\r\nconst f = () =&gt; console.log(&#x27;now&#x27;);Promise.resolve().then(f);console.log(&#x27;next&#x27;);// next// now\r\n上面代码中，函数f是同步的，但是用 Promise\r\n包装了以后，就变成异步执行了。\r\n那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的\r\nAPI 呢？用法如下：\r\nPromise.try(() =&gt; database.users.get(&#123;id: userId&#125;))  .then(...)  .catch(...)\r\nAsync Await\r\nawait命令就是 promise 中 then`命令的语法糖。\r\nasync 函数\r\n致谢\r\n详细的原文链接：阮一峰老师的 ES6入门 之 Promise\r\n对象\r\n","categories":["Develop","Javascript","JSLanguage"],"tags":["NexT","Javascript","promise"]},{"title":"数组中 unshift 与解构赋值一起使用，顺序错误分析","url":"/posts/2020/1SH18GY.html","content":"js 数组为空时，使用 unshift\r\n方法，通过解构向数组头部插入数据时，会失效，等同于 push 效果。\r\n\r\n代码复现：\r\nconst arr = []// unshift 2 个值arr.unshift(...[1,2])console.log(&#x27;空数组 unshift 后的值: &#x27;,arr);\r\n// 结果空数组 unshift 后的值:  [ 1, 2 ]\r\n我们发现，上面的结果并不是我们想要的，我们所期望的结果应该是：\r\n// 期望结果空数组 unshift 后的值:  [ 2, 1 ]\r\n那么，为什么出现上面意外的结果，原因就是因为 arr 初始值为空。\r\n","categories":["Develop","Javascript","JSLanguage"],"tags":["Javascript"]},{"title":"javalscript 中的原型来源和理解","url":"/posts/2021/1RYMZHY.html","content":"一直不能很好的理解 javascrip\r\n的原型，个人认为它的原型有些反人类直觉，所以让人不是很好理解，所以特意抽时间整理了下。\r\n\r\n为什么用原型来实现继承\r\n我一直存在这样一个疑惑，既然 js 提供了对象，为什么不能提供像\r\nC#、Javal\r\n这种语言中对象的继承特性，而是要靠原型来实现，让我开始接触时，产生了不解和抵触。\r\n直到我看到了这篇文章：Javascript继承机制的设计思想\r\n才恍然大悟。\r\njavascrip 设计者 Brendan\r\nEich，他的主要方向和兴趣是函数式编程。再加上当时网景公司的整个管理层，都是Java语言的信徒，Sun公司完全介入网页脚本语言的决策。\r\n所以，Javascript语言实际上是两种语言风格的混合产物----（简化的）函数式编程+（简化的）面向对象编程。这是由Brendan\r\nEich（函数式编程）与网景公司（面向对象编程）共同决定的。\r\njavascript 的设计思路为：\r\n\r\n借鉴C语言的基本语法；\r\n借鉴Java语言的数据类型和内存管理；\r\n借鉴Scheme语言，将函数提升到\"第一等公民\"（first\r\nclass）的地位；\r\n借鉴Self语言，使用基于原型（prototype）的继承机制。\r\n\r\n由于 Javascript 借鉴了 Java 里的设计思想，javascrip\r\n里面都是对象，所以必须有一种机制，将所有对象联系起来。最后，Brendan\r\nEich设计了基于原型的\"继承\"。\r\n怎么理解原来及原型链\r\n原型及原型链的理解可以参考：一张图搞定JS原型&amp;原型链\r\n参考\r\n\r\nJavascript继承机制的设计思想\r\nJavascript诞生记\r\n一张图搞定JS原型&amp;原型链\r\n\r\n","categories":["Develop","Javascript","JSLanguage"],"tags":["Javascript"]},{"title":"js中单击按钮选择本地文件","url":"/posts/2021/383PEWF.html","content":"js 原生打开本地文件是通过设置 input 的\r\ntype='file'来实现的，但是它的界面很丑，往往达不到使用的要求，于是，我们通常的做法是通过一个\r\nbutton 去触发 input 的事件，实现文件选择。\r\n\r\nvue 实现\r\n以下示例使用 quasar 组件开发。\r\n// template代码&lt;q-btn  label=&quot;从Excel导入&quot;  dense  size=&quot;sm&quot;  outline  color=&quot;orange&quot;  @click=&quot;selectExcelFile&quot;&gt;&lt;/q-btn&gt;&lt;input type=&quot;file&quot; id=&quot;fileInput&quot; style=&quot;display: none&quot; @change=&quot;fileSelected&quot; /&gt;// excel模块import XLSX from &#x27;js-xlsx&#x27;// js 代码methods: &#123;  // 选择文件  selectExcelFile() &#123;    const elem = document.getElementById(&#x27;fileInput&#x27;)    elem.click()    elem.value=&#x27;&#x27; // 清空 vule，这样才可以再次选择文件  &#125;,  fileSelected(e) &#123;           // 判断是否选择了文件      if (e.target.files.length === 0) &#123;        return      &#125;      // 获取选择的文件      const file = e.target.files[0]      // 获取选择的文件      const file = e.target.files[0]      const excelData = await this.readExcelData(file)      if (!excelData) return      // 其它操作    &#125;,  // 读取 excel 数据  async readExcelData(file) &#123;      return new Promise((resolve, reject) =&gt; &#123;        const reader = new FileReader()        reader.onload = e =&gt; &#123;          const data = new Uint8Array(e.target.result)          const workbook = XLSX.read(data, &#123; type: &#x27;array&#x27; &#125;)          /* DO SOMETHING WITH workbook HERE */          // 变成json          const jsonObj = XLSX.utils.sheet_to_json(            workbook.Sheets[workbook.SheetNames[0]]          )          resolve(jsonObj)        &#125;        reader.onerror = () =&gt; &#123;          reject(false)        &#125;        reader.readAsArrayBuffer(file)      &#125;)    &#125;&#125;\r\n选项说明\r\n\r\n\r\n\r\n选项名\r\n描述\r\n\r\n\r\n\r\n\r\nmultiple\r\n表示可以多选文件\r\n\r\n\r\naccept\r\n用逗号隔开的 MIME 类型列表。\r\n\r\n\r\n\r\n常见\r\nMIME 类型列表\r\n","categories":["Develop","Javascript","JSLanguage"],"tags":["Javascript","文件选择"]},{"title":"javalscript 中的原型来源和理解","url":"/posts/2021/1RYMZHY.html","content":"一直不能很好的理解 javascrip\r\n的原型，个人认为它的原型有些反人类直觉，所以让人不是很好理解，所以特意抽时间整理了下。\r\n\r\n为什么用原型来实现继承\r\n我一直存在这样一个疑惑，既然 js 提供了对象，为什么不能提供像\r\nC#、Javal\r\n这种语言中对象的继承特性，而是要靠原型来实现，让我开始接触时，产生了不解和抵触。\r\n直到我看到了这篇文章：Javascript继承机制的设计思想\r\n才恍然大悟。\r\njavascrip 设计者 Brendan\r\nEich，他的主要方向和兴趣是函数式编程。再加上当时网景公司的整个管理层，都是Java语言的信徒，Sun公司完全介入网页脚本语言的决策。\r\n所以，Javascript语言实际上是两种语言风格的混合产物----（简化的）函数式编程+（简化的）面向对象编程。这是由Brendan\r\nEich（函数式编程）与网景公司（面向对象编程）共同决定的。\r\njavascript 的设计思路为：\r\n\r\n借鉴C语言的基本语法；\r\n借鉴Java语言的数据类型和内存管理；\r\n借鉴Scheme语言，将函数提升到\"第一等公民\"（first\r\nclass）的地位；\r\n借鉴Self语言，使用基于原型（prototype）的继承机制。\r\n\r\n由于 Javascript 借鉴了 Java 里的设计思想，javascrip\r\n里面都是对象，所以必须有一种机制，将所有对象联系起来。最后，Brendan\r\nEich设计了基于原型的\"继承\"。\r\n怎么理解原来及原型链\r\n原型及原型链的理解可以参考：一张图搞定JS原型&amp;原型链\r\n参考\r\n\r\nJavascript继承机制的设计思想\r\nJavascript诞生记\r\n一张图搞定JS原型&amp;原型链\r\n\r\n","categories":["Develop","Javascript","JSLanguage"],"tags":["Javascript"]},{"title":"个人常用 js 开发包","url":"/posts/2022/3B8HS2.html","content":"本文收集本人在开发中使用到的一些工具包，在使用之前，经过对比，筛选出自认为合适的应用于实际开发中。\r\n\r\n工具类\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n包名\r\n作用\r\n官网\r\n备注\r\n\r\n\r\n\r\n\r\nlodash.js\r\n提供对数组，集合，时间，函数，类型判断，数学，数字，队列，字符串，属性等操作的工具包\r\nhttps://lodash.com/docs/4.17.15\r\n\r\n\r\n\r\n*ramda.js\r\n一个专门为函数式编程风格设计的库，一个可以轻松创建函数管道的库，一个永远不会改变用户数据的库\r\nhttps://ramdajs.com/\r\n功能同 lodash,但是使用方式不一样，loash 更符合 lumda 表达式习惯\r\n\r\n\r\nmoment.js\r\n时间处理相关包\r\nhttps://momentjs.com/\r\n\r\n\r\n\r\n*day.js\r\n时间处理相关包\r\nhttps://day.js.org/zh-CN/\r\n比 moment 小，压缩后只有 2 k 左右\r\n\r\n\r\n*big.js\r\n一个小型，快速的JavaScript库，用于任意精度的十进制算术运算\r\nhttps://mikemcl.github.io/big.js/\r\n此处有两个其它同类型库的比较，使前需要仔细对比：https://github.com/MikeMcl/big.js/issues/45#issuecomment-104211175\r\n\r\n\r\nqs\r\n一个 url参数转化 (parse和stringify)的轻量级js库\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n文件操作\r\n\r\n\r\n\r\n包名\r\n作用\r\n官网\r\n备注\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n* 号代表暂未使用，但觉得不错，用于收藏\r\n\r\n参考\r\n本文主要参考以下文章，在此致以诚挚谢意！\r\n\r\n知乎：有哪些必看的 JS\r\n库？\r\n\r\n","categories":["Develop","Javascript","JSLanguage"],"tags":["Javascript"]},{"title":"深入浅出地理解 js 中原型","url":"/posts/2022/18JF19Q.html","content":"准备静心理解一下 JS\r\n中的原型，仔细一查，网上各有各的理解，各有各的缺点，让人眼花缭乱，看不通透。本文将从原理手，由浅入深地理解原型的概念。\r\n\r\n\r\n相信初学者一定认得此图，本人才理解时，把它视作天书，日夜观摩，妄想一步登天，顿悟\r\nJS\r\n原型链的大道，后来才发现，还是得从原理出发，才能行以致远，取得真经。\r\n咱们先从 JS 的起源说起。\r\nJS 的诞生\r\n","categories":["Develop","Javascript","JSLanguage"],"tags":["Javascript","原型"]},{"title":"js 下载文件后弹出保存框","url":"/posts/2022/WP9100.html","content":"本文介绍了如何在前端 js\r\n在下载文件时，弹出另存为对话框，方便用户可以选择保存的位置。\r\n\r\n正文\r\n可以使用 showSaveFilePicker() API 来实现，这个实现是 File System Access\r\nAPI 的一部分，虽然它仍然是一个草案，但是可以在 Chromuim\r\n内核的浏览器中使用。\r\n代码如下：\r\nasync function handleSaveImg(event)&#123;  const image = await new Promise( (res) =&gt; canvas.toBlob( res ) );  if( window.showSaveFilePicker ) &#123;    const handle = await showSaveFilePicker();    const writable = await handle.createWritable();    await writable.write( image );    writable.close();  &#125;  else &#123;    const saveImg = document.createElement( &quot;a&quot; );    saveImg.href = URL.createObjectURL( image );    saveImg.download= &quot;image.png&quot;;    saveImg.click();    setTimeout(() =&gt; URL.revokeObjectURL( saveImg.href ), 60000 );  &#125;&#125;\r\n参考\r\n\r\nlive demo\r\ncode\r\nForce\r\nshowing the \"Save as\" dialog box when downloading a file\r\n\r\n","categories":["Develop","Javascript","JSLanguage"],"tags":["Javascript"]},{"title":"如何向回调函数中传递参数","url":"/posts/2022/BA7F9Q.html","content":"有时候我们需要向回调函数中传递参数，比如在 vue\r\n中父组件向子组件的事件响应函数中传递自定义对象。\r\n\r\nVue 中实现\r\n子组件中：\r\nthis.$emit(&quot;changed&quot;, data);\r\n父组件中：\r\n&lt;ele @changed=&quot;valueChanged($event,customData)&quot;/&gt;\r\n\r\n$event 的位置可以改变\r\n\r\nJS 中实现\r\nrunMethod(data,(callbackData)=&gt;&#123;   return callback(callbackData,customData)&#125;)\r\n\r\n在回调函数上包裹一层匿名函数，然后当成回调传递给方法使用\r\n\r\n","categories":["Develop","Javascript","JSLanguage"],"tags":["Javascript"]},{"title":"js 中常用的几个精度计算库，解决精度丢失问题","url":"/posts/2022/2J626YP.html","content":"Javascript 中所有的数据都是 64 位的浮点数保存，无法做到非常精确。\r\n比如：0.1+0.2、0.1*0.2 这样的计算。\r\n然而在进行一些金额的计算时，对于精度要求的需要比较精准，所以需要使用一些包来进行处理。\r\n\r\nMath.js\r\nMath.js 是一个用于\r\nJavaScript 和 Node.js 的扩展数学库。\r\n它具有支持符号计算的灵活表达式解析器，大量内置函数和常量，并提供了集成的解决方案来处理不同的数据类型，例如数字，大数，复数，分数，单位和矩阵。\r\n强大且易于使用。\r\ndecimal.js\r\ndecimal.js 是\r\nJavaScript 的任意精度的十进制类型。\r\nbig.js\r\nbig.js\r\n是一个小型，快速，易于使用的库，用于任意精度的十进制算术运算。\r\nbignumber.js\r\nbignumber.js\r\n是一个用于任意精度算术的 JavaScript 库。\r\n比较\r\n\r\n","categories":["Develop","Javascript","JSLanguage"],"tags":["Javascript"]},{"title":"js 对象与 json 互相转换","url":"/posts/2023/18D31C7.html","content":"js 转 json：\r\nJSON.stringify(对象,过滤器，缩进)\r\njson 转 javascript：\r\nJSON.parse(jsonText,过滤器)\r\n\r\n参考：\r\nJavaScript\r\n对象与 JSON 对象的相互转换\r\n","categories":["Develop","Javascript","JSLanguage"],"tags":["Javascript"]},{"title":"Quasar中css总结","url":"/posts/2021/3BD2JEJ.html","content":"Quasar 中的控件常用用法总结。\r\n\r\nq-select\r\n映射选项\r\n使返回值为对象中的某个字段\r\n\r\n代码\r\n\r\n&lt;q-select  class=&quot;field-value&quot;  filled  fill-input  v-model=&quot;fixedAssetInfo.typeId&quot;  :options=&quot;types&quot;  use-input  option-value=&quot;_id&quot;  display-value=&quot;&quot;  emit-value  map-options  option-label=&quot;name&quot;  dense  options-dense&gt;  &lt;template v-slot:no-option&gt;    &lt;q-item&gt;      &lt;q-item-section class=&quot;text-grey&quot;&gt;No results&lt;/q-item-section&gt;    &lt;/q-item&gt;  &lt;/template&gt;&lt;/q-select&gt;\r\n\r\n说明\r\n\r\n\r\n\r\n\r\n属性\r\n说明\r\n\r\n\r\n\r\n\r\nfilled\r\n边框为方形\r\n\r\n\r\n\r\n","categories":["Develop","Javascript","Quasar"],"tags":["Quasar"]},{"title":"Quasar中css总结","url":"/posts/2020/3BD2JEJ.html","content":"用了一段时间的quasar了，它里面封装的 css\r\n类确实很好用，但是在帮助文档中，描述得零零散散，不方便使用，遂总结一下。\r\n\r\n字体\r\n文字大小\r\ntext-[ h1~6, subtitle1, subtitle2, body1~2, caption, overline ]\r\n字体粗细\r\ntext-weight-[ thin, light, regular, medium, bold, bolder ]\r\n字体对齐\r\ntext-[ right, left, center, justify, bold, italic, no-wrap, stike,\r\nuppercase, lowercase, captitalize ]\r\n字体颜色\r\ntext-[颜色名称]：text-teal\r\n颜色\r\n基本色\r\nprimary（淡蓝），secondary（淡绿），accent（淡紫），dark（黑色），positive（深绿），negative（红色），Info（亮蓝），warning（黄色）\r\n其它颜色\r\n每种颜色由浅到深分为 1-14 级\r\nred, pink, purple, deep-purple, indigo（靛蓝）, blue, light-blue,\r\ncyan, teal（青色）, green, light-green, lime, yellow, amber, orange,\r\ndeep-orange, brown, grey, blue-grey\r\n在 css 中使用\r\n在应用程序的*.vue文件中，可以使用$primary，$red-1等颜色。\r\n&lt;!-- 注意lang=&quot;sass&quot; --&gt;&lt;style lang=&quot;sass&quot;&gt;div  color: $red-1  background-color: $grey-5&lt;/style&gt;\r\n间距\r\n语法\r\nq-[p|m][t|r|b|l|a|x|y]-[none|auto|xs|sm|md|lg|xl]    T       D                   ST - type  - values: p (padding), m (margin)D - direction  - values:      t (top), r (right), b (bottom), l (left),      a (all), x (both left &amp; right), y (both top &amp; bottom)S - size  - values:      none,      auto (ONLY for specific margins: q-ml-*, q-mr-*, q-mx-*),      xs (extra small),      sm (small),      md (medium),      lg (large),      xl (extra large)\r\n例子\r\n&lt;!-- 所有方向小的padding --&gt;&lt;div class=&quot;q-pa-sm&quot;&gt;...&lt;/div&gt;&lt;!-- 项部中margin, 右边小margin --&gt;&lt;q-card class=&quot;q-mt-md q-mr-sm&quot;&gt;...&lt;/q-card&gt;\r\n阴影\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncss 类名\r\n说明\r\n\r\n\r\n\r\n\r\nno-shadow\r\n移除任何阴影\r\n\r\n\r\ninset-shadow\r\n设置一个插入阴影\r\n\r\n\r\nshadow-1\r\n设置1的深度\r\n\r\n\r\nshadow-2\r\n设置2的深度\r\n\r\n\r\nshadow-N\r\n其中N是1到24的整数\r\n\r\n\r\nshadow-transition\r\n在阴影上应用CSS转换; 最好与hoverable类一起使用\r\n\r\n\r\nshadow-up-1\r\n设置1的深度\r\n\r\n\r\nshadow-up-2\r\n设置2的深度\r\n\r\n\r\nshadow-up-N\r\n其中N是1到24的整数\r\n\r\n\r\n\r\n可见性\r\n常见功能\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n类名\r\n说明\r\n\r\n\r\n\r\n\r\ndisabled\r\n游标更改为“disable”，不透明度设置为较低值。\r\n\r\n\r\nhidden\r\n将display设置为none。与下面的类相比\r\n- hidden类意味着元素不会显示并且不会占用布局中的空间。\r\n\r\n\r\ninvisible\r\n将visibility设置为hidden。与上面的类相比，invisible类意味着元素不会显示，但它仍然占用布局空间。\r\n\r\n\r\ntransparent\r\n背景颜色是透明的。\r\n\r\n\r\ndimmed\r\n在您的元素上应用深色透明覆盖层。不要在已经有:after伪元素的元素上使用。\r\n\r\n\r\nlight-dimmed\r\n在您的元素上应用白色透明覆盖层。不要在已经有:after伪元素的元素上使用。\r\n\r\n\r\nellipsis\r\n截取文本并在没有足够的可用空间时显示省略号。\r\n\r\n\r\nellipsis-2-lines\r\n当两行中没有足够的可用空间时，截断文本并显示省略号（仅适用于Webkit浏览器）。\r\n\r\n\r\nellipsis-3-lines\r\n当三行中没有足够的可用空间时，截断文本并显示省略号（仅适用于Webkit浏览器）。\r\n\r\n\r\nz-top\r\n将元素定位在任何其他组件的顶部，但位于Popovers、提示框、通知框之后。\r\n\r\n\r\nz-max\r\n将元素定位在任何其他组件（包括Drawer，Modals，Notifications，Layout\r\nheader/footer…）之上\r\n\r\n\r\n\r\n定位\r\n对齐\r\n\r\n\r\n\r\n类名\r\n说明\r\n\r\n\r\n\r\n\r\nfloat-left\r\n浮动到左侧\r\n\r\n\r\nfloat-right\r\n浮动到右侧\r\n\r\n\r\non-left\r\n在右侧设置一个小边距;通常用于有兄弟元素的图标元素\r\n\r\n\r\non-right\r\n在左侧设置一个小边距;通常用于有兄弟元素的图标元素\r\n\r\n\r\n\r\n辅助类\r\n鼠标相关\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n类名\r\n说明\r\n\r\n\r\n\r\n\r\nnon-selectable\r\n用户将无法选择DOM节点及其文本\r\n\r\n\r\nscroll\r\n应用CSS调整使所有平台上的滚动工作达到最佳状态\r\n\r\n\r\nno-scroll\r\n隐藏DOM节点上的滚动条\r\n\r\n\r\nno-pointer-events\r\nDOM元素不会成为鼠标事件的目标 -\r\n点击、悬停等\r\n\r\n\r\nall-pointer-events\r\nno-pointer-events的反义词\r\n\r\n\r\ncursor-pointer\r\n改变DOM元素上的鼠标指针，看起来好像在可点击的链接上\r\n\r\n\r\ncursor-not-allowed\r\n更改DOM元素上的鼠标指针，使其看起来好像不会执行任何操作\r\n\r\n\r\ncursor-inherit\r\n将DOM元素上的鼠标指针更改为与父选项相同\r\n\r\n\r\ncursor-none\r\n没有鼠标光标被渲染\r\n\r\n\r\n\r\n大小相关\r\n\r\n\r\n\r\n类名\r\n说明\r\n\r\n\r\n\r\n\r\nfit\r\n宽度和高度设置为100％\r\n\r\n\r\nfull-height\r\n高度设置为100％\r\n\r\n\r\nfull-width\r\n宽度设置为100％\r\n\r\n\r\nwindow-height\r\n高度设置为100vh，顶部和底部边距为0\r\n\r\n\r\nwindow-width\r\n宽度设置为100vw，左边距和右边距0\r\n\r\n\r\nblock\r\n将display属性设置为block\r\n\r\n\r\n\r\n方向有关\r\n\r\n\r\n\r\n类名\r\n说明\r\n\r\n\r\n\r\n\r\nrotate-45\r\n旋转45度\r\n\r\n\r\nrotate-90\r\n旋转90度\r\n\r\n\r\nrotate-135\r\n旋转135度\r\n\r\n\r\nrotate-180\r\n旋转180度\r\n\r\n\r\nrotate-205\r\n旋转205度\r\n\r\n\r\nrotate-270\r\n旋转270度\r\n\r\n\r\nrotate-315\r\n旋转315度\r\n\r\n\r\nflip-horizontal\r\n水平翻转DOM元素\r\n\r\n\r\nflip-vertical\r\n垂直翻转DOM元素\r\n\r\n\r\n\r\n边界相关\r\n\r\n\r\n\r\n类名\r\n说明\r\n\r\n\r\n\r\n\r\nno-border\r\n删除任何边框\r\n\r\n\r\nno-border-radius\r\n删除边框可能具有的任何半径\r\n\r\n\r\nrounded-borders\r\n应用通用边框半径\r\n\r\n\r\n\r\nFlex\r\n设置方向\r\n\r\n\r\n\r\n类名\r\n说明\r\n\r\n\r\n\r\n\r\nrow\r\nFlex行\r\n\r\n\r\nrow inline\r\n内联Flex行\r\n\r\n\r\ncolumn\r\nFlex列\r\n\r\n\r\ncolumn inline\r\n内联Flex列\r\n\r\n\r\nrow reverse\r\n将flex-direction设置为row-reverse的Flex行\r\n\r\n\r\ncolumn reverse\r\n将flex-direction设置为column-reverse的Flex列\r\n\r\n\r\n\r\n包裹\r\n\r\n\r\n\r\n类名\r\n说明\r\n\r\n\r\n\r\n\r\nwrap\r\n如有必要进行包裹（默认为“on”，不需要指定）\r\n\r\n\r\nno-wrap\r\n即使有必要，也不要包裹\r\n\r\n\r\nreverse-wrap\r\n如有必要逆向包裹\r\n\r\n\r\n\r\n对齐\r\n\r\n沿主轴\r\n\r\n\r\nimg\r\n\r\n垂直于主轴\r\n\r\n\r\nimg\r\n\r\n多条主轴且有多余空间时\r\n\r\n\r\nimg\r\n\r\n\r\n自对齐\r\n子元素可以覆盖父元素上指定的对齐方式。\r\n这允许对单个Flex项进行对齐。\r\n可用值有： self-start, self-center,\r\nself-baseline, self-end,\r\nself-stretch\r\n\r\n\r\nimg\r\n\r\n大小\r\n与 flex 值使用类似\r\nQuasar使用一个12分的列系统来分配子行的大小。\r\n以下是可用的CSS辅助类的一些示例：\r\n&lt;div class=&quot;row&quot;&gt;  &lt;div class=&quot;col-8&quot;&gt;two thirds&lt;/div&gt;  &lt;div class=&quot;col-2&quot;&gt;one sixth&lt;/div&gt;  &lt;div class=&quot;col-auto&quot;&gt;auto size based on content and available space&lt;/div&gt;  &lt;div class=&quot;col&quot;&gt;fills remaining available space&lt;/div&gt;&lt;/div&gt;\r\n在上面的例子中，由于8/12 = 2/3 =\r\n66％，col-8占据了行宽的三分之二（2/3），而col-2占据了六分之一（2/12 = 1\r\n/ 6〜16.67％）。\r\nCSS辅助类col-auto使单元格只填充需要渲染的空间。\r\n另一方面，col试图填充所有可用的空间，同时如果需要也可以缩小。\r\nCSS辅助类col-grow使单元格至少填充需要渲染的空间，并有可能在有更多空间可用时增长。\r\nCSS辅助类col-shrink使单元格最多填充需要呈现的空间，并且当没有足够的可用空间时有可能收缩。\r\n顺序\r\n您可以使用order-first和order-last\r\nCSS辅助类来设置子元素的顺序。\r\n默认情况下，Flex项按源(source)顺序排列。\r\n但是，order属性控制它们在flex容器中的显示顺序。\r\n如果您需要更多粒度，请使用order CSS属性并分配所需的值。\r\n例子：\r\n&lt;div class=&quot;row&quot;&gt;  &lt;div style=&quot;order: 2&quot;&gt;Second column&lt;/div&gt;  &lt;div class=&quot;order-last&quot;&gt;Third column&lt;/div&gt;  &lt;div class=&quot;order-first&quot;&gt;First column&lt;/div&gt;&lt;/div&gt;\r\n以下是CSSorder属性的工作原理：\r\n\r\n\r\nimg\r\n\r\n","categories":["Develop","Javascript","Quasar"],"tags":["Quasar"]},{"title":"vue2.x中安装quasar","url":"/posts/2021/2HDPP49.html","content":"随着 quasar 的升级，quasar 从 1.x升级到了 2.x，而通过\r\nvue add quasar 会安装vue-cli-plugin-quasar\r\n4.x，通过该 CLI 安装的 qusar 为 quasar 2.x 版本，2.x 版本支持\r\nvue3,但是却不兼容 vue2.x。这导致在 vue 2.x 中按照教程使用\r\nvue add quasar 后，运行时总是失败。\r\n\r\n失败错误如下：\r\nUncaught TypeError: Object(...) is not a function    at eval (webpack-internal:///./node_modules/quasar/src/plugins/Platform.js:29)    at Module../node_modules/quasar/src/plugins/Platform.js (chunk-vendors.js:4272)    at __webpack_require__ (app.js:849)    at fn (app.js:151)    at eval (webpack-internal:///./node_modules/quasar/src/install-quasar.js:18)    at Module../node_modules/quasar/src/install-quasar.js (chunk-vendors.js:4236)    at __webpack_require__ (app.js:849)    at fn (app.js:151)    at eval (webpack-internal:///./node_modules/quasar/src/vue-plugin.js:2)    at Module../node_modules/quasar/src/vue-plugin.js (chunk-vendors.js:4380)\r\n为了解决上述问题，我们需要使用 quasar-cli 3.x\r\n或者以下的版本来安装。\r\n在使用 vue add 的时候，增加一个版本号，如下：\r\nvue add quasar@3.x\r\n","categories":["Develop","Javascript","Quasar"],"tags":["Quasar"]},{"title":"Quasar 中 Table 虚拟滚动切换后数据显示不全的解决办法","url":"/posts/2023/3XYDGYD.html","content":"在使用 Quasar 中的 Table\r\n控件时，当用户选择全部后，由于数据较多，会导致响应会非常卡顿，为了解决这个问题，于是向\r\nTable 增加虚拟滚动的功能。\r\n可是当进行页面切换时，发现不能完整的显示当前页的数据，每行最多只有 12\r\n条数据。\r\n\r\n\r\n\r\nimage-20230515101947071\r\n\r\n通过排查，发现下面浅绿色的部分用于滚动触发，所以猜想是否是虚拟列表中渲染的最小行数限制了，于是将\r\nvirtual-scroll-slice-size 设置成 25\r\n后，问题得到了解决。\r\n参考：表格 |\r\nQuasar Framework 中文网 (quasarchs.com)\r\n","categories":["Develop","Javascript","Quasar"],"tags":["Vue","Quasar"]},{"title":"Quasar 项目中的别名","url":"/posts/2023/4PA3A5.html","content":"\r\n使用 Quasar CLI 与 Vite 搭建 vue 项目后，没有经典的 vite.config.js\r\n文件，相反，只有\r\nquasar.config.js文件（更多详细信息：https://quasar.dev/quasar-cli-vite/quasar-config-file）。\r\n在这种情况下，如何为 src 目录设置别名呢？\r\n\r\n如果有使用 ElementUI Admin 的经验，可能会将 src 设置成别名\r\n@，然而在 Quasar 中，官方建议不将将 @ 当作 src\r\n的别名，因为 npm 包中，组织包是以 @ 开头，会发生冲突。\r\n\r\n在所有项目中，最好都不要使用 @ 作为 src 别名\r\n\r\n系统别名\r\nQuasar 为我们提供了配置好的别名，可以直接使用，它们分别是：\r\n\r\n\r\n\r\nAlias\r\nResolves to\r\n\r\n\r\n\r\n\r\nsrc\r\n/src\r\n\r\n\r\napp\r\n/\r\n\r\n\r\ncomponents\r\n/src/components\r\n\r\n\r\nlayouts\r\n/src/layouts\r\n\r\n\r\npages\r\n/src/pages\r\n\r\n\r\nassets\r\n/src/assets\r\n\r\n\r\nboot\r\n/src/boot\r\n\r\n\r\n\r\n自定义别名\r\n如果上述别名无法满足日常使用，还可以通过这个教程添加自定义别名：Adding\r\nWebpack aliases\r\n参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\nSetting\r\nalias ‘@’ on Quasar CLI with Vite - Florin Codreanu - Medium\r\nHow\r\nto set own alias · Issue #3306 · quasarframework/quasar\r\n(github.com)\r\nHandling\r\nWebpack | Quasar Framework\r\n","categories":["Develop","Javascript","Quasar"],"tags":["Quasar"]},{"title":"Vite 配置别名","url":"/posts/2023/HR60E3.html","content":"当以命令行方式运行 vite 时，Vite 会自动解析 项目根目录\r\n下名为 vite.config.js 的文件。\r\n\r\n因此，我们在 vite.config.js 中进行别名的配置。\r\n配置\r\nimport &#123; defineConfig &#125; from &#x27;vite&#x27;import path from &#x27;path&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;// https://vitejs.dev/config/export default defineConfig(&#123;  resolve: &#123;    alias: &#123;      &#x27;@&#x27;: path.resolve(__dirname, &#x27;src&#x27;),      components: path.resolve(__dirname, &#x27;src/components&#x27;),      styles: path.resolve(__dirname, &#x27;src/styles&#x27;),      plugins: path.resolve(__dirname, &#x27;src/plugins&#x27;),      views: path.resolve(__dirname, &#x27;src/views&#x27;),      layouts: path.resolve(__dirname, &#x27;src/layouts&#x27;),      utils: path.resolve(__dirname, &#x27;src/utils&#x27;),      apis: path.resolve(__dirname, &#x27;src/apis&#x27;),      dirs: path.resolve(__dirname, &#x27;src/directives&#x27;)    &#125;  &#125;,  plugins: [vue()]&#125;)\r\n参考\r\n\r\n配置 Vite\r\nresolve.alias\r\n\r\n","categories":["Develop","Javascript","Vite"],"tags":["Vite"]},{"title":"verdaccio 私有化配置","url":"/posts/2022/38ND00E.html","content":"添加用户\r\n添加用户是通过终端电脑的npm来操作的，在输入下列命令后，根据要求输入用户名和密码即可。\r\nnpm adduser --registry https://mydomain.com:port/\r\n授权验证\r\ni18n\r\n发布包\r\nnpm publish --registry https://mydomain.com:port/\r\n参考\r\n\r\nverdaccio\r\n官方配置文档\r\n\r\n","categories":["Develop","Javascript","Verdaccio"],"tags":["verdaccio","私服npm"]},{"title":"WindowsServer安装Verdaccio安装排坑日记","url":"/posts/2022/7MJX55.html","content":"为了在js开发中更加便利的模块化，解决开发中频繁地更新npm包的问题，决定搭建一个轻量的npm包管理服务。比较了\r\nverdaccio，cnpm 后，最后选择了\r\nverdaccio。因为它够方便和快速，同时也够用。\r\n\r\nnpm 私有仓库\r\nnpm 私有仓库的好处\r\n\r\n安全性角度考虑：如果我们想要一个公共组件库，那么把组件放到我们私有库中，只有内网可以访问，这样可以避免组件中业务的泄露；\r\n模块复用性角度考虑：多个项目之间有重复的共有模块，当需要修改模块，通过简单的统一的配置就可以实现；提炼后的组件有专门的地址可以用来查看，方便使用，在后期项目的引用中也能节约开发成本\r\nnpm 包下载速度角度考虑：使用内部的地址，能够在开发下载 node\r\n包的同时，将关联的依赖包缓存到 npm\r\n私有仓库服务器中，下载速度更快；\r\n项目开发中的路劲角度考虑：在项目开发中书写代码更整洁简练，不需书写更长的相对路径；\r\n公司技术沉淀角度考虑：知识的沉淀，在公司业务相关的应用上尤佳；\r\n版本角度的考虑：相当于一个容器，统一管理需要的包，保持版本的唯一；\r\n开发效率角度考虑：使私有公共业务或组件模块能以共有包一样的管理组织方式，保持一致性，提高开发效率.\r\n\r\nnpm 私有仓库的原理\r\n\r\n\r\nimg\r\n\r\n用户 install 后向私有 npm\r\n发起请求，服务器会先查询所请求的这个模块是否是我们自己的私有模块或已经缓存过的公共模块，如果是则直接返回给用户；如果请求的是一个还没有被缓存的公共模块，那么则会向上游源请求模块并进行缓存后返回给用户。上游的源可以是\r\nnpm 仓库，也可以是淘宝镜像。\r\n常用的仓库地址\r\n\r\nnpm —— https://registry.npmjs.org\r\ncnpm —— http://r.cnpmjs.org\r\ntaobao —— https://registry.npm.taobao.org\r\nnj —— https://registry.nodejitsu.com\r\nrednpm —— http://registry.mirror.cqupt.edu.cn\r\nnpmMirror —— https://skimdb.npmjs.com/registry\r\nedunpm —— http://registry.enpmjs.org\r\n\r\nwindows server环境\r\n\r\nwindows server 2022\r\n宝塔面板\r\n\r\n配置nginx\r\nserver &#123;\tlisten 443 ssl http2;\tserver_name registry.xxx.com;      # ssl    ssl on;    ssl_certificate cert.crt;    ssl_certificate_key cert.key;    ssl_session_timeout 5m;    ssl_protocols TLSv1.2 TLSv1.1 TLSv1; #SSL协议    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#SSL加密算法    ssl_prefer_server_ciphers on;\tlocation / &#123;        proxy_set_header    Host $host;        proxy_set_header    X-Real-IP $remote_addr;        proxy_set_header    X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_set_header    X-Forwarded-Proto $scheme;        proxy_pass          http://127.0.0.1:4873/;        proxy_read_timeout  600;        proxy_redirect off;\t &#125;\t\t // 必须要有\t location ~ ^/verdaccio/(.*)$ &#123;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_set_header Host $host;        proxy_set_header X-NginX-Proxy true;        proxy_pass http://127.0.0.1:4873/$1;        proxy_redirect off;    &#125;&#125;\r\n无法加载 venders 等静态文件\r\n按照官方教程配置完成后，在 ngnix 配置\r\nhttps，然后通过域名（https://mydomain.com:4433）访问 verdaccio\r\n时，一直是空白。\r\nF12打开调试面板，查看网络项，发现读取 runtime, vendors, main\r\n等文件是失败的，查看其 headers，发现其请求的 url 是\r\nhttps://mydomain.com/-/xx, 端口莫名丢掉了。\r\n\r\n造成这种问题的原因是，在nginx的配置中，少了\r\nlocation ~ ^/verdaccio/(.*)$ ...\r\n这项配置。\r\n参考\r\n本文主要参考以下，在此报以诚挚感谢！\r\n\r\nnpm\r\n私有仓库工具 Verdaccio 搭建\r\nVerdaccio\r\n5 migration guidelines，介绍了 VERDACCIO_PUBLIC_URL的作用\r\nDebugging\r\nVerdaccio\r\n\r\n","categories":["Develop","Javascript","Verdaccio"],"tags":["私服npm","Verdaccio"]},{"title":"EmbedIO获取request中的body数据","url":"/posts/2021/1SG7HMG.html","content":"我使用 EmbedIO 搭建了一个 web 服务，使用\r\nWebApiController 提供路由服务。在使用中，为了获取 request\r\n中的 Body 数据，踩了一些坑，作此记录。\r\n\r\n代码如下：\r\n// BaseController.cs// 自定义所有 controller 的基类namespace Server.Http.Controller&#123;    public abstract class BaseController: WebApiController    &#123;        protected IContainer IoC &#123; get; private set; &#125;        protected LiteDBManager LiteDb &#123; get; private set; &#125;        /// &lt;summary&gt;        /// 获取控制数据库操作类        /// &lt;/summary&gt;        protected override async void OnBeforeHandler()        &#123;            IoC = HttpContext.GetIoCScope();            LiteDb = IoC.Get&lt;LiteDBManager&gt;();            base.OnBeforeHandler();                   &#125;    &#125;&#125;\r\n// User.cs// User相关的APInamespace Server.Http.Controller&#123;    public class User : BaseController    &#123;        // 方式1        [Route(HttpVerbs.Post, &quot;/user/login&quot;)]        public async Task&lt;bool&gt; UserLogin_1()        &#123;            var Body = HttpContext.GetRequestDataAsync&lt;User&gt;();            return true;        &#125;                // 方式2        [Route(HttpVerbs.Post, &quot;/user/login&quot;)]        public async Task&lt;bool&gt; UserLogin_2([FormData] NameValueCollection body)        &#123;            return false;        &#125;                // 方式3        [Route(HttpVerbs.Post, &quot;/user/login&quot;)]        public async Task&lt;bool&gt; UserLogin_1()        &#123;            // 读取jsonData            var Body = JObject.Parse(await HttpContext.GetRequestBodyAsStringAsync());            return true;        &#125;    &#125;&#125;\r\n上述三种方式，原则上都是可以的，但是实际的使用中，会有一些坑要注意：\r\n坑1：\r\n不要在 OnBeforeHandler 方法中尝试获取 body\r\n的值，始终为空。\r\n坑2：\r\n方式1中的 User\r\n在进行类的定义时，必须是可读可写的属性，而不能是字段，如果是字段，会出现赋值为空的情况。\r\n坑3：\r\n方式2的读取方法可以读到数据，但是读到的数据只有一个字符串，而不是字典，实际中无法使用。\r\n综上所述，获取 request 中的 body\r\n数据，上述三个方式都可以，但是使用时，要注意它们的使用条件。\r\n","categories":["Develop","DotNET","EmbedIO"],"tags":["EmbedIO","MVVM"]},{"title":"使用 Linq 后导致修改列表对象字段无效","url":"/posts/2024/395GBDB.html","content":"最近使用 Linq 写了这样一段代码：\r\n先用 Select 生成\r\nIEnumerable&lt;T&gt;，然后通过 First()将对象从\r\nIEnumerable&lt;T&gt;\r\n中查找出来，接着修改该对象的字段值，最后将\r\nIEnumerable&lt;T&gt; 转换成 List 返回。\r\n我惊奇地发现，刚刚对第一个对象的修改，居然没有生效，这个 bug\r\n让人促不及防。\r\n\r\n伪代码复现\r\n伪代码如下：\r\n// Person 类internal class Person&#123;    public string Name &#123; get; set; &#125; = &quot;defaultName&quot;;    public Person(string name)    &#123;        Name = name;        Console.WriteLine(&quot;create a new person: &quot;);               &#125;    public void ShowSelf()    &#123;        Console.WriteLine($&quot;My name is &#123;Name&#125;&quot;);    &#125;&#125;\r\n使用代码：\r\n// 使用 Select 生成 IEnumerable&lt;Person&gt;IEnumerable&lt;Person&gt; list = new List&lt;string&gt;()&#123;    &quot;ZhangSan&quot;,&quot;LiSi&quot;,&quot;WangWu&quot;    &#125;.Select(x =&gt; new Person(x));var firstPerson = list.First();Console.WriteLine();Console.WriteLine($&quot;I am the first person, my name was changed from &#123;firstPerson.Name&#125; to ZhangSanPro&quot;);firstPerson.Name = &quot;ZhangSanPro&quot;;firstPerson.ShowSelf();Console.WriteLine();Console.WriteLine(&quot;persons in list:&quot;);foreach (var person in list)&#123;    person.ShowSelf();&#125;Console.ReadKey();\r\n结果：\r\ncreate a new person:I am the first person, my name was changed from ZhangSan to ZhangSanProMy name is ZhangSanPropersons in list:create a new person:create a new person:create a new person:My name is ZhangSanMy name is LiSiMy name is WangWu\r\n从输出可以看到，对第一个对象的 Name\r\n修改是生效，但是为什么后面转换成 List\r\n后，它的值却没改变呢，按道理修改引用对象的字段，也会影响到\r\nList 中的对象的。\r\n原因分析\r\n在上述代码中，Select 方法返回的是一个\r\nIEnumerable&lt;Person&gt;，这是一个延迟执行的查询，意味着查询的结果（也就是\r\nPerson\r\n对象的集合）直到第一次遍历它时才会被计算。因此，当修改\r\nfirstPerson 的 Name 属性后，再次遍历\r\nlist 时，Select 查询会再次执行，从而创建新的\r\nPerson 对象，这就是为什么看到的 Name\r\n属性没有被修改。\r\n因为了为保证修改的对象与遍历的对象是一致的，可以将其转换成\r\nList，再执行后续操作\r\nIEnumerable&lt;Person&gt; list = new List&lt;string&gt;()&#123;    &quot;ZhangSan&quot;,&quot;LiSi&quot;,&quot;WangWu&quot;    &#125;.Select(x =&gt; new Person(x)).ToList();\r\n.ToList() 会在调用时将所有的 Person\r\n马上实例化，这样在修改 firstPerson 的 Name\r\n属性后，list 中的第一个元素的 Name 才会相应的修改。\r\n参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\n延迟执行和延迟计算\r\n- LINQ to XML - .NET | Microsoft Learn\r\n链式查询示例\r\n(C#) - LINQ to XML - .NET | Microsoft Learn\r\n","categories":["Develop","DotNET","Linq"],"tags":["C#","Linq"]},{"title":".NetCore 路由配置指南","url":"/posts/2022/249XC4P.html","content":"ASP.NET Core 控制器使用路由中间件来匹配传入请求的 URL\r\n并将它们映射到操作。本文以使用者的角度，对路由的使用进行概括说明，方便知识回顾与使用。\r\n前言\r\nASP.NET Core 控制器使用路由中间件来匹配传入请求的 URL\r\n并将它们映射到操作。它支持传统路由，也支持属性路由。如果感觉到陌生，不要着急，继续向下看，下面会一一道来。\r\n传统路由\r\n传统路由通常在 MVC 框架中使用。\r\nProgram.cs 配置\r\n它在 program.cs 中定义，如下：\r\n完整方法：\r\napp.MapControllerRoute(  // 路由名称    name: &quot;default&quot;,  // 模板为：controllerName/actionName/&#123;id?&#125;  // = 号用于设置默认值  pattern: &quot;&#123;controller=Home&#125;/&#123;action=Index&#125;/&#123;id?&#125;&quot;);\r\n简化使用：\r\napp.MapDefaultControllerRoute();\r\n说明：\r\n上面的完整路由定义中：\r\n\r\n第一个路径段 &#123;controller=Home&#125;\r\n映射到控制器名称。\r\n如 UserController 中的控制器名为\r\nUser。\r\n第二段 &#123;action=Index&#125; 映射到操作名称。\r\naction 就是 Controller 类中的方法名。\r\n第三段 &#123;id?&#125; 用于可选 id。\r\n&#123;id?&#125; 中的 ? 使其成为可选。 id\r\n用于映射到模型实体。\r\n\r\nController 定义\r\npublic class HomeController : Controller&#123;  \t// 默认所有的 http 谓词 get、post 等请求都会调用该接口    public IActionResult Index() &#123;&#125;      // 可以通过特性来约束 http 谓词的调用    // HttpPost 标记后，只有 post 才能调用这个方法    [HttpPost]    public IActionResult Create()&#123;&#125;&#125;\r\n多个传统路由\r\n可以多次调用 MapControllerRoute\r\n来设置多个传统路由，如下：\r\napp.MapControllerRoute(name: &quot;blog&quot;,                pattern: &quot;blog/&#123;*article&#125;&quot;,                defaults: new &#123; controller = &quot;Blog&quot;, action = &quot;Article&quot; &#125;);app.MapControllerRoute(name: &quot;default&quot;,               pattern: &quot;&#123;controller=Home&#125;/&#123;action=Index&#125;/&#123;id?&#125;&quot;);\r\n上述代码中的 blog 路由是专用的传统路由。 之所以称为专用传统路由是因为\r\ncontroller 和 action 不会以参数形式出现在路由模板 \"blog/{*article}\"\r\n中，它们只能具有默认值 { controller = \"Blog\", action = \"Article\"\r\n}。因此，此路由将会始终映射到操作\r\nBlogController.Article。\r\n传统路由顺序\r\n\r\n按定义顺序匹配\r\n具体的路由在可变路由之前匹配\r\n比如 users/demo 会在 users/&#123;userId&#125;\r\n之前进行匹配\r\n\r\n特性（Attribute）路由\r\nAttribute 本应翻译成属性，但为了与 .NET\r\n中的属性字段区分，本文称之为特性。\r\n特性路由通常在 REST API 中使用。\r\nProgram.cs 配置\r\nvar builder = WebApplication.CreateBuilder(args);builder.Services.AddControllers();var app = builder.Build();app.UseHttpsRedirection();app.UseAuthorization();app.MapControllers();app.Run();\r\n属性路由通过调用 MapControllers\r\n来映射属性路由控制器。\r\nController 定义\r\n下面的示例中，HomeController 匹配一组类似于默认传统路由\r\n&#123;controller=Home&#125;/&#123;action=Index&#125;/&#123;id?&#125; 匹配的 URL。\r\npublic class HomeController : Controller&#123;    [Route(&quot;&quot;)]    [Route(&quot;Home&quot;)]    [Route(&quot;Home/Index&quot;)]    [Route(&quot;Home/Index/&#123;id?&#125;&quot;)]    public IActionResult Index(int? id)    &#123;        return ControllerContext.MyDisplayRouteInfo(id);    &#125;    [Route(&quot;Home/About&quot;)]    [Route(&quot;Home/About/&#123;id?&#125;&quot;)]    public IActionResult About(int? id)    &#123;        return ControllerContext.MyDisplayRouteInfo(id);    &#125;&#125;\r\n保留关键字\r\n\r\naction\r\narea\r\ncontroller\r\nhandler\r\npage\r\n\r\n这些关键词是保留的路由参数名，在定义路由时，不能使用这些关键词。\r\nHTTP 谓词模板\r\n\r\n[HttpGet]\r\n[HttpPost]\r\n[HttpPut]\r\n[HttpDelete]\r\n[HttpHead]\r\n[HttpPatch]\r\n\r\n路由模板\r\n路由模板用于定义路由匹配的模板，它分为\r\n\r\nHTTP\r\n谓词模板\r\n[Route]\r\n特性模板\r\n\r\n谓词模板示例\r\n假设如下控制器：\r\n[Route(&quot;api/[controller]&quot;)][ApiController]public class Test2Controller : ControllerBase&#123;    [HttpGet]   // GET /api/test2    public IActionResult ListProducts()    &#123;        return ControllerContext.MyDisplayRouteInfo();    &#125;    [HttpGet(&quot;&#123;id&#125;&quot;)]   // GET /api/test2/xyz    public IActionResult GetProduct(string id)    &#123;       return ControllerContext.MyDisplayRouteInfo(id);    &#125;    [HttpGet(&quot;int/&#123;id:int&#125;&quot;)] // GET /api/test2/int/3    public IActionResult GetIntProduct(int id)    &#123;        return ControllerContext.MyDisplayRouteInfo(id);    &#125;    [HttpGet(&quot;int2/&#123;id&#125;&quot;)]  // GET /api/test2/int2/3    public IActionResult GetInt2Product(int id)    &#123;        return ControllerContext.MyDisplayRouteInfo(id);    &#125;&#125;\r\n在上述代码中：\r\n\r\n每个操作都包含 [HttpGet] 属性，该属性仅将匹配限制为\r\nHTTP GET 请求。\r\nGetProduct 操作包含 \"&#123;id&#125;\" 模板，因此\r\nid 被附加到控制器上的 \"api/[controller]\"\r\n模板中。 方法模板为 \"api/[controller]/\"&#123;id&#125;\"\"。\r\n因此，此操作仅匹配\r\n/api/test2/xyz、/api/test2/123、/api/test2/&#123;any string&#125;\r\n等形式的 GET 请求。\r\n[HttpGet(&quot;&#123;id&#125;&quot;)]   // GET /api/test2/xyzpublic IActionResult GetProduct(string id)&#123;   return ControllerContext.MyDisplayRouteInfo(id);&#125;\r\nGetIntProduct 操作包含 \"int/&#123;id:int&#125;\")\r\n模板。 模板的 :int 部分将 id\r\n路由值限制为可以转换为整数的字符串。\r\n[HttpGet(&quot;int/&#123;id:int&#125;&quot;)] // GET /api/test2/int/3public IActionResult GetIntProduct(int id)&#123;    return ControllerContext.MyDisplayRouteInfo(id);&#125;\r\n对于 /api/test2/int/abc 的 GET\r\n请求，将会无法匹配到路由，并返回 404  Not Found\r\n错误\r\nGetInt2Product 操作在模板中包含\r\n&#123;id&#125;，但不将 id 限制为可以转换为整数的值。\r\n对于 /api/test2/int2/abc 的 GET 请求，处理如下：\r\n\r\n与此路由匹配。\r\n模型绑定无法将 abc 转换为整数。 该方法的\r\nid 参数是整数。\r\n返回 400 Bad\r\nRequest，因为模型绑定未能将 abc 转换为整数。\r\n\r\n[HttpGet(&quot;int2/&#123;id&#125;&quot;)]  // GET /api/test2/int2/3public IActionResult GetInt2Product(int id)&#123;    return ControllerContext.MyDisplayRouteInfo(id);&#125;\r\n\r\n生成 REST API 时，很少需要在 操作方法 上使用\r\n[Route(...)] ，因为该操作接受所有 HTTP 方法。\r\n建议使用更具体的 HTTP 谓词属性来明确 API 所支持的操作。 API 的 REST\r\n客户端应知道哪些路径和 HTTP 谓词映射到特定的逻辑操作。\r\nREST API 应使用属性路由将应用的功能建模为一组资源，其中操作由 HTTP\r\n谓词表示。 也就是说，对同一逻辑资源执行的许多操作（例如，GET 和\r\nPOST）都使用相同 URL。\r\n[ApiController]public class MyProductsController : ControllerBase&#123;    [HttpGet(&quot;/products3&quot;)]    public IActionResult ListProducts()    &#123;        return ControllerContext.MyDisplayRouteInfo();    &#125;    [HttpPost(&quot;/products3&quot;)]    public IActionResult CreateProduct(MyProduct myProduct)    &#123;        return ControllerContext.MyDisplayRouteInfo(myProduct.Name);    &#125;&#125;\r\n上述代码中的 URL 路径为 /products3：\r\n\r\n当 HTTP\r\n谓词 为 GET 时，调用\r\nMyProductsController.ListProducts。\r\n当 HTTP\r\n谓词 为 POST 时，调用\r\nMyProductsController.CreateProduct 。\r\n\r\n特性路由组合\r\n在控制器上定义的所有路由模板均作为操作上路由模板的前缀。在控制器上放置的路由特性会使控制器中的所有操作都使用该特性路由。\r\n[ApiController][Route(&quot;products&quot;)]public class ProductsApiController : ControllerBase&#123;    [HttpGet]    public IActionResult ListProducts()    &#123;        return ControllerContext.MyDisplayRouteInfo();    &#125;    [HttpGet(&quot;&#123;id&#125;&quot;)]    public IActionResult GetProduct(int id)    &#123;        return ControllerContext.MyDisplayRouteInfo(id);    &#125;&#125;\r\n在上面的示例中：\r\n\r\nURL 路径 /products 可以匹配\r\nProductsApi.ListProducts\r\nURL 路径 /products/5 可以匹配\r\nProductsApi.GetProduct(int)。\r\n\r\n这两项操作仅匹配 HTTP GET，因为它们标记了\r\n[HttpGet]。\r\n操作上以 / 或 ~/\r\n开头的路由模板不与控制器的路由模板合并。\r\n\r\n\r\n\r\nAttribute\r\n与 [Route(\"Home\")] 结合\r\n定义路由模板\r\n\r\n\r\n\r\n\r\n[Route(\"\")]\r\n是\r\n\"Home\"\r\n\r\n\r\n[Route(\"Index\")]\r\n是\r\n\"Home/Index\"\r\n\r\n\r\n[Route(\"/\")]\r\n否\r\n\"\"\r\n\r\n\r\n[Route(\"About\")]\r\n是\r\n\"Home/About\"\r\n\r\n\r\n\r\n特性路由继承\r\n在父类控制器上定义的路由特性会继承给子类，可以在父类中定义一个通用的路由特性，减少在子类的控制器上重复定义。\r\n例如：\r\n[ApiController][Route(&quot;[controller]/[action]&quot;)]public abstrct class CustomBaseController : ControllerBase&#123;   &#125;// 此处可不进行路由特性定义public class ProductsApiController : CustomBaseController&#123;    [HttpGet]    public IActionResult Index()&#123;&#125;&#125;\r\n标记替换\r\n特性路由支持标记替换，将标记用方括号（[、]）括起来即可。\r\n标记 [action]、[area] 和\r\n[controller]\r\n会替换成定义了路由的操作中的操作名称、区域名称和控制器名称。\r\n// Products0：控制器名称[Route(&quot;[controller]/[action]&quot;)]public class Products0Controller : Controller&#123;    // List：操作名称    [HttpGet]    public IActionResult List()    &#123;        return ControllerContext.MyDisplayRouteInfo();    &#125;    [HttpGet(&quot;&#123;id&#125;&quot;)]    public IActionResult Edit(int id)    &#123;        return ControllerContext.MyDisplayRouteInfo(id);    &#125;&#125;\r\n\r\nAreas是一项\r\nMVC 功能，用于将相关功能作为一个单独的组组织到一个组中，单击链接可跳转阅读更加详细的内容\r\n\r\n标记样式转换\r\n[controller]，[action]\r\n等会默认使用定义的名称作用 URL，而在实际开发中，我们可能需要将\r\nPascalCase 命名转换成 hyphenCase 命名，如将 FindAll 变成\r\nfind-all。\r\n可以通过实现 IOutboundParameterTransformer\r\n接口来自定义。\r\n接口实现：\r\nusing System.Text.RegularExpressions;public class SlugifyParameterTransformer : IOutboundParameterTransformer&#123;    public string? TransformOutbound(object? value)    &#123;        if (value == null) &#123; return null; &#125;        return Regex.Replace(value.ToString()!,                             &quot;([a-z])([A-Z])&quot;,                             &quot;$1-$2&quot;,                             RegexOptions.CultureInvariant,                             TimeSpan.FromMilliseconds(100)).ToLowerInvariant();    &#125;&#125;\r\n使用：\r\nbuilder.Services.AddControllersWithViews(options =&gt;&#123;    options.Conventions.Add(new RouteTokenTransformerConvention(                                 new SlugifyParameterTransformer()));&#125;);\r\nRouteTokenTransformerConvention\r\n是应用程序的模型约定，可以：\r\n\r\n将参数转换程序应用到程序中的所有特性路由中。\r\n在替换特性路由标记值时对其进行自定义\r\n\r\n多个路由特性\r\n同一个控制器或者路由上，可以同时添加多个路由特性标记。\r\n[Route(&quot;Store&quot;)][Route(&quot;[controller]&quot;)]public class Products6Controller : Controller&#123;    [HttpPost(&quot;Buy&quot;)]       // Matches &#x27;Products6/Buy&#x27; and &#x27;Store/Buy&#x27;    [HttpPost(&quot;Checkout&quot;)]  // Matches &#x27;Products6/Checkout&#x27; and &#x27;Store/Checkout&#x27;    public IActionResult Buy()    &#123;        return ControllerContext.MyDisplayRouteInfo();    &#125;&#125;\r\n一般不要使用多个路由特性，会让 URL 看起来不易于理解，且容易冲突。\r\n可选参数、默认值和约束\r\n特性路由支持使用与传统路由相同的内联语法，来指定可选参数、默认值和约束。\r\npublic class Products14Controller : Controller&#123;    [HttpPost(&quot;&#123;controller=ProductsDefault&#125;/&#123;id:int:string&#125;/&#123;name?&#125;&quot;)]    public IActionResult ShowProduct(int id)    &#123;        return ControllerContext.MyDisplayRouteInfo(id);    &#125;&#125;\r\n使用说明：\r\n\r\n= 赋予默认值\r\n: 进行约束，可以同时使用多个约束\r\n? 表示可选参数\r\n\r\n内置路由约束：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n约束\r\n示例\r\n匹配项示例\r\n说明\r\n\r\n\r\n\r\n\r\nint\r\n&#123;id:int&#125;\r\n123456789,\r\n-123456789\r\n匹配任何整数\r\n\r\n\r\nbool\r\n&#123;active:bool&#125;\r\ntrue, FALSE\r\n匹配 true 或\r\nfalse。 不区分大小写\r\n\r\n\r\ndatetime\r\n&#123;dob:datetime&#125;\r\n2016-12-31,\r\n2016-12-31 7:32pm\r\n在固定区域性中匹配有效的\r\nDateTime 值。 请参阅前面的警告。\r\n\r\n\r\ndecimal\r\n&#123;price:decimal&#125;\r\n49.99,\r\n-1,000.01\r\n在固定区域性中匹配有效的\r\ndecimal 值。 请参阅前面的警告。\r\n\r\n\r\ndouble\r\n&#123;weight:double&#125;\r\n1.234,\r\n-1,001.01e8\r\n在固定区域性中匹配有效的\r\ndouble 值。 请参阅前面的警告。\r\n\r\n\r\nfloat\r\n&#123;weight:float&#125;\r\n1.234,\r\n-1,001.01e8\r\n在固定区域性中匹配有效的\r\nfloat 值。 请参阅前面的警告。\r\n\r\n\r\nguid\r\n&#123;id:guid&#125;\r\nCD2C1638-1638-72D5-1638-DEADBEEF1638\r\n匹配有效的 Guid 值\r\n\r\n\r\nlong\r\n&#123;ticks:long&#125;\r\n123456789,\r\n-123456789\r\n匹配有效的 long 值\r\n\r\n\r\nminlength(value)\r\n&#123;username:minlength(4)&#125;\r\nRick\r\n字符串必须至少为 4 个字符\r\n\r\n\r\nmaxlength(value)\r\n&#123;filename:maxlength(8)&#125;\r\nMyFile\r\n字符串不得超过 8 个字符\r\n\r\n\r\nlength(length)\r\n&#123;filename:length(12)&#125;\r\nsomefile.txt\r\n字符串必须正好为 12 个字符\r\n\r\n\r\nlength(min,max)\r\n&#123;filename:length(8,16)&#125;\r\nsomefile.txt\r\n字符串必须至少为 8 个字符，且不得超过 16\r\n个字符\r\n\r\n\r\nmin(value)\r\n&#123;age:min(18)&#125;\r\n19\r\n整数值必须至少为 18\r\n\r\n\r\nmax(value)\r\n&#123;age:max(120)&#125;\r\n91\r\n整数值不得超过 120\r\n\r\n\r\nrange(min,max)\r\n&#123;age:range(18,120)&#125;\r\n91\r\n整数值必须至少为 18，且不得超过 120\r\n\r\n\r\nalpha\r\n&#123;name:alpha&#125;\r\nRick\r\n字符串必须由一个或多个字母字符组成，a-z，并区分大小写。\r\n\r\n\r\nregex(expression)\r\n&#123;ssn:regex(^\\\\d&#123;&#123;3&#125;&#125;-\\\\d&#123;&#123;2&#125;&#125;-\\\\d&#123;&#123;4&#125;&#125;$)&#125;\r\n123-45-6789\r\n字符串必须与正则表达式匹配。\r\n请参阅有关定义正则表达式的提示。\r\n\r\n\r\nrequired\r\n&#123;name:required&#125;\r\nRick\r\n用于强制在 URL 生成过程中存在非参数值\r\n\r\n\r\n\r\n自定义特性路由\r\n所有路由属性都实现 IRouteTemplateProvider。 ASP.NET Core\r\n运行时：\r\n\r\n应用启动时，在控制器类和操作方法上查找属性。\r\n使用实现 IRouteTemplateProvider\r\n的属性来构建初始路由集。\r\n\r\n每个 IRouteTemplateProvider\r\n都允许定义一个包含自定义路由模板、顺序和名称的路由：\r\npublic class MyApiControllerAttribute : Attribute, IRouteTemplateProvider&#123;    public string Template =&gt; &quot;api/[controller]&quot;;    public int? Order =&gt; 2;    public string Name &#123; get; set; &#125; = string.Empty;&#125;[MyApiController][ApiController]public class MyTestApiController : ControllerBase&#123;    // GET /api/MyTestApi    [HttpGet]    public IActionResult Get()    &#123;        return ControllerContext.MyDisplayRouteInfo();    &#125;&#125;\r\n上述 Get 方法返回\r\nOrder = 2, Template = api/MyTestApi。\r\n路由返回值\r\nASP.NET Core 使用以下类型作为 Web API 控制器的操作返回类型：\r\n\r\n特定类型\r\nIActionResult\r\nActionResult\r\nHttpResults\r\n\r\n\r\n请点击 ASP.NET\r\nCore Web API 中控制器操作的返回类型 进行详细阅读\r\n\r\n传统路由与特性路由对比\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n类型\r\n传统路由\r\n特性路由\r\n\r\n\r\n\r\n\r\n定义方式\r\n在 Program.cs 中调用 MapControllerRoute\r\n建立 URL 映射\r\n在每个 Controller 中通过特性来定义 URL 映射\r\n\r\n\r\n操作性\r\n更简洁\r\n要对每个 action 进行定义\r\n\r\n\r\n\r\n路由快速配置\r\n当理解了路由相关知识后，需要可以快速应用到实际项目中，本节记录一些快速配置代码，方便进行初始化。\r\n映射路由\r\n// ...// 在 Run 之前调用 MapControllers 进行映射app.MapControllers();app.Run();\r\n设置 hyphenCase 路由\r\n增加 SlugifyParameterTransformer 类\r\nusing System.Text.RegularExpressions;public class SlugifyParameterTransformer : IOutboundParameterTransformer&#123;    public string? TransformOutbound(object? value)    &#123;        if (value == null) &#123; return null; &#125;        return Regex.Replace(value.ToString()!,                             &quot;([a-z])([A-Z])&quot;,                             &quot;$1-$2&quot;,                             RegexOptions.CultureInvariant,                             TimeSpan.FromMilliseconds(100)).ToLowerInvariant();    &#125;&#125;\r\nProgram.cs 中配置\r\nbuilder.Services.AddControllersWithViews(options =&gt;&#123;    options.Conventions.Add(new RouteTokenTransformerConvention(                                 new SlugifyParameterTransformer()));&#125;);\r\n新建路由基类\r\n所有子类都继承自这个基类\r\n[Route(&quot;api/v1/[controller]&quot;)][ApiController]public class CustomControllerBase: ControllerBase&#123;&#125;\r\n参考\r\n在\r\nASP.NET Core 中路由到控制器操作 | Microsoft Learn\r\nASP.NET\r\nCore 中的路由 | Microsoft Learn\r\nASP.NET\r\nCore Web API 中控制器操作的返回类型\r\nASP.NET\r\nCore 中的模型绑定 | Microsoft Learn\r\n","categories":["Develop","DotNET","DotNetCore"],"tags":[".NET Core"]},{"title":".NET Core中配置 JWT 授认证","url":"/posts/2022/28BGV5K.html","content":"本文主要介绍如何在 .NET Core 项目中配置基于 JWT 的 Token 验证。\r\n\r\n前言\r\n.NET Core 中使用 Authentication 和\r\nAuthorization\r\n来进行权限控制。这两个单词长的十分相似，而且还经常一起出现，很多时候容易搞混了。\r\nAuthentication\r\n是认证的意思，当用户请求到来时，判断用户是否是合法的，比如用户名密码是否正确，token\r\n是否合法且有效等等。它是 Web 服务的第一道门。\r\nAuthorization\r\n是授权的意思，当用户通过认证后，还需要验证是否有访问某个接口的权限。授权使用\r\nAuthorize 在 Action(方法) 上进行标标记。\r\n默认情况下，认证通过即认为有权限访问相关的接口。也可以基于角色、策略、自定义的方式来实现接口的授权。\r\n配置 JWT 授权\r\n\r\n本文使用的 .NET Core 版本为 6.1\r\n\r\n安装包\r\n使用 jwt 验证需要安装两个包：\r\n\r\nSystem.IdentityModel.Tokens.Jwt\r\nMicrosoft.AspNetCore.Authentication.JwtBearer\r\n\r\n添加 Token 配置\r\n在 appsettings.json 添加如下内容：\r\n&quot;TokenParam&quot;: &#123;    &quot;Secret&quot;: &quot;15927306782&quot;,    &quot;Expire&quot;: 43200000,    &quot;Issuer&quot;: &quot;wowToolAPI&quot;,    &quot;Audience&quot;: &quot;everybody&quot;&#125;,\r\n添加 JWT 服务配置\r\n在 Program.cs 中的 var app = builder.Build();\r\n前添加一个服务：\r\n// 从 appsettings.json 配置中获取 Secret 值var secret = builder.Configuration[&quot;TokenParam:Secret&quot;];services.AddAuthentication(x =&gt;&#123;    // 设置验证方式为 Bearer Token    x.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;    x.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;&#125;).AddJwtBearer(x =&gt;    &#123;        x.RequireHttpsMetadata = false;        x.TokenValidationParameters = new TokenValidationParameters        &#123;            ValidateIssuerSigningKey = true,            IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(secret)),            ValidateIssuer = false,            ValidateAudience = false            // 是否验证令牌有效期            ValidateLifetime = true,            // 每次颁发令牌，令牌有效时间            ClockSkew = TimeSpan.FromMinutes(1440)        &#125;;    &#125;);\r\n添加验证中间件\r\n在 Program.cs 中添加下列代码：\r\n// 添加认证中间件app.UseAuthentication();// 添加授权中间件app.UseAuthorization();\r\n\r\n上述两个中间件必须要同时添加，顺序也不能错\r\n\r\n在 Controller 中添加授权控制\r\n需要在 Controller 或者 Action 上添加 [Authorize]\r\n特性，该特性表明当前 Controller 或 Action 需要先进行授权验证。\r\n// 不适用特性，可以直接访问public class AController : ControllerBase&#123;    public string Get() &#123; return &quot;666&quot;; &#125;&#125;/// &lt;summary&gt;/// 整个控制器都需要授权才能访问/// &lt;/summary&gt;[Authorize]public class BController : ControllerBase&#123;    public string Get() &#123; return &quot;666&quot;; &#125;&#125;public class CController : ControllerBase&#123;    // 只有 Get 需要授权    [Authorize]    public string Get() &#123; return &quot;666&quot;; &#125;    public string GetB() &#123; return &quot;666&quot;; &#125;&#125;/// &lt;summary&gt;/// 整个控制器都需要授权，但 Get 不需要/// &lt;/summary&gt;[Authorize]public class DController : ControllerBase&#123;    [AllowAnonymous]    public string Get() &#123; return &quot;666&quot;; &#125;&#125;\r\n一次将授权添加到所有的\r\nController 上\r\n在开发中，一般只有个别 API 不需要权限认证，如果每添加一个\r\nController，都在上面标记\r\n[Authorize]，使用起来挺难受的。\r\n有没有办法只在一个地方设置一次，全部 Controller 都添加了呢？\r\n当然，咱们可以先添加一个基类，在这个类上添加 [Authorize]\r\n特性。然后其它的 Controller 只要继承这个基类就可以了。\r\n// 不适用特性，可以直接访问public class MyControllerBase : ControllerBase&#123;    &#125;/// &lt;summary&gt;/// 整个控制器都需要授权/// &lt;/summary&gt;[Authorize]public class EController : MyControllerBase&#123;&#125;/// &lt;summary&gt;/// 整个控制器都不需要授权/// &lt;/summary&gt;[AllowAnonymous]public class FController : MyControllerBase&#123;&#125;\r\n生成 JWT token\r\n/// &lt;summary&gt;/// 创建 token/// &lt;/summary&gt;/// &lt;param name=&quot;payload&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static string CreateToken(this TokenParams tokenParam, Dictionary&lt;string, string&gt; payload)&#123;    // 定义用户信息    var claims = new List&lt;Claim&gt;();    if (payload != null)    &#123;        claims = payload.ToList().ConvertAll(kv =&gt;        &#123;            return new Claim(kv.Key, kv.Value);        &#125;);    &#125;    // 和 Startup 中的配置一致    SymmetricSecurityKey key = new(Encoding.UTF8.GetBytes(tokenParam.Secret));    JwtSecurityToken token = new(        issuer: tokenParam.Issuer,        audience: tokenParam.Audience,        claims: claims,        notBefore: DateTime.Now,        expires: DateTime.Now.AddMinutes(1440),        signingCredentials: new SigningCredentials(key, SecurityAlgorithms.HmacSha256)    );    string jwtToken = new JwtSecurityTokenHandler().WriteToken(token);    return jwtToken;&#125;\r\n从请求中获取 JWT\r\n从请求中获取 token 字符串\r\nprotected string GetToken()&#123;    string tokenHeader = Request.Headers[HeaderNames.Authorization].ToString();    if (string.IsNullOrEmpty(tokenHeader))        throw new ArgumentNullException(&quot;缺少token!&quot;);    string pattern = &quot;^Bearer (.*?)$&quot;;    if (!Regex.IsMatch(tokenHeader, pattern))        throw new Exception(&quot;token格式不对!格式为:Bearer &#123;token&#125;&quot;);    string? token = Regex.Match(tokenHeader, pattern)?.Groups[1]?.ToString();    if (string.IsNullOrEmpty(token))        throw new Exception(&quot;token不能为空!&quot;);    return token;&#125;\r\n解析 token\r\npublic static Result&lt;JObject&gt; GetTokenPayload(this TokenParams tokenParam, string token)&#123;    //校验token    var validateParameter = new TokenValidationParameters()    &#123;        ValidateLifetime = true,        ValidateAudience = true,        ValidateIssuer = true,        ValidateIssuerSigningKey = true,        ValidIssuer = tokenParam.Issuer,        ValidAudience = tokenParam.Audience,        IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(tokenParam.Secret))    &#125;;    //校验并解析token    new JwtSecurityTokenHandler().ValidateToken(token, validateParameter, out SecurityToken validatedToken);//validatedToken:解密后的对象    var jwtPayload = ((JwtSecurityToken)validatedToken).Payload.SerializeToJson(); //获取payload中的数据    var jobj = JObject.Parse(jwtPayload);    return jobj;&#125;\r\n参考\r\n\r\nASP.NET\r\nCore 中jwt授权认证的流程原理\r\nUseAuthentication和UseAuthorization\r\nhttps://zhuanlan.zhihu.com/p/176966592\r\nASP.NET\r\nCore 6.0 添加 JWT 认证和授权\r\n\r\n","categories":["Develop","DotNET","DotNetCore"],"tags":[".NET Core","JWT"]},{"title":".NETCore 批量注册 Service 到 IOC","url":"/posts/2023/23HY8MD.html","content":"Service 主要面向数据库，为数据库提供一个统一的 CURD\r\n接口。在日常的使用中，通常把 Service 层注册为 Scoped\r\n类型，随着上下文变动。\r\n在实际开发中，会有非常多的 Service，可以使用如下方法将这些 Service\r\n进行批量注册：\r\n\r\n定义服务基类\r\n首先，需要定义一个空接口 IService，所有的 Service\r\n都继承该接口，这样就可以找到当前程序集中所有实现了 IService\r\n接口的类进行批量注册。\r\n批量注册\r\n直接上代码：\r\n// 扩展方法public static IServiceCollection MapServices(this IServiceCollection services)&#123;    // 批量注入 Services 单例    var serviceBaseType = typeof(IService);              var serviceTypeList = Assembly.GetCallingAssembly()        .GetTypes()        .Where(x =&gt; !x.IsAbstract &amp;&amp; serviceBaseType.IsAssignableFrom(x))        .ToList();    serviceTypeList.ForEach(type =&gt; services.AddTransient(type));    return services;&#125;// 使用builder.services.MapServices();\r\n","categories":["Develop","DotNET","DotNetCore"],"tags":[".NET Core"]},{"title":".NET Core 中使用配置文件","url":"/posts/2023/D4VJ6Q.html","content":"ASP.NET Core\r\n中的应用程序可以使用一个或多个配置。本文主要介绍常用的配置类型，方便在项目中快速应用。将会介绍：\r\n\r\n环境设置文件，appsettings.{Environment}.json\r\n例如，appsettings.Production.json 和\r\nappsettings.Development.json。\r\n设置文件，例如 appsettings.json\r\n\r\n\r\n配置示例\r\n以 appsettings.json 配置为例，定义如下：\r\n&#123;  &quot;Position&quot;: &#123;    &quot;Title&quot;: &quot;Editor&quot;,    &quot;Name&quot;: &quot;Joe Smith&quot;  &#125;,  &quot;MyKey&quot;: &quot;My appsettings.json Value&quot;,  &quot;Logging&quot;: &#123;    &quot;LogLevel&quot;: &#123;      &quot;Default&quot;: &quot;Information&quot;,      &quot;Microsoft&quot;: &quot;Warning&quot;,      &quot;Microsoft.Hosting.Lifetime&quot;: &quot;Information&quot;    &#125;  &#125;,  &quot;AllowedHosts&quot;: &quot;*&quot;&#125;\r\n加载顺序\r\n默认的 JsonConfigurationProvider\r\n会按以下顺序加载配置：\r\n\r\nappsettings.json\r\nappsettings.{Environment}.json\r\n例如，appsettings.Production.json 和\r\nappsettings.Development.json 文件。 文件的环境版本是根据 IHostingEnvironment.EnvironmentName\r\n加载的。 有关详细信息，请参阅在\r\nASP.NET Core 中使用多个环境。\r\n\r\n后加载的 appsettings.{Environment}.json 的值会覆盖掉\r\nappsettings.json 中相同的键。\r\n数据访问\r\n要访问配置，使用 IConfiguration\r\n的接口获取数据，Configuration 在 IOC\r\n容器中注册了单例实例，只需要在使用的类中用构造函数的方式注入即可。如：\r\npublic class TestModel : PageModel&#123;    // requires using Microsoft.Extensions.Configuration;    private readonly IConfiguration Configuration;  \t// 构造函数注入    public TestModel(IConfiguration configuration)    &#123;        Configuration = configuration;    &#125;  \t// 使用    public ContentResult OnGet()    &#123;        var myKeyValue = Configuration[&quot;MyKey&quot;];        var title = Configuration[&quot;Position:Title&quot;];        var name = Configuration[&quot;Position:Name&quot;];        var defaultLogLevel = Configuration[&quot;Logging:LogLevel:Default&quot;];        return Content($&quot;MyKey value: &#123;myKeyValue&#125; \\n&quot; +                       $&quot;Title: &#123;title&#125; \\n&quot; +                       $&quot;Name: &#123;name&#125; \\n&quot; +                       $&quot;Default Log Level: &#123;defaultLogLevel&#125;&quot;);    &#125;&#125;\r\n通过路径获取数据\r\n想发通过路径的方式来获取数据，不同层级的路径名之间使用 :\r\n进行分隔，例如：Position:Name。\r\n数据绑定\r\n定义\r\n可以定义类来将 json 配置映射成强类型，这样方便使用。\r\n例如有如下配置：\r\n&quot;Position&quot;: &#123;    &quot;Title&quot;: &quot;Editor&quot;,    &quot;Name&quot;: &quot;Joe Smith&quot;&#125;\r\n可以创建一个 PositionOptions 类：\r\npublic class PositionOptions&#123;    public const string Position = &quot;Position&quot;;    public string Title &#123; get; set; &#125; = String.Empty;    public string Name &#123; get; set; &#125; = String.Empty;&#125;\r\n条件\r\n选项类要求：\r\n\r\n必须是包含公共无参数构造函数的非抽象类。\r\n类型的所有公共读写属性都已绑定。\r\n字段不是绑定的。 在上面的代码中，Position 未绑定。\r\n由于使用了 Position\r\n字段，因此在将类绑定到配置提供程序时，不需要在应用中对字符串\r\n\"Position\" 进行硬编码。\r\n\r\n使用时绑定\r\n下面的示例代码将：\r\n\r\n调用 ConfigurationBinder.Bind\r\n将类绑定到 Position 部分。\r\n显示 Position 配置数据。\r\n\r\npublic class Test22Model : PageModel&#123;    private readonly IConfiguration Configuration;    public Test22Model(IConfiguration configuration)    &#123;        Configuration = configuration;    &#125;  \t// 获取后通过 Bind 进行绑定    public ContentResult OnGet()    &#123;        var positionOptions = new PositionOptions();        Configuration.GetSection(PositionOptions.Position).Bind(positionOptions);        return Content($&quot;Title: &#123;positionOptions.Title&#125; \\n&quot; +                       $&quot;Name: &#123;positionOptions.Name&#125;&quot;);    &#125;      // 通过 Get&lt;T&gt; 泛型自动绑定    public ContentResult OnGet2()    &#123;                    positionOptions = Configuration.GetSection(PositionOptions.Position)                                                     .Get&lt;PositionOptions&gt;();        return Content($&quot;Title: &#123;positionOptions.Title&#125; \\n&quot; +                       $&quot;Name: &#123;positionOptions.Name&#125;&quot;);    &#125;&#125;\r\nIOC 绑定\r\nvar builder = WebApplication.CreateBuilder(args);builder.Services.AddRazorPages();// 提前注入 ioc 服务builder.Services.Configure&lt;PositionOptions&gt;(    builder.Configuration.GetSection(PositionOptions.Position));var app = builder.Build();\r\n\r\n可以将配置与实体的绑定写到一个扩展方法中，从而简化 Program.cs\r\n中的代码\r\n\r\n使用\r\n通过 IOptions&lt;T&gt; 来通过 IOC\r\n自动获取注册的实例。\r\npublic class Test2Model : PageModel&#123;    private readonly PositionOptions _options;    public Test2Model(IOptions&lt;PositionOptions&gt; options)    &#123;        _options = options.Value;    &#125;    public ContentResult OnGet()    &#123;        return Content($&quot;Title: &#123;_options.Title&#125; \\n&quot; +                       $&quot;Name: &#123;_options.Name&#125;&quot;);    &#125;&#125;\r\n参考\r\nASP.NET\r\nCore 中的配置\r\nASP.NET\r\nCore 中的选项模式\r\n","categories":["Develop","DotNET","DotNetCore"],"tags":[".NET Core"]},{"title":".NETCore设置跨域","url":"/posts/2023/NY7H5J.html","content":"var builder = WebApplication.CreateBuilder(args);builder.Services.AddCors(options =&gt;&#123;    options.AddDefaultPolicy(        policy =&gt;        &#123;            policy.WithOrigins(&quot;http://example.com&quot;,                           &quot;http://www.contoso.com&quot;)              .AllowAnyMethod()            \t.AllowAnyHeader();        &#125;);&#125;);builder.Services.AddControllers();var app = builder.Build();app.UseHttpsRedirection();app.UseStaticFiles();app.UseRouting();// 在静态文件后调用app.UseCors();app.UseAuthorization();app.MapControllers();app.Run();\r\n\r\n参考：\r\n在\r\nASP.NET Core 中启用跨源请求 (CORS) | Microsoft Learn\r\n","categories":["Develop","DotNET","DotNetCore"],"tags":[".NET Core"]},{"title":".NETCore 中配置 Swagger","url":"/posts/2023/1EDD6ES.html","content":"\r\n官方文档写得非常详细，本文只列出一些常用配置，方便拷贝进行快速配置使用。\r\n\r\n定义\r\nbuilder.services.AddSwaggerGen(swaggerOptions =&gt;&#123;    // 配置文档信息    swaggerOptions.SwaggerDoc(&quot;v1&quot;, new OpenApiInfo()    &#123;        Title = &quot;WowToolAPI&quot;,        Contact = new OpenApiContact()        &#123;            Name = &quot;galens&quot;,            Url = new Uri(&quot;https://uyoufu.uzoncloud.com&quot;),            Email = &quot;gmx_galens@163.com&quot;        &#125;    &#125;);    // Set the comments path for the Swagger JSON and UI.    // 需要打开生成API文档功能    var xmlFile = $&quot;&#123;Assembly.GetExecutingAssembly().GetName().Name&#125;.xml&quot;;    var xmlPath = Path.Combine(AppContext.BaseDirectory, xmlFile);    swaggerOptions.IncludeXmlComments(xmlPath);    // Bearer 的scheme定义    var securityScheme = new OpenApiSecurityScheme()    &#123;        Description = &quot;JWT Authorization header using the Bearer scheme. Example: \\&quot;Authorization: Bearer &#123;token&#125;\\&quot;&quot;,        Name = &quot;Authorization&quot;,        //参数添加在头部        In = ParameterLocation.Header,        //使用Authorize头部        Type = SecuritySchemeType.Http,        //内容为以 bearer开头        Scheme = &quot;bearer&quot;,        BearerFormat = &quot;JWT&quot;    &#125;;    //把所有方法配置为增加bearer头部信息    var securityRequirement = new OpenApiSecurityRequirement    &#123;        &#123;            new OpenApiSecurityScheme            &#123;               Reference = new OpenApiReference               &#123;                   Type = ReferenceType.SecurityScheme,                   Id = &quot;bearerAuth&quot;               &#125;            &#125;,            Array.Empty&lt;string&gt;()        &#125;    &#125;;    //注册到swagger中    swaggerOptions.AddSecurityDefinition(&quot;bearerAuth&quot;, securityScheme);    swaggerOptions.AddSecurityRequirement(securityRequirement);&#125;);\r\n在开发环境中启用\r\nif (app.Environment.IsDevelopment())&#123;    app.UseSwagger();    app.UseSwaggerUI();&#125;\r\n打开生成 API 文档\r\n在属性-&gt;生成-&gt;输出，勾选文档文件。生成包含 API 文档的 XML\r\n说明文件。\r\n美化界面\r\n可以使用 IGeekFan.AspNetCore.Knife4jUI\r\n进行美化，由于平时使用 Apifox 进行调试，Swagger\r\n用得比较少，此处不详细展开介绍。\r\n\r\n参考\r\nLearn more about\r\nconfiguring Swagger/OpenAPI\r\n","categories":["Develop","DotNET","DotNetCore"],"tags":[".NETCore","uyoufu"]},{"title":".NET 中使用 Minio 遇到的一些坑","url":"/posts/2022/22T138.html","content":"本文总结了在 .NetCore 中使用 Minio 的过程中遇到的一些问题。\r\n\r\n连接客户端时报错\r\n在连接客户端时，报错：Minio.Exceptions.InvalidEndpointException: MinIO API responded with message=No path allowed in endpoint.\r\n连接代码为：\r\nMinioClient minioClient = new MinioClient(&quot;https://XXXX:9000&quot;,accessKey:&quot;Q3AM3UQ867SPQQA43P2F&quot;,secretKey:&quot;zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG&quot;).WithSSL();\r\n解决方法：\r\n把 url 的前缀 https:// 去掉即可。\r\n签名验证失败\r\n在使用 minioClient时，报错：\r\nMinIO API responded with message=The request signature we calculated does not match the signature you provided. Check your key and signing method.\r\n解决办法：\r\n出现这种问题的原因是 minio 在校验 signature 是否有效的时候，必须从\r\nhttp header 里面获取 host，而我们这里没有对 header\r\n作必要的处理。如果源请求未携带这个头，则 minio 处无法获取请求头中的\r\nhost。\r\n可以在 nginx 中添加如下配置解决：\r\nlocation /&#123;     proxy_set_header X-Real-IP $remote_addr;     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;     proxy_set_header X-Forwarded-Proto $scheme;     proxy_set_header Host $http_host;     proxy_connect_timeout 300;     # Default is HTTP/1, keepalive is only enabled in HTTP/1.1     proxy_http_version 1.1;     proxy_set_header Connection &quot;&quot;;     proxy_pass http://localhost:9000;     chunked_transfer_encoding off;&#125;\r\n\r\n参考：\r\n\r\nhttp://www.dreamwu.com/post-2068.html\r\nhttps://docs.min.io/docs/setup-nginx-proxy-with-minio.html\r\nhttps://segmentfault.com/a/1190000019422246\r\n\r\n\r\n访问bucket被拒绝\r\n当调用 BucketExistsAsync(\"public\")\r\n时，报错：MinIO API responded with message=Access denied on the resource: public/.\r\n解决办法：\r\n","categories":["Develop","DotNET","Minio"],"tags":[".NET","Minio"]},{"title":"CSharp中的JsonPath语法","url":"/posts/2021/0CYX0R.html","content":"字符串匹配查询，== 号 加 ‘ ’ 号\r\n","categories":["Develop","DotNET","NewtonJson"],"tags":["C#","JsonPath","json"]},{"title":"Swagger使用中的一些注意总结","url":"/posts/2022/3S2PQT2.html","content":"本文主要记录 Swagger\r\n在使用过程中遇到的一些问题，从而避免再次踩坑。\r\n\r\n正文\r\n\r\n报错 Failed to load API definition\r\n可能是由于 Controller 定义中，有未用\r\nHttpVerb 标记的公共方法。\r\n可以将这些不是接口的 public 方法改成私有的。\r\n\r\n","categories":["Develop","DotNET","DotNetCore"],"tags":[".NET Core","Swagger","OpenAPI"]},{"title":"EF Core 实现多对多关系的几种方式","url":"/posts/2023/3NAXE1Y.html","content":"当一个实体类型的任意数量的实体与相同或另一个实体类型的任意数量的实体相关联时，将使用多对多关系。\r\n实现多对多主要有两种方式：\r\n\r\n使用“关联”表来联接两个实体，这个是官方支持的做法\r\n若只关心单向的一对多关系，可以将数据转换成 json 保存\r\n\r\n\r\n通过关联表实现多对多\r\n通过 Json 实现多对多\r\n参考\r\n多对多关系\r\n- EF Core | Microsoft Learn\r\n","categories":["Develop","DotNET","DotNetCore"],"tags":["EF Core","DotNET Core"]},{"title":"WPF MVVM Stylet使用文档（中文）01-Introduction","url":"/posts/2020/MDKVCV.html","content":"在 Github 上发现一个开源轻巧的 MVVM\r\n框架，发现网上缺少相应的中文文档，便进行了翻译总结，英文水平有限，MVVM也才初学，若有错误，还请斧正。\r\n\r\n概述\r\nStylet 是一个小巧，但强大的 MVVM 框架，它的灵感来自于 Caliburn.Micro。它通过进一步减少复杂性和各种事件，让不熟悉任何\r\nMVVM 框架的人(同事)更快地使用 MVVM 框架。\r\n它还提供了在 Caliburn.Micro\r\n里没有的功能。包括独有的【IoC容器】，更简单的【 ViewModel验证】和兼容\r\nmvvm 的消息框架。\r\n少量的代码（LOC : Line Of Code）和非常全面的测试组件使得 Sytlet\r\n对于那些使用、验证或确认 SOUP\r\n导致高开销的项目是一个很有吸引力的选择。Stylet 的模块化 toolkit-inspired\r\n架构意味着它很容易让你自由使用，使用你喜欢的部分,或替掉你不喜欢的部分。\r\n下面是一个简洁的特点列表。也可以点击链接了解更多信息。\r\n视图模型优先（A\r\nViewModel-First apporach）\r\n典型的 MVVM\r\n结构：视图（View）知道如何实例化它的视图模型（ViewModel），而 ViewModel\r\n通常不直接通信，这种结构被称之为\r\n视图优先（View-First）。然而，反转这个模式——使用者自己实例化\r\nViewModels，然后框架自动将 View 附加到实例化的 ViewModel\r\n上——这种方式有很多优点，它允许你以一种非常熟悉的方式组合ViewModels。这种\r\nViewModel-First 方式是 Stylet 唯一支持的。\r\n响应（Action）\r\nWPF 使用的 ICommand 接口非常强大，但是在 MVVM\r\n体系结构中使用时显得有些笨拙。ViewModel\r\n对一些过程的响应似乎是不对的，比如按钮的单击操作应该表示为属性，而不是方法。一个简单的语句&lt;Button Command=\"{s:Action DoSomething}\"/&gt;使得在每次单击按钮时调用\r\nViewModel 上的 DoSomething() 。\r\n另外，如果您有一个名为 CanDoSomething 的 bool\r\n属性，它将被观察并用于判断按钮应该启用还是禁用。这被称为防护属性。\r\n响应还可以与事件一起工作，允许您执行以下操作：&lt;Button MouseEnter=\"{s:Action DoSomethingElse}\"/&gt;\r\nScreen\r\n类和 Conductors\r\nScreen 类提供了很多功能，使得它成为 ViewModel\r\n的一个很有吸引力的基类：属性改变通知，验证，当它 显示/隐藏/关闭\r\n时被通知的功能，当它关闭时，是否能够被控制的功能。\r\n事件聚合器（The Event\r\nAggregator）\r\nStylet 的事件聚合器与 Caliburn\r\n非常相似。允许订阅者在不知情或不保留对方的情况下接收发布的消息。这对于\r\nviewmodel 之间的消息传递特别有用，当然它还有许多其他用途。\r\n窗体管理器（The\r\nWindowManager）\r\n使用 ViewModel-first 方式，通过引用要显示的 ViewModel\r\n来显示窗口和对话框，视图会自动附加。WindowManager可以轻松地完成这一任务。\r\n它还提供了一个mvvm兼容的消息框实现，因此您不必自己动手。\r\n验证（Validation）\r\n传统的 MVVM\r\n中的验证有一个痛点：它需要在每个需要验证的视图模型中使用大量的样板文件，关于如何做好这一点的资料却很少。\r\nStylet 提供了一个框架来获取您最喜欢的验证库（例如FluentValidation），并处理运行的验证和向视图报告结果。\r\nStylet 控制反转（StyletIoC）\r\nStylet\r\n自带了自己的轻量级和极快(但仍然很强大)的IoC容器，当然如果您愿意，可以很容易地使用另一个IoC。\r\nMIT 许可（MIT license）\r\nStylet 是在 MIT 许可下发布的，它允许您修改\r\nStylet，并将其包含在商业项目中，而不需要声明(惟一的限制是必须包含许可的副本)。如果你需要的话，我可以根据具体情况重新授权。\r\n名词解释\r\n\r\nIoC: Inversion of Control,控制反转\r\nLoC: Line of Code，代码行\r\nDI: Dependency Injection，依赖注入\r\nMIT license: 软件授权条款之一，详见百度\r\n\r\n","categories":["Develop","DotNET","Stylet 框架"],"tags":["MVVM","WPF"]},{"title":"利用 HttpClient 进行网络请求并获取进度信息","url":"/posts/2022/1621QC.html","content":".NET 下主要有三种方式可以进行网络请求相关操作，它们分别是\r\nHttpWebRequest，WebClient 和\r\nHttpClient。这三者的关系是不断递进发展的，所以一般使用\r\nHttpClient 来进行网络请求。\r\n本文主要讲述 HttpClient 的使用方法和进度获取。\r\n\r\n比较\r\n\r\n\r\n\r\n类别\r\nHttpWebRequset\r\nWebClient\r\nHttpClient\r\n\r\n\r\n\r\n\r\n命名空间\r\nSystem.Net\r\nSystem.Net\r\nSystem.Net.Http\r\n\r\n\r\n继承类\r\nWebRequest\r\nComponent\r\nHttpMessageInvoker\r\n\r\n\r\n支持url转向\r\n是\r\n否\r\n是\r\n\r\n\r\n支持cookie和session\r\n是\r\n否\r\n否\r\n\r\n\r\n支持用户代理服务器\r\n是\r\n否\r\n是\r\n\r\n\r\n使用复杂度\r\n高\r\n低\r\n低\r\n\r\n\r\n\r\nHttpClient 使用方式\r\n// 使用方式&#123;\tHttpClientHandler handler = new HttpClientHandler();    ProgressMessageHandler progressMessageHandler = new ProgressMessageHandler(handler);    // 接收进度\tprogressMessageHandler.HttpReceiveProgress += ProgressMessageHandler_HttpProgress;    // 发送进度    progressMessageHandler.HttpSendProgress += ProgressMessageHandler_HttpProgress;\tHttpClient httpClient = new HttpClient(progressMessageHandler)\t&#123;\t\tTimeout = TimeSpan.FromMinutes(60)\t&#125;;        using (MultipartFormDataContent multipartFormData = new MultipartFormDataContent())\t&#123;        multipartFormData.Add(new StreamContent(fileInfo.OpenRead()), &quot;file&quot;, fileInfo.Name);        HttpResponseMessage resMessage = httpClient.PutAsync(uploadUrl, multipartFormData).GetAwaiter().GetResult();        if (!resMessage.IsSuccessStatusCode)        &#123;            resultUrls.Add(resMessage.ReasonPhrase);            continue;        &#125;\t&#125;&#125;// 进度回调private void ProgressMessageHandler_HttpProgress(object sender, HttpProgressEventArgs e)&#123;    // 在此处通过 HttpProgressEventArgs 获取进度信息&#125;\r\n\r\nProgressMessageHandler 位于 System.Net.Http.Formatting.dll\r\n程序集中。一般系统没有自带该类库，要从网上自行下载。\r\n✈\r\n点击下载\r\n\r\n参考\r\n\r\nWebClient,\r\nHttpClient, HttpWebRequest的比较\r\n\r\n","categories":["Develop","DotNET","Http"],"tags":[".NET","Http","HttpClient"]},{"title":"WPF MVVM Stylet使用文档（中文）03-Bootstrapper","url":"/posts/2020/268PCBJ.html","content":"简介\r\n引导程序负责启动应用程序。它配置 IoC 容器，创建根 ViewModel\r\n的新实例，并使用 WindowManager 显示它。\r\n\r\n它还提供了其他各种功能，如下所述。\r\n引导程序有两种形式:\r\n\r\nBootstrapperBase&lt;TRootViewModel&gt;，这种需要您自己配置\r\nIoC 容器;\r\nBootstrapper &lt;TRootViewModel&gt;，使用 Stylet 的内置\r\nIoC 容器 StyletIoC。\r\n\r\n示例 Bootstrapper，使用 StyletIoC:\r\nclass Bootstrapper : Bootstrapper&lt;MyRootViewModel&gt;&#123;   protected override void OnStart()   &#123;      // This is called just after the application is started, but before the IoC container is set up.      // Set up things like logging, etc      //程序启动之后，IoC窗口配置之前调用      //进行一些设置，比如日志   &#125;    protected override void ConfigureIoC(IStyletIoCBuilder builder)   &#123;      // Bind your own types. Concrete types are automatically self-bound.      builder.Bind&lt;IMyInterface&gt;().To&lt;MyType&gt;();   &#125;    protected override void Configure()   &#123;      // This is called after Stylet has created the IoC container, so this.Container exists, but before the Root ViewModel is launched.      // Configure your services, etc, in here   &#125;    protected override void OnLaunch()   &#123;      // This is called just after the root ViewModel has been launched      // Something like a version check that displays a dialog might be launched from here   &#125;    protected override void OnExit(ExitEventArgs e)   &#123;      // Called on Application.Exit   &#125;    protected override void OnUnhandledException(DispatcherUnhandledExceptionEventArgs e)   &#123;      // Called on Application.DispatcherUnhandledException   &#125;&#125;\r\n使用自定义的 IoC 容器(Using a Custom IoC Container)\r\n使用带有 Stylet 的另一个 IoC 容器很容易。我在 Bootstrappers\r\nproject 中包含了许多流行的 IoC\r\n容器的bootstrappers。这些都是经过单元测试而非实战测试的:\r\n您可以随意定制它们。\r\n注意，Stylet nuget package/dll\r\n不包括这些，因为它会添加不必要的依赖。同样，我也不会发布特定的 IoC\r\n容器的包，因为这是一种浪费。\r\n将您想要的引导程序从上面的链接复制到您的项目中。然后子类化它，就像您通常子类化Bootstrapper&lt;TRootViewModel&gt;，上面有文档说明。然后将子类添加到\r\nApp.xaml.cs 中。正如 Quick Start 中说明的那样。\r\npublic class Bootstrapper : AutofacBootstrapper&lt;ShellViewModel&gt;&#123;&#125;\r\n&lt;Application x:Class=&quot;Stylet.Samples.Hello.App&quot;             xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;             xmlns:s=&quot;https://github.com/canton7/Stylet&quot;             xmlns:local=&quot;clr-namespace:Stylet.Samples.Hello&quot;&gt;    &lt;Application.Resources&gt;       &lt;s:ApplicationLoader&gt;            &lt;s:ApplicationLoader.Bootstrapper&gt;                &lt;local:Bootstrapper/&gt;            &lt;/s:ApplicationLoader.Bootstrapper&gt;        &lt;/s:ApplicationLoader&gt;    &lt;/Application.Resources&gt;&lt;/Application&gt;\r\n如果您想为另一个 IoC\r\n容器编写自己的引导程序，这也很容易。看看上面的描述，看看需要做什么。\r\n向 App.xmal 添加资源字典(Adding Resource Dictionaries to\r\nApp,xmal)\r\ns:ApplicationLoader 本身就是一个\r\nResourceDictionary。如果你需要将自己的资源字典添加到 App.xaml\r\n中，你需要将s:ApplicationLoader 嵌入到你的\r\nResourceDictionary 中作为一个合并字典，就像这样:\r\n&lt;Application.Resources&gt;    &lt;ResourceDictionary&gt;        &lt;ResourceDictionary.MergedDictionaries&gt;            &lt;s:ApplicationLoader&gt;                &lt;s:ApplicationLoader.Bootstrapper&gt;                    &lt;local:Bootstrapper/&gt;                &lt;/s:ApplicationLoader.Bootstrapper&gt;            &lt;/s:ApplicationLoader&gt;            &lt;ResourceDictionary Source=&quot;YourDictionary.xaml&quot;/&gt;        &lt;/ResourceDictionary.MergedDictionaries&gt;    &lt;/ResourceDictionary&gt;&lt;/Application.Resources&gt;\r\n","categories":["Develop","DotNET","Stylet 框架"],"tags":["MVVM","WPF"]},{"title":"WPF MVVM Stylet使用文档（中文）02-Quick Start","url":"/posts/2020/2APET5T.html","content":"想要尽快让 stylet 运行起来吗?就是这里!\r\n\r\n\r\n注意:如果您正在寻找示例应用程序，请下载源代码并查看Samples\r\n文件夹。\r\n\r\n下面的介绍将建立一个最小的框架项目。\r\n自动设置(AutoMatic\r\nOption)\r\n.NET Framework\r\n\r\n注意:如果您的项目 NuGet 包使用的是 PackageReference，或者您使用的是\r\nVS2013 或更早的版本，这将不起作用。请改用下面的“手动选项”部分。\r\n\r\n如果您是 Stylet 新手(并且正在运行 VS2015\r\n或更高版本)，这是最简单的入门方法。\r\n\r\n打开 Visual Studio，并创建一个新的 WPF 应用程序项目。\r\n打开 NuGet\r\n(右键单击你的项目-&gt;管理NuGet包)，并搜索并安装Stylet.start包。\r\n\r\n这将为您提供一个工作框架项目。\r\n安装完成后，卸载style . start。\r\n编码快乐!\r\n.NET Core\r\n对于 .NET Core 项目，最快的入门方法是使用 dotnet new和\r\nStylet 的模板。\r\n打开一个命令窗口，并定位到你想安装新项目的位置\r\n\r\n使用下面命令安装 Stylet 模板:\r\ndotnet new -i Stylet.Templates\r\n使用下面的命令新建一个工程\r\ndotnet new stylet -o MyStyletProject\r\n适当更改 MyStyletProject\r\n\r\n手动设置\r\n如果你不想用 Stylet.Start\r\n包并希望创建自己的框架项目，请按照下面的的步骤：\r\n\r\n打开 Visual Studio，并创建一个新的WPF应用程序项目。\r\n打开 NuGet(右键单击你的项目-&gt;管理NuGet包)，并安装\r\nStylet包。\r\n首先，删除 MainWindow.xaml 和 MainWindow.xaml.cs /\r\nvb。你不需要他们。\r\n接下来，您需要一个根 View 和一个 ViewModel。根 View 必须是一个\r\nWindow 或者 继承于 Window\r\n，除了这个，没有其它任何限制，View 如下：\r\n&lt;Window x:Class=&quot;Stylet.Samples.Hello.RootView&quot;        xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;        xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;        Height=&quot;300&quot; Width=&quot;300&quot;&gt;    &lt;TextBlock&gt;Hello, World&lt;/TextBlock&gt;&lt;/Window&gt;\r\n\r\n\r\nViewModel 可以是任何一个旧类(现在—您可能希望它是一个 Screen 或\r\nConductor)。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nC#\r\nVB.NET\r\n\r\n\r\n\r\n\r\npublic class RootViewModel { }\r\nPublic Class RootViewModel End Class &gt;\r\n\r\n\r\n\r\n\r\n\r\n接下来，您需要一个引导程序。现在，您不需要任何特殊的东西——只需要一些东西来标识根\r\nViewModel。然后，您将能够在这里配置 IoC容器\r\n以及其他应用程序级的内容，如下：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nC#\r\nVB.NET\r\n\r\n\r\n\r\n\r\npublic class Bootstrapper : Bootstrapper {\r\n}\r\nPublic Class Bootstrapper Inherits Bootstrapper(Of RootViewModel)\r\nEnd Cl\r\n\r\n\r\n\r\n最后，需要将其作为资源引用到您的 App.xaml 中。您需要删除 StartUri\r\n属性，并为 Stylet 和您自己的应用程序添加 xmlns 条目。最后，您需要将\r\nStylet 的 ApplicationLoader 添加到资源中，并识别您在上面创建的引导程序\r\n(Bootstrapper)。\r\n像下面这样：\r\n&lt;Application x:Class=&quot;Stylet.Samples.Hello.App&quot;             xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;             xmlns:s=&quot;https://github.com/canton7/Stylet&quot;             xmlns:local=&quot;clr-namespace:Stylet.Samples.Hello&quot;&gt;    &lt;Application.Resources&gt;       &lt;s:ApplicationLoader&gt;            &lt;s:ApplicationLoader.Bootstrapper&gt;                &lt;local:Bootstrapper/&gt;            &lt;/s:ApplicationLoader.Bootstrapper&gt;        &lt;/s:ApplicationLoader&gt;    &lt;/Application.Resources&gt;&lt;/Application&gt;\r\n\r\n就是这样!运行它，你会得到一个带有 Hello World 的窗体。\r\n程序加载器(The\r\nApplicationLoader)\r\n值得注意的是，上面的&lt;s:ApplicationLoader&gt;是\r\nResourceDictionary 子类。这允许它加载 Stylet 的嵌入资源(参见 Screen 和\r\nConductors )。你可以选择不加载 Stylet 的资源，像这样:\r\n&lt;s:ApplicationLoader LoadStyletResources=&quot;False&quot;&gt;   ...&lt;/s:ApplicationLoader&gt;\r\n如果你想添加自己的 Resource/ResourceDictionaries\r\n到应用程序，最简单的方法是这样的:\r\n&lt;Application.Resources&gt;    &lt;s:ApplicationLoader&gt;        &lt;s:ApplicationLoader.Bootstrapper&gt;            &lt;local:Bootstrapper/&gt;        &lt;/s:ApplicationLoader.Bootstrapper&gt;        &lt;Style x:Key=&quot;MyResourceKey&quot;&gt;            ...        &lt;/Style&gt;        &lt;s:ApplicationLoader.MergedDictionaries&gt;            &lt;ResourceDictionary Source=&quot;MyResourceDictionary.xaml&quot;/&gt;        &lt;/s:ApplicationLoader.MergedDictionaries&gt;    &lt;/s:ApplicationLoader&gt;&lt;/Application.Resources&gt;\r\n如果这让你感到不舒服，你也可以这样做:\r\n&lt;Application.Resources&gt;    &lt;ResourceDictionary&gt;        &lt;ResourceDictionary.MergedDictionaries&gt;            &lt;s:ApplicationLoader&gt;                &lt;s:ApplicationLoader.Bootstrapper&gt;                    &lt;local:Bootstrapper/&gt;                &lt;/s:ApplicationLoader.Bootstrapper&gt;            &lt;/s:ApplicationLoader&gt;            &lt;ResourceDictionary Source=&quot;MyResourceDictionary.xaml&quot;/&gt;        &lt;/ResourceDictionary.MergedDictionaries&gt;        &lt;Style x:Key=&quot;MyResourceKey&quot;&gt;            ...        &lt;/Style&gt;    &lt;/ResourceDictionary&gt;&lt;/Application.Resources&gt;\r\n","categories":["Develop","DotNET","Stylet 框架"],"tags":["MVVM","WPF"]},{"title":"WPF MVVM Stylet使用文档（中文）05-Actions","url":"/posts/2020/3C0QABE.html","content":"你有一个按钮，你想点击它并在 ViewModel 上执行一个方法? Actiions\r\n完全可以解决这种问题。\r\n\r\n响应和方法（Actions and\r\nMethods）\r\n在“传统的” WPF 中，你需要在 ViewModel 上创建一个属性来实现 ICommand\r\n接口，并将按钮的命令属性绑定到它。这工作得相当好 (ViewModel 对 View\r\n一无所知，也不需要代码隐藏)，但它有点混乱——您确实需要在ViewModel\r\n上调用一个方法，而不是在某个属性上执行一个方法。\r\nStylet 通过引入响应（Action） 解决了这个问题。看看这个:\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nC#\r\nVB.NET\r\n\r\n\r\n\r\n\r\nclass ViewModel {  public void DoSomething()  {\r\n Debug.WriteLine(\"DoSomething called\");  } }\r\nClass ViewModel Public Sub DoSomething()\r\nConsole.WriteLine(\"DoSomething called\")End Sub End Class\r\n\r\n\r\n\r\n&lt;UserControl x:Class=&quot;MyNamespace.View&quot;             xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;             xmlns:s=&quot;https://github.com/canton7/Stylet&quot;&gt;   &lt;Button Command=&quot;&#123;s:Action DoSomething&#125;&quot;&gt;Click me&lt;/Button&gt;&lt;/UserControl&gt;\r\n您可能已经猜到了，单击按钮的时候，会调用 ViewModel 上的 DoSomething\r\n方法。\r\n就这么简单。\r\n如果您的方法接受单个参数，可以传递按钮的 CommandParameter\r\n属性的值。例如:\r\n\r\n\r\n\r\nC#\r\n\r\n\r\nVB.NET\r\n\r\n\r\n\r\n\r\nclass ViewModel\r\n{\r\n   public void DoSomething(string argument)\r\n   {\r\n      Debug.WriteLine(String.Format(&quot;Argument is {0}&quot;, argument));\r\n   }\r\n}\r\n\r\n\r\n\r\nClass ViewModel\r\n&nbsp;\r\n  Public Sub DoSomething(argument As String)\r\n&nbsp;\r\n  Debug.WriteLine(String.Format(&quot;Argument is {0}&quot;, argument)\r\n&nbsp;\r\n  End Sub\r\nEnd Class\r\n\r\n\r\n\r\n&lt;UserControl x:Class=&quot;MyNamespace.View&quot;             xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;             xmlns:s=&quot;https://github.com/canton7/Stylet&quot;&gt;   &lt;Button Command=&quot;&#123;s:Action DoSomething&#125;&quot; CommandParameter=&quot;Hello&quot;&gt;Click me&lt;/Button&gt;&lt;/UserControl&gt;\r\n\r\n注意：Actions 对所有的 ICommand 属性都起作用 (比如 KeyBinding)\r\n\r\n保护属性（Guard Properties）\r\n您还可以使用 Guard Properties\r\n来控制是否启用按钮。给定方法的保护属性是一个布尔属性，其名称为\r\n“Can&lt;方法名&gt;”，因此如果您的方法名为\r\n“DoSomething”，则相应的保护属性为 “CanDoSomething”。\r\nStylet 将检查保护属性是否存在，如果存在，如果返回 false\r\n禁用按钮，如果返回 true 则启用按钮。它还将监视该属性的 PropertyChanged\r\n通知，因此您可以控制按钮是否启用。\r\n例如:\r\n\r\n\r\n\r\nC#\r\n\r\n\r\nVB.NET\r\n\r\n\r\n\r\n\r\nclass ViewModel\r\n{\r\n   public bool CanDoSomething\r\n   {\r\n      get { return this.someOtherConditionIsSatisfied(); }\r\n   }\r\n   public void DoSomething()\r\n   {\r\n      Debug.WriteLine(&quot;DoSomething called&quot;);\r\n   }\r\n\r\n\r\n\r\nClass ViewModel\r\n&nbsp;\r\n  Public ReadOnly Property CanDoSomething As Boolean\r\n        Get\r\n            Return Me.someOtherConditionIsSatisfied()\r\n        End Get\r\n    End Property\r\n&nbsp;\r\n    Public Sub DoSomething()\r\n        Debug.WriteLine(&quot;DoSomething called&quot;)\r\n    End Sub\r\nEnd Class\r\n\r\n\r\n\r\n事件（Events）\r\n但是如果您想在事件发生时调用 ViewModel 方法呢? Actions\r\n也包括这些。语法是完全相同的，但是没有保护属性的概念。\r\n&lt;UserControl x:Class=&quot;MyNamespace.View&quot;             xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;             xmlns:s=&quot;https://github.com/canton7/Stylet&quot;&gt;   &lt;Button Click=&quot;&#123;s:Action DoSomething&#125;&quot;&gt;Click me&lt;/Button&gt;&lt;/UserControl&gt;\r\n被调用的方法必须有 0个 或者 1个 或者 2个 参数。可能的情况如下：\r\n\r\n\r\n\r\nC#\r\n\r\n\r\nVB.NET\r\n\r\n\r\n\r\n\r\npublic void HasNoArguments() { }\r\n&nbsp;\r\n// This can accept EventArgs, or a subclass of EventArgs\r\npublic void HasOneSingleArgument(EventArgs e) { }\r\n&nbsp;\r\n// Again, a subclass of EventArgs is OK\r\npublic void HasTwoArguments(object sender, EventArgs e) { }\r\n\r\n\r\n\r\nPublic Sub HasNoArguments()\r\nEnd Sub\r\n&nbsp;\r\n&#39; This can accept EventArgs, or a subclass of EventArgs\r\nPublic Sub HasOneSingleArgument(ByVal e As EventArgs)\r\nEnd Sub\r\n&nbsp;\r\n&#39;Again, a subclass of EventArgs is OK\r\nPublic Sub HasTwoArguments(ByVal sender As Object, ByVal e As EventArgs)\r\nEnd Sub\r\n\r\n\r\n\r\n响应目标（The\r\nView.ActionTarget）\r\n到目前为止，我一直在说一个善意的谎言。我一直在说 Actions 是在\r\nViewModel 上调用的，但这并不完全正确。让我们更详细一点。\r\nStylet 定义了一个可继承的附加属性\r\nView.ActionTarget。当一个视图被绑定到它的视图模型，View\r\n中根元素上的ActionTarget 绑定到\r\nViewModel，然后由视图中的每个元素继承。当您调用一个 响应\r\n时，它将在View.ActionTarget中被调用。\r\n这意味着，在默认情况下，不管当前的 DataContext 是什么，都会在\r\nViewModel 上调用操作，这可能就是您想要的。\r\n这是非常重要的一点，值得强调。DataContext\r\n可能会在整个可视树中的多个位置发生变化。但是, View.ActionTarget\r\n将保持不变(除非您手动更改它)。这意味着 Actions 总是由您的 ViewModel\r\n来处理，而不是由绑定到的对象来处理，这几乎总是您想要的。\r\n当然，您可以更改单个元素的 View.ActionTarget，例如:\r\n\r\n\r\n\r\nC#\r\n\r\n\r\nVB.NET\r\n\r\n\r\n\r\n\r\nclass InnerViewModel\r\n{\r\n   public void DoSomething() { }\r\n}\r\nclass ViewModel\r\n{\r\n   public InnerViewModel InnerViewModel { get; private set; }\r\n   public ViewModel()\r\n   {\r\n      this.InnerViewModel = new InnerViewModel();\r\n   }\r\n}\r\n\r\n\r\n\r\nClass InnerViewModel\r\n&nbsp;\r\n    Public Sub DoSomething()\r\n    End Sub\r\n&nbsp;\r\nEnd Class\r\n&nbsp;\r\nClass ViewModel\r\n&nbsp;\r\n    Public Property InnerVM As InnerViewModel\r\n&nbsp;\r\n    Public Sub New()\r\n        Me.InnerVM = New InnerViewModel()\r\n    End Sub\r\n&nbsp;\r\nEnd Class\r\n\r\n\r\n\r\n&lt;UserControl x:Class=&quot;MyNamespace.View&quot;             xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;             xmlns:s=&quot;https://github.com/canton7/Stylet&quot;&gt;   &lt;Button s:View.ActionTarget=&quot;&#123;Binding InnerViewModel&#125;&quot; Command=&quot;&#123;s:Action DoSomething&#125;&quot;&gt;Click me&lt;/Button&gt;&lt;/UserControl&gt;\r\n在这里, 单击按钮时将调用 InnerViewModel.DoSomething。还有，因为\r\nView.ActionTarget 是继承的，按钮的任何子元素也会将它们的\r\nView.ActionTarget 设置为 InnewViewModel。\r\n响应和样式（Actions and\r\nStyles）\r\n从样式设置器执行的 Actions 将不起作用。WPF\r\n中需要的类都是内部的，这意味着没有办法修复这个问题。不幸的是，在这种(罕见的)情况下，您需要使用老式的命令。\r\n快捷方式——快捷菜单和弹出菜单（Gotchas\r\n- ContextMenu and Popup）\r\n当然，View.ActionTarget\r\n是一个附加属性，它被配置为由设置它的任何元素的子元素继承，就像任何附加的属性一样，甚至是\r\nDataContext，有一些边界是不能被继承的，比如:\r\n\r\n使用快捷菜单\r\n使用弹出窗口\r\n使用框架\r\n\r\n在这些情况下，Stylet 将尽其所能找到一个合适的 ActionTarget\r\n(例如，它可能会找到与当前 XAML 文件中的根元素相关联的 ActionTarget\r\n)，但这可能不是您所期望的(例如，它可能会忽略你的页面中间的\r\ns:View.ActionTarget = \"{Binding…}\r\n行)，或者它可能(在罕见的情况下)根本找不到一个ActionTarget。\r\n在这种情况下，请设置s:View.ActionTarget\r\n一个合适的值。您可能很难从 ContextMenu 的内部获得对ContextMenu\r\n之外任何内容的引用: 我建议使用BindingProxy技术。\r\n其它行为（Additional\r\nBehaviour）\r\n有两种情况会阻止操作正常工作:\r\n\r\n如果 View.ActionTarget 为空\r\n或者如果指定的方法在 View.ActionTarget 根本不存在。\r\n\r\n这些情况下的默认行为如下:\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nView.ActionTarget == null\r\nNo method on View.ActionTarget\r\n\r\n\r\n\r\n\r\nCommands\r\nDisable the control\r\nThrow an exception when the control is clicked\r\n\r\n\r\nEvents\r\nEnable the control\r\nThrow an exception when the event is raised\r\n\r\n\r\n\r\n这样做的理由是如果 View.ActionTarget\r\n为空，你必须自己设置它，所以你可能知道你在做什么。但是，如果指定的方法在\r\nView.ActionTarget 中不存在，这可能是个错误，你应该知道。\r\n当然，这种行为是可配置的。\r\n当在 View.ActionTarget 为null时，要控制它的行为，可以在\r\nAction 标记扩展上设置 NullTarget\r\n属性，使它的值为 Enable、Disable 或\r\nThrow都可以。(请注意，当Action\r\n在事件中使用时，“Disable”是无效的时候，因为我们没有权力禁用任何东西)。\r\n例如:\r\n&lt;Button Command=&quot;&#123;s:Action MyMethod, NullTarget=Enable&#125;&quot;/&gt;&lt;Button Click=&quot;&#123;s:Action MyMethod, NullTarget=Throw&#125;&quot;/&gt;\r\n更熟悉的方式，你也可以设置 ActionNotFound\r\n的值为上面三个值之一\r\n&lt;Button Command=&quot;&#123;s:Action MyMethod, ActionNotFound=Disable&#125;&quot;/&gt;&lt;Button Click=&quot;&#123;s:Action MyMethod, ActionNotFound=Enable&#125;&quot;/&gt;\r\n","categories":["Develop","DotNET","Stylet 框架"],"tags":["MVVM","WPF"]},{"title":"WPF MVVM Stylet使用文档（中文）04-ViewModel First","url":"/posts/2020/CCGDMG.html","content":"简介\r\nViewModel-first 方式对于 Stylet\r\n的体系结构非常重要，但是如果您以传统的 View-first\r\n方式学习MVVM，就会发现它并不直观。\r\n\r\n希望这篇文章能把一切都讲清楚。\r\nView-first 方式 (The\r\nView-First Appoach)\r\n让我们从定义 View-First 的方式开始，我这么说是什么意思呢?\r\nMVVM 声明 ViewModel 应该不知道 View 的任何信息，但是该 View 应该知道\r\nViewModel。联 系 View 和 ViewModel 最简单的方法就是让 View\r\n在它的代码背后构造它的 ViewModel——就像这样:\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nC#\r\nVB.NET\r\n\r\n\r\n\r\n\r\npublic partial class MyView : Window { public MyView()\r\n{ InitializeComponent(); this.DataContext = new\r\nMyViewModel(); } }\r\nPartial Public Class MyView : Inherits Window Public Sub\r\nNew() InitializeComponent() Me.DataContext = new\r\nMyViewModel() End Class\r\n\r\n\r\n\r\n这是很好。View 可以创建和拥有其他 View，这意味着可以将 View\r\n组合成层次结构。一切都很好。\r\n当你组合了几个视图，比如这样，一个 Shell\r\n包含一个顶部栏和一个框架，里面的任何页面都可以显示:\r\n&lt;!-- This is a window which contains a top bar and another page --&gt;&lt;Window x:Class=&quot;MyNamespace.ShellView&quot; ....&gt;   &lt;StackPanel&gt;      &lt;my:TopBarView/&gt;      &lt;Frame x:Name=&quot;navigationFrame&quot;/&gt;   &lt;/StackPanel&gt;&lt;/Window&gt;\r\nTopBarView 有它自己的 ViewModel 。\r\n现在假设 TopBarView\r\n有一个字段，其中包含您想要更新的一些数据，例如当前页面的标题。现在，ShellViewModel\r\n知道这一点(毕竟它决定了当前页面是什么)，但是 TopBarViewModel\r\n不知道(它怎么知道?它什么都不知道)。这样做是为了暴露 TopBarView\r\n的依赖属性，并将其绑定到 ShellViewModel 中，就像这样:\r\n&lt;Window x:Class=&quot;MyNamespace.ShellView&quot; .... x:Name=&quot;rootObject&quot;&gt;   &lt;StackPanel&gt;      &lt;my:TopBarView CurrentPageTitle=&quot;&#123;Binding CurrentPageTitle, ElementName=rootObject&#125;&quot;/&gt;      &lt;Frame x:Name=&quot;navigationFrame&quot;/&gt;   &lt;/StackPanel&gt;&lt;/Window&gt;\r\n但那太恶心了。现在您已经得到了一个绑定到 ShellViewMode l 的视图。\r\n另一个主要的关注点是显示窗口和对话框。\r\n在传统的 MVVM 中，这是一个痛点。第一种选择是实例化并从 ViewModel\r\n中显示视图(使用 Show() 或 ShowDialog() ) ，这使得\r\nViewModel，或者至少是它的一部分，变得不可测试。\r\n更好的选择是在你当前视图的后台代码中显示新视图的时候才实例化，并从那里显示它。这意味着您需要建立一种方式来通知当前视图，让其显示实例化的视图，同时，还需要建立一种方式来获取对话框的结果并返回到\r\nViewModel。\r\n实际上，为上面的框架设置内容需要实例化一个视图并放进视图中。这也面临同样的困境——要么视图模型实例化它(使其不可测试)，要么视图实例化它(导致通信困难)。\r\n不管怎样，这种方法都有一些缺点。\r\nViewModel-First 方式( The ViewModel-First Approach)\r\nViewModel-first 方式的思想是：ViewModel 不应该知道其 View\r\n的任何信息，同时 View 也不负责构造\r\nViewModel。相反，第三个服务负责为给定的 ViewModel 定位正确的\r\nView，并正确地设置它的DataContext。\r\n默认实现使用命名约定对给定的 ViewModel 定位正确的 View，将\r\n“ViewModel” 替换为其名称中的 “View”。在 ViewManager\r\n中有更详细的解释。\r\n这允许其他 viewmodel 创建 viewmodel。它允许 viewmodel 了解和拥有其他\r\nviewmodel。这允许您正确地组合您的视图模型。\r\n这个技巧还有另外一个部分，可以用例子来解释:\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nC#\r\nVB.NET\r\n\r\n\r\n\r\n\r\npublic class ShellViewModel { public TopBarViewModel TopBar\r\n{ get; private set; } // Stuff to instantiate and assign\r\nTopBarViewModel }\r\nPublic Class ShellViewModel Public Property TopBar as\r\nTopBarViewModel ' Stuff to instantiate and assign\r\nTopBarViewModel End Class\r\n\r\n\r\n\r\n&lt;Window x:Class=&quot;MyNamespace.ShellView&quot;        xmlns:s=&quot;https://github.com/canton7/Stylet&quot; .....&gt;   &lt;StackPanel&gt;      &lt;ContentControl s:View.Model=&quot;&#123;Binding TopBar&#125;&quot;/&gt;      &lt;!-- ... --&gt;   &lt;/StackPanel&gt;&lt;/Window&gt;\r\nView.Model 关联的属性将获取它绑定到的 ViewModel(在本例中是\r\nTopBarViewModel 的一个实例)，并定位正确的 View\r\n(TopBarView)。它将实例化一个实例，并将其设置为 ContentControl\r\n的内容。\r\n这样的结果是 TopBarView 可以从它的 TopBarViewModel\r\n中获得当前页面的名称，而 TopBarViewModel 可以通过 ShellViewModel\r\n得知这一点。问题解决了!\r\nContentControl 的技巧也适用于导航:\r\n&lt;Window x:Class=&quot;MyNamespace.ShellView&quot;        xmlns:s=&quot;https://github.com/canton7/Stylet&quot; .....&gt;   &lt;StackPanel&gt;      &lt;ContentControl s:View.Model=&quot;&#123;Binding TopBar&#125;&quot;/&gt;      &lt;ContentControl s:View.Model=&quot;&#123;Binding CurrentPage&#125;&quot;/&gt;   &lt;/StackPanel&gt;&lt;/Window&gt;\r\n通过实例化该页面的 ViewModel 的新实例，并将其分配给属性 CurrentPage,\r\nShellViewModel 将导航到一个新的页面。请注意，ShellViewModel\r\n不再需要知道关于视图的任何信息。它不必实例化一个视图。这是一个非常重要、有用和强大的点。\r\n对话框和窗口的处理方式与 WindowManager\r\n非常相似。它接受一个给定的ViewModel实例，并将其视图显示为一个对话框或窗口。\r\n删除后台代码！（Delete the\r\nCode-Behind! ）\r\n有了这种方法，您实际上不需要在代码背后做任何事情。您当然可以这样做，但是很少有\r\n响应(用于处理事件)、转换器、附加属性和(最重要的)附加行为\r\n不能解决的问题。\r\nStylet 允许您完全删除代码(它将为您调用\r\nInitializeComponent)，强烈建议您这样做。删除后台代码!\r\n\r\n注意:如果您使用的是VB。有时，如果您删除了后面的代码，则 XAML\r\n名称空间将停止工作。如果是这种情况，只需用匹配的文件名重新创建，给它正确的名称空间和类名，然后将其余部分留空。例如，MyView.xaml.vb:\r\nNamespace Views    Public Class MyView    End ClassEnd Namespace\r\n\r\n","categories":["Develop","DotNET","Stylet 框架"],"tags":["MVVM","WPF"]},{"title":"WPF MVVM Stylet使用文档（中文）08-The EventAggregator","url":"/posts/2020/155MT1J.html","content":"简介\r\n事件聚合器——EventAggregator——是一个分散的、弱绑定的、基于发布/订阅的事件管理器。\r\n\r\n发布者和订阅者（Publishers\r\nand Subscribers）\r\n订阅者（Subscribers）\r\n对特定事件感兴趣的订阅者可以将自己的兴趣告诉\r\nIEventAggregator，并且每当发布者将特定事件发布到IEventAggregator\r\n时，都会收到通知。\r\n事件是类——可以用它们做任何你想做的事情。例如:\r\n\r\n\r\n\r\nC#\r\n\r\n\r\nVB.NET\r\n\r\n\r\n\r\n\r\nclass MyEvent { \r\n&nbsp;\r\n  // Do something \r\n&nbsp;\r\n}\r\n\r\n\r\n\r\nClass MyEvent\r\n&nbsp;\r\n  &#39; Do Something\r\n&nbsp;\r\nEnd Class\r\n\r\n\r\n\r\n订阅者必须实现 IHandle&lt;T&gt;，其中 T\r\n是他们感兴趣的事件类型 (当然，他们可以实现多个\r\nIHandle&lt;T&gt; 's for多个 T\r\n's)。然后他们必须获得 IEventAggregator 的实例，并订阅自己，例如:\r\n\r\n\r\n\r\nC#\r\n\r\n\r\nVB.NET\r\n\r\n\r\n\r\n\r\nclass Subscriber : IHandle&lt;MyEvent&gt;, IHandle&lt;MyOtherEvent&gt;\r\n{\r\n   public Subscriber(IEventAggregator eventAggregator)\r\n   {\r\n      eventAggregator.Subscribe(this);\r\n   }\r\n&nbsp;\r\n   public void Handle(MyEvent message)\r\n   {\r\n      // ...\r\n   }\r\n&nbsp;\r\n   public void Handle(MyOtherEvent message)\r\n   {\r\n      // ...\r\n   }\r\n}\r\n\r\n\r\n\r\nClass Subscriber : Implements IHandle(Of MyEvent)\r\n&nbsp;\r\n  Public Sub New(ByRef eventAggregator as IEventAggregator)\r\n  eventAggregator.Subscribe(Me)\r\n  End Sub\r\n&nbsp;\r\n  Public Sub Handle(message as MyEvent) Implements IHandle(Of MyEvent).Handle\r\n  &#39; ...\r\n  End Sub\r\n&nbsp;\r\n  Public Sub Handle(message as MyOtherEvent) Implements IHandle(Of MyOtherEvent).Handle\r\n  &#39; ...\r\n  End Sub\r\n&nbsp;\r\nEnd Class\r\n\r\n\r\n\r\nVB.NET 用户，通过引用传递 eventAggregator 的 Sub New()\r\n在跨命名空间时可能会失败，而且必须定义每个新订阅者，这可能会令人恼火。因此，在全局模块中定义eventAggregator，然后直接订阅它，而不是将其引用传递给调用的每个新\r\nViewModel，可能更容易。\r\nModule Global  Public eventAggregator as IEventAggregatorEnd ModuleClass Subscriber : Implements IHandle(Of MyEvent)  Public Sub New()  Global.eventAggregator.Subscribe(Me)  End Sub    &#x27;Public Sub Handle...End Class\r\n确保将 module\r\n的名称空间保留为空，以便可以在整个程序中使用它。\r\n发布者（Publishers）\r\n发布者也必须获得 IEventAggregator\r\n的实例，但他们不需要订阅自己—只需在每次发布想要发布的事件时调用\r\nIEventAggregator.Publish ，例如:\r\n\r\n\r\n\r\nC#\r\n\r\n\r\nVB.NET\r\n\r\n\r\n\r\n\r\nclass Publisher\r\n{\r\n   private IEventAggregator eventAggregator;\r\n   public Publisher(IEventAggregator eventAggregator)\r\n   {\r\n      this.eventAggregator = eventAggregator;\r\n   }\r\n&nbsp;\r\n   public void PublishEvent()\r\n   {\r\n      this.eventAggregator.Publish(new MyEvent());\r\n   }\r\n}\r\n\r\n\r\n\r\nClass Publisher \r\n&nbsp;\r\n  Dim eventAggregator as IEventAggregator\r\n&nbsp;\r\n  Public Sub New(ByRef eventAggregator as IEventAggregator)\r\n    Me.eventAggregator = eventAggregator\r\n  End Sub\r\n&nbsp;\r\n  Public Sub PublishEvent()\r\n  Me.eventAggregator.Publish(New MyEvent())\r\n  End Sub\r\n&nbsp;\r\nEnd Class\r\n\r\n\r\n\r\n再次,VB.NET用户，如果您已经设置了全局模块，那么您不需要将\r\neventAggregator 传递给发布者。你可以直接发布到全局事件聚合器:\r\nClass Publisher  Public Sub PublishEvent()  Global.eventAggregator.Publish(New MyEvent())  End Sub  End Class\r\n取消订阅和弱绑定（UnSubscribing\r\nadn weak binding）\r\n因为 IEventAggregator 是弱绑定的，订阅者不需要取消订阅—\r\nIEventAggregator\r\n不会保留它们。但是，如果订阅者想要取消订阅，也可以取消订阅。如下：\r\n\r\n\r\n\r\nC#\r\n\r\n\r\nVB.NET\r\n\r\n\r\n\r\n\r\nIEventAggregator.Unsubscribe(this);\r\n\r\n\r\n\r\nIEventAggregator.UnSubscribe(Me)\r\n\r\n\r\n\r\n同步和异步发布（Publishing\r\nsynchronously and asynchronously）\r\n默认的 IEventAggregator.Publish\r\n方法是同步发布事件。您还可以调用 PublishOnUIThread\r\n来异步地调度UI 线程，或者调用\r\nPublishWithDispatcher，并传递您希望充当 dispatcher\r\n的任何操作(如果在IEventAggregator上编写自己的方法，这将非常有用)。\r\n频道（Channels）\r\n订阅者可以侦听特定的频道，发布者可以将事件发布到特定的频道。如果将事件发布到特定的频道，则只有已订阅该频道的订阅者才能接收该事件。如果在几个不同的上下文中使用相同的消息类型，那么这将非常有用。\r\n频道是字符串，因此允许一个频道的订阅者和该频道的发布者之间的松散耦合。\r\n默认情况下，Subscribe() 将订阅方订阅到默认频道\r\nEventAggregator.DefaultChannel。类似地，\r\nPublish() (及其所有变体)\r\n将把事件发布到相同的默认频道。然而，你也可以指定自己的频道。\r\n订阅到频道（Subscribing to\r\nchannels）\r\n若要订阅特定频道，请将其作为参数传递给 subscribe”:\r\neventAggregator.Subscribe(this,“ChannelA”)。你也可以订阅多个频道:\r\neventAggregator.Subscribe(this,“ChannelA”,“ChannelB”)。\r\n在这两种情况下，你都不会订阅到\r\nEventAggregator.DefaultChannel\r\n-只订阅到指定的频道。你也只会收到被推送至“ChannelA”或“ChannelB”的事件。\r\n发布到频道（Publishing to\r\nchannels）\r\n若要发布到特定通道，请将其作为参数传递给publish:\r\neventAggregator.Publish(message，“ChannelA”) 或\r\neventAggregator.PublishOnUIThread(message，“ChannelA”，“ChannelB”)，等等。与上面的订阅一样，事件将发布到所有指定的通道，而不再是默认通道。\r\n从频道取消订阅（Unsubscribing\r\nfrom channels）\r\n要取消频道订阅，请将其传递给 Unsubscribe:\r\neventAggregator.Unsubscribe(this, \"ChannelA\")。您将继续订阅您以前订阅的且没有取消订阅的任何其他频道。\r\n调用 eventAggregator.Unsubscribe(this) 将从所有\r\n频道取消订阅。\r\n使用自己的 IoC\r\n容器（Using your own IoC container）\r\n如果你在 StyletIoC 中使用默认的\r\nBootstrapper&lt;TRootViewModel&gt;，你不需要担心这个——EventAggregator\r\n在默认情况下是正确设置的。\r\n如果你使用另一个 IoC 容器,那么,你需要确保 EventAggregator 注册为\r\nIEventAggregator 的独立服务， EventAggregator\r\n只能有一个实例,每次请求的时候，都必须返回这个实例。\r\n","categories":["Develop","DotNET","Stylet 框架"],"tags":["MVVM","WPF"]},{"title":"WPF MVVM Stylet使用文档（中文）06-The WindowManager","url":"/posts/2020/2RDEGH9.html","content":"在传统的 \"视图优先\"\r\n的方式中，如果您想要显示一个新窗口或对话框，您需要创建一个视图的新实例，然后调用\r\n. show() 或 .showdialog()。\r\n\r\n在 ViewModel-first\r\n方式中，您不能直接与视图交互，所以您不能这样做。WindowManager\r\n解决了这个问题——调用\r\nIWindowManager.ShowWindow(someViewModel) 将获取那个\r\nViewModel，找到它的视图，实例化它，将它绑定到那个ViewModel，并显示它。\r\n\r\n\r\n\r\nC#\r\n\r\n\r\nVB.NET\r\n\r\n\r\n\r\n\r\nclass SomeViewModel\r\n{\r\n   private IWindowManager windowManager;\r\n   public SomeViewModel(IWindowManager windowManager)\r\n   {\r\n      this.windowManager = windowManager;\r\n   }\r\n&nbsp;\r\n   public void ShowAWindow()\r\n   {\r\n      var viewModel = new OtherViewModel();\r\n      this.windowManager.ShowWindow(viewModel);\r\n   }\r\n&nbsp;\r\n   public void ShowADialog()\r\n   {\r\n      var viewModel = new OtherViewModel();\r\n      bool? result = this.windowManager.ShowDialog(viewModel);\r\n      // result holds the return value of Window.ShowDialog()\r\n      if (result.GetValueOrDefault(true))\r\n      {\r\n         // DialogResult was set to true\r\n      }\r\n   }\r\n}\r\n\r\n\r\n\r\nClass SomeViewModel\r\n&nbsp;\r\n    Private windowManager As IWindowManager\r\n&nbsp;\r\n    Public Sub New(ByVal windowManager As IWindowManager)\r\n        Me.windowManager = windowManager\r\n    End Sub\r\n&nbsp;\r\n    Public Sub ShowAWindow()\r\n        Dim viewModel = New OtherViewModel()\r\n        Me.windowManager.ShowWindow(viewModel)\r\n    End Sub\r\n&nbsp;\r\n    Public Sub ShowADialog()\r\n        Dim viewModel = New OtherViewModel()\r\n        Dim result As Boolean? = Me.windowManager.ShowDialog(viewModel)\r\n        &#39; Result holds the return value of Window.ShowDialog()\r\n        If result.GetValueOrDefault(True) Then\r\n        &#39; DialogResult was set to true\r\n        End If\r\n    End Sub\r\nEnd Class\r\n\r\n\r\n\r\n很简单! 此外，IWindowManager 的引入(而不是直接在 ViewModel\r\n上调用方法)使测试变得更加容易。\r\n要从视图模型中关闭窗口或对话框，请使用\r\nScreen.RequestClose, 像这样:\r\n\r\n\r\n\r\nC#\r\n\r\n\r\nVB.NET\r\n\r\n\r\n\r\n\r\nclass ViewModelDisplayedAsWindow\r\n{\r\n   // Called by pressing the &#39;close&#39; button\r\n   public void Close()\r\n   {\r\n      this.RequestClose();\r\n   }\r\n}\r\n&nbsp;\r\nclass ViewModelDisplayedAsDialog\r\n{\r\n   // Called by pressing the &#39;OK&#39; button\r\n   public void CloseWithSuccess()\r\n   {\r\n      this.RequestClose(true);\r\n   }\r\n}\r\n\r\n\r\n\r\nClass ViewModelDisplayedAsWindow\r\n&nbsp;\r\n    &#39; Called by pressing the  &#39;close&#39; button\r\n    Public Sub Close()\r\n        Me.RequestClose()\r\n    End Sub\r\n&nbsp;\r\n  End Class\r\n&nbsp;\r\nClass ViewModelDisplayedAsDialog\r\n&nbsp;\r\n    &#39; Called by pressing the &#39;OK&#39; button\r\n    Public Sub CloseWithSuccess()\r\n        Me.RequestClose(True)\r\n    End Sub\r\nEnd Class\r\n\r\n\r\n\r\n","categories":["Develop","DotNET","Stylet 框架"],"tags":["MVVM","WPF"]},{"title":"WPF MVVM Stylet使用文档（中文） 07- MessageBox","url":"/posts/2020/1005Z29.html","content":"简介\r\n我们都知道，WPF有自己的消息框实现——“System.Windows.MessageBox”。这很好，除了你不能从你的\r\nViewModel中调用它(好吧，你可以，但它使你的 ViewModel\r\n不可测试)。网上常见的解决办法是“实现你自己的消息框”。\r\n好吧，Stylet 自带了自己的 MessageBox 克隆，它的外观和行为几乎与 WPF\r\n的一样(包括外观、按钮、图标、自动调整大小、声音、对齐等)。\r\n\r\n使用方法（Usage）\r\n从 IWindowManager 调用 ShowMessageBox 即可，像这样：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nC#\r\nVB.NET\r\n\r\n\r\n\r\n\r\npublic MyViewModel{ private readonly IWindowManager\r\nwindowManager; public MyViewModel(IWindowManager\r\nwindowManager) { this.windowManager = windowManager;\r\n} public void ShowMessagebox() { var result =\r\nthis.windowManager.ShowMessageBox(\"Hello\"); }\r\nPublic Class MyViewModel Private ReadOnly windowManager As\r\nIWindowManager  Public Sub New(ByVal windowManager As\r\nIWindowManager) Me.windowManager = windowManager End Sub\r\n Public Sub ShowMessagebox() Dim result =\r\nMe.windowManager.ShowMessageBox(\"Hello\") End SubEnd\r\nClass\r\n\r\n\r\n\r\nMessageBox接受与WPF消息框相同的所有选项，还有增加了一些其它选项。\r\n定制消息框（Customising\r\nthe MessageBox)\r\nStylet 的 MessageBox 实现为一个\r\nViewModel，MessageBoxViewModel，以及它相应的视图\r\nMessageBoxView。ViewModel 实现了一个接口\r\nIMessageBoxViewModel，而 ShowMessageBox()\r\n方法使用这个接口来检索 ViewModel 的实例。\r\n因此，您可以通过编写一个实现 IMessageBoxViewModel 的\r\nViewModel，并将其注册到 IoC 容器中，从而提供自己的\r\nMessageBoxViewModel 和 MessageBoxView\r\n的自定义实现。然后 ShowMessageBox()将使用它。\r\n如果你只是想调整现有的 MessageBoxViewModel\r\n的行为，你可以有以下选择:\r\n定制按钮文本（Custom Button\r\nText）\r\n通过修改\r\nMessageBoxViewModel.ButtonLabels，您可以在每个应用程序的基础上编辑任何按钮的按钮文本。它是一个字典，保存每个按钮要显示的文本。如果你只是想编辑文本的一个特定的消息框，ShowMessageBox\r\n将接受一个字典，你可以这样做：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nC#\r\nVB.NET\r\n\r\n\r\n\r\n\r\nMessageBoxViewModel.ButtonLabels[MessageBoxResult.No] = \"No,\r\nthanks\"; this.windowManager.ShowMessageBox(\"Do you want\r\nbreakfast?\",  buttons: MessageBoxButton.YesNo,  buttonLabels:\r\nnew Dictionary&lt;MessageBoxResult, string&gt;() { {\r\nMessageBoxResult.Yes, \"Yes please!\" }, }); // Will\r\ndisplay a MessageBox with the buttons \"Yes please!\" and \"No,\r\nthanks\"\r\nMessageBoxViewModel.ButtonLabels(MessageBoxResult.No) = \"No,\r\nthanks\"Me.windowManager.ShowMessageBox(\"Do you want\r\nbreakfast?\", buttons:=MessageBoxButton.YesNo,\r\nbuttonLabels:=New Dictionary(Of MessageBoxResult, String)() _ From\r\n&#123;&#123;MessageBoxResult.Yes, \"Yes please!\"&#125;&#125;) ' Will display a MessageBox\r\nwith the buttons \"Yes Please!\" and \"No, thanks\"\r\n\r\n\r\n\r\n定制按钮显示枚举值（Custom\r\nButton Set）\r\nMessageBoxViewModel.ButtonToResults 字典为每个\r\nMessageBoxButton 指定显示哪些按钮的枚举值。想要同时显示\r\n“OK“，“Yes” 和 “No” 按钮吗? 修改这个字典就可以了。\r\n定制图标（Custom Icons）\r\nMessageBoxViewModel.IconMapping 字典指定不同的\r\nMessageBoxImage\r\n的值显示对应的图标。这个字典必须包含MessageBoxImage\r\n所有可能的 Key 值 (注意不同的 Key 值在这里允许有相同的 Value\r\n值)，一个值也可以是null，在这种情况下不会显示任何图标。\r\n定制音效（Custom Sounds）\r\nMessageBoxViewModel.SoundMapping 是一个字典，它为每个\r\nMessageBoxImage 指定应该播放哪个声音。与\r\nIconMapping 一样，MessageBoxImage\r\n的每个值都必须有一个键值对，null也是一个有效值(在这种情况下不播放声音)。\r\n定制文本流向和文本对齐方式（Custom\r\nFlowDirection and TextAlignment）\r\nIWindowManager.ShowMessageBox() 的参数允许您指定\r\nFlowDirection 和 TextAlignment 。\r\n如果不指定这些参数，则使用默认的\r\nMessageBoxViewModel.FlowDirection 和\r\nMessageBoxViewModel.TextAlignment 使用。\r\n如果愿意，您也可以更改这些默认值。\r\n","categories":["Develop","DotNET","Stylet 框架"],"tags":["WPF,MVVM"]},{"title":"WPF MVVM Stylet使用文档（中文）09-PropertyChangedBase","url":"/posts/2020/DGFHG1.html","content":"简介\r\nPropertyChangedBase 是实现 INotifyPropertyChanged\r\n类型的基类，它提供了触发 PropertyChanged 通知的方法。\r\n\r\n触发通知（Raising\r\nNotifications）\r\n有许多方法可以触发 PropertyChanged 通知，具体取决于您想要做什么。\r\n最常见的情况是，每次将值分配给一个属性时，它都会引发一个通知。PropertyChangedBase\r\n提供了一个很好的实用程序方法来帮助:\r\nSetAndNotify，它的参数需为要分配值的字段的引用和分配给该字段的值。如果字段的值不等于原来的值，则会赋值，并引发\r\nPropertyChanged 通知。如下：\r\nclass MyClass : PropertyChangedBase&#123;   private string _name;   public string Name   &#123;      get &#123; return this._name; &#125;      set &#123; SetAndNotify(ref this._name, value); &#125;   &#125;\r\n如果您想为当前属性以外的属性发出 PropertyChanged\r\n通知，也有几种方法可以实现(取决于您是使用c# 6还是更低)。\r\n首选的 C# 6方法是使用\r\nnameof()，因为它开销特别小，并且提供了编译时安全性。\r\n如果您使用的是 C# 5或更低的版本，您可以使用表达式:\r\n这比较慢，但是也提供了编译时的安全性。\r\n如果你真的想要，你也可以使用原始字符串。\r\n见下文:\r\nclass MyClass : PropertyChangedBase&#123;   public string Name &#123; get; private set; &#125;   public void RaiseNameChangedExpression()   &#123;      // Preferred if you&#x27;re using C# 6, as it provides compile-time safety      this.NotifyOfPropertyChange(nameof(this.Name));      // Preferred for C# 5 and below, as it provides compile-time safety      this.NotifyOfPropertyChange(() =&gt; this.Name);      // Not preferred, but is very occasionally necessary      this.NotifyOfPropertyChange(&quot;Name&quot;);   &#125;&#125;\r\n调试事件（Dispatching Events）\r\n默认情况下，PropertyChanged 事件在当前线程上引发\r\n(WPF负责将它们分派到UI线程)。但是，如果您确实想改变这一点，您可以!\r\nPropertyChangedBase 有一个名为 PropertyChangedDispatcher\r\n的属性，它有一个 Action&lt;Action&gt;\r\n并且默认执行。DefaultPropertyChangedDispatcher(您可以分配它)(它的值为\r\na =&gt; a())。\r\n如果希望将其更改为在UI线程上执行，可以执行以下操作。\r\n改变 PropertyChangedBase 的所有实例:\r\nclass Bootstrapper : Bootstrapper&lt;MyRootViewModel&gt;&#123;   public override void Configure()   &#123;      base.Configure();      Execute.DefaultPropertyChangedDispatcher = Execute.OnUIThread;   &#125;&#125;\r\n改变 PropertyChangedBase 的一个实例:\r\nclass MyClass : PropertyChangedBase&#123;   public MyClass()   &#123;      this.PropertyChangedDispatcher = Execute.OnUIThread;   &#125;&#125;\r\n使用\r\nPropertyChanged.Fody (Use with PropertyChanged.Fody)\r\nPropertyChanged.Fody\r\n是一个非常棒的包，它在编译时注入代码，为您的属性自动触发 PropertyChanged\r\n通知，允许您编写非常简洁的代码。它还会找出你的属性之间的依赖关系，并提出适当的通知，例如:\r\nclass MyClass : PropertyChangedBase&#123;   public string FirstName &#123; get; private set; &#125;   public string LastName &#123; get; private set; &#125;   public string FullName &#123; get &#123; return String.Format(&quot;&#123;0&#125; &#123;1&#125;&quot;, this.FirstName, this.LastName); &#125; &#125;   public void SomeMethod()   &#123;      // PropertyChanged notifications are automatically raised for both FirstName and FullName      this.FirstName = &quot;Fred&quot;;   &#125;\r\nPropertyChangedBase 还负责与 Fody.PropertyChanged\r\n集成。Fody.PropertyChanged 发出的通知使用\r\nPropertyChangedDispatcher 触发。\r\n因此，在任何Screen、ValidatingModelBase或者\r\nPropertyChangedBase\r\n的子类中，你不需要做任何特殊的事情来使用\r\nFody.PropertyChanged 。\r\n名词解释\r\n\r\n属性依赖：一个属性需要依靠其它属性的值才能得出结果。\r\n\r\n","categories":["Develop","DotNET","Stylet 框架"],"tags":["MVVM","WPF"]},{"title":"WPF MVVM Stylet使用文档（中文）10-Execute：Dispatching to the UI thread","url":"/posts/2020/3R00ZSM.html","content":"简介（Summary）\r\nExecute\r\n是一个小的静态帮助类，它使得在UI线程上运行委托变得更容易。它包装了\r\nApplication.Current.Dispatcher，并提供使其更容易和更简洁使用的方法。\r\n它还提供了一个属性的帮助类：Execute.InDesignMode。当且仅当\r\nVisual Studio 或 Expression Blend\r\n设计器处于活动状态，并且代码为了设计时显示提供虚拟数据时。\r\n下表给出了它提供的方法的总结，后面给出了更深入的解释：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nMethod\r\nInline if possible\r\nWaits for Completion\r\n\r\n\r\n\r\n\r\nExecute.OnUIThread\r\n✔\r\n✘\r\n\r\n\r\nExecute.OnUIThreadSync\r\n✔\r\n✔ (Blocks)\r\n\r\n\r\nExecute.OnUIThreadAsync\r\n✔\r\n✔ (Task)\r\n\r\n\r\nExecute.PostToUIThread\r\n✘\r\n✘\r\n\r\n\r\nExecute.PostToUIThreadAsync\r\n✘\r\n✔ (Task)\r\n\r\n\r\n\r\nInline if possible:\r\n该方法将检查当前线程是否为UI线程。如果是，则委托将同步运行。如果不是，那么它将以某种形式被分派到UI线程。\r\nWaits for completion:\r\n要么阻塞直到委托完成执行，要么返回一个任务，该任务在委托完成执行时完成。\r\n\r\n详细（Details）\r\nExecute.OnUIThread\r\n检查当前线程是否为 UI\r\n线程。如果是，则委托将同步运行。如果不是，委托将被分派到UI线程，并在将来的某个时候运行。在这种情况下，Execute.OnUIThread\r\n将不会等待委托完成。\r\n这反映了传统的模式:\r\npublic static void InvokeIfRequired(Action action)&#123;    if (Application.Current.Dispatcher.CheckAccess())        action();    else        Application.Current.Dispatcher.BeginInvoke(action);&#125;\r\nExecute.OnUIThreadSync\r\n检查当前线程是否为 UI\r\n线程。如果是，那么它将同步运行委托。如果不是，那么它将分派委托在UI线程上运行，并且阻塞，直到它完成执行。\r\n因此，它与 Execute.OnUIThread\r\n非常相似。除了它会在委托完成执行后才返回。\r\nExecute.OnUIThreadAsync\r\n检查当前线程是否为 UI\r\n线程。如果是，那么它将同步运行委托，并返回一个已完成的任务。如果不是，那么它将分派委托在将来的某个时候在\r\nUI 线程上运行，并返回一个任务，该任务将在委托完成执行后完成。\r\n因此，它实际上是 Execute.OnUIThreadSync 的异步版本。\r\nExecute.PostToUIThread\r\n无论当前线程是否为 UI 线程，都将在将来的某个时候在 UI\r\n线程上发布要运行的委托。\r\nExecute.PostToUIThreadAsync\r\n无论当前线程是否为 UI 线程，都将在将来的某个时候在 UI\r\n线程上发布要运行的委托，并返回一个任务，该任务将在委托执行完成时完成。\r\nBEWARE 你绝对不能做\r\nExecute.PostToUIThreadAsync(() =&gt; something(foo)).Wait()\r\n这样的事情。如果从UI线程执行此操作，将导致死锁。这种方法对\r\nExecute.PostXXX\r\n没有意义，请使用Execute.OnUIThreadSync or\r\nExecute.OnUIThreadAsync 来代替。\r\n高级：单元测试（Advanced:\r\nUnit Testing）\r\n分配器（The Dispatcher）\r\nExecute 实际上有一个来自\r\nApplication.Current.Dispatcher 的抽象级别。\r\nExecute.Dispatcher 是类型 IDispatcher\r\n的静态属性，被 Execute 用于分派委托。\r\n该属性永远不能为空，默认为 IDispatcher\r\n的实现，它同步执行所有操作。然后在 BootstrapperBase\r\n中覆盖它，成为 Application.Current.Dispatcher\r\n的包装器。\r\n这种行为意味着使用 Execute\r\n方法的方法可以进行单元测试，或者在设计时使用。\r\n在单元测试中，所有的 Execute\r\n方法将同步运行它们的委托(因为调度程序不可用)。\r\n如果需要，你也可以设置 Execute.Dispatcher,\r\n为您的单元测试提供一个自定义的 IDispatcher 实现。\r\n设计模式（Design Mode）\r\nExecute.InDesignMode\r\n也是可设置的，这将覆盖“实际”值。\r\n预计您几乎永远都不需要这样做，但有时为了单元测试奇怪的小边缘情况(在Stylet中有一些这样的情况)，这种情况它是不可用的。\r\n","categories":["Develop","DotNET","Stylet 框架"],"tags":["MVVM","WPF"]},{"title":"C#中json的增删改查","url":"/posts/2021/32SP0MA.html","content":"json 是 C#\r\n中比较自由的数据存储格式，它的自由体现在可以不用声明很多类来规范数据格式就可以灵活地存取\r\njson 对象。现将常用的增删查改操作方式整理出来，以便开发，以飨读者。\r\n\r\nJson对象类图\r\nSystem.Object└── Newtonsoft.Json.Linq.JToken    ├── Newtonsoft.Json.Linq.JValue    ├── Newtonsoft.Json.Linq.JRaw    └── Newtonsoft.Json.Linq.JContainer        ├── Newtonsoft.Json.Linq.JObject        ├── Newtonsoft.Json.Linq.JArray        ├── Newtonsoft.Json.Linq.JConstructor        └── Newtonsoft.Json.Linq.JProperty\r\n转换\r\n\r\n从文本转 Json Object\r\nstring json = @&quot;&#123;  CPU: &#x27;Intel&#x27;,  Drives: [    &#x27;DVD read/writer&#x27;,    &#x27;500 gigabyte hard drive&#x27;  ]&#125;&quot;;JObject o = JObject.Parse(json);\r\n从文本转 Json Array\r\nstring json = @&quot;[  &#x27;Small&#x27;,  &#x27;Medium&#x27;,  &#x27;Large&#x27;]&quot;;JArray a = JArray.Parse(json);\r\n从文件转 Json Object\r\nusing (StreamReader reader = File.OpenText(@&quot;c:\\person.json&quot;))&#123;    JObject o = (JObject)JToken.ReadFrom(new JsonTextReader(reader));    // do stuff&#125;\r\n\r\n创建\r\n\r\n手动创建\r\nJArray array = new JArray();JValue text = new JValue(&quot;Manual text&quot;);JValue date = new JValue(new DateTime(2000, 5, 23));array.Add(text);array.Add(date);string json = array.ToString();// [//   &quot;Manual text&quot;,//   &quot;2000-05-23T00:00:00&quot;// ]\r\n通过 Linq 创建\r\nList&lt;Post&gt; posts = GetPosts();JObject rss =    new JObject(        new JProperty(&quot;channel&quot;,            new JObject(                new JProperty(&quot;title&quot;, &quot;James Newton-King&quot;),                new JProperty(&quot;link&quot;, &quot;http://james.newtonking.com&quot;),                new JProperty(&quot;description&quot;, &quot;James Newton-King&#x27;s blog.&quot;),                new JProperty(&quot;item&quot;,                    new JArray(                        from p in posts                        orderby p.Title                        select new JObject(                            new JProperty(&quot;title&quot;, p.Title),                            new JProperty(&quot;description&quot;, p.Description),                            new JProperty(&quot;link&quot;, p.Link),                            new JProperty(&quot;category&quot;,                                new JArray(                                    from c in p.Categories                                    select new JValue(c)))))))));Console.WriteLine(rss.ToString());//&#123;//  &quot;channel&quot;: &#123;//    &quot;title&quot;: &quot;James Newton-King&quot;,//    &quot;link&quot;: &quot;http://james.newtonking.com&quot;,//    &quot;description&quot;: &quot;James Newton-King\\&#x27;s blog.&quot;,//    &quot;item&quot;: [//      &#123;//        &quot;title&quot;: &quot;Json.NET 1.3 + New license + Now on CodePlex&quot;,//        &quot;description&quot;: &quot;Announcing the release of Json.NET 1.3, the MIT license and being available on CodePlex&quot;,//        &quot;link&quot;: &quot;http://james.newtonking.com/projects/json-net.aspx&quot;,//        &quot;category&quot;: [//          &quot;Json.NET&quot;,//          &quot;CodePlex&quot;//        ]//      &#125;,//      &#123;//        &quot;title&quot;: &quot;LINQ to JSON beta&quot;,//        &quot;description&quot;: &quot;Announcing LINQ to JSON&quot;,//        &quot;link&quot;: &quot;http://james.newtonking.com/projects/json-net.aspx&quot;,//        &quot;category&quot;: [//          &quot;Json.NET&quot;,//          &quot;LINQ&quot;//        ]//      &#125;//    ]//  &#125;//&#125;\r\n通过匿名对象创建\r\nJObject o = JObject.FromObject(new&#123;    channel = new    &#123;        title = &quot;James Newton-King&quot;,        link = &quot;http://james.newtonking.com&quot;,        description = &quot;James Newton-King&#x27;s blog.&quot;,        item =            from p in posts            orderby p.Title            select new            &#123;                title = p.Title,                description = p.Description,                link = p.Link,                category = p.Categories            &#125;    &#125;&#125;);\r\n\r\n修改\r\n\r\n赋值修改\r\nJObject jobj = new JObject();jobj[&quot;name&quot;] = &quot;value&quot;\r\n\r\n查询\r\n基本查询\r\n\r\n通过名称或者索引访问\r\nstring json = @&quot;&#123;  &#x27;channel&#x27;: &#123;    &#x27;title&#x27;: &#x27;James Newton-King&#x27;,    &#x27;link&#x27;: &#x27;http://james.newtonking.com&#x27;,    &#x27;description&#x27;: &#x27;James Newton-King\\&#x27;s blog.&#x27;,    &#x27;item&#x27;: [      &#123;        &#x27;title&#x27;: &#x27;Json.NET 1.3 + New license + Now on CodePlex&#x27;,        &#x27;description&#x27;: &#x27;Announcing the release of Json.NET 1.3, the MIT license and the source on CodePlex&#x27;,        &#x27;link&#x27;: &#x27;http://james.newtonking.com/projects/json-net.aspx&#x27;,        &#x27;categories&#x27;: [          &#x27;Json.NET&#x27;,          &#x27;CodePlex&#x27;        ]      &#125;,      &#123;        &#x27;title&#x27;: &#x27;LINQ to JSON beta&#x27;,        &#x27;description&#x27;: &#x27;Announcing LINQ to JSON&#x27;,        &#x27;link&#x27;: &#x27;http://james.newtonking.com/projects/json-net.aspx&#x27;,        &#x27;categories&#x27;: [          &#x27;Json.NET&#x27;,          &#x27;LINQ&#x27;        ]      &#125;    ]  &#125;&#125;&quot;;JObject rss = JObject.Parse(json);string rssTitle = (string)rss[&quot;channel&quot;][&quot;title&quot;];// James Newton-Kingstring itemTitle = (string)rss[&quot;channel&quot;][&quot;item&quot;][0][&quot;title&quot;];// Json.NET 1.3 + New license + Now on CodePlexJArray categories = (JArray)rss[&quot;channel&quot;][&quot;item&quot;][0][&quot;categories&quot;];// [&quot;Json.NET&quot;, &quot;CodePlex&quot;]IList&lt;string&gt; categoriesText = categories.Select(c =&gt; (string)c).ToList();// Json.NET// CodePlex\r\n通过 Linq 查询\r\nvar postTitles =    from p in rss[&quot;channel&quot;][&quot;item&quot;]    select (string)p[&quot;title&quot;];foreach (var item in postTitles)&#123;    Console.WriteLine(item);&#125;//LINQ to JSON beta//Json.NET 1.3 + New license + Now on CodePlexvar categories =    from c in rss[&quot;channel&quot;][&quot;item&quot;].SelectMany(i =&gt; i[&quot;categories&quot;]).Values&lt;string&gt;()    group c by c    into g    orderby g.Count() descending    select new &#123; Category = g.Key, Count = g.Count() &#125;;foreach (var c in categories)&#123;    Console.WriteLine(c.Category + &quot; - Count: &quot; + c.Count);&#125;//Json.NET - Count: 2//LINQ - Count: 1//CodePlex - Count: 1\r\n\r\n特殊查询\r\n\r\n查询 JObject 中所有字段的名称\r\nJProperty jp = inputObj.Properties();\r\n如何在多级查询中避免不存在而报错？\r\n假设有如下数据结构：\r\n&#123;  &quot;details&quot;: &#123;    &quot;threeds2.fingerprint&quot;: &quot;123&quot;  &#125;,  &quot;paymentData&quot;: &quot;456&quot;&#125;\r\n查询方式：\r\njobj.SelectToken(&quot;details.[&#x27;threeds2.fingerprint&#x27;]&quot;)).ValueOrDefault(string.Empty)\r\n\r\nSelectToken方法支持我们输入深度Key的访问路径来获取数据，父子级使用\".\"连接；如果遇到key含有特殊符号点的，使用中括号加单引号包裹。而且这种写法不会抛出异常，如果路径错误或不存在返回值为null。\r\n\r\nValueOrDefault 扩展：\r\npublic static T ValueOrDefault&lt;T&gt;(this IEnumerable&lt;JToken&gt; jt, T default_)&#123;  if (jt == null) return default_;  T value = jt.Value&lt;T&gt;();  if (value == null) return default_;  return value;&#125;\r\n\r\n","categories":["Develop","DotNET","NewtonJson"],"tags":["C#","json"]},{"title":"WPF MVVM Stylet使用文档（中文）13-Validation Use ValidatingModelBase","url":"/posts/2020/1HXBM8H.html","content":"简介（Introduction）\r\n想象这个场景……用户正在填写您精心编写的表单，他们在应该输入电子邮件地址的地方输入了自己的名字。您需要检测这个问题，并以清晰的方式显示问题。\r\n\r\n输入验证是一个很大的领域，有很多方法可以实现它。最简单和最吸引人的是在你的属性的\r\nsetter 中抛出一个异常，像这样:\r\nprivate string _name;public string Name&#123;   get &#123; return this._name; &#125;   set   &#123;      if (someConditionIsFalse)         throw new ValidationException(&quot;Message&quot;);      this._name = value;   &#125;\r\n当绑定设置此属性时，它会通知是否抛出异常，并相应地更新控件的验证状态。\r\n然而，这最终会变成一个彻底的坏主意。这意味着您的属性只有在设置时才能被验证(例如，当用户单击\r\n“Submit”\r\n时，您不能遍历并验证整个表单)，这会导致大量重复逻辑的属性设置器。好可怕。\r\nc#还定义了两个接口，WPF知道这两个接口: IDataErrorInfo和\r\nINotifyDataErrorInfo。这两种方法都为ViewModel\r\n提供了一种方法，通过事件和 PropertyChanged\r\n通知来告诉视图，输入中一个或多个属性有一个或多个验证错误。其中，INotifyDataErrorInfo\r\n更新、更容易使用，并且允许异步验证。\r\n但是，使用 INotifyDataErrorInfo 仍然有点不直观:\r\n它允许您广播一个或多个属性有错误的问题，但是没有为您提供运行验证的简单方法，并且要求您记录哪些错误与哪些属性相关联。\r\nValidatingModelBase\r\n的目标是解决这些问题，并提供一种直观、简单的方法来运行和报告验证。\r\nValidatingModelBase\r\nValidatingModelBase 派生自PropertyChangedBase，并由\r\nScreen 继承。它建立在 PropertyChangeBase\r\n的功能上，当属性发生变化时，它可以通知并报告验证。\r\nIModelValidator\r\n有许多方法可以运行验证，有许多好的库可以帮助您。Stylet\r\n并不打算提供另一个验证库，因此 Stylet 允许您提供自己的验证库，以便\r\nValidatingModelBase 使用。\r\n这体现在 ValidatingModelBase 的 validator\r\n属性中，它是一个 IModelValidator。这样做的目的是编写自己的\r\nIModelValidator\r\n实现，它封装了首选的验证库(稍后我将介绍一些如何实现的示例)，以便ValidatingModelBase\r\n可以使用它。\r\n这个接口有两个重要的方法:\r\nTask&lt;IEnumerable&lt;string&gt;&gt; ValidatePropertyAsync(string propertyName);Task&lt;Dictionary&lt;string, IEnumerable&lt;string&gt;&gt;&gt; ValidateAllPropertiesAsync();\r\n当需要通过名称验证单个属性时，ValidatingModelBase\r\n将调用第一个方法，并返回一个验证错误的数组。第二个是 ValidatingModelBase\r\n在您要求它执行完整验证时调用的，并返回一个'property name =&gt; array of validation errors。\r\n这些方法是异步的，这允许您利用 INotifyDataErrorInfo\r\n的异步验证功能，并可以在某些外部服务上运行验证。但是，这个接口的大多数实现都只返回一个完成的任务。\r\n还有第三个方法:\r\nvoid Initialize(object subject);\r\n当 ValidatingModelBase\r\n第一次设置它的验证时，它会调用这个函数，并传递它自己的一个实例。这使得\r\nIModelValidator 的实现可以专门用于验证 ValidatingModelBase\r\n的特定实例。当我们将东西绑定到 StyletIoC中时，这更有意义。\r\n还有这个接口的一个通用版本\r\nIModelValidator&lt;T&gt;，它只是扩展了\r\nIModelValidator，没有添加任何额外的内容。当 IoC\r\n容器进入画面时，这也是很有用的—稍后会详细介绍。\r\n运行验证（Running\r\nValidations）\r\n首先，您必须记住将 IModelValidator 实现传递给\r\nValidatingModelBase。你可以通过设置 validator\r\n属性，或者调用一个合适的构造函数来实现:\r\npublic class MyViewModel : ValidatingModelBase&#123;   public MyViewModel(IModelValidator validator) : base(validator)   &#123;   &#125;&#125;\r\n默认情况下，每当一个属性发生变化时，ValidatingModelBase\r\n都会运行该属性的验证(前提是您调用 SetAndNotify。使用\r\nNotifyOfPropertyChange 或使用\r\nPropertyChanged.Fody 来触发 PropertyChangedBase\r\n中定义的机制来引发PropertyChanged通知）。然后，它将使用\r\nINotifyDataErrorInfo\r\n接口中定义的机制报告该属性的验证状态的任何更改。它还将更改\r\nHasErrors属性的值。\r\n如果您想要禁用这种自动验证行为，请将 AutoValidate\r\n属性设置为 false 。\r\n如果需要，可以通过调用 ValidateProperty(\"PropertyName\"),\r\n或 ValidateProperty(() =&gt; this.PropertyName)\r\n来手动运行单个属性的验证。如果您的验证是异步的，那么还有异步的版本—稍后将详细介绍。如果你想验证一个属性，无论何时设置，你可以这样做:\r\nprivate string _namepublic string Name&#123;   get &#123; return this._name; &#125;   set   &#123;      SetAndNotify(ref this._name, value);      ValidateProperty();   &#125;&#125;\r\n另外，可以通过调用 Validate() 对所有属性运行验证。\r\n如果您希望在验证状态发生变化(任何属性的验证错误发生变化)时运行一些自定义代码，请覆盖\r\nOnValidationStateChanged()。\r\n理解和使用 IModelValidator\r\n在接下来的几节中，我将带您通过使用一个非常有用的 FluentValidation\r\n库实现验证的示例。\r\nFluentValidation 是通过创建一个新类来工作的，它实现了\r\nIValidator&lt;T&gt; (通常通过扩展\r\nAbstractValidator&lt;T&gt; 来实现，它可以验证特定类型的模型\r\nT)。您需要创建一个新的实例，并使用它来运行验证。例如，如果你有一个\r\nUserViewModel，你将定义一个\r\nUserViewModelValidator，它扩展了\r\nAbstractValidator&lt;UserViewModel&gt;，因此实现了\r\nIValidator&lt;UserViewModel&gt;，就像这样:\r\npublic class UserViewModel : Screen&#123;   private string _name;   public string Name   &#123;      get &#123; return this._name; &#125;      set &#123; SetAndNotify(ref this._name, value); &#125;   &#125;&#125;public class UserViewModelValidator : AbstractValidator&lt;UserViewModel&gt;&#123;   public UserViewModelValidator()   &#123;      RuleFor(x =&gt; x.Name).NotEmpty();   &#125;&#125;\r\n如果我们直接使用 UserViewModelValidator (没有\r\nValidatingModelBase 的帮助)，我们会做以下事情:\r\npublic UserViewModel(UserViewModelValidator validator)&#123;   this.Validator = validator;&#125;// ...this.Validator.Validate(this);\r\n但是，使用 ValidatingModelBase\r\n的意义在于它将自动运行和自动报告验证。如前所述，我们需要以ValidatingModelBase\r\n知道如何与之交互的方式包装我们的\r\nUserViewModelValidator。\r\n做到这一点的最简单的方法是编写一个适配器，它可以接受\r\nIValidator&lt;T&gt;\r\n的任何实现(即您编写的任何自定义验证器)，并以 ValidatingModelBase\r\n能够理解的方式公开它。如果它消失了，我可以再次运行它:\r\n\r\nValidatingModelBase.Validator 是一个 IModelValidator\r\nUserViewModelValidator是一个 IValidator\r\n我们将编写一个适配器，FluentValidationAdapter，这是一个\r\nIModelValidator\r\nFluentValidationAdapter 将接受一个\r\nIValidator，并封装它，以便可以通过 IModelValidator 访问它\r\n因此，FluentValidationAdapter 将接受一个\r\nUserViewModelValidator，并将其公开为IModelValidator;\r\n\r\n明白了吗?这可能听起来工作量很大，但是我们可以让 IoC\r\n容器完成大部分繁重的工作，我们很快就会看到这一点。\r\n现在，在实践中会是什么样子呢?首先，还记得我说过\r\nIModelValidator&lt;T&gt; 被定义为一个只实现\r\nIModelValidator\r\n的接口吗?我现在还不会告诉你为什么，但是请记住它们基本上是同义词。\r\n// Define the adapterpublic class FluentValidationAdapter&lt;T&gt; : IModelValidator&lt;T&gt;&#123;   public FluentValidationAdapter(IValidator&lt;T&gt; validator)   &#123;      // Store the validator   &#125;   // Implement all IModelValidator methods, using the stored validator&#125;// This implements IValidator&lt;UserViewModel&gt;public class UserViewModelValidator : AbtractValidator&lt;UserViewModel&gt;&#123;   public UserViewModelValidator()   &#123;      // Set up validation rules   &#125;&#125;public class UserViewModel&#123;   public UserViewModel(IModelValidator&lt;UserViewModel&gt; validator) : base(validator)   &#123;      // ...   &#125;&#125;\r\n看这里！如果我们要手动实例化一个新的\r\nUserViewModel，我们会这样做:\r\nvar validator = new UserViewModelValidator();var validatorAdapter = new FluentValidationAdapter&lt;UserViewModel&gt;(validator);var viewModel = new UserViewModel(validatorAdapter);\r\n但是，我们可以配置 IoC 容器来完成这一任务。这里假设您使用的是\r\nStyletIoC，尽管其他容器也可以进行类似的配置。\r\n在你的 bootstrapper 中 重写\r\nConfigureIoC，首先，每当你要求一个\r\nIModelValidator&lt;T&gt; 时，告诉 StyletIoC 返回一个\r\nFluentValidationAdapter&lt;T&gt; ，这样做:\r\nbuilder.Bind(typeof(IModelValidator&lt;&gt;)).To(typeof(FluentValidationAdapter&lt;&gt;));\r\n因此，无论何时 StyletIoC 都创建了一个新的\r\nUserViewModel，它都会意识到它需要一个\r\nIModelValidator&lt;UserViewModel&gt;。它知道已经被告知如何创建一个IModelValidator&lt;T&gt;——通过实例化一个新的\r\nFluentValidationAdapter&lt;T&gt;。因此，它将尝试创建一个新的\r\nFluentValidationAdapter&lt;UserViewModel&gt;，但是发现创建它需要一个新的\r\nIValidator&lt;UserViewModel&gt;,这会因为找不到而失败。\r\n因此，我们需要告诉 StyletIoC 如何创建一个新的\r\nIValidator&lt;UserViewModel&gt;。我们可以\r\n用这种比较长的方式，像这样：\r\n// The long waybuilder.Bind&lt;IValidator&lt;UserViewModel&gt;&gt;().To&lt;UserViewModelValidator&gt;();\r\n但是，如果有很多验证器，就需要很多行配置。最好告诉S tyletIoC\r\n发现所有的\r\nIValidator&lt;T&gt;实现，并绑定它们本身，通过这样做:\r\n// The short waybuilder.Bind(typeof(IValidator&lt;&gt;)).ToAllImplementations();\r\n漂亮! 当 StyletIoC 试图创建一个新的\r\nFluentValidationAdapter&lt;UserViewModel&gt;\r\n时，它将看到它需要一个\r\nIValidator&lt;UserViewModel&gt;，并将实例化一个新的UserViewModelValidator。\r\n现在您可以看到为什么我们在这里使用\r\nIModelValidator&lt;T&gt; 而不是\r\nIModelValidator。如果 UserViewModel\r\n需要一个IModelValidator，StyletIoC\r\n就不能计算出它应该创建一个\r\nFluentValidationAdapter&lt;UserViewModel&gt;，而不是一个\r\nFluentValidationAdapter&lt;LogInViewModel&gt;。通过向\r\nIModelValidator 添加类型信息，我们为 IoC\r\n容器提供了足够的信息。\r\n使用预制的\r\nIModelValidator（Using a pre-made IModelValidator）\r\n我写了以下 IModelValidator 实现，欢迎大家使用:\r\n\r\nFluentValidationAdapter\r\n\r\n如果你写了一个，你很乐意分享它，请让我知道，我会添加它。\r\n实现同步验证适配器（Implementing\r\nIModelValidator (Synchronously)）\r\n编写一个 IModelValidator\r\n实现在概念上很简单，但是有一些问题。与前面一样，本节将假设我们正在为FluentValidation\r\n库实现一个适配器，尽管您可以应用在这里学到的知识来为几乎所有的库编写一个适配器。\r\n现在，我们假设所有的验证都是同步的。对于返回 Task\r\n的方法，我们只返回一个已完成的 Task。一件容易的事。\r\n首先，我们将实现\r\nIModelValidator&lt;T&gt;，原因在前一节中讨论过。它还需要接受一个\r\nIValidator&lt;T&gt; 作为构造函数参数，就像这样:\r\npublic class FluentValidationAdapter : IModelValidator&lt;T&gt;&#123;   private readonly IValidator&lt;T&gt; validator;   public FluentValidationAdapter(IValidator&lt;T&gt; validator)   &#123;      this.validator = validator;   &#125;&#125;\r\n记住 ValidatingModelBase 需要一个\r\nIModelValidator，它专门用于验证特定的 ViewModel\r\n实例，因为它增加了更多的灵活性。这意味着\r\nValidationModelBase 可以调用\r\nValidateAllPropertiesAsync()，正确的 ViewModel\r\n实例将被验证。然而，这里我们有一个鸡生蛋还是蛋生鸡的情况—为了使适配器专门化，ViewModel\r\n必须存在。但是，只有在适配器被验证之后才能实例化 ViewModel，因为\r\nViewModel需 要适配器作为构造函数参数。\r\n解决方案是 Initialize(object subject)方法。它被\r\nValidatingModelBase\r\n调用，当它传递一个新的适配器时，它将把自己作为参数传递。然后适配器将存储这个实例，并在运行验证时使用它。是这样的:\r\npublic class FluentValidationAdapter : IModelValidator&lt;T&gt;&#123;   private readonly IValidator&lt;T&gt; validator;   private T subject;   public FluentValidationAdapter(IValidator&lt;T&gt; validator)   &#123;      this.validator = validator;   &#125;   public void Initialize(object subject)   &#123;      this.subject = (T)subject;   &#125;&#125;\r\n现在,实现\r\nValidatePropertyAsync。这应该验证单个属性，并返回验证错误列表，如果没有验证错误，则返回\r\nnull/emptyarray。使用 FluentValidation 执行同步验证，它可能是这样的:\r\npublic Task&lt;IEnumerable&lt;string&gt;&gt; ValidatePropertyAsync(string propertyName)&#123;   var errors = this.validator.Validate(this.subject, propertyName).Errors.Select(x =&gt; x.ErrorMessage);   return Task.FromResult(errors);&#125;\r\n类似地，ValidateAllPropertiesAsync\r\n方法验证所有属性，并返回{ propertyName =&gt; array of validation errors }的字典。如果属性没有任何验证错误，您可以从字典中完全删除它，或者将其值设置为\r\nnull/emptyarray。\r\npublic Task&lt;Dictionary&lt;string, IEnumerable&lt;string&gt;&gt;&gt; ValidateAllPropertiesAsync()&#123;   var errors = this.validator.Validate(this.subject).Errors.GroupBy(x =&gt; x.PropertyName).ToDictionary(x =&gt; x.Key, x =&gt; x.Select(failure =&gt; failure.ErrorMessage));   return Task.FromResult(errors);&#125;\r\n把这些都放在一起，您就有了适配器!\r\n实现异步验证适配器（Implementing\r\nIModelValidator (Asynchronously)）\r\n实现异步验证(对于支持异步验证的库来说比较复杂)。\r\n首先，请记住 ValidatingModelBase\r\n有一组同步方法(Validate、ValidateProperty)和异步方法(ValidateAsync、ValidatePropertyAsync)。在底层，同步版本调用异步版本，但是阻塞线程，直到异步操作完成\r\n(使用 Task.Wait())。\r\n现在，如果你经常使用任务，这应该会敲响警钟。你看，当你\r\nawait DoSomethingAsync(); DoSomethingElse(); 时，你会说\r\n“捕获当前线程 [*] ”。当 DoSomethingAsync()\r\n异步操作完成后，我想让你发布一条消息到那个捕获的线程，告诉它运行\r\nDoSomethingElse()。但是，如果该线程正在等待异步操作完成，那么它将永远不会接收到该消息，操作将永远不会完成，并且会出现死锁。\r\n[*]不完全正确——它捕获当前的\r\nSynchronizationContext。但是在UI线程上，这是相同的。\r\n换句话说，这意味着下面的代码，从 UI 线程运行，将死锁:\r\npublic async Task DoSomethingAsync()&#123;   await Task.Delay(100);&#125;// ... DoSomethingAsync().Wait();DoSomethingElse();\r\n当 Task . Delay(100) 任务完成时，它会向 UI\r\n线程返回一条消息，说 “好的，运行\r\nDoSomethingElse()”。但是，UI 线程被 Wait()\r\n卡住了，永远不会处理消息，你就陷入了僵局。\r\n为什么和这相关? 好。如果你写一个\r\nIModelValidator&lt;T&gt; 的方法，它看起来像这样:\r\npublic async Task&lt;IEnumerable&lt;string&gt;&gt; ValidatePropertyAsync(string propertyName)&#123;   var result = await this.Validator.ValidateAsync(this.subject, propertyName);   return result.Errors.Select(x =&gt; x.ErrorMessage);&#125;\r\n然后调用 ValidateProperty，\r\n你会死锁。\r\n窍门是告诉 await不要捕获当前线程，使用\r\nConfigureAwait(false)，即\r\npublic async Task&lt;IEnumerable&lt;string&gt;&gt; ValidatePropertyAsync(string propertyName)&#123;   var result = await this.Validator.ValidateAsync(this.subject, propertyName).ConfigureAwait(false);   return result.Errors.Select(x =&gt; x.ErrorMessage);&#125;\r\n现在，返回 result.Errors…\r\n行将运行在另一个线程(而不是发布到 UI 线程)，没有死锁发生。\r\n","categories":["Develop","DotNET","Stylet 框架"],"tags":["MVVM","WPF"]},{"title":"WPF MVVM Stylet使用文档（中文）11-Screens and Conductors","url":"/posts/2020/1H4GT7T.html","content":"Screen 和 Conductor\r\n是一个简单的主题，但它需要一些思维跳跃，并且要求您在它们变得有意义之前覆盖它们的所有部分。相信我，值得你花时间阅读这篇文章——它们非常强大，值得你花时间投资。\r\n\r\nViewModel\r\n生命周期（ViewModel Lifecycles）\r\n一个好的起点是查看 ViewModel 的生命周期。\r\n想象一个选项卡式界面——类似 Visual Studio，它有(非常简单地)一个 shell\r\n(包含菜单、工具栏等)和一个包含编辑器选项卡的选项卡控件。在 Stylet\r\n中，每个编辑器标签都由它自己的视图模型支持。\r\n现在，其中一个 Viewmodel\r\n将通过实例化开始它的生命周期。接下来，它将被显示。之后，根据当前处于活动状态的选项卡，可能会显示或隐藏它，最后关闭它。就在它关闭之前，它有机会阻止关闭来提示您保存文件。\r\n简而言之，这就是ViewModel的生命周期：它被创建，然后被激活(显示给用户)。在此之后，它可以被停用(仍然是活动的，但没有显示)，并再次激活任意次数，直到最后被关闭(在被询问是否准备关闭之后)。\r\nIDisposable\r\n值得注意的是，如果 ViewModel 实现了\r\nIDisposable，那么它将在父类关闭后被处理(除非父类的\r\nDisposeChildren属性为 false)。\r\nConductors\r\n介绍（Introduceing Conductors）\r\n现在，ViewModel\r\n并不能神奇地知道它何时被显示、隐藏或关闭。它必须被告知。这就是 Conductor\r\n的角色。\r\n简单地说，一个 Conductor 就是一个 ViewModel，它拥有另一个\r\nViewModel，并且知道如何管理它的生命周期。\r\n在我们的 Visual Studio 示例中，Conducotr 是拥有 TabControl 的\r\nViewModel，并显示一个 TabControl 的 ViewModel——代码编辑界面，因此\r\nConductor 可能是 Shell\r\nViewModel。每当用户选择一个新的编辑器选项卡时，Conductor\r\n将停用旧选项卡，并激活新选项卡。当用户关闭一个选项卡时，指挥将告诉该选项卡它已经关闭，然后决定下一个要显示的选项卡，并激活它。\r\n就是这样，真的。ViewModel 有一个生命周期，它是由拥有 ViewModel 的\r\nConductor 实现的。\r\n到目前为止，这是相当抽象的-让我们进入细节。\r\nIScreen and Screen\r\n正如我们在上面所看到的，一个 ViewModel 的生命周期是由一个在 ViewModel\r\n上调用方法的 Conductor\r\n来管理的。那些方法是在一组独立的接口中定义的——如果你实现了接口，并且那个\r\nViewModel 被管理为一个\r\nConductor，那个方法就会被调用。如果需要，您可以选择想要的接口。\r\n有一个名为 IScreen\r\n的总接口，它包含了所有这些功能，还有一个名为 Screen\r\n的默认实现。这表现得非常好，您可能永远都不需要实现自己的\r\nIScreen—但是如果您愿意，您可以这样做。\r\n\r\nIScreenState: 用于激活，停用，并关闭视图模型。有\r\nActivate、Deactivate 和\r\nClose方法，以及跟踪Screen 状态变化的事件和属性。\r\nIGuardClose: 用来询问 ViewModel 是否可以关闭。有一个\r\nCanCloseAsync 方法。\r\nIViewAware:\r\n有时视图模型需要知道它的视图(当它被附加时，它是什么，等等)。这个接口允许通过一个\r\nView 属性和一个 AttachView\r\n方法来实现。\r\nIHaveDisplayName: 有一个 DisplayName\r\n属性。这个名称用作窗口和使用 WindowManager\r\n显示的对话框的标题，对于选项卡控件之类的东西也很有用。\r\nIChild: 对于 ViewModel 来说，知道管理它的是什么\r\nConductor 是有利的(例如，请求关闭它)。如果ViewModel 实现了\r\nIChild，它将被告知这一点。\r\n\r\n请注意，无法保证调用 Activate、Deactivate 和 Close 的顺序——一个\r\nViewModel 可以连续激活两次，然后在不停用的情况下关闭。由 ViewModel\r\n来注意这些事情，并做出相应的反应。Stylet's Screen\r\n做这个。\r\nScreen 有一些虚方法，如果你需要，你可以重写它们：\r\n\r\nOnInitialActivate: 在第一次激活 Screen\r\n时调用，以后再也不会调用。可以设置不想在构造函数中设置的内容。\r\nOnActivate: 当 Screen 激活时调用。仅在 Screen\r\n尚未激活时调用。\r\nOnDeactivate: 当 Screen 被停用时调用。仅在 Screen\r\n尚未停用时调用。\r\nOnClose: 当 Screen 关闭时调用。只会被调用一次。仅在\r\nScreen 停用时调用。\r\nOnViewLoaded: 当视图的\r\nLoaded事件被触发时调用。\r\nCanCloseAsync: 当 Conductor 想知道 Screen\r\n是否可以关闭时，就会调用这个函数。默认情况下，retuns\r\nTask.FromResult(this.CanClose)，但是您可以在这里添加自己的异步逻辑。\r\nCanClose: 默认情况下由 CanCloseAsync\r\n调用。这只是为了方便。如果您想决定是否可以同步关闭，请覆盖\r\nCanClose。如果你想异步决定，覆盖\r\nCanCloseAsync。\r\nRequestClose(bool? dialogResult = null):\r\n当您想从您拥有的 Conductor\r\n请求一个关闭时，您可以调用它。如果你想显示关闭结果到对话框中，可以使用\r\nDialogResult。\r\n\r\nScreen 源自 PropertyChangedBase ，因此很容易引发 PropertyChanged\r\n通知。\r\n您可能会发现所有的 Viewmodel 都是 Screen\r\n的子类。这并不是说它们必须如此—您可以创建自己的\r\nIScreen实现，或者从上面选择您想要实现的接口—但是确实\r\nScreen 非常方便和强大。\r\nConductors 细节（Conductors\r\nin Detail）\r\nConductor 有各种各样的形式，每一种都有自己的使用案例。一个 Conductor\r\n可以拥有一个单一的视图模型(比如一次显示一个页面的导航)，或者多个视图模型。那些具有多个\r\nViewmodel 的视图一次可能只有一个(想想上面 Visual Studio 例子中的\r\nTabControl )，或者全部(想想带有许多独立元素的网格)激活。Conductor\r\n还可以添加一些行为，比如记录显示的是哪一个视图模型(对于导航很有用)。\r\n与 Screen 类一样，Stylet 定义了许多 Conductor\r\n感兴趣的接口和实现(取决于所需的 Conductor\r\n行为的种类)，当然您也可以实现自己的接口。\r\n主要接口是 IConductor&lt;T&gt;，它表示一个\r\nConductor，你将与它进行交互。它有以下方法\r\n\r\nActivateItem(T item):\r\n获取给定的项并激活它。是否使先前的项失效是由 Conductor 决定的。\r\nDeactivateItem(T item):\r\n获取给定的项，然后停用它。是否激活另一个项目是由 Conductor\r\n决定的。\r\nCloseItem(T item): 获取给定的项并关闭它。Conductor\r\n指定是否由另外的项激活并替换该关闭的项。\r\n\r\n拥有单个活动项的 Conductor (不管它们可能有多少个非活动项) 还实现了\r\nIHaveActiveItem&lt;T&gt;，它都有唯一属性ActiveItem。\r\n如果项目实现了 IChild，那么所有的内置 Conductor\r\n都将把项的 Parent 属性设置为自身。所有的内置 Conductor\r\n都额外实现了\r\nIChildDelegate，它允许子进程请求关闭它(通过调用\r\nCloseItem)。在默认的 Screen 实现中，调用\r\nScreen.RequestClose 将导致 Screen 在它的 \"父\" 上调用\r\nCloseItem (提供它的父实现\r\nIChildDelegate)，这反过来导致它的\r\n“父”(如果它存在)关闭它。\r\n内置 Conductor（Built-In\r\nConductors）\r\nStylet 带有一些内置的 Conductor，它们以多种直观的方式执行。\r\n所有这些 Conductor 都来自 Screen，允许 Conductor\r\n轻松地拥有其他 Conductor。这意味着你可以以任何你想要的方式组合你的\r\nConductor 和 Screen。\r\nConductor&lt;T&gt;\r\n这个非常简单的 Conductor 只有一个 ViewModel (类型为\r\nT)，它被公开为\r\nActiveItem。ActivateItem 方法用一个新的\r\nViewModel 实例替换当前的\r\nActiveItem，并激活新项且关闭旧项。每当\r\nCondcutor&lt;T&gt;被激活时，它就会激活它的\r\nActiveItem; 同样地，当它被停止活动或关闭时，它也会让\r\nActiveItem 停止活动和关闭。\r\n当被问及是否可以关闭(当调用 CanCloseAsync时)，它会返回\r\nActiveItem 返回的任何结果，如果没有\r\nActiveItem，则返回true。\r\n也可以直接设置 ActiveItem，其效果与调用\r\nActivateItem 相同。\r\nConductor 的视图模型看起来是这样的——一个 ContentControl 绑定到\r\nConductor 的 ActiveItem 上:\r\n&lt;Window x:Class=&quot;MyNamespace.ConductorViewModel&quot;        xmlns:s=&quot;https://github.com/canton7/Stylet&quot; ....&gt;   &lt;ContentControl s:View.Model=&quot;&#123;Binding ActiveItem&#125;&quot;/&gt;&lt;/Window&gt;\r\nConductor&lt;T&gt;.Collection.OneActive\r\n这个 Conductor\r\n拥有许多项，但一次只能激活一个。通过这种方式，它模拟了一个选项卡控件的行为——许多选项卡可以同时存在，但一次只能显示一个。\r\n它拥有一个名为 Items 的 T 集合，其中一个是\r\nActiveItem。调用 ActivateItem将添加 项到\r\nItems 集合，并将激活它且将其设置为ActiveItem;\r\n如果先前设置了 ActiveItem，则其旧值将被停用，并保留在\r\nItems 集合中。\r\n在一个项上调用 DeactivateItem 或 CloseItem\r\n将分别导致该项被停用和关闭。因为它不再是活动的，它不能保持为\r\nActiveItem——相反，另一个项被选择为\r\nActiveItem时，它将被激活。默认情况下，新的\r\nActiveItem 是存在于 Items\r\n集合中的，位于被停用/关闭的项之前。\r\n如果需要，可以直接操作 Items 集合。也可以直接设置\r\nActiveItem，其效果与调用\r\nActivateItem并添加该项相同。\r\n使用这个 Conductor 的，带有 TabControl\r\n的视图模型可能是这样的(查看下面的简短版本):\r\n&lt;TabControl ItemsSource=&quot;&#123;Binding Items&#125;&quot; SelectedItem=&quot;&#123;Binding ActiveItem&#125;&quot; DisplayMemberPath=&quot;DisplayName&quot;&gt;   &lt;TabControl.ContentTemplate&gt;      &lt;DataTemplate&gt;         &lt;ContentControl s:View.Model=&quot;&#123;Binding&#125;&quot; VerticalContentAlignment=&quot;Stretch&quot; HorizontalContentAlignment=&quot;Stretch&quot; IsTabStop=&quot;False&quot;/&gt;      &lt;/DataTemplate&gt;   &lt;/TabControl.ContentTemplate&gt;&lt;/TabControl&gt;\r\n但是，这有点拗口，所以 Stylet\r\n为您提供了一个样式，它可以完成相同的工作。这意味着你可以这样做:\r\n&lt;TabControl Style=&quot;&#123;StaticResource StyletConductorTabControl&#125;&quot;/&gt;\r\nConductor&lt;T&gt;.Collection.AllActive\r\n这个 Conductor 与\r\nConductor&lt;T&gt;.Collection.OneActive非常相似，除了它没有\r\nActiveItem。相反，它只有一个 Item\r\n集合。当一个项被激活时(使用 ActivateItem\r\n)，它被添加到这个集合中，当它被关闭时，它被从这个集合中删除。\r\n调用 DeactivateItem 将在不从 Items\r\n集合中移除的情况下就地停用该项目。\r\n还可以直接操作 Items\r\n集合。任何添加的项将被激活，任何移除的项将被关闭。\r\n一个典型的用例可能是使用一个\r\nItemsControl，其中所有的项都是同时可见的。以这种方式使用 ItemsControl\r\n的ViewModel 可能看起来是这样的(同样，查看下面的简短版本):\r\n&lt;ItemsControl ItemsSource=&quot;&#123;Binding Items&#125;&quot;&gt;   &lt;ItemsControl.ItemTemplate&gt;      &lt;DataTemplate&gt;         &lt;ContentControl s:View.Model=&quot;&#123;Binding&#125;&quot; VerticalContentAlignment=&quot;Stretch&quot; HorizontalContentAlignment=&quot;Stretch&quot; IsTabStop=&quot;False&quot;/&gt;      &lt;/DataTemplate&gt;   &lt;/ItemsControl.ItemTemplate&gt;&lt;/ItemsControl&gt;\r\n由于这很冗长，Stylet 提供了一个样式来设置这些属性:\r\n&lt;ItemsControl Style=&quot;&#123;StaticResource StyletConductorItemsControl&#125;&quot;/&gt;\r\nConductor&lt;T&gt;.StackNavigation\r\n这个 Conductor 是 Conductor &lt;T&gt;和\r\nConductor&lt;T&gt;.Collection.OneActive\r\n的混合体。它提供了一些额外的功能:基于堆栈的导航。\r\n它有一个单独的\r\nActiveItem，但也保留了一个(私有的)过去活动项目的历史记录。当您激活一个新项目时，先前的\r\nActiveItem 将被停用，并推入历史堆栈。调用\r\nGoBack() 将关闭当前\r\nActiveItem，并重新激活这个历史堆栈中的顶部项目，并将其设置为新的\r\nActiveItem。\r\n如果您在当前的 ActiveItem 上调用\r\nCloseItem，则会产生相同的效果。如果您在历史堆栈中存在的任何项目上调用\r\nCloseItem，该项目将被关闭并从历史堆栈中删除。调用\r\nClear() 将关闭并从历史堆栈中删除所有项。\r\nWindowConductor\r\n这个有点奇怪，因为它是内部的，你不需要直接与它交互，但我把它包含在这里是为了引起兴趣。当你使用\r\nWindowManager\r\n显示一个对话框或窗口时(这包括当你第一次启动你的应用程序时 Stylet\r\n显示的窗口)，一个新的 WindowConductor\r\n管理它的生命周期。当你的窗口或对话框最小化时，它就会失效。只要最大化，它就会被激活。如果您的\r\nViewModel 请求关闭它(参见上面的 RequestClose)，则\r\nWindowConductor\r\n将处理此操作。类似地，如果用户自己关闭窗口，WindowConductor将询问\r\nViewModel 是否准备关闭。\r\n","categories":["Develop","DotNET","Stylet 框架"],"tags":["MVVM","WPF"]},{"title":"WPF MVVM Stylet使用文档（中文）12-BindableCollection","url":"/posts/2020/1YXZ99D.html","content":"概述（Overview）\r\nBindableCollection&lt;T&gt; 是 ObservableCollection&lt;T&gt;\r\n的一个子类。如果你在你的 ViewModel\r\n中有一个集合，并且想要将它用作你视图中的某个控件的\r\nItemsSource\r\n等等，那么你就可以使用这个类（当一个项目被添加到/从集合中移除时，视图会得到通知）。\r\n\r\n而且，它增加了一些有用的额外功能:\r\n\r\n新增AddRange、RemoveRange和Refresh方法\r\n是线程安全的\r\n\r\n新方法\r\nObservableCollection&lt;T&gt;缺少两个非常有用的方法:\r\nAddRange 和 RemoveRange 。\r\n它们的作用与您的预期相差无几，允许您立即添加/移除范围内的元素，而无需手动遍历每个元素，并在每个元素添加时调用\r\ncollection.Add (element)(这使得触发大量的元素添加事件)。AddRange\r\n和 RemoveRange 只会在每个范围增加/删除时引发一组事件。\r\n刷新方法很方便。\r\n它不会以任何方式修改集合，但会触发 PropertyChanged 和\r\nCollectionChanged 事件，向任何 UI\r\n元素表明集合已被修改，它们应该重新加载数据。\r\n这不是经常需要的，但当它真的有需要的时候。\r\n线程安全（Thead Safety）\r\n线程安全是通过将所有操作 (添加、删除、清除、重置等) 分派给 UI\r\n线程来实现的。分派使用Execute.OnUIThreadSync，意思是:\r\n\r\n这些操作是同步的:被调用的方法在操作完成之前不会返回。\r\n它们是自由的，如果你已经在 UI\r\n线程，操作将在这种情况下同步进行。\r\n所有 PropertyChanged 和\r\nCollectionChanged 事件总是在 UI 线程上引发。\r\n\r\n这最后一点意味着与 PropertyChagedBase 有\r\nPropertyChangedDispatcher\r\n不同，BindableCollection &lt; T &gt; 上是没有\r\nPropertyChangedDispatcher 属性的——事件总是在 UI\r\n线程上,因为操作的属性与总是在 UI 线程上执行，所以，也没有\r\nCollectionChangedDispatcher 概念。\r\n","categories":["Develop","DotNET","Stylet 框架"],"tags":["MVVM","WPF"]},{"title":"WPF MVVM Stylet使用文档（中文）16-Listening to INotifyPropertyChanged","url":"/posts/2020/1SHECQH.html","content":"可能容易实现\r\nINotifyPropertyChanged，但通常是有点痛苦，想象一个对象需要propertychange\r\n通知：你需要注册一个事件处理程序,检查属性名是否是你所期望的,完成后又需要注销事件处理程序。\r\n这是一个很常见的问题，Stylet提供了一些方法来简化工作。\r\n\r\nINotifyPropertyChanged.Bind\r\n这是订阅 PropertyChanged\r\n事件的最简单方法，它使用对订阅服务器的强引用(与普通事件一样)来实现这一点。这意味着如果你打算在订阅的东西还存在的时候发布，你必须记得取消订阅。\r\n用法很简单。假设有一个对象的形式:\r\n// Can be any implementation of INotifyPropertyChanged - I&#x27;m using PropertyChangedBase as it makes the example shorterclass Model : PropertyChangedBase&#123;   private string _stringProperty;   public string StringProperty   &#123;      get &#123; return this._stringProperty; &#125;      set &#123; SetAndNotify(ref this._stringProperty, value); &#125;   &#125;&#125;\r\n您希望每次 StringProperty\r\n属性更改时都得到通知。你这样做:\r\nvar model = new Model();// ... model.Bind(x =&gt; x.StringProperty, (sender, eventArgs) =&gt; Debug.WriteLine(String.Format(&quot;New value for property &#123;0&#125; on &#123;1&#125; is &#123;2&#125;&quot;, eventArgs.PropertyName, sender, eventArgs.NewValue)));\r\nx =&gt; x.StringProperty\r\n是指定你想观察那个属性，这种方式是类型安全的。x\r\n可以任意命名，当你打出 x=&gt;x.\r\n时，智能感知会提示你一个属性列表。\r\n(propertyName, newValue) =&gt; Debug.WriteLine(String.Format(\"New value is {0}\", newValue))在每次属性改变时被调用。\r\nBind 方法实际上返回一个 IEventBinding\r\n的实现，它只有一个\r\nUnbind方法。要删除绑定，请调用该方法。例如:\r\nvar model = new Model();// ... var binding = model.Bind(x =&gt; x.StringProperty, (sender, eventArgs) =&gt; Debug.WriteLine(String.Format(&quot;New value for property &#123;0&#125; on &#123;1&#125; is &#123;2&#125;&quot;, eventArgs.PropertyName, sender, eventArgs.NewValue)));// ...binding.Unbind();\r\nINotifyPropertyChanged.BindWeak\r\n通常，当您订阅一个事件时，接收事件通知的对象至少与发布事件的对象存活的时间一样长，因为发布事件的对象最终会引用接收事件通知的对象。\r\n这通常是不受欢迎的。例如，如果您有一个\r\nViewModel，它想要监视它所依赖的某些服务上的 PropertyChanged事件。\r\nStylet 在 INotifyPropertyChanged 上提供了一个名为\r\nBindWeak 的扩展方法，它与 Bind\r\n非常相似，只是它创建了一个弱绑定。语法与 Bind\r\n相同，所以这里我就不重复了。\r\n\r\n请注意，以弱方式绑定每个委托是不可能的。捕获局部变量的委托通常会失败。下面将对此进行更详细的讨论。\r\n\r\n技术:弱事件订阅（Technical:\r\nWeak Event Subscriptions）\r\n我将忽略委托的一些细节，但在基本术语中，当您订阅一个事件时，您创建一个新的委托实例，并将其传递给拥有该事件的对象。委托(基本上)由两部分组成:\r\n要调用的方法(method)属性和要调用该方法的实例(Target属性)。\r\n如果你创建一个委托，它指向你的类的一个实例方法，一切都很好，很简单:\r\nclass MyClass&#123;   public MyClass(Model model)   &#123;      model.PropertyChanged += new PropertyChangedEventHandler(this.PropertyChangedHandler);      // or, more concisely      model.PropertyChanged += this.PropertyChangedHandler;   &#123;   public void PropertyChangedHandler(object sender, PropertyChangedEventArgs e)   &#123;      // ...   &#125;&#125;\r\n在这种情况下，一个新的委托被创建，它的 Target 被设置为\r\nMyClass 实例，它的 method 被设置为\r\nMethodInfo，代表你的 PropertyChangedHandler\r\n方法。\r\nmodel 实例然后成为该委托的所有者。这意味着\r\nmodel 实例拥有一个拥有 MyClass\r\n实例的委托，这意味着 MyClass 实例不能被释放，直到\r\nmodel 实例被释放。\r\n当匿名委托/ lambdas开始发挥作用时，事情开始变得有点复杂，例如:\r\nclass MyClass&#123;   public MyClass(Model model)   &#123;      model.PropertyChanged += delegate &#123; Debug.WriteLine(&quot;Hi&quot;); &#125;;      // Or, using lambas (preferred)      model.PropertyChanged += (o, e) =&gt; Debug.WriteLine(&quot;Hi&quot;);   &#125;&#125;\r\n在这里，c#\r\n编译器必须在你的类上创建一个新的，特殊的方法，它看起来像这样:\r\nclass MyClass&#123;   public MyClass(Model model)   &#123;      model.PropertyChanged += new PropertyChangedEventHandler(this.&lt;.ctor&gt;b__0);   &#125;   [CompilerGenerated]   private void &lt;.ctor&gt;b__0(object sender, PropertyChangedEventArgs e)   &#123;      Debug.WriteLine(&quot;Hi&quot;);   &#125;&#125;\r\n注意上面那个特殊方法名的使用——其中包含字符( “&lt;” 和\r\n“&gt;”)，这些字符在 c# 中无效，但在 CLR 中有效)。\r\n如果我们有一个捕获局部变量的匿名委托/lambda，这将变得更加复杂。在这里，c#\r\n编译器需要生成一个全新的嵌入式类，它保留了对该变量的引用。例如:\r\nclass MyClass&#123;   public MyClass(Model model)   &#123;      string test = &quot;test&quot;;      model.PropertyChanged += (o, e) =&gt; Debug.WriteLine(test);   &#125;&#125;\r\n编译成看起来有点像:\r\nclass MyClass&#123;   public MyClass(Model model)   &#123;      MyClass.&lt;&gt;c__DisplayClass1 c__DisplayClass1 = new MyClass.&lt;&gt;c__DisplayClass1();      c__DisplayClass1.test = &quot;test&quot;;      model.PropertyChanged += new PropertyChangedEventHandler(c__DisplayClass1.&lt;.ctor&gt;b__0);   &#125;   [CompilerGenerated]   private sealed class &lt;&gt;c__DisplayClass1   &#123;      public string test;      public void &lt;.ctor&gt;b__0(object sender, PropertyChangedEventArgs e)      &#123;         Debug.WriteLine(this.test);      &#125;   &#125;\r\n这里，创建的 PropertyChangedEventHandler 委托将\r\n&lt;&gt;c__DisplayClass 的实例作为它的 Target\r\n属性的值。\r\n这意味着，当MyClass\r\n的构造函数返回时，&lt;&gt;c__DisplayClass\r\n实例引用的唯一东西就是委托。&lt;&gt;c__DisplayClass\r\n实例的生命周期现在完全独立于 MyClass 实例。\r\n实现弱事件的方法是让委托的 “target” 属性以某种方式成为\r\n“WeakReference”\r\n——通常是让它指向一个中间类，而这个中间类又有一个指向“真正”目标的\r\n“WeakReference”。这意味着委托不会保留目标。\r\n如果这个目标是一个编译器生成的内部类，那么除了我们创建的\r\nWeakReference\r\n之外，没有其他任何东西会保存对它的引用。这意味着这个内部类将被直接收集，因此委托将永远不会被调用。\r\n因此，如果委托给它有一个target，且有\r\nCompilerGenerated 属性，BindWeak\r\n将抛出一个异常。\r\n","categories":["Develop","DotNET","Stylet 框架"],"tags":["MVVM","WPF"]},{"title":"WebClient, HttpClient, HttpWebRequest ,RestSharp之间的区别与抉择","url":"/posts/2022/34CSWY8.html","content":"NETCore提供了三种不同类型用于生产的REST API：\r\nHttpWebRequest;WebClient;HttpClient，开源社区创建了另一个名为\r\nRestSharp的库。\r\n如此多的http库，该怎样选择呢？\r\n\r\nHttpWebRequest\r\n这是.NET创建者最初开发用于使用HTTP请求的标准类。使用HttpWebRequest可以让开发者控制请求/响应流程的各个方面，如\r\ntimeouts, cookies, headers,\r\nprotocols。另一个好处是HttpWebRequest类不会阻塞UI线程。例如，当您从响应很慢的API服务器下载大文件时，您的应用程序的UI不会停止响应。\r\n然而，强大的个性化操作带来了极大的复杂性。为了简单起见，GET您需要至少五行代码;\r\nHttpWebRequest http = (HttpWebRequest)WebRequest.Create(&quot;http://example.com&quot;);WebResponse response = http.GetResponse();Stream stream = response.GetResponseStream();using (var streamtemn = File.Create(&quot;路径&quot;))&#123;    stream.CopyTo(streamtemn);&#125;\r\n如果对http协议不是了如指掌，使用HttpWebRequest会增加你的开发成本，除非你需要非常细节的处理和底层的控制，另外HttpWebRequest库已经过时，不适合业务中直接使用，他更适用于框架内部操作。\r\nWebClient\r\nWebClient是一种更高级别的抽象，是HttpWebRequest为了简化最常见任务而创建的，使用过程中你会发现他缺少基本的\r\nheader，timesout 的设置，不过这些可以通过继承\r\nhttpwebrequest\r\n来实现。使用WebClient可能比HttpWebRequest直接使用更慢（大约几毫秒）。但这种“低效率”带来了巨大的好处：它需要更少的代码和隐藏了细节处理，更容易使用，并且在使用它时你不太可能犯错误。同样的请求示例现在很简单只需要两行而且内部周到的处理完了细节：\r\nusing (WebClient webClient = new WebClient())&#123;    webClient.DownloadFile(&quot;http://example.com&quot;, &quot;路径&quot;);&#125;\r\nHttpClient\r\nHttpClient提供强大的功能，提供了异步支持，可以轻松配合async\r\nawait 实现异步请求，具体使用可参考：NetCore\r\n2.1中的HttpClientFactory最佳实践\r\nRestSharp\r\nrestsharp是开源社区贡献，具有HttpWebRequest的细节控制和WebClient的使用简单的优点从而让他功能强大的同时又简化了操作(从他定义的接口可以看出真是一个优秀的http库啊😊)\r\n结论\r\n\r\nHttpWebRequest\r\n已经不推荐直接使用了，这已经作为底层机制，不适合业务代码使用\r\nWebClient\r\n不想为http细节处理而头疼的coder而生，由于内部已经处理了通用设置，某些情况可能导致性能不是很理想\r\nRestSharp 兼具强大功能和友好api很适合业务中使用\r\nHttpClient 更加适用于异步编程模型中\r\n\r\n参考\r\nhttps://stackoverflow.com/questions/22791376/is-httpwebrequest-or-webclient-faster/22792326#22792326\r\nhttps://stackoverflow.com/questions/20530152/deciding-between-httpclient-and-webclient\r\nhttps://social.msdn.microsoft.com/Forums/vstudio/en-US/2ce80a71-1ced-4bcd-adb4-88eef6e6a42d/httpclient-vs-httpwebrequest?forum=wcf\r\nhttps://stackify.com/restsharp/?utm_referrer=https%3A%2F%2Fwww.google.com%2F\r\n","categories":["Develop","DotNET","Web"],"tags":["Web"]},{"title":"WPF MVVM Stylet使用文档（中文）17-Design Mode Support","url":"/posts/2020/1VM70C3.html","content":"简介（Introduction）\r\n“设计模式”或“设计时”指的是项目加载到 Visual Studio XAML 设计器或\r\nExpression Blend 中时，显示的是 XAML\r\n的呈现版本。大多数情况下，设计人员不会尝试评和估任何绑定，也不会为它们提供任何智能感知。然而，通过一些配置，您可以获得可爱的智能感知，并在视图中显示来自\r\nViewModel 的一些虚拟值。\r\nStylet\r\n对设计模式有一些基本的支持。本文记录了它，并提供了如何使用它以及如何利用现有的\r\nXAML 特性来增强设计时体验的说明。\r\n\r\n这里显示的所有示例都可以在 DesignMode\r\nsample project中的 \"ready to run\" 里面找到。\r\n只有智能感知，没有绑定（IntelliSense\r\nonly, no bindings）\r\n这是最基本的技巧，你只需要做很少的额外工作。您将获得绑定的智能感知(至少在\r\nVisual Studio 2013 及以上版本中)，但是您不会在视图中看到来自 ViewModel\r\n的任何虚拟数据。\r\n首先，需要在视图的根目录中声明以下内容。如果你在 Visual Studio 2013\r\n中创建了一个 UserControl，这些将会被默认添加。\r\nxmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; mc:Ignorable=&quot;d&quot; \r\n你还需要为你的视图模型添加一个命名空间:\r\nxmlns:vms=&quot;clr-namespace:DesignMode.ViewModels&quot;\r\n一旦你有了这个，你需要一个额外的神奇的一行，它告诉 XAML\r\n设计器，这个视图的 DataContext 是你的\r\nSampleViewModel，绑定智能感知应该使用这个属性:\r\nd:DataContext=&quot;&#123;d:DesignInstance vms:SampleViewModel&#125;&quot;\r\n把它们放在一起，你会得到这样的结果:\r\n&lt;UserControl x:Class=&quot;DesignMode.Views.SampleView&quot;             xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;             xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;              xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot;              mc:Ignorable=&quot;d&quot;             xmlns:vms=&quot;clr-namespace:DesignMode.ViewModels&quot;             d:DataContext=&quot;&#123;d:DesignInstance vms:SampleViewModel&#125;&quot;&gt;   ...&lt;/UserControl&gt;\r\n智能感知和虚拟数据，让设计器实例化视图模型（Intellisense\r\nand Dummy Data, letting the Designer instantiate the ViewModel）\r\n除了让 XAML 设计人员为我们实例化 ViewModel\r\n之外，这种技术与前面的技术非常相似。设计器将使用这个ViewModel\r\n实例来获取绑定的虚拟数据。\r\n为了让设计器能够做到这一点，ViewModel\r\n必须有一个无参数的构造函数。这既是祝福也是诅咒。好的方面是，它为您提供了一个将一些虚拟数据注入\r\nViewModel 属性以供设计人员使用的好地方。不好的一面是你的 ViewModel\r\n现在包含了只会被设计师使用的代码…\r\n\r\n注意：在设计时没有访问 IoC\r\n容器的权限(任何请求访问的人将被带到后台…处理)。因此，如果您的ViewModel\r\n有任何依赖项，它们在设计时将不可用。通常这不是问题:\r\n只有属性被访问(没有方法被调用)，所以您不应该做任何需要访问某个依赖项的事情。只要把它记在心里。\r\n\r\n以这种方式编写的支持设计模式的示例视图模型如下所示:\r\npublic class SampleViewModel&#123;    private readonly IUserService userService;    public string CurrentUserName &#123; get; private set; &#125;    public SampleViewModel()    &#123;        this.CurrentUserName = &quot;Dummy Username&quot;;    &#125;    public SampleViewModel(IUserService userService)    &#123;        this.userService = userService;        this.CurrentUserName = this.userService.CurrentUser.UserName;    &#125;&#125;\r\n\r\n注意：StyletIoC\r\n总是会选择具有最多可解析参数的构造函数，它也会调用接受\r\nIUserService\r\n的重载。另一方面，设计器总是调用无参数的构造函数。\r\n\r\n如果 ViewModel 通常只有一个无参数的构造函数，那么可以使用\r\nExecute.InDesignMode 或者\r\nExecute: Dispatching to the UI thread，如下:\r\npublic class SampleViewModel&#123;    public string SomeText &#123; get; set; &#125;    public SampleViewModel()    &#123;        if (Execute.InDesignMode)            this.SomeText = &quot;Dummy Text&quot;;        else            this.SomeText = &quot;Actual Text&quot;;    &#125;&#125;\r\n不管怎样，一旦你有了一个 ViewModel\r\n的无参数构造函数，设计师可以使用，你可以告诉设计师实例化它使用:\r\nd:DataContext=&quot;&#123;d:DesignInstance vms:SampleViewModel, IsDesignTimeCreatable=True&#125;&quot;\r\n或者，如下完整版本：\r\n&lt;UserControl x:Class=&quot;DesignMode.Views.SampleView&quot;             xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;             xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;              xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot;              mc:Ignorable=&quot;d&quot;             xmlns:vms=&quot;clr-namespace:DesignMode.ViewModels&quot;             d:DataContext=&quot;&#123;d:DesignInstance vms:SampleViewModel, IsDesignTimeCreatable=True&#125;&quot;&gt;   ...&lt;/UserControl&gt;\r\n智能感知我虚拟数据，使用视图模型定位器\r\n（Intellisense and Dummy Data, using a ViewModelLocator）\r\n前面的方法有一个很大的缺点: 它要求 ViewModel\r\n知道设计模式，并且包含只在设计时调用的代码。这被一些人认为是一种巨大的代码味道。\r\n另一种方法是使用\r\nViewModelLocator——一个只在设计时使用的类，它可以实例化和配置您的\r\nviewmodel。这意味着任何设计时都可以进入\r\nViewModelLocator，并且不进入各个视图。\r\n如果这听起来很复杂，请原谅我。这一切在一分钟内就会变得明晰。\r\n首先，让我们构建一个 SampleViewModel：\r\npublic class SampleViewModel&#123;    private readonly IUserService userService;    public string CurrentUserName &#123; get;set; &#125;    public SampleViewModel(IUserService userService)    &#123;        this.userService = userService;        this.CurrentUserName = this.userService.CurrentUser.UserName;    &#125;&#125;\r\n拉下来，我们需要一个\r\nViewModelLocator，这是一个简单的类，每个视图模型包含一个属性，我们可能想在设计时访问:\r\npublic class ViewModelLocator&#123;    public SampleViewModel SampleViewModel    &#123;        get        &#123;            var vm = new SampleViewModel();            vm.CurrentUserName = &quot;Dummy Username&quot;;            return vm;        &#125;    &#125;&#125;\r\n注意到 ViewModel 是如何仅在需要时实例化的吗? 这是因为\r\nViewModelLocator\r\n本身将在运行时实例化，但是它的属性将只在设计时访问。\r\n接下来，让我们把它添加到我们的应用程序的资源中，这样它就可以用于我们的视图:\r\n&lt;Application x:Class=&quot;DesignMode.App&quot;             xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;             xmlns:s=&quot;https://github.com/canton7/Stylet&quot;             xmlns:local=&quot;clr-namespace:DesignMode&quot;&gt;    &lt;Application.Resources&gt;        &lt;s:ApplicationLoader&gt;            &lt;s:ApplicationLoader.Bootstrapper&gt;                &lt;local:Bootstrapper/&gt;            &lt;/s:ApplicationLoader.Bootstrapper&gt;                        &lt;local:ViewModelLocator x:Key=&quot;ViewModelLocator&quot;/&gt;        &lt;/s:ApplicationLoader&gt;    &lt;/Application.Resources&gt;&lt;/Application&gt;\r\n然后在视图中使用：\r\n&lt;UserControl x:Class=&quot;DesignMode.Views.SampleView&quot;             xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;             xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;              xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot;              mc:Ignorable=&quot;d&quot;             xmlns:vms=&quot;clr-namespace:DesignMode.ViewModels&quot;             d:DataContext=&quot;&#123;Binding Source=&#123;StaticResource ViewModelLocator&#125;, Path=SampleViewModel&#125;&quot;&gt;   ...&lt;/UserControl&gt;\r\n在设计时启用/不启用按钮（Enabling/Disabling\r\nButtons at Design Time）\r\n在上面的所有例子中，我们只绑定了视图的 DataContext\r\n：我们没有对它的 “View. actiontarget |Actions#the-viewactiontarget”\r\n做任何事情。这意味着按钮的可启用性不会反映保护属性的值(如果它存在的话)——它总是被启用的。\r\n注意：默认情况下，Stylet\r\n会绑定视图。当它实例化视图时，ActionTarget\r\n指向相应的视图模型。然而，在设计时，Stylet 并不负责实例化视图，因此\r\nView.ActionTarget 不绑定。\r\n如果你想让按钮的 enabledless 反映它的保护属性，你需要添加:\r\ns:View.ActionTarget=\"{Binding}\"到你的视图，例如:\r\n&lt;UserControl x:Class=&quot;DesignMode.Views.SampleView&quot;             xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;             xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;              xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot;             xmlns:s=&quot;https://github.com/canton7/Stylet&quot;             mc:Ignorable=&quot;d&quot;             xmlns:vms=&quot;clr-namespace:DesignMode.ViewModels&quot;             d:DataContext=&quot;&#123;d:DesignInstance vms:SampleViewModel, IsDesignTimeCreatable=True&#125;&quot;             s:View.ActionTarget=&quot;&#123;Binding&#125;&quot;&gt;   ...&lt;/UserControl&gt;\r\n使用替代视图模型（Using\r\nSubstitute ViewModels）\r\n另一个解决\"视图模型知道设计时，但它其它不应该知道\"这个问题的办法是你的视图实现一个接口(真正的接口,或在头部假装实现一个)，然后，构造\r\ndesign-time-only\r\n视图并实现相同的接口，同时包含虚拟数据。然后在设计时以相同的方式绑定它:\r\nd:DataContext=\"{d:DesignInstance vms:DummyViewModel, IsDesignTimeCreatable=True}\"。但是，对于大多数开发人员来说，这样的开销太大了。\r\nWPF也有一个设计时数据的概念，参见例子。\r\n为什么\r\nStylet 不能自动找到我的 ViewModel ?（Why can't Stylet find my ViewModel\r\nautomatically?）\r\n由于 Stylet 能够获取一个\r\nViewModel，并查找和实例化它的视图，您可能会想问为什么它不能以另一种方式做到这一点:\r\n也就是说，在设计时，为给定的视图自动找到正确的\r\nViewModel，并用正确的依赖项实例化它。这是一个非常糟糕的想法，原因有很多:\r\n\r\n我们需要添加一种将 View 名称转换为 ViewModel 名称的方法，这增加了\r\nViewManager 的复杂性(特别是对于任何提供自己的\r\nViewManager 的人来说)。\r\n我们需要在设计时实例化一个适当的\r\nIViewManager实现。由于用户可以提供自己的实现，这意味着打开整个\r\nIoC\r\n容器。因为这依赖于正确地设置了引导程序的程序集属性，所以我们需要打开整个引导程序。这可能会产生令人讨厌的副作用(请考虑启动执行网络提交、文件系统访问等的服务)。\r\n我们需要提供一个具有所有依赖关系的\r\nViewModel。这意味着实例化服务，这可能会产生令人讨厌的副作用。\r\nViewModel\r\n可能不会包含合适的虚拟数据，所以我们没有获得太多。\r\n由于我们太过聪明而导致某些服务以错误的方式启动，因此出现设计器错误(或者更糟，出现网络/文件系统副作用)，调试起来很痛苦，我们不应该把这种情况强加于人。\r\n\r\ns:View.Model and Embedded\r\nViews\r\n如果你有一个内嵌视图(例如\r\n&lt;ContentControl s:View.Model=\"{Binding SomeChildViewModel}\"/&gt;)在您的视图中，然后\r\nStylet 将在 View for ViewModelType.SomeChildViewModel\r\n行简单地显示一条消息。而不是试图找到正确的视图。这与我们没有自动定位\r\nViewModels 的原因非常相似: 这意味着打开 IoC 容器(我们需要找到用户的\r\nIViewManager\r\n实现)，这意味着运行引导程序，这让我们可以做真正危险的事情。最好避免。\r\n","categories":["Develop","DotNET","Stylet 框架"],"tags":["MVVM","WPF"]},{"title":"WPF MVVM Stylet使用文档（中文）18-Logging","url":"/posts/2020/4NQDGJ.html","content":"简介\r\n有时候，查看 Stylet\r\n在幕后做了什么是很有用的，特别是当它没有做一些你期望它做的事情，或者做一些意想不到的事情的时候。\r\n值得庆幸的是，Stylet\r\n可以很容易地配置来生成日志输出，因此您可以了解它在做什么。\r\n\r\n快速启动\r\n要快速启用日志记录，请在Bootstrapper的配置方法中放入以下内容:\r\nprotected override void OnStart()&#123;   Stylet.Logging.LogManager.Enabled = true;&#125;\r\n这将把日志消息打印到 Visual Studio\r\n的输出窗口。在内部，默认的日志记录器使用\r\nTrace.WriteLine。\r\n定制日志\r\n当然，您可以向 Stylet 提供自己的日志记录器，Stylet\r\n将使用它来打印日志消息。\r\n首先，定义一个实现 Stylet.Logging.ILogger 接口的类:\r\npublic class MyLogger : Stylet.Logging.ILogger&#123;   public MyLogger(string loggerName)   &#123;      // TODO   &#125;   public void Info(string format, params object[] args)   &#123;      // TODO   &#125;   public void Warn(string format, params object[] args)   &#123;      // TODO   &#125;   public void Error(Exception exception, string message = null)   &#123;      // TODO   &#125;&#125;\r\n然后，配置 LogManager\r\n来使用它。与之前一样，在你的Bootstrapper的配置方法:\r\nprotected override void OnStart()&#123;   Stylet.Logging.LogManager.LoggerFactory = name =&gt; new MyLogger(name);   Stylet.Logging.LogManager.Enabled = true;&#125;\r\n在应用程序中进行日志记录（Logging\r\nwithin your Application）\r\n我建议不要用 Stylet.Logging\r\n在其他地方进行日志记录。它是非常轻量级的，几乎没有任何特性——编写它的唯一原因是为了让\r\nStylet 不依赖于日志框架来支持一个几乎永远不会被使用的特性。\r\nNLog 和 log4net\r\n是两个主要的c#日志记录框架。如果您不想将您的应用程序与任何特定的日志记录框架耦合，那么可以考虑\r\nCommon.Logging，它提供了一个与框架无关的接口，在这个接口后面可以连接\r\nNLog、log4net或其他框架。\r\n","categories":["Develop","DotNET","Stylet 框架"],"tags":["MVVM","WPF"]},{"title":"Webview2 中无法打开文件选择对话框","url":"/posts/2022/1RWN42Y.html","content":"webview2 可以是一个 .NET\r\n环境下运行网页的一个组件，用它可以将网页封装成桌面端程序。封装后，可能会出现无法打开文件选择框的情况，可按如下方法解决。\r\n\r\n解决方法\r\n\r\n删除目录运行目录下的 ProgramName.exe.WebView2\r\n文件夹\r\n用普通账户打开(不要用管理员账户运行程序)\r\n\r\n参考\r\nWebView2\r\nWPF application can't open file dialog when it run as\r\nadministrator\r\nCannot\r\nopen files dialog\r\nFile\r\nOpen/Save Dialog doesn't show running w/ elevated privileges\r\n","categories":["Develop","DotNET","Webview2"],"tags":["C#","webview2"]},{"title":"DotNET 读写 XML 文件入门必读","url":"/posts/2023/345REE4.html","content":"作为入门必读，本文将介绍 XML\r\n的读取方式选择，然后总结初学者可能会遇到的坑。\r\n\r\n方式比选\r\n在 C# 中，有多种方式可以读取 XML 数据，以下是一些常见的方法：\r\n\r\n使用 XmlDocument 类：这是 .NET\r\nFramework 中最早的 XML 处理类，它提供了丰富的方法和属性来读取和操作 XML\r\n文档。\r\nXmlDocument doc = new XmlDocument();doc.Load(&quot;file.xml&quot;);XmlNode node = doc.DocumentElement.SelectSingleNode(&quot;/book/title&quot;);\r\n使用 XDocument 和 XElement\r\n类：这些类是 .NET Framework 的 LINQ to XML\r\n技术的一部分，它们提供了更现代和强大的方式来处理 XML。\r\nXDocument doc = XDocument.Load(&quot;file.xml&quot;);XElement node = doc.Root.Element(&quot;title&quot;);\r\n使用 XmlReader\r\n类：这是一个基于流的读取器，它提供了一种高效的方式来读取大型\r\nXML 文件，因为它一次只读取文档的一小部分。\r\nusing (XmlReader reader = XmlReader.Create(&quot;file.xml&quot;))&#123;  while (reader.Read())  &#123;    // 处理每个节点...  &#125;&#125;\r\n使用 XmlSerializer 类：这个类可以将\r\nXML 数据反序列化为 .NET 对象，或将 .NET 对象序列化为\r\nXML。这是处理复杂数据结构的理想选择。\r\nXmlSerializer serializer = new XmlSerializer(typeof(MyClass));MyClass obj = (MyClass)serializer.Deserialize(new StreamReader(&quot;file.xml&quot;));\r\n\r\n以上每种方法都有其优点和适用场景，在日常开发中若无特殊要求，建议选择更加现代化的\r\nLINQ\r\nto XML 方式来读取 XML。\r\n注意事项\r\n注意 xmlns(命名空间)\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;KeyinTree xmlns=&quot;http://www.bentley.com/schemas/1.0/MicroStation/AddIn/KeyinTree.xsd&quot;&gt;  &lt;RootKeyinTable&gt;    &lt;Keyword CommandWord=&quot;app&quot; SubtableRef=&quot;app&quot; /&gt;  &lt;/RootKeyinTable&gt;  &lt;SubKeyinTables&gt;    &lt;SubKeyinTable ID=&quot;default&quot; /&gt;    &lt;SubKeyinTable ID=&quot;app&quot;&gt;      &lt;Keyword CommandWord=&quot;test&quot; SubtableRef=&quot;test&quot; /&gt;    &lt;/SubKeyinTable&gt;    &lt;SubKeyinTable ID=&quot;test&quot;&gt;      &lt;Keyword CommandWord=&quot;keyin&quot; /&gt;    &lt;/SubKeyinTable&gt;  &lt;/SubKeyinTables&gt;  &lt;KeyinHandlers&gt;    &lt;KeyinHandler Keyin=&quot;app test keyin&quot; Function=&quot;Namespace.App.Functions.Func&quot; /&gt;  &lt;/KeyinHandlers&gt;&lt;/KeyinTree&gt;\r\n在 XML\r\n中，节点的名称由两部分组成：{命名空间}+逻辑名称。\r\n上面的 XML 中，根节点 KeyinTree 是逻辑名称，它的 Name 是\r\n{http://www.bentley.com/schemas/1.0/MicroStation/AddIn/KeyinTree.xsd}KeyinTree。因此：\r\n\r\n不同命名空间的节点不能相互包含\r\n在查询时，要注意区分是全称还是逻辑名称\r\n使用 LINQ to XML\r\n时，若只希望按标签来筛选，则应该去匹配它的逻辑名称\r\nvar document = XDocument.Load(path);var keyinTree = document.Elements().FirstOrDefault(x=&gt;x.Name.LocalName==&quot;KeyinTree&quot;)\r\n\r\n其它\r\n可以添加以下扩展方法来读取 XML，简化对命名空间的处理\r\npublic static class XDocumentExtension&#123;    /// &lt;summary&gt;    /// 使用带有命名空间的名称查询后代    /// &lt;/summary&gt;    /// &lt;param name=&quot;element&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;localName&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static IEnumerable&lt;XElement&gt; DescendantsWithNSP(this XElement element, string localName)    &#123;        var fullName = &quot;&#123;&quot; + element.Name.NamespaceName + &quot;&#125;&quot; + localName;        return element.Descendants(fullName);    &#125;    /// &lt;summary&gt;    /// 转换成带有命名空间的 XName    /// &lt;/summary&gt;    /// &lt;param name=&quot;localName&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;template&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static XName ToXNameWithNSP(this string localName, XElement template)    &#123;        return template.Name.Namespace + localName;    &#125;&#125;\r\n参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\nLINQ\r\nto XML 概述 - .NET | Microsoft Learn\r\n","categories":["Develop","DotNET","XML"],"tags":["DotNET","XML"]},{"title":"WPF MVVM Stylet使用文档（中文）15-The ViewManager","url":"/posts/2020/39AEVSS.html","content":"ViewManager 是 Stylet 的核心组件之一，负责获取\r\nViewModel，并为其定位正确的视图。然后实例化该视图，并将其绑定到\r\nViewModel。\r\n本文将告诉您这个过程是如何工作的，以及如何修改它。\r\n\r\n定位视图（Locating a View）\r\n默认的视图定位策略非常简单: 将在 ViewModel的类型和名称空间中将字符串\r\n“ViewModel” 替换为字符串\r\n“View”，然后搜索所有已配置的程序集，寻找具有该名称的类型。\r\n就是这样。\r\n“已配置程序集” 是指 ViewManager 的 viewassembly\r\n属性中的所有程序集。如果您希望搜索更多的程序集，请将它们添加到此列表中(参见下面的示例)。\r\n这个过程由 ViewManager.LocateViewForModel\r\n控制。所以如果你想修改它，继续子类化\r\nViewManager——参见本文底部的章节。\r\n创建视图（Creating a View）\r\n一旦确定了视图类型，就通过调用提供给 ViewManager\r\n的工厂方法来实例化它。在默认情况下，引导程序将其设置为调用 IoC\r\n容器。然后调用\r\nInitializeComponent，这意味着如果需要，您可以删除您的后台代码。\r\n这是由ViewManager.CreateViewForModel\r\n处理的。你也可以覆盖它。\r\n将视图绑定到它的视图模型（Binding\r\nthe View to its ViewModel）\r\n绑定视图模型及其对应的视图非常简单:\r\n\r\n视图的 DataContext 被设置为 ViewModel。\r\n视图的 ActionTarget 被设置为 ViewModel(参见\r\n[[Actions]])。\r\n如果 ViewModel 实现了 ViewAware，则调用它的\r\nAttachView 方法，并传递视图(参见 [[Screens and\r\nconductor]])。\r\n\r\n处理\r\nView.Model 的更改（Dealing with View.Model\r\nChanges）\r\nViewManager 还负责响应 ContentControl 中\r\nView.Model 附加属性的更改——参见 [[ViewModel First]]。\r\n它将获取附加属性的新值(应该绑定到 ViewModel 实例)，并使用\r\nCreateViewForModel 和 BindViewToModel\r\n创建一个新的配置视图实例，然后将其设置为 ContentControl\r\n的内容。\r\n配置视图管理器（Configuring\r\nthe ViewManager）\r\nViewManager 是可配置的。要配置它，在你的 Configure\r\n方法中获取它的一个实例:\r\nprotected override void Configure()&#123;    var viewManager = this.Container.Get&lt;ViewManager&gt;();    // ...&#125;\r\n一旦你有了它，有几个事情你可以配置:\r\n\r\nViewSuffix: 视图类名的后缀。默认为 “View”。\r\nViewModelSuffix: 视图类名的后缀。默认为\r\n“ViewModel”。\r\nViewassembly:\r\n要扫描哪些程序集的视图。默认包含引导程序的程序集。\r\nnamespacetransformation: 这是一个\r\nfrom -&gt; to\r\n替换的字典，允许你的视图和视图模型存在于不同的名称空间中。如果你的视图位于Foo.Frontend.Views\r\n中。视图模型位于 Foo.FrontendLogic.ViewModels\r\n中。你可以添加一个条目（键值对）到这个关键字为 \"Foo.Frontend“ 和值为\r\n“Foo.FrontendLogic”字典。注意，您必须包含所有的根名称空间:\r\n您不能在这里使用 从 “Frontend” 到 “FrontendLogic” 的转换。\r\n\r\n创建自己的\r\nViewManager（Creating your own ViewManager）\r\n当 Stylet 需要 ViewManager 时，它从 IoC 容器中检索一个\r\nIViewManager 实例。这意味着您可以创建一个您想要的\r\nIViewManager 实现，并将其注册到 IoC 容器中，Stylet 将获取并使用它。\r\n一个非常简单的例子:\r\n// CustomViewManager.cspublic class CustomViewManager : ViewManager&#123;   public CustomViewManager(ViewManagerConfig config)      : base(config)   &#123; &#125;   public override UIElement CreateAndSetupViewForModel(object model)   &#123;      // This dummy application only has one view, and it&#x27;s this one :)      return new SingletonView();   &#125;&#125;// Bootstrapper.cspublic class Bootstrapper : Bootstrapper&lt;MyRootViewModel&gt;&#123;   protected override void ConfigureIoC(IStyletIoCBuilder builder)   &#123;      builder.Bind&lt;IViewManager&gt;().To&lt;CustomViewManager&gt;();   &#125;&#125;\r\n这是它!\r\n更完整的示例可以在 Stylet.Samples.OverridingViewManager\r\nsample。\r\n","categories":["Develop","DotNET","Stylet 框架"],"tags":["MVVM","WPF"]},{"title":"webview2 打开网页时一片空白","url":"/posts/2023/1Q13G3F.html","content":"在 WPF 中使用 webview2\r\n组件来展示网页，若打开之后，界面显示空白，目前读者遇到的可能的原因有：\r\n\r\nwebview2 环境缺失或版本不对\r\n可能安装了某个软件，其注入 dll 到 webview2 失败\r\n\r\n可以通过以下步骤来详细排查：\r\n\r\n排查 webview2 问题\r\n如果 webview2 版本太低或者与使用的 webview2 SDK\r\n不匹配时，也会出现页面空白问题，可以通过或修复 webview2\r\n来排除 webview2 环境影响。\r\n通过代码进行异常排查\r\n首先监听 webview2 事件（不用看逻辑，直接复制使用）：\r\nwebView.CoreWebView2.ProcessFailed += WebView_ProcessFailed;\r\n// WebView_ProcessFailedvoid WebView_ProcessFailed(object sender, CoreWebView2ProcessFailedEventArgs e)&#123;    void ReinitIfSelectedByUser(string caption, string message)    &#123;        this.Dispatcher.InvokeAsync(() =&gt;        &#123;            var selection = MessageBox.Show(message, caption, MessageBoxButton.YesNo);            if (selection == MessageBoxResult.Yes)            &#123;                // The control cannot be re-initialized so we setup a new instance to replace it.                // Note the previous instance of the control is disposed of and removed from the                // visual tree before attaching the new one.                if (_isControlInVisualTree)                &#123;                    RemoveControlFromVisualTree(webView);                &#125;                webView.Dispose();                webView = GetReplacementControl(false);                AttachControlToVisualTree(webView);                // Set background transparent                webView.DefaultBackgroundColor = System.Drawing.Color.Transparent;            &#125;        &#125;);    &#125;    void ReloadIfSelectedByUser(string caption, string message)    &#123;        this.Dispatcher.InvokeAsync(() =&gt;        &#123;            var selection = MessageBox.Show(message, caption, MessageBoxButton.YesNo);            if (selection == MessageBoxResult.Yes)            &#123;                webView.Reload();                // Set background transparent                webView.DefaultBackgroundColor = System.Drawing.Color.Transparent;            &#125;        &#125;);    &#125;    bool IsAppContentUri(Uri source)    &#123;        // Sample virtual host name for the app&#x27;s content.        // See CoreWebView2.SetVirtualHostNameToFolderMapping: https://learn.microsoft.com/dotnet/api/microsoft.web.webview2.core.corewebview2.setvirtualhostnametofoldermapping        return source.Host == &quot;appassets.example&quot;;    &#125;    if (e.ProcessFailedKind == CoreWebView2ProcessFailedKind.FrameRenderProcessExited)    &#123;        // A frame-only renderer has exited unexpectedly. Check if reload is needed.        // In this sample we only reload if the app&#x27;s content has been impacted.        foreach (CoreWebView2FrameInfo frameInfo in e.FrameInfosForFailedProcess)        &#123;            if (IsAppContentUri(new System.Uri(frameInfo.Source)))            &#123;                System.Threading.SynchronizationContext.Current.Post((_) =&gt;                &#123;                    ReloadIfSelectedByUser(&quot;App content frame unresponsive&quot;,                        &quot;Browser render process for app frame exited unexpectedly. Reload page?&quot;);                &#125;, null);            &#125;        &#125;        return;    &#125;    // Show the process failure details. Apps can collect info for their logging purposes.    this.Dispatcher.InvokeAsync(() =&gt;    &#123;        StringBuilder messageBuilder = new StringBuilder();        messageBuilder.AppendLine($&quot;Process kind: &#123;e.ProcessFailedKind&#125;&quot;);        messageBuilder.AppendLine($&quot;Reason: &#123;e.Reason&#125;&quot;);        messageBuilder.AppendLine($&quot;Exit code: &#123;e.ExitCode&#125;&quot;);        messageBuilder.AppendLine($&quot;Process description: &#123;e.ProcessDescription&#125;&quot;);        MessageBox.Show(messageBuilder.ToString(), &quot;Child process failed&quot;, MessageBoxButton.OK);    &#125;);    if (e.ProcessFailedKind == CoreWebView2ProcessFailedKind.BrowserProcessExited)    &#123;        ReinitIfSelectedByUser(&quot;Browser process exited&quot;,            &quot;Browser process exited unexpectedly. Recreate webview?&quot;);    &#125;    else if (e.ProcessFailedKind == CoreWebView2ProcessFailedKind.RenderProcessUnresponsive)    &#123;        ReinitIfSelectedByUser(&quot;Web page unresponsive&quot;,            &quot;Browser render process has stopped responding. Recreate webview?&quot;);    &#125;    else if (e.ProcessFailedKind == CoreWebView2ProcessFailedKind.RenderProcessExited)    &#123;        ReloadIfSelectedByUser(&quot;Web page unresponsive&quot;,            &quot;Browser render process exited unexpectedly. Reload page?&quot;);    &#125;&#125;\r\n获取到异常信息后，可以根据异常信息去排查问题。\r\n通过 webview2\r\n运行日志排查问题\r\n添加环境变量：WEBVIEW2_ADDITIONAL_BROWSER_ARGUMENTS = --enable-logging --v=1 --log-file=c:\\temp\\webview2.log\r\n来捕获 webview2 运行详细日志\r\n通过该详细日志来分析 webview2 报错。\r\n# 添加环境变量[Environment]::SetEnvironmentVariable(&#x27;WEBVIEW2_ADDITIONAL_BROWSER_ARGUMENTS&#x27;, &#x27;--enable-logging --v=1 --log-file=c:\\temp\\webview2.log&#x27; , &#x27;User&#x27;)\r\n已知报错及处理方案\r\n错误：WebView2_Child\r\nprocess failed ExitCode:-1073740760\r\n可以按以下 2 种方式来解决：\r\n\r\n方法 1：卸载影响的软件\r\n通过事件查看器定位是哪个第三方 dll 注入失败，如果找到对应 dll\r\n属于哪个程序，可以对该程序进行 修复或者卸载。\r\n在 windows 搜索栏中搜索\r\neventvwr(又叫事件查看器)，打开后找到\r\n【应用程序和服务日志】/【Microsoft】/【Windows】/【CodeIntegrity】/【Operational】，找到错误项进行查看。\r\n# 例如出现如下错误，说明是 Ldxghijt64.dll 注入失败导致的Code Integrity determined that a process (\\Device\\HarddiskVolume5\\Program Files (x86)\\Microsoft\\EdgeWebView\\Application\\114.0.1823.67\\msedgewebview2.exe) attempted to load \\Device\\HarddiskVolume5\\Windows\\System32\\Ldxghijt64.dll that did not meet the Microsoft signing level requirements.\r\n\r\n特别说明：\r\nLdxghijt64.dll 是厦门天税绿盾软件的 dll。\r\n可以在任务管理器中通过搜索 Ld 开头的进程来定位目标程序位置\r\n\r\n方法 2：禁用 dll 注入\r\n可以通过添加环境变量\r\nWEBVIEW2_ADDITIONAL_BROWSER_ARGUMENTS =--disable-features=RendererCodeIntegrity\r\n来取消第三方 dll 注入\r\n在 powershell(非管理员) 中运行以下命令行：\r\n[Environment]::SetEnvironmentVariable(&#x27;WEBVIEW2_ADDITIONAL_BROWSER_ARGUMENTS&#x27;, &#x27;--disable-features=RendererCodeIntegrity&#x27; , &#x27;User&#x27;)\r\n若上述操作不生效，可以通过修改注册表的方式来禁用第三方 dll 注入：\r\n&quot;HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Microsoft\\Edge\\WebView2&quot; /v RendererCodeIntegrityEnabled /t REG_DWORD /d 0\r\n\r\n错误：System.Runtime.nteropServices.COMException\r\n(0x8007139F)\r\n完整的错误如下：\r\nWebView2 creation failed with exception =System.Runtime.nteropServices.COMException (0x8007139F): 组或资源的状态不是执行请求操作的正确状态。(异常来自 HRESULT:Ox8007139F)在System.Runtime.lnteropServices.Marshal.ThrowExceptionForHRInternal(Int32 errorCode, IntPtr errorlnfo)在Microsoft.Web.WebView2.Core.CoreWebView2Environment.&lt;CreateCoreWebView2ControllerAsync&gt;d_135.MoveNext0---引发异常的上一位置中堆栈跟踪的末尾 ---在 System.Runtime.ExceptionServices.ExceptionDispatchlnfo.Throw()在System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)在Microsoft.Web.WebView2.Wpf.WebView2.&lt;&gt;c_DisplayClass34_0.&lt;&lt;EnsureCoreWebView2Async&gt;g_Init|0&gt;d.MoveNext()\r\n这种情况，一般是 webview2 COM 接口导致的错误，可以通过重装WebView2\r\n- Microsoft Edge Developer 来解决。\r\n如果重装不能完全解决这个问题的话，可以查看 webview2\r\n运行的日志来分析错误。\r\n目前，作者遇到过的问题有：\r\n\r\nDPI（分辨率）的问题\r\n可以在程序上右键【属性/兼容性/更改高 DPI 设置】，选中界面上的 DPI\r\n选项，如下图所示：\r\n\r\n\r\nimage-20230728123007643\r\n\r\n\r\n参考\r\n\r\nWebView2_Child\r\nprocess failed ExitCode:-1073740760\r\nWhy\r\nwebview2 is displayed as a white screen, but other computers can use the\r\nsame application\r\nhttps://github.com/MicrosoftEdge/WebView2Feedback/issues/349#issuecomment-1250870240\r\nhttps://support.templafy.com/hc/en-us/articles/10510746266525-How-to-repair-Webview2-Runtime\r\nldxghijt64.dll\r\n是个什么东西？ - 知乎 (zhihu.com)\r\nhttps://github.com/MicrosoftEdge/WebView2Feedback/issues/3008#issuecomment-1335747853\r\nHow\r\nto edit, clear, and delete environment variables in Windows - Digital\r\nCitizen\r\nCOMException\r\n0x8007139F in Microsoft.Web.WebView2.WinForms.WebView2.d__13.MoveNext\r\n·问题 #3008 ·MicrosoftEdge/WebView2Feedback (github.com)\r\ndid\r\nnot meet the Microsoft signing level requirements\r\n解决Renderer\r\nCode Integrity造成Chrome浏览器崩溃\r\nProblem/Bug:\r\n--disable features=RenderCodeIntegrity, starting from v118 version, no\r\nlonger functional · Issue #4094 ·\r\nMicrosoftEdge/WebView2Feedback\r\n\r\n","categories":["Develop","DotNET","Webview2"],"tags":["NexT","Webview2"]},{"title":"C# 中检测 Webview2 是否安装","url":"/posts/2023/210TYTX.html","content":"在 C# 中主要有两种方式来检测 Webview2 是否已经安装：\r\n\r\n通过\r\nCoreWebView2Environment.GetAvailableBrowserVersionString()\r\n返回值来判断\r\n通过注册表值来判断\r\n\r\n这种方式不是很稳定，有时候用户的注册会缺失\r\n\r\n\r\n\r\nGetAvailableBrowserVersionString()\r\n方法\r\npublic static class WebView2Install&#123;    public static InstallInfo GetInfo()    &#123;        var version = GetWebView2Version();        return new InstallInfo(version);    &#125;    private static string GetWebView2Version()    &#123;        try        &#123;            return CoreWebView2Environment.GetAvailableBrowserVersionString();        &#125;        catch (Exception) &#123; return &quot;&quot;; &#125;    &#125;&#125;public class InstallInfo&#123;    public InstallInfo(string version) =&gt; (Version) = (version);    public string Version &#123; get; &#125;    public InstallType InstallType =&gt; Version switch    &#123;            var version when version.Contains(&quot;dev&quot;) =&gt; InstallType.EdgeChromiumDev,            var version when version.Contains(&quot;beta&quot;) =&gt; InstallType.EdgeChromiumBeta,            var version when version.Contains(&quot;canary&quot;) =&gt; InstallType.EdgeChromiumCanary,            var version when !string.IsNullOrEmpty(version) =&gt; InstallType.WebView2,            _ =&gt; InstallType.NotInstalled    &#125;;&#125;public enum InstallType&#123;    WebView2, EdgeChromiumBeta, EdgeChromiumCanary, EdgeChromiumDev, NotInstalled&#125;\r\n注册表法\r\npublic static bool HasWebView2InstalledByReg()&#123;    using var key = Microsoft.Win32.Registry.LocalMachine.OpenSubKey(@&quot;SOFTWARE\\WOW6432Node\\Microsoft\\EdgeUpdate\\Clients\\&#123;F3017226-FE2A-4295-8BDF-00C3A9A7E4C5&#125;&quot;);    if (key == null) return false;    var versionStr = key.GetValue(&quot;pv&quot;);    if(versionStr == null) return false;    return !string.IsNullOrEmpty(versionStr.ToString());&#125;\r\n参考\r\n.net\r\n- Detect if WebView2 is installed on clients machine (VB.NET) - Stack\r\nOverflow\r\n","categories":["Develop","DotNET","Webview2"],"tags":["C#","webview2"]},{"title":"PropertyGrid 中实现动态的下拉选项","url":"/posts/2020/3GJFFVV.html","content":"在使用 PropertyGrid 控件中，有时候我们在属性的上面添加类型转换特性\r\n(TypeConverterAttribute) 来自定义下拉选项。\r\n这个时候，我们可能会有这样的要求，一个属性的改变会导致另一个属性的候选项发生改变，也就是说，我们需要为特定属性设置动态的下拉选项。\r\n\r\n此处以 StringConverter 为例。\r\npublic class RebarDiameterConverter:StringConverter&#123;    private List&lt;string&gt; _diameters = new List&lt;string&gt;() &#123; &quot;φ8&quot;,&quot;φ10&quot;,&quot;φ12&quot;, &quot;φ14&quot;, &quot;φ16&quot;, &quot;φ18&quot;, &#125;;    //true enable,false disable    public override bool GetStandardValuesSupported(ITypeDescriptorContext context)    &#123;        return true;    &#125;    public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)    &#123;        if(context!=null &amp;&amp; context.Instance is ISwRebarProperty rebar)        &#123;            _diameters = swOpenRoadsSDK.ParseSpecificationXml.Instance.GetSpecifications(rebar.FeatureName);        &#125;        return new StandardValuesCollection(_diameters.ToArray()); //编辑下拉框中的items    &#125;    //true: disable text editting.    false: enable text editting;    public override bool GetStandardValuesExclusive(ITypeDescriptorContext context)    &#123;        return true;    &#125;&#125;\r\n在 GetStandardValues 方法中，会传递下来一个 context, 而\r\ncontext.Instance\r\n就是调用该转换器的实例，所以，将它转换成相应的对象，然后利用对象里面的值来动态生成下拉选项。\r\n","categories":["Develop","DotNET","WPF"],"tags":["C#",".NET"]},{"title":"PropertyGrid 中只显示部分属性","url":"/posts/2020/35EQCZA.html","content":"最近用到了PropertyGrid，原来从来没用到过，拿在手里，一头雾水，经过一段时间研究后，大概理解了Property的使用方法，下面仔细剖析一下。\r\nPropertyGrid控件就是Visual\r\nStudio开发工具里面的属性浏览器，我们在VS里面可以通过属性浏览器查看，修改控件的属性，并主要通过使用反射来检索项目的属性。\r\n\r\n普通显示\r\n在PropertyGrid中显示属性很容易，我们可以直接给propertyGrid1.SelectedObject\r\n属性赋值，SelectObject属性可以获取或设置当前选定的对象，数据类型为object,这就意味着我们可以直接将一个对象赋给它。针对一个对象，它会将对象中的所有公共属性显示在PropertyGrid上。\r\n如果要同时显示多个对象，可以将一个对象数组赋值给\r\npropertyGrid1.SelectedObjects。它会自动计算多个对象的公开属性并显示，当各个对象中属性值相同时，会显示相同的值，如果不同时，则会不显示确定的值。\r\n更改显示方式\r\n当只用上面的赋值方式，那么显示出来的数据名称会直接是属性的名称，如果想要进行汉化，需要对每个属性添加相应的特性（Attribute）来进行配置。\r\n特性是用于为类型、字段、方法和属性等编程元素添加批注的声明标记，在运行时可以使用反射对其进行检索。下面列出了在\r\nPropertyGrid 中用到的特性：\r\n\r\nDescriptionAttribute\r\n设置显示在属性下方说明帮助窗格中的属性文本。这是一种为活动属性（即具有焦点的属性）提供帮助文本的有效方法。\r\nCategoryAttribute\r\n设置属性在网格中所属的类别。当您需要将属性按类别名称分组时，此特性非常有用。如果没有为属性指定类别，该属性将被分配给\r\n\"杂项\" 类别。可以将此特性应用于所有属性。\r\nBrowsableAttribute\r\n表示是否在网格中显示属性。此特性可用于在网格中隐藏属性。默认情况下，公共属性始终显示在网格中。\r\nReadOnlyAttribute\r\n表示属性是否为只读。此特性可用于禁止在网格中编辑属性。默认情况下，带有\r\nget 和 set 访问函数的公共属性在网格中是可以编辑的，如果只有 get\r\n访问器的公共属性也是只读的。\r\nDefaultValueAttribute\r\n表示属性的默认值。如果希望为属性提供默认值，然后确定该属性值是否与默认值相同，则可使用此特性。可以将此特性应用于所有属性。\r\nDefaultPropertyAttribute\r\n表示类的默认属性。在网格中选择某个类时，将首先突出显示该类的默认属性。\r\n\r\n\r\n如果想要在属性表中添加颜色选择和字体选择那是很容易一件事，可以在要展示的类中添加Color类型属性，和Font类型属性，绑定后，就可以进行颜色选择和字体选择了\r\n\r\n自定义显示\r\n我们可以看出这种上面这种显示属性方法并不够灵活，我们不能方便的及时增加或者删除属性。\r\n//属性表管理类public class PropertyManageCls : CollectionBase, ICustomTypeDescriptor&#123;    public void Add(Property value)    &#123;        int flag=-1;        if (value != null)        &#123;            if (base.List.Count&gt;0)            &#123;                IList &lt;Property&gt; mList=new List&lt;Property&gt;();                for (int i = 0; i &lt; base.List.Count; i++)                &#123;                    Property p = base.List[i] as Property;                    if (value.Name == p.Name)                    &#123;                        flag = i;                    &#125;                    mList.Add(p);                &#125;                if (flag == -1)                &#123;                    mList.Add(value);                &#125;                base.List.Clear();                foreach (Property p in mList)                &#123;                    base.List.Add(p);                &#125;            &#125;            else            &#123;                base.List.Add(value);            &#125;        &#125;    &#125;    public void Remove(Property value)    &#123;        if(value!=null&amp;&amp;base.List.Count&gt;0)        base.List.Remove(value);    &#125;    public Property this[int index]    &#123;        get        &#123;            return (Property)base.List[index];        &#125;        set        &#123;            base.List[index] = (Property)value;        &#125;    &#125;    #region ICustomTypeDescriptor 成员    public AttributeCollection GetAttributes()    &#123;        return TypeDescriptor.GetAttributes(this,true);    &#125;    public string GetClassName()    &#123;        return TypeDescriptor.GetClassName(this, true);    &#125;    public string GetComponentName()    &#123;        return TypeDescriptor.GetComponentName(this, true);    &#125;    public TypeConverter GetConverter()    &#123;        return TypeDescriptor.GetConverter(this, true);    &#125;    public EventDescriptor GetDefaultEvent()    &#123;        return TypeDescriptor.GetDefaultEvent(this, true);    &#125;    public PropertyDescriptor GetDefaultProperty()    &#123;        return TypeDescriptor.GetDefaultProperty(this, true);    &#125;    public object GetEditor(Type editorBaseType)    &#123;        return TypeDescriptor.GetEditor(this, editorBaseType, true);    &#125;    public EventDescriptorCollection GetEvents(Attribute[] attributes)    &#123;        return TypeDescriptor.GetEvents(this, attributes, true);    &#125;    public EventDescriptorCollection GetEvents()    &#123;        return TypeDescriptor.GetEvents(this,true);    &#125;    public PropertyDescriptorCollection GetProperties(Attribute[] attributes)    &#123;        PropertyDescriptor[] newProps = new PropertyDescriptor[this.Count];        for (int i = 0; i &lt; this.Count; i++)        &#123;            Property prop = (Property)this[i];            newProps[i] = new CustomPropertyDescriptor(ref prop, attributes);        &#125;        return new PropertyDescriptorCollection(newProps);    &#125;    public PropertyDescriptorCollection GetProperties()    &#123;        return TypeDescriptor.GetProperties(this, true);    &#125;    public object GetPropertyOwner(PropertyDescriptor pd)    &#123;        return this;            &#125;    #endregion&#125;//属性类public class Property&#123;    private string _name=string.Empty;    private object _value=null;    private bool _readonly=false;    private bool _visible=true;    private string _category=string.Empty;    TypeConverter _converter=null;    object _editor = null;    private string _displayname = string.Empty;    public Property(string sName, object sValue)    &#123;        this._name = sName;        this._value = sValue;    &#125;    public Property(string sName, object sValue, bool sReadonly, bool sVisible)    &#123;        this._name = sName;        this._value = sValue;        this._readonly = sReadonly;        this._visible = sVisible;    &#125;    public string Name  //获得属性名    &#123;        get        &#123;            return _name;        &#125;        set        &#123;            _name=value;        &#125;    &#125;    public string DisplayName   //属性显示名称    &#123;        get        &#123;            return _displayname;        &#125;        set        &#123;            _displayname = value;        &#125;    &#125;    public TypeConverter Converter  //类型转换器，我们在制作下拉列表时需要用到    &#123;        get         &#123;            return _converter;        &#125;        set        &#123;            _converter = value;        &#125;    &#125;    public string Category  //属性所属类别    &#123;        get        &#123;            return _category;        &#125;        set        &#123;            _category = value;        &#125;    &#125;    public object Value  //属性值    &#123;        get        &#123;            return _value;        &#125;        set        &#123;            _value=value;        &#125;    &#125;    public bool ReadOnly  //是否为只读属性    &#123;        get        &#123;            return _readonly;        &#125;        set        &#123;            _readonly = value;        &#125;    &#125;    public bool Visible  //是否可见    &#123;        get        &#123;            return _visible;        &#125;        set        &#123;            _visible = value;        &#125;    &#125;    public virtual object Editor   //属性编辑器    &#123;        get         &#123;             return _editor;         &#125;        set         &#123;             _editor = value;         &#125;    &#125;&#125;public class CustomPropertyDescriptor : PropertyDescriptor&#123;    Property m_Property;    public CustomPropertyDescriptor(ref Property myProperty, Attribute[] attrs)        : base(myProperty.Name, attrs)    &#123;        m_Property = myProperty;    &#125;    #region PropertyDescriptor 重写方法    public override bool CanResetValue(object component)    &#123;        return false;    &#125;    public override Type ComponentType    &#123;        get        &#123;            return null;        &#125;    &#125;    public override object GetValue(object component)    &#123;        return m_Property.Value;    &#125;    public override string Description    &#123;        get        &#123;            return m_Property.Name;        &#125;    &#125;    public override string Category    &#123;        get        &#123;            return m_Property.Category;        &#125;    &#125;    public override string DisplayName    &#123;        get        &#123;            return m_Property.DisplayName!=&quot;&quot;?m_Property.DisplayName:m_Property.Name;        &#125;    &#125;    public override bool IsReadOnly    &#123;        get        &#123;            return m_Property.ReadOnly;        &#125;    &#125;    public override void ResetValue(object component)    &#123;        //Have to implement    &#125;    public override bool ShouldSerializeValue(object component)    &#123;        return false;    &#125;    public override void SetValue(object component, object value)    &#123;        m_Property.Value = value;    &#125;    public override TypeConverter Converter    &#123;        get        &#123;            return m_Property.Converter;        &#125;    &#125;    public override Type PropertyType    &#123;        get &#123; return m_Property.Value.GetType(); &#125;    &#125;    public override object GetEditor(Type editorBaseType)    &#123;        return m_Property.Editor==null? base.GetEditor(editorBaseType):m_Property.Editor;    &#125;    #endregion&#125;\r\n下面我们来看看该如何使用，我们仍然在Form_load中添加代码如下：\r\nPropertyManageCls pmc = new PropertyManageCls();Property pp = new Property(&quot;ID&quot;, &quot;1&quot;, false, true);pp.Category = &quot;基本信息&quot;;pp.DisplayName = &quot;我的ID&quot;;pmc.Add(pp);propertyGrid1.SelectObject=pmc;\r\n显示结果：\r\n\r\n实现下拉框\r\n要实现下拉框，需要使用类型转换器，继承与TypeConverter或者StringConverter，然后重写方法，代码如下：\r\n//下拉框类型转换器public class DropDownListConverter : StringConverter&#123;    object[] m_Objects;    public DropDownListConverter(object[] objects)    &#123;        m_Objects = objects;    &#125;    public override bool GetStandardValuesSupported(ITypeDescriptorContext context)    &#123;        return true;    &#125;    public override bool GetStandardValuesExclusive(ITypeDescriptorContext context)    &#123;        return true;//true下拉框不可编辑    &#125;    public override    System.ComponentModel.TypeConverter.StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)    &#123;        //我们可以直接在内部定义一个数组，但并不建议这样做，这样对于下拉框的灵活性有很大影响        return new StandardValuesCollection(m_Objects);                // 此处一般是根据 context 中传递下来的 Instance，从中获取下拉的条件，动态生成下拉选项            &#125;&#125;\r\n我们实现了下拉框类型转换器，但该如何使用呢？\r\n\r\n方法一：在属性上方添加标记\r\n[TypeConverter(typeof(DropDownListConverter))]\r\n方法二：我们可以在外部定义数组，使用方便，使用方法代码如下：\r\nprivate void Form_load(object sender, EventArgs e)    &#123;            PropertyManageCls pmc = new PropertyManageCls();            string []s=new string[] &#123; &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot; &#125;;            Property pp = new Property(txtname.Text,txtvalue.Text, false, true);            pp.Category = &quot;基本信息&quot;;            pp.DisplayName = &quot;我的ID&quot;;            pp.Converter = new DropDownListConverter(s);//Property的Converter属性就可以设置类型转换            pmc.Add(pp);            propertyGrid1.SelectObject = pmc;&#125;\r\n\r\n效果图如下：\r\n\r\n\r\n20200721234055.png\r\n\r\n属性编辑器\r\n使用属性编辑器实现路径选择，属性编辑器需要继承与UITypeEditor。\r\n//文件路径选择                                                                                                                     public class PropertyGridFileItem : UITypeEditor&#123;    public override UITypeEditorEditStyle GetEditStyle(System.ComponentModel.ITypeDescriptorContext context)    &#123;        return UITypeEditorEditStyle.Modal;    &#125;    public override object EditValue(System.ComponentModel.ITypeDescriptorContext context, System.IServiceProvider provider, object value)    &#123;        IWindowsFormsEditorService edSvc =            (IWindowsFormsEditorService)provider.GetService(typeof(IWindowsFormsEditorService));        if (edSvc != null)        &#123;            // 可以打开任何特定的对话框            OpenFileDialog dialog = new OpenFileDialog();            dialog.AddExtension = false;            if (dialog.ShowDialog().Equals(DialogResult.OK))            &#123;                return dialog.FileName;            &#125;        &#125;        return value;    &#125;&#125;\r\n使用方法：\r\n\r\n在属性上方添加标记[EditorAttribute(typeof(PropertyGridFileItem),\r\ntypeof(System.Drawing.Design.UITypeEditor))]\r\n使用代码\r\nprivate void Form_load(object sender, EventArgs e)&#123;    PropertyManageCls pmc = new PropertyManageCls();    Property pp = new Property(txtname.Text,txtvalue.Text, false, true);    pp.Category = &quot;基本信息&quot;;    pp.DisplayName = &quot;我的ID&quot;;    pp.Editor= new PropertyGridFileItem();//Property的Editor属性就可以设置属性编辑    pmc.Add(pp);    propertyGrid1.SelectObject = pmc;&#125;\r\n\r\n效果图如下：\r\n\r\n自定义要显示的属性\r\nPropertyGrid\r\n默认显示所有的公开属性，包括父类的公开属性。在使用的过程中，我们可能会有如下需求：\r\n\r\n只想显示子类的某些属性，而父类因为某些原因不能将它的属性标记为\r\n[Browsable(false)]\r\n想通过自定义的 Attribute 来控制属性的显示\r\n\r\n这个时候，我们就需要对显示的属性进行筛选。我们通过实现\r\nICustomTypeDescriptor，然后重写方法\r\npublic PropertyDescriptorCollection GetProperties(Attribute[] attributes)\r\n来实现。\r\n实现部分代码如下：\r\npublic class NamedGroup :ICustomTypeDescriptor&#123;    #region ICustomTypeDescriptor    public AttributeCollection GetAttributes()    &#123;        return TypeDescriptor.GetAttributes(this, true);    &#125;    public string GetClassName()    &#123;        return TypeDescriptor.GetClassName(this, true);    &#125;    public string GetComponentName()    &#123;        return TypeDescriptor.GetComponentName(this, true);    &#125;    public TypeConverter GetConverter()    &#123;        return TypeDescriptor.GetConverter(this, true);    &#125;    public EventDescriptor GetDefaultEvent()    &#123;        return TypeDescriptor.GetDefaultEvent(this, true);    &#125;    public PropertyDescriptor GetDefaultProperty()    &#123;        return TypeDescriptor.GetDefaultProperty(this, true);    &#125;    public object GetEditor(Type editorBaseType)    &#123;        return TypeDescriptor.GetEditor(this, editorBaseType, true);    &#125;    public EventDescriptorCollection GetEvents()    &#123;        return TypeDescriptor.GetEvents(this, true);    &#125;    public EventDescriptorCollection GetEvents(Attribute[] attributes)    &#123;        return TypeDescriptor.GetEvents(this, attributes, true);    &#125;    public object GetPropertyOwner(PropertyDescriptor pd)    &#123;        return this;    &#125;    // 修改此属性，进行展示    public PropertyDescriptorCollection GetProperties()    &#123;        return TypeDescriptor.GetProperties(this,true);    &#125;    public PropertyDescriptorCollection GetProperties(Attribute[] attributes)    &#123;        // 特别注意，此处的 true 代表不使用当前类的 GetProperties 方法来获取属性，默认为 false,这会导致无限循环，从而导致栈溢出        PropertyDescriptorCollection pdc = TypeDescriptor.GetProperties(this, attributes, true);        PropertyDescriptor[] properties = pdc.Cast&lt;PropertyDescriptor&gt;().Where(item =&gt; item.Attributes.Cast&lt;Attribute&gt;().Any(itemA =&gt; itemA is BrowsableAttribute ba &amp;&amp; ba.Browsable)).ToArray();        return new PropertyDescriptorCollection(properties);    &#125;        #endregion&#125;\r\n致谢\r\n[1]. 本文来源：C#自定义PropertyGrid属性\r\n更多参考资料\r\n[1]. PropertyGrid控件心得\r\n[2]. Customized\r\ndisplay of collection data in a PropertyGrid\r\n[3]. TypeConverter的层次结构\r\n[4]. 关于PropertyGrid中属性的值动态从数据库取出\r\n[5]. 动态可订制属性的\r\nPropertyGrid\r\n","categories":["Develop","DotNET","WPF"],"tags":["C#",".NET"]},{"title":".NET Core 单元测试从零基础到项目应用","url":"/posts/2022/3D1SMMC.html","content":"本文讲述了如何在 .NET Core\r\n的项目中从零开始搭建单元测试，然后达到项目应用的程度。通过本文，你可以\r\nget 以下知识：\r\n\r\n.NET 中现有单元测试框架有哪些\r\n为什么选择 MSTest 框架\r\n如何创建一个单元测试\r\n怎么运行单元测试\r\n\r\n框架选型\r\n我们在使用一种技术时，往往需要对现有技术调研，通过比较最终确定使用哪个。.NET\r\n官方推荐的单元测试有 3 种：xUnit、NUnit、MSTest。\r\n除了标注测试类和方法的特性用的不一样之外，它们是非常相似的。而 MSTest\r\n与 VisualStudio 集成度更高，所以本人建议使用 MSTest。\r\nStackOverflow 看到一条我很赞同的看法：\r\n\r\n其实不用顾虑那么多，随便选择吧，MSTest 对 VS\r\n的集成是最好的，而且也很容易上手，如果哪一天碰到它所无法解决的事情，切换到其他框架也非常简单，仅仅只是Nuget下个包，换下特性而已。\r\n\r\n添加单元测试\r\n在 VS 中，选中方法名，右键 -&gt; 创建单元测试，点击确定。\r\n通过上述步骤，VS\r\n会自动创建一个单元测试项目，在该项目里面自动生成单元测试内容。\r\n// 标记测试类[TestClass()]public class MinioAdapterTests&#123;    // 标记测试方法    [TestMethod()]    public void BucketExistsAsyncTest()    &#123;        // 在此处编写单元测试代码        Assert.Fail();    &#125;&#125;\r\n编写测试案例\r\n依赖注入怎么测试\r\nASP.NET Core 支持依赖关系注入 (DI)\r\n软件设计模式，并且默认注入了很多服务，具体可以参考 官方文档,\r\n相信只要使用过依赖注入框架的同学，都会对此有不同深入的理解，在此无需赘言。\r\n然而，在引入 IOC 框架之后，对于之前常规的对于类的依赖（new\r\nClass）变成通过构造函数对于接口的依赖（ASP.NET CORE\r\n默认注入方式），这本身更加符合依赖倒置原则，但是对于单元测试来说确会带来另一个问题：\r\n由于层层依赖，导致在某个类的方法进行测试的时候，需要构造一大堆该类依赖的接口的实现，非常麻烦。\r\n这个时候，我们脑子里会下意识想一个问题：为什么常用的 .Net\r\n单元测试框架不支持依赖注入？\r\n于是笔者带着这个问题在查阅了一些关于在单元测试中支持依赖注入的讨论Github\r\nIssue,以及其他的相关文档，突然明白一个之前一直忽视但实际却非常重要的问题：\r\n\r\n在对于一个方法的单元测试中，我们应该关注的是这个方法内部的逻辑测试，而这个方法内部对于外部的依赖，则不在这个单元测试关注的范围内\r\n\r\n换言之，单元测试永远都只关注需要测试的方法内部的逻辑实现，至于外部依赖方法的测试，则应该放在另一个专门针对这个方法的单元测试用例中。\r\n弄清楚这个问题，我们才能更加理解另一个单元测试不可缺少的框架——Mock框架。在我们写的测试中，应该忽略外部依赖具体的实现，而是通过模拟该接口方法来显示的指定返回值，从而降低该返回值对于当前单元测试结果的影响，而\r\nMock 框架（例如最常用的Moq），刚好可以满足我们对于接口的模拟需求。\r\n\r\n相信有同学跟我有同样的疑惑，并且当我尝试在 ASP.NET Core\r\n单元测试中的一切外部依赖通过 Mock\r\n的方式进行编写的时候，遇到了一些问题，下文会将这些问题一一道来，希望对有同样疑惑的同学有所帮助。\r\n\r\nMock 框架选择\r\n在 .NET 中有几种 mock 框架可供选择，比如\r\nNMock、PhinoMocks、FakeItEasy和Moq。尽管Moq相对较新，但是它非常易用。不需要像传统的\r\nRecord/Replay。并且使用 Moq 在 VS\r\n中可以得到智能提示。学习成本也不高。\r\n所以选择 Moq 作为 Mock\r\n数据框架。Moq 有一个自动 Mock 库 Moq.AutoMock，建议安装该库。\r\nMoq 基本使用\r\nvar mock = new Mock&lt;ILoveThisLibrary&gt;();// WOW! No record/replay weirdness?! :)// 给 DownloadExists 传递一个参数，并使其返回 truemock.Setup(library =&gt; library.DownloadExists(&quot;2.0.0.0&quot;))      .Returns(true);// Use the Object property on the mock to get a reference to the object// implementing ILoveThisLibrary, and then exercise it by calling// methods on itILoveThisLibrary lovable = mock.Object;bool download = lovable.DownloadExists(&quot;2.0.0.0&quot;);// Verify that the given method was indeed called with the expected value at most oncemock.Verify(library =&gt; library.DownloadExists(&quot;2.0.0.0&quot;), Times.AtMostOnce());\r\n上面的方式可以简化成：\r\nILoveThisLibrary lovable = Mock.Of&lt;ILoveThisLibrary&gt;(l =&gt;    l.DownloadExists(&quot;2.0.0.0&quot;) == true);// Exercise the instance returned by Mock.Of by calling methods on it...bool download = lovable.DownloadExists(&quot;2.0.0.0&quot;);// Simply assert the returned state:Assert.True(download);  // If you really want to go beyond state testing and want to // verify the mock interaction instead...Mock.Get(lovable).Verify(library =&gt; library.DownloadExists(&quot;2.0.0.0&quot;));\r\n简而言之，Mock 数据的使用步骤可总结如下：\r\n\r\n新建一个 Mock 实例 mock\r\n通过 mock 设置方法的返回值\r\n通过 mock.Object 获取 Mock\r\n的对象来传递给目标方法使用\r\n\r\nMoq.AutoMock 使用\r\n基本使用方法\r\nvar mocker = new AutoMocker();var car = mocker.CreateInstance&lt;Car&gt;();car.DriveTrain.ShouldNotBeNull();car.DriveTrain.ShouldImplement&lt;IDriveTrain&gt;();Mock&lt;IDriveTrain&gt; mock = Mock.Get(car.DriveTrain);\r\n注入现有实例\r\nvar mocker = new AutoMocker();mocker.Use&lt;IDriveTrain&gt;(new DriveTrain());// OR, setup a Mockmocker.Use&lt;IDriveTrain&gt;(x =&gt; x.Shaft.Length == 5);var car = mocker.CreateInstance&lt;Car&gt;();\r\n结语\r\nCI/CD 流程中应该包含单元测试\r\n例如在编写 Repository\r\n层进行单元测试时，经常有同学会编写依赖于数据库数据的单元测试，这样并不利于随时随地的进行单元测试检查。\r\n如果将该流程放在 CI/CD\r\n中，在代码的发布过程中通过单元测试可以检查代码逻辑的正确性，同时依赖于数据库的单元测试将不会通过（通常情况下，生产环境和开发环境隔离），变相迫使开发小伙伴通过\r\nmock 方式模拟数据库返回结果。\r\n这个原则同样适用于不能依赖三方API编写单元测试。\r\n\r\nCI/CD 是一种通过在应用开发阶段引入自动化来频繁向客户交付应用的方法。CI/CD\r\n的核心概念是持续集成、持续交付和持续部署。作为一个面向开发和运营团队的解决方案，CI/CD\r\n主要针对在集成新代码时所引发的问题（亦称：\"集成地狱\"）。\r\n点击查看更多内容\r\n\r\n单元测试覆盖率\r\n通常很多开发 Leader\r\n都会要求开发团队编写单元测试，但是很少检查单元测试的质量，即单元测试最重要的指标——单元测试代码覆盖率，如果不注重覆盖率的提升，那么很有可能会导致开发成员为了单元测试而写单元测试，预期就会与实际情况相差甚远。\r\n保证单元测试代码覆盖率，将会大大降低代码变更带来的 Bug\r\n率，从而节省整体开发成本。\r\n新人问题：为何要写单元测试？\r\n对于初次开始编写单元测试的开发人员，脑中经常会对此表示怀疑：我为什么要去验证一堆我自己写的正确的逻辑？\r\n实际这个问题包含了区分一个一般开发人员和优秀开发人员很重要的一个条件：他是否会反向思考当前逻辑的正确性。有了这种思维，看待问题才会从多个角度入手分析，对问题的本质掌握更加全面。\r\n不要怀疑，坚持写单元测试，因为这本身也是对反向思维的一种锻炼，以笔者的经验，只有当编写过一段时间之后，才会真正认识单元测试的魅力，并且开始非常习惯的在写一段逻辑之后，顺手写了对于它的单元测试。\r\n即使笔者也算很早就开始写单元测试了，但直到写这篇文章，仍然不断在加深对单元测试的认识。\r\n参考\r\n\r\nC#常用单元测试框架比较：XUnit,\r\nNUnit, 和 Visual Studio(MSTest)\r\nTesting in\r\n.NET\r\nAsp.Net Core\r\n单元测试正确姿势\r\nC#单元测试：使用Moq框架Mock对象\r\n\r\n","categories":["Develop","DotNET","单元测试"],"tags":[".NET Core","单元测试"]},{"title":"WPF中修改TextBox的行高及实现RichTextBox绑定","url":"/posts/2020/1PP7XJ3.html","content":"在 WPF 中，有时需要利用 TexTBox\r\n来多行展示数据，但是，它默认的行高太丑，需要我们自己定义。\r\n\r\n设置如下属性即可：\r\n&lt;TextBox TextBlock.LineHeight=&quot;10&quot; TextBlock.LineStackingStrategy=&quot;BlockLineHeight&quot; /&gt; \r\n当然，也有可能会用 RichTextBox，这就不会有这个问题，但是 WPF\r\n的富文本不能进行 Text 绑定，所以在 MVVM 中，用起来很难受。\r\n幸好，有一个扩展可以解决这个问题，它叫 wpftoolkit\r\n用法如下：\r\n&lt;toolkit:RichTextBox x:Name=&quot;_richTextBox&quot; Grid.Row=&quot;1&quot; Margin=&quot;10&quot; BorderBrush=&quot;Gray&quot; Padding=&quot;10&quot;                                          Text=&quot;&#123;Binding Notes&#125;&quot;                                           ScrollViewer.VerticalScrollBarVisibility=&quot;Auto&quot; /&gt;\r\n","categories":["Develop","DotNET","WPF"],"tags":["WPF","TextBox"]},{"title":"WPF中修改TextBox的行高及实现RichTextBox绑定","url":"/posts/2020/1PP7XJ3.html","content":"在 WPF 中，有时需要利用 TexTBox\r\n来多行展示数据，但是，它默认的行高太丑，需要我们自己定义。\r\n\r\n设置如下属性即可：\r\n&lt;TextBox TextBlock.LineHeight=&quot;10&quot; TextBlock.LineStackingStrategy=&quot;BlockLineHeight&quot; /&gt; \r\n当然，也有可能会用 RichTextBox，这就不会有这个问题，但是 WPF\r\n的富文本不能进行 Text 绑定，所以在 MVVM 中，用起来很难受。\r\n幸好，有一个扩展可以解决这个问题，它叫 wpftoolkit\r\n用法如下：\r\n&lt;toolkit:RichTextBox x:Name=&quot;_richTextBox&quot; Grid.Row=&quot;1&quot; Margin=&quot;10&quot; BorderBrush=&quot;Gray&quot; Padding=&quot;10&quot;                                          Text=&quot;&#123;Binding Notes&#125;&quot;                                           ScrollViewer.VerticalScrollBarVisibility=&quot;Auto&quot; /&gt;\r\n","categories":["Develop","DotNET","WPF"],"tags":["WPF","TextBox"]},{"title":"C# 获取枚举上的 Description 特性值","url":"/posts/2022/9RVNQC.html","content":"有些时候，我们会利用枚举来进行数据映射，通过会在枚举上添加\r\nDescription 特性来标记映射的值。\r\n本文介绍如何获取枚举上的描述。\r\n\r\n枚举定义：\r\npublic enum BookType&#123;    [Descrption(&quot;语文&quot;)]    Chinese,        [Descrption(&quot;数学&quot;)]    Math&#125;\r\n通过枚举获取描述：\r\n/// &lt;summary&gt;/// 获取枚举的描述值/// &lt;/summary&gt;/// &lt;param name=&quot;enum&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static string GetDescription(this Enum @enum)&#123;    string value = @enum.ToString();    FieldInfo field = @enum.GetType().GetField(value);    // 获取描述特性，禁止继承的特性    object[] objs = field.GetCustomAttributes(typeof(DescriptionAttribute), false);    // 当描述特性没有时，直接返回名称    if (objs.Length == 0)        return value;    DescriptionAttribute descriptionAttribute = (DescriptionAttribute)objs[0];    return descriptionAttribute.Description;&#125;\r\n通过描述获取枚举：\r\n/// &lt;summary&gt;/// 通过描述获取枚举值/// &lt;/summary&gt;/// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;/// &lt;param name=&quot;description&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;/// &lt;exception cref=&quot;DllNotFoundException&quot;&gt;&lt;/exception&gt;public static T GetEnumByDescription&lt;T&gt;(this string description) where T : Enum&#123;    FieldInfo[] fields = typeof(T).GetFields();    foreach(var field in fields)    &#123;        object[] objs = field.GetCustomAttributes(typeof(DescriptionAttribute), false);        if(objs.Length&gt;0 &amp;&amp; objs[0] is DescriptionAttribute da &amp;&amp; da.Description == description)        &#123;            return (T)field.GetValue(null);        &#125;    &#125;    throw new DllNotFoundException($&quot;not found &#123;description&#125;&quot;);&#125;\r\n","categories":["Develop","DotNET","实用代码"],"tags":["C#","实用代码"]},{"title":"数组下标无限循环算法","url":"/posts/2021/1MAH7MY.html","content":"在进行数组访问时，为了防止数组溢出，可以在在使用中对下标进行处理。处理代码如下：\r\n\r\n// 用于for循环中，最大值溢出时返回到开始public static int CycleInt(this int index, int count)&#123;    int indexTemp = index % count;    if (index &lt; 0) return count + indexTemp;    return indexTemp;&#125;\r\n","categories":["Develop","DotNET","实用代码"],"tags":["C#","实用代码"]},{"title":"C# 通过 ()=>obj.Property 的形式获取实例和属性名","url":"/posts/2022/1A0Q13P.html","content":"在利用反射编程的时候，我们有时候往往需要通过对象的属性来获取属性名和其对象，例\r\n()=&gt;obj.Property。这样做的好处是：属性名称不再是字符串，而是直接从属性名获取，方便后期维护。\r\n\r\n正文\r\n实现代码如下：\r\npublic static Tuple&lt;object, MemberInfo&gt; GetFieldInfoAndInstance&lt;T&gt;(Expression&lt;Func&lt;T&gt;&gt; lambdaExpression)&#123;    // 获取 memberInfo    MemberExpression memberExpression = (!(lambdaExpression.Body is UnaryExpression expression)) ? ((MemberExpression)lambdaExpression.Body) : ((MemberExpression)expression.Operand);    MemberInfo memberInfo = memberExpression.Member;    // 获取实例    MemberExpression instanceMemberInfoExp = memberExpression.Expression as MemberExpression;    FieldInfo instanceFieldInfo = instanceMemberInfoExp.Member as FieldInfo;    var classInstanceExp = instanceMemberInfoExp.Expression as ConstantExpression;    var instance = instanceFieldInfo.GetValue(classInstanceExp.Value);    return new Tuple&lt;object, MemberInfo&gt;(instance, memberInfo);&#125;\r\n使用代码\r\n// student 是一个学生定义，此处不展示代码var student = new Student();// result 第一个值为 student 对象// result 第二个值为 student 中 Name 相关信息，通过它就可以获取 Name 的名称Tuple&lt;object, FieldInfo&gt; result = TestExpression.GetFieldInfoAndInstance(() =&gt; student.Name);\r\n参考\r\n\r\nHow\r\ncan I get object instance from ()=&gt;foo.Title expression\r\n\r\n","categories":["Develop","DotNET","实用代码"],"tags":["C#","实用代码"]},{"title":"通用的深复制功能实现","url":"/posts/2022/14XRC75.html","content":"在代码中经常会遇到需要把对象复制一遍，或者把属性名相同的值复制一遍。为了使得复制操作更加优雅，可以使用下列方式来进行复制，而不必针为每个类实现克隆操作。\r\n\r\n代码\r\n/// &lt;summary&gt;/// 深度复制/// 这样做了为了能够/// 参考 /// &lt;/summary&gt;public static class DeepClone&lt;TIn, TOut&gt;&#123;    private static Func&lt;TIn, TOut&gt; _cache = null;    private static Func&lt;TIn, TOut&gt; GetFunc()    &#123;        ParameterExpression parameterExpression = Expression.Parameter(typeof(TIn), &quot;p&quot;);        List&lt;MemberBinding&gt; memberBindingList = new List&lt;MemberBinding&gt;();        Type inType = typeof(TIn);        foreach (var item in typeof(TOut).GetProperties())        &#123;            if (!item.CanWrite)                continue;            // 有可能克隆目标为子类，父类中没有相应属性            var prop = inType.GetProperty(item.Name);            if (prop == null) continue;            MemberExpression property = Expression.Property(parameterExpression,prop);            MemberBinding memberBinding = Expression.Bind(item, property);            memberBindingList.Add(memberBinding);        &#125;        MemberInitExpression memberInitExpression = Expression.MemberInit(Expression.New(typeof(TOut)), memberBindingList.ToArray());        Expression&lt;Func&lt;TIn, TOut&gt;&gt; lambda = Expression.Lambda&lt;Func&lt;TIn, TOut&gt;&gt;(memberInitExpression, new ParameterExpression[] &#123; parameterExpression &#125;);        return lambda.Compile();    &#125;    /// &lt;summary&gt;    /// 获取结果    /// &lt;/summary&gt;    /// &lt;param name=&quot;tIn&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public static TOut Clone(TIn tIn)    &#123;        if (_cache == null) _cache = GetFunc();        return _cache(tIn);    &#125;&#125;\r\n参考\r\nC#\r\n快速高效率复制对象（表达式树）\r\nC#基于表达式（Expression）实现对象深拷贝\r\n","categories":["Develop","DotNET","实用代码"],"tags":["C#","实用代码"]},{"title":"C# 读取嵌入的文件","url":"/posts/2021/2P07T4K.html","content":"如何在 C# 中读取嵌入的文件资源？\r\n\r\n// 读取程序中嵌入的文件Stream stream = Assembly.GetExecutingAssembly().GetManifestResourceStream(&quot;命名空间.文件夹名（多层级用.分隔）.文件名（带后缀）&quot;);StreamReader sr = new StreamReader(stream, Encoding.UTF8); // 编码格式用utf8，防止中文乱码var systemShortcutsConfig = sr.ReadToEnd();sr.Close();stream.Close();\r\n","categories":["Develop","DotNET","实用代码"],"tags":["C#","实用代码"]},{"title":"非常完善的 Log4net使用说明","url":"/posts/2020/3T2VKQ2.html","content":"概述\r\nlog4net 是 .Net 下一个非常优秀的开源日志记录组件。log4net\r\n记录日志的功能非常强大。它可以将日志分不同的等级，以不同的格式，输出到不同的媒介。本文主要是介绍如何在\r\nVisual Studio 中使用 log4net\r\n快速创建系统日志，如何扩展以输出自定义字段。\r\n\r\n一个简单的使用实例\r\n\r\n添加 log4net 包\r\n# 进入到 .csproj 目录# 执行下列命令安装 logt4netdotnet add package log4net\r\n创建 log4net 配置文件\r\n在项目根目录（.csproj 所在目录）创建\r\nlog4net.config\r\n配置文件，并修改文件属性为：得到到输出目录：始终复制。\r\n配置文件内容如下：\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;log4net&gt;    &lt;root&gt;      &lt;!--可填值 DEBUG:调试 INFO:信息 WARN:警告 ERROR:错误 FATAL:致命--&gt;      &lt;level value=&quot;DEBUG&quot;/&gt;      &lt;appender-ref ref=&quot;console&quot;/&gt;      &lt;appender-ref ref=&quot;rollingFile&quot;/&gt;    &lt;/root&gt;    &lt;logger name=&quot;Mxt&quot;&gt;      &lt;level value=&quot;DEBUG&quot;/&gt;    &lt;/logger&gt;    &lt;appender name=&quot;trace&quot; type=&quot;log4net.Appender.TraceAppender,log4net&quot;&gt;      &lt;layout type=&quot;log4net.Layout.PatternLayout,log4net&quot;&gt;        &lt;param name=&quot;ConversionPattern&quot; value=&quot;T %d&#123;ABSOLUTE&#125; %-5p %c&#123;1&#125;:%L - %m%n&quot;/&gt;      &lt;/layout&gt;    &lt;/appender&gt;    &lt;appender name=&quot;console&quot; type=&quot;log4net.Appender.ConsoleAppender, log4net&quot;&gt;      &lt;layout type=&quot;log4net.Layout.PatternLayout,log4net&quot;&gt;        &lt;param name=&quot;ConversionPattern&quot; value=&quot;%d&#123;ABSOLUTE&#125; %-5p %c&#123;1&#125;:%L - %m%n&quot;/&gt;      &lt;/layout&gt;    &lt;/appender&gt;    &lt;appender name=&quot;rollingFile&quot; type=&quot;log4net.Appender.RollingFileAppender,log4net&quot;&gt;      &lt;param name=&quot;File&quot; value=&quot;Logs/log-file&quot;/&gt;      &lt;param name=&quot;AppendToFile&quot; value=&quot;true&quot;/&gt;      &lt;param name=&quot;RollingStyle&quot; value=&quot;Date&quot;/&gt;      &lt;param name=&quot;DatePattern&quot; value=&quot;.yyyy.MM.dd.&amp;quot;log&amp;quot;&quot;/&gt;      &lt;param name=&quot;StaticLogFileName&quot; value=&quot;true&quot;/&gt;      &lt;filter type=&quot;log4net.Filter.LevelRangeFilter&quot;&gt;        &lt;param name=&quot;LevelMin&quot; value=&quot;DEBUG&quot; /&gt;        &lt;param name=&quot;LevelMax&quot; value=&quot;WARN&quot; /&gt;      &lt;/filter&gt;      &lt;layout type=&quot;log4net.Layout.PatternLayout,log4net&quot;&gt;        &lt;param name=&quot;ConversionPattern&quot; value=&quot;%d %-5p [%t] %c - %m%n&quot;/&gt;      &lt;/layout&gt;    &lt;/appender&gt;  &lt;/log4net&gt;\r\n告诉 log4net 加载配置\r\n在项目中的 AssemblyInfo.cs 文件末尾，追加如下配置：\r\n[assembly: log4net.Config.XmlConfigurator(ConfigFile = &quot;log4net.config&quot;,Watch = true)]\r\n\r\n上述配置相当于在代码中调用：XmlConfigurator.Configure(fileInfo)\r\n\r\n更多配置参考：Apache\r\nlog4net – Apache log4net Manual: Configuration - Apache\r\nlog4net\r\n使用\r\nclass Program&#123;    private static readonly log4net.ILog log = log4net.LogManager.GetLogger(System.Reflection.MethodBase.GetCurrentMethod().DeclaringType);    static void Main(string[] args)    &#123;        log.Info(&quot;Hello logging world!&quot;);        Console.WriteLine(&quot;Hit enter&quot;);        Console.ReadLine();    &#125;&#125;\r\n这样就将信息同时输出到控制台和写入到文件名为 “Logs-file.txt”\r\n的文件中，也可以定义为绝对路径，配置如：&lt;param name=\"File\" value=\"C:/log-file.txt\" /&gt;\r\n就写入C盘根目录下log-file.txt文件中。\r\n\r\nLog4net的主要组成部分\r\nAppenders\r\nAppenders 用来定义日志的输出方式，即日志要写到那种介质上去。较常用的\r\nLog4net\r\n已经实现好了，直接在配置文件中调用即可，可参见上面配置文件例子；当然也可以自己写一个，需要从\r\nlog4net.Appender.AppenderSkeleton 类继承。它还可以通过配置\r\nFilters 和 Layout 来实现日志的过滤和输出格式。\r\n已经实现的输出方式有：\r\n\r\nAdoNetAppender 将日志记录到数据库中。可以采用 SQL\r\n和存储过程两种方式。\r\nAnsiColorTerminalAppender 将日志高亮输出到 ANSI 终端。\r\nAspNetTraceAppender 能用 asp.net中Trace\r\n的方式查看记录的日志。\r\nBufferingForwardingAppender 在输出到子 Appenders\r\n之前先缓存日志事件。\r\nConsoleAppender 将日志输出到应用程序控制台。\r\nEventLogAppender 将日志写到 Windows Event Log。\r\nFileAppender 将日志输出到文件。\r\nForwardingAppender 发送日志事件到子 Appenders。\r\nLocalSyslogAppender 将日志写到 local syslog service (仅用于 UNIX\r\n环境下)。\r\nMemoryAppender 将日志存到内存缓冲区。\r\nNetSendAppender 将日志输出到 Windows Messenger service.\r\n这些日志信息将在用户终端的对话框中显示。\r\nOutputDebugStringAppender 将日志输出到 Debuger，如果程序没有\r\nDebuger，就输出到系统 Debuger。如果系统 Debuger\r\n也不可用，将忽略消息。\r\nRemoteSyslogAppender 通过 UDP 网络协议将日志写到 Remote syslog\r\nservice。\r\nRemotingAppender 通过 .NET Remoting\r\n将日志写到远程接收端。\r\nRollingFileAppender 将日志以回滚文件的形式写到文件中。\r\nSmtpAppender 将日志写到邮件中。\r\nSmtpPickupDirAppender 将消息以文件的方式放入一个目录中，像 IIS\r\nSMTP agent 这样的 SMTP 代理就可以阅读或发送它们。\r\nTelnetAppender 客户端通过 Telnet 来接受日志事件。\r\nTraceAppender 将日志写到 .NET trace 系统。\r\nUdpAppender 将日志以无连接 UDP 数据报的形式送到远程宿主或用\r\nUdpClient 的形式广播。\r\n\r\nFilters\r\n使用过滤器可以过滤掉 Appender 输出的内容。过滤器通常有以下几种：\r\n\r\nDenyAllFilter 阻止所有的日志事件被记录\r\nLevelMatchFilter 只有指定等级的日志事件才被记录\r\nLevelRangeFilter 日志等级在指定范围内的事件才被记录\r\nLoggerMatchFilter 与Logger名称匹配，才记录\r\nPropertyFilter 消息匹配指定的属性值时才被记录\r\nStringMathFilter 消息匹配指定的字符串才被记录\r\n\r\nLayouts\r\nLayout 用于控制 Appender 的输出格式，可以是线性的也可以是 XML。\r\n一个 Appender 只能有一个Layout。\r\n最常用的 Layout 应该是经典格式的 PatternLayout，其次是\r\nSimpleLayout，RawTimeStampLayout 和 ExceptionLayout。然后还有\r\nIRawLayout，XMLLayout 等几个，使用较少。Layout\r\n可以自己实现，需要从log4net.Layout.LayoutSkeleton\r\n类继承，来输出一些特殊需要的格式，在后面扩展时就重新实现了一个\r\nLayout。\r\n\r\nSimpleLayout 简单输出格式，只输出日志级别与消息内容。\r\nRawTimeStampLayout\r\n用来格式化时间，在向数据库输出时会用到。\r\n\r\n样式如 “yyyy-MM-dd HH:mm:ss“\r\n\r\nExceptionLayout 需要给 Logger 的方法传入 Exception\r\n对象作为参数才起作用，否则就什么也不输出。输出的时候会包含 Message 和\r\nTrace。\r\nPatterLayout 使用最多的一个\r\nLayout，能输出的信息很多，使用方式可参见上面例子中的配置文件。PatterLayout\r\n的格式化字符串见文后附注8.1。\r\n\r\nLoggers\r\nLogger 是直接和应用程序交互的组件。Logger\r\n只是产生日志，然后由它引用的 Appender 记录到指定的媒介，并由 Layout\r\n控制输出格式。\r\nLogger 提供了多种方式来记录一个日志消息，也可以有多个 Logger\r\n同时存在。每个实例化的 Logger 对象对被log4net 作为命名实体（Named\r\nEntity）来维护。log4net 使用继承体系，也就是说假如存在两个\r\nLogger，名字分别为 a.b.c 和 a.b。那么 a.b 就是 a.b.c 的祖先。每个 Logger\r\n都继承了它祖先的属性。所有的 Logger 都从 Root 继承，Root 本身也是一个\r\nLogger。\r\n日志的等级，它们由高到底分别为：\r\nOFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; ALL\r\n高于等级设定值方法（如何设置参见“配置文件详解”）都能写入日志， Off\r\n所有的写入方法都不写到日志里，ALL则相反。例如当我们设成 Info\r\n时，logger.Debug 就会被忽略而不写入文件，但是 FATAL,ERROR,WARN,INFO\r\n会被写入，因为他们等级高于 INFO。\r\n在具体写日志时，一般可以这样理解日志等级：\r\n\r\nFATAL（致命错误）：记录系统中出现的能使用系统完全失去功能，服务停止，系统崩溃等使系统无法继续运行下去的错误。例如，数据库无法连接，系统出现死循环。\r\nERROR（一般错误）：记录系统中出现的导致系统不稳定，部分功能出现混乱或部分功能失效一类的错误。例如，数据字段为空，数据操作不可完成，操作出现异常等。\r\nWARN（警告）：记录系统中不影响系统继续运行，但不符合系统运行正常条件，有可能引起系统错误的信息。例如，记录内容为空，数据内容不正确等。\r\nINFO（一般信息）：记录系统运行中应该让用户知道的基本信息。例如，服务开始运行，功能已经开户等。\r\nDEBUG\r\n（调试信息）：记录系统用于调试的一切信息，内容或者是一些关键数据内容的输出。\r\n\r\nLogger 实现的 ILog接口，ILog 定义了 5\r\n个方法（Debug,Inof,Warn,Error,Fatal）分别对不同的日志等级记录日志。这 5\r\n个方法还有 5 个重载。以 Debug 为例说明一下，其它的和它差不多。\r\nILog中对Debug方法的定义如下：\r\nvoid Debug(object message);void Debug(object message, Exception ex);\r\n还有一个布尔属性：\r\nbool IsDebugEnabled &#123; get; &#125;\r\n如果使用 Debug(object message, Exception ex)，则无论 Layout\r\n中是否定义了 %exception，默认配置下日志都会输出 Exception。包括\r\nException 的 Message 和 Trace。如果使用 Debug(object\r\nmessage)，则日志是不会输出 Exception。\r\n最后还要说一个 LogManager 类，它用来管理所有的 Logger。它的 GetLogger\r\n静态方法，可以获得配置文件中相应的 Logger：\r\nlog4net.ILog log = log4net.LogManager.GetLogger(&quot;logger-name&quot;);\r\nObject Renders\r\n它将告诉 logger 如何把一个对象转化为一个字符串记录到日志里。（ILog\r\n中定义的接口接收的参数是 Object，而不是 String。）\r\n例如你想把 Orange 对象记录到日志中，但此时 logger 只会调用 Orange\r\n默认的 ToString 方法而已。所以要定义一个 OrangeRender 类实现\r\nlog4net.ObjectRender.IObjectRender\r\n接口，然后注册它（我们在本文中的扩展不使用这种方法，而是直接实现一个自定义的\r\nLayout）。这时 logger 就会知道如何把 Orange 记录到日志中了。\r\nRepository\r\nRepository 主要用于日志对象组织结构的维护。\r\n配置文件详解\r\n配置文件构成\r\n主要有两大部分，一是申明一个名为 “log4net“\r\n的自定义配置节，如下所示：\r\n&lt;configSections&gt;&lt;section name=&quot;log4net&quot;    type=&quot;log4net.Config.Log4NetConfigurationSectionHandler, log4net&quot; /&gt;&lt;/configSections&gt;\r\n二是 &lt;log4net&gt;\r\n节的具体配置，这是下面要重点说明的。\r\n&lt;log4net&gt;\r\n所有的配置都要在 &lt;log4net&gt; 元素里定义。\r\n支持的属性：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名称\r\n描述\r\n\r\n\r\n\r\n\r\ndebug\r\n可选，取值是true或false，默认是false。设置为true，开启log4net的内部调试。\r\n\r\n\r\nupdate\r\n可选，取值是Merge(合并)或Overwrite(覆盖)，默认值是Merge。设置为Overwrite，在提交配置的时候会重置已经配置过的库。\r\n\r\n\r\nthreshold\r\n可选，取值是repository（库）中注册的level，默认值是ALL。\r\n\r\n\r\n\r\n支持的子元素：\r\n\r\n\r\n\r\n名称\r\n描述\r\n\r\n\r\n\r\n\r\nappender\r\n0或多个\r\n\r\n\r\nlogger\r\n0或多个\r\n\r\n\r\nrenderer\r\n0或多个\r\n\r\n\r\nroot\r\n最多一个\r\n\r\n\r\nparam\r\n0或多个\r\n\r\n\r\n\r\n&lt;root&gt;\r\n实际上就是一个根 logger，所有其它 logger\r\n都默认继承它，如果配置文件里没有显式定义，则框架使用根日志中定义的属性。root\r\n元素没有属性。\r\n支持的子元素：\r\n\r\n\r\n\r\n名称\r\n描述\r\n\r\n\r\n\r\n\r\nappender-ref\r\n0个或多个，要引用的appender的名字。\r\n\r\n\r\nlevel\r\n最多一个。 只有在这个级别或之上的事件才会被记录。\r\n\r\n\r\nparam\r\n0个或多个， 设置一些参数。\r\n\r\n\r\n\r\n&lt;logger&gt;\r\n支持的属性：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名称\r\n描述\r\n\r\n\r\n\r\n\r\nname\r\n必须的，logger的名称\r\n\r\n\r\nadditivity\r\n可选，取值是true或false，默认值是true。设置为false时将阻止父logger中的appender。\r\n\r\n\r\n\r\n支持的子元素：\r\n\r\n\r\n\r\n名称\r\n描述\r\n\r\n\r\n\r\n\r\nappender-ref\r\n0个或多个，要引用的appender的名字。\r\n\r\n\r\nlevel\r\n最多一个。 只有在这个级别或之上的事件才会被记录。\r\n\r\n\r\nparam\r\n0个或多个， 设置一些参数。\r\n\r\n\r\n\r\n&lt;appender&gt;\r\n定义日志的输出方式，只能作为 log4net\r\n的子元素。name属性必须唯一，type属性必须指定。\r\n支持的属性：\r\n\r\n\r\n\r\n名称\r\n描述\r\n\r\n\r\n\r\n\r\nname\r\n必须的，Appender对象的名称\r\n\r\n\r\ntype\r\n必须的，Appender对象的输出类型\r\n\r\n\r\n\r\n支持的子元素：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名称\r\n描述\r\n\r\n\r\n\r\n\r\nappender-ref\r\n0个或多个，允许此appender引用其他appender，并不是所以appender类型都支持。\r\n\r\n\r\nfilter\r\n0个或多个，定义此app使用的过滤器。\r\n\r\n\r\nlayout\r\n最多一个。定义appender使用的输出格式。\r\n\r\n\r\nparam\r\n0个或多个， 设置Appender类中对应的属性的值。\r\n\r\n\r\n\r\n实际上 &lt;appender&gt;\r\n所能包含的子元素远不止上面4个。\r\n&lt;layout&gt;\r\n布局，只能作为 &lt;appender&gt; 的子元素。\r\n支持的属性：\r\n\r\n\r\n\r\n名称\r\n描述\r\n\r\n\r\n\r\n\r\ntype\r\n必须的，Layout的类型\r\n\r\n\r\n\r\n支持的子元素：\r\n\r\n\r\n\r\n名称\r\n描述\r\n\r\n\r\n\r\n\r\nparam\r\n0个或多个， 设置一些参数。\r\n\r\n\r\n\r\n&lt;filter&gt;\r\n过滤器，只能作为 &lt;appender&gt; 的子元素。\r\n支持的属性：\r\n\r\n\r\n\r\n名称\r\n描述\r\n\r\n\r\n\r\n\r\ntype\r\n必须的，Filter的类型\r\n\r\n\r\n\r\n支持的子元素：\r\n\r\n\r\n\r\n名称\r\n描述\r\n\r\n\r\n\r\n\r\nparam\r\n0个或多个， 设置一些参数。\r\n\r\n\r\n\r\n&lt;param&gt;\r\n&lt;param&gt; 元素可以是任何元素的子元素。\r\n支持的属性：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名称\r\n描述\r\n\r\n\r\n\r\n\r\nname\r\n必须的，取值是父对象的参数名。\r\n\r\n\r\nvalue\r\n可选的，value和type中，必须有一个属性被指定。value是一个能被转化为参数值的字符串。\r\n\r\n\r\ntype\r\n可选的，value和type中，必须有一个属性被指定。type是一个类型名，如果type不是在log4net程序集中定义的，就需要使用全名。\r\n\r\n\r\n\r\n支持的子元素：\r\n\r\n\r\n\r\n名称\r\n描述\r\n\r\n\r\n\r\n\r\nparam\r\n0个或多个， 设置一些参数。\r\n\r\n\r\n\r\n&lt;appender&gt; 配置\r\n&lt;appender&gt;\r\n在配置文件中至少有一个，也可以有多个，有些 &lt;appender&gt;\r\n类型还可以引用其他 &lt;appender&gt;\r\n类型，具体参数可参见上表。\r\n下面只对写入回滚文件与输出到数据库（这里使用 SQL\r\n数据库）配置体会说一下，其他配置可参考官方网站：http://logging.apache.org/log4net/release/config-examples.html\r\n写入回滚文件\r\n&lt;appender name=&quot;ReflectionLayout&quot; type=&quot;log4net.Appender.RollingFileAppender,log4net&quot;&gt;&lt;!--日志文件路径，“/”与“/”作用相同，到达的目录相同，文件夹不存在则新建 --&gt;&lt;!--按文件大小方式输出时在这里指定文件名，并且当天的日志在下一天时在文件名后自动追加当天日期形成新文件。--&gt;&lt;!—按照日期形式输出时，直接连接元素 DatePattern 的 value 形成文件路径。此处使用这种方式 --&gt;&lt;!--param的名称,可以直接查对应的appender类的属性名即可,这里要查的就是RollingFileAppender类的属性 --&gt;      &lt;param name=&quot;File&quot; value=&quot;D:/Log/&quot; /&gt;      &lt;!--是否追加到文件--&gt;      &lt;param name=&quot;AppendToFile&quot; value=&quot;true&quot; /&gt;      &lt;!--记录日志写入文件时，不锁定文本文件，防止多线程时不能写Log,官方说线程非安全--&gt;      &lt;lockingModel type=&quot;log4net.Appender.FileAppender+MinimalLock&quot; /&gt;      &lt;!--使用Unicode编码--&gt;      &lt;Encoding value=&quot;UTF-8&quot; /&gt;      &lt;!--最多产生的日志文件数，超过则只保留最新的n个。设定值value=&quot;－1&quot;为不限文件数--&gt;      &lt;param name=&quot;MaxSizeRollBackups&quot; value=&quot;10&quot; /&gt;      &lt;!--是否只写到一个文件中--&gt;      &lt;param name=&quot;StaticLogFileName&quot; value=&quot;false&quot; /&gt;      &lt;!--按照何种方式产生多个日志文件(日期[Date],文件大小[Size],混合[Composite])--&gt;      &lt;param name=&quot;RollingStyle&quot; value=&quot;Composite&quot; /&gt;      &lt;!--按日期产生文件夹和文件名［在日期方式与混合方式下使用］--&gt;       &lt;!—此处按日期产生文件夹，文件名固定。注意&quot; 的位置--&gt;      &lt;param name=&quot;DatePattern&quot; value=&quot;yyyy-MM-dd/&quot;ReflectionLayout.log&quot;&quot;  /&gt;        &lt;!—这是按日期产生文件夹，并在文件名前也加上日期--&gt;      &lt;param name=&quot;DatePattern&quot; value=&quot;yyyyMMdd/yyyyMMdd&quot;-TimerServer.log&quot;&quot;  /&gt;        &lt;!—这是先按日期产生文件夹，再形成下一级固定的文件夹—&gt;       &lt;param name=&quot;DatePattern&quot; value=&quot;yyyyMMdd/&quot;TimerServer/TimerServer.log&quot;&quot;  /&gt;      &lt;!--每个文件的大小。只在混合方式与文件大小方式下使用。超出大小后在所有文件名后自动增加正整数重新命名，数字最大的最早写入。可用的单位:KB|MB|GB。不要使用小数,否则会一直写入当前日志--&gt;      &lt;param name=&quot;maximumFileSize&quot; value=&quot;500KB&quot; /&gt;       &lt;!--计数类型为1，2，3…--&gt;      &lt;param name=&quot;CountDirection&quot; value=&quot;1&quot;/&gt;       &lt;!—过滤设置，LevelRangeFilter为使用的过滤器。 --&gt;      &lt;filter type=&quot;log4net.Filter.LevelRangeFilter&quot;&gt;        &lt;param name=&quot;LevelMin&quot; value=&quot;DEBUG&quot; /&gt;        &lt;param name=&quot;LevelMax&quot; value=&quot;WARN&quot; /&gt;      &lt;/filter&gt;       &lt;!--记录的格式。一般用log4net.Layout.PatternLayout布局--&gt;       &lt;!—此处用继承了log4net.Layout.PatternLayout的自定义布局，TGLog.ExpandLayout2为命名空间。%property&#123;Operator&#125;、%property&#123;Action&#125;是自定义的输出-－&gt;      &lt;layout type=&quot;TGLog.ExpandLayout2.ReflectionLayout,TGLog&quot;&gt;        &lt;param name=&quot;ConversionPattern&quot; value=&quot;记录时间：%date 线程ID:[%thread] 日志级别：%-5level 记录类：%logger     操作者ID：%property&#123;Operator&#125; 操作类型：%property&#123;Action&#125;%n             当前机器名:%property%n当前机器名及登录用户：%username   %n               记录位置：%location%n 消息描述：%property&#123;Message&#125;%n                    异常：%exception%n 消息：%message%newline%n%n&quot; /&gt;      &lt;/layout&gt;&lt;/appender&gt;\r\n注意这些配置属性有些是可选的，如果需要，一定要写正确，否则要么输出的不是自己想要的结果，要么干脆不输出任何信息。\r\n写入SQL数据库\r\n需要在相应的数据库中准备好一张表，创建语句如下：\r\nCREATE TABLE [Log] ([ID] [int] IDENTITY (1, 1) NOT NULL ,[Date] [datetime] NOT NULL ,[Thread] [varchar] (100) COLLATE Chinese_PRC_CI_AS NULL ,[Level] [varchar] (100) COLLATE Chinese_PRC_CI_AS NULL ,[Logger] [varchar] (200) COLLATE Chinese_PRC_CI_AS NULL ,[Operator] [int] NULL ,[Message] [text] COLLATE Chinese_PRC_CI_AS NULL ,[ActionType] [int] NULL ,[Operand] [varchar] (300) COLLATE Chinese_PRC_CI_AS NULL ,[IP] [varchar] (20) COLLATE Chinese_PRC_CI_AS NULL ,[MachineName] [varchar] (100) COLLATE Chinese_PRC_CI_AS NULL ,[Browser] [varchar] (50) COLLATE Chinese_PRC_CI_AS NULL ,[Location] [text] COLLATE Chinese_PRC_CI_AS NULL ,[Exception] [text] COLLATE Chinese_PRC_CI_AS NULL)\r\n&lt;appender name=&quot;ADONetAppender&quot; type=&quot;log4net.Appender.ADONetAppender,log4net&quot;&gt;&lt;!--BufferSize为缓冲区大小，只有日志记录超设定值才会一块写入到数据库--&gt;&lt;bufferSize value=&quot;10&quot; /&gt;&lt;!—或写为&lt;param name=&quot;BufferSize&quot; value=&quot;10&quot; /&gt;--&gt;&lt;!--引用--&gt;&lt;connectionType value=&quot;System.Data.SqlClient.SqlConnection,  System.Data, Version=1.0.3300.0, Culture=neutral,  PublicKeyToken=b77a5c561934e089&quot; /&gt;&lt;!--连接数据库字符串--&gt;&lt;connectionString value=&quot;data  source=.;initial catalog=Test;integrated security=false;persist  security info=True;User ID=sa;Password=;&quot; /&gt;&lt;!--插入到表Log--&gt;&lt;commandText value=&quot;INSERT  INTO Log  ([Date],[Thread],[Level],[Logger],[Operator],[Message],[ActionType],[Operand],[IP],[MachineName],[Browser],[Location],[Exception])  VALUES (@log_date, @thread, @log_level, @logger,@operator,  @message,@action_type,@operand,@ip,@machineName,@browser,@location,@exception)&quot; /&gt;&lt;!—日志记录时间，RawTimeStampLayout为默认的时间输出格式 --&gt;​      &lt;parameter&gt;​        &lt;parameterName value=&quot;@log_date&quot; /&gt;​        &lt;dbType value=&quot;DateTime&quot; /&gt;​        &lt;layout type=&quot;log4net.Layout.RawTimeStampLayout&quot; /&gt;​      &lt;/parameter&gt;​      &lt;!--线程号--&gt;​      &lt;parameter&gt;​        &lt;parameterName value=&quot;@thread&quot; /&gt;​        &lt;dbType value=&quot;String&quot; /&gt;&lt;!—长度不可以省略，否则不会输出--&gt;​        &lt;size value=&quot;100&quot; /&gt;​        &lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&gt;​          &lt;conversionPattern value=&quot;%thread&quot; /&gt;​        &lt;/layout&gt;​      &lt;/parameter&gt;​      &lt;!--日志等级--&gt;​      &lt;parameter&gt;​        &lt;parameterName value=&quot;@log_level&quot; /&gt;​        &lt;dbType value=&quot;String&quot; /&gt;​        &lt;size value=&quot;100&quot; /&gt;​        &lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&gt;​          &lt;conversionPattern value=&quot;%level&quot; /&gt;​        &lt;/layout&gt;​      &lt;/parameter&gt;​      &lt;!--日志记录类名称--&gt;​      &lt;parameter&gt;​        &lt;parameterName value=&quot;@logger&quot; /&gt;​        &lt;dbType value=&quot;String&quot; /&gt;​        &lt;size value=&quot;200&quot; /&gt;​        &lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&gt;​          &lt;conversionPattern value=&quot;%logger&quot; /&gt;​        &lt;/layout&gt;​      &lt;/parameter&gt;​     ​      &lt;!--操作者。这个是自定义的输出字段，使用重新实现的布局器ReflectionLayout --&gt;​      &lt;parameter&gt;​        &lt;parameterName value=&quot;@operator&quot; /&gt;&lt;!—设置为Int32时只有bufferSize的 value&lt;=&quot;1&quot;才正确输出，没有找出原因。--&gt;​        &lt;dbType value=&quot;Int16&quot; /&gt;​        &lt;layout type=&quot;TGLog.ExpandLayout2.ReflectionLayout,TGLog&quot;&gt;​          &lt;conversionPattern value=&quot;%property&#123;Operator&#125;&quot; /&gt;​        &lt;/layout&gt;​      &lt;/parameter&gt;​      &lt;!--操作对象--&gt;​      &lt;parameter&gt;​        &lt;parameterName value=&quot;@operand&quot; /&gt;​        &lt;dbType value=&quot;String&quot; /&gt;​        &lt;size value=&quot;300&quot; /&gt;​        &lt;layout type=&quot;TGLog.ExpandLayout2.ReflectionLayout,TGLog&quot;&gt;​          &lt;conversionPattern value=&quot;%property&#123;Operand&#125;&quot; /&gt;​        &lt;/layout&gt;​      &lt;/parameter&gt;​      &lt;!—IP地址--&gt;​      &lt;parameter&gt;​        &lt;parameterName value=&quot;@ip&quot; /&gt;​        &lt;dbType value=&quot;String&quot; /&gt;​        &lt;size value=&quot;20&quot; /&gt;​        &lt;layout type=&quot;TGLog.ExpandLayout2.ReflectionLayout,TGLog&quot;&gt;​          &lt;conversionPattern value=&quot;%property&#123;IP&#125;&quot; /&gt;​        &lt;/layout&gt;​      &lt;/parameter&gt;​      &lt;!--机器名--&gt;​      &lt;parameter&gt;​        &lt;parameterName value=&quot;@machineName&quot; /&gt;​        &lt;dbType value=&quot;String&quot; /&gt;​        &lt;size value=&quot;100&quot; /&gt;​        &lt;layout type=&quot;TGLog.ExpandLayout2.ReflectionLayout,TGLog&quot;&gt;​          &lt;conversionPattern value=&quot;%property&#123;MachineName&#125;&quot; /&gt;​        &lt;/layout&gt;​      &lt;/parameter&gt;​      &lt;!--浏览器--&gt;​      &lt;parameter&gt;​        &lt;parameterName value=&quot;@browser&quot; /&gt;​        &lt;dbType value=&quot;String&quot; /&gt;​        &lt;size value=&quot;50&quot; /&gt;​        &lt;layout type=&quot;TGLog.ExpandLayout2.ReflectionLayout,TGLog&quot;&gt;​          &lt;conversionPattern value=&quot;%property&#123;Browser&#125;&quot; /&gt;​        &lt;/layout&gt;​      &lt;/parameter&gt;​     ​      &lt;!—日志消息--&gt;​      &lt;parameter&gt;​        &lt;parameterName value=&quot;@message&quot; /&gt;​        &lt;dbType value=&quot;String&quot; /&gt;​        &lt;size value=&quot;3000&quot; /&gt;​        &lt;layout type=&quot;TGLog.ExpandLayout2.ReflectionLayout,TGLog&quot;&gt;​          &lt;conversionPattern value=&quot;%property&#123;Message&#125;&quot; /&gt;​        &lt;/layout&gt;​      &lt;/parameter&gt;​      &lt;!--动作类型--&gt;​      &lt;parameter&gt;​        &lt;parameterName value=&quot;@action_type&quot; /&gt;​        &lt;dbType value=&quot;Int16&quot; /&gt;​        &lt;layout type=&quot;TGLog.ExpandLayout2.ReflectionLayout,TGLog&quot;&gt;​          &lt;conversionPattern value=&quot;%property&#123;ActionType&#125;&quot; /&gt;​        &lt;/layout&gt;​      &lt;/parameter&gt;​      &lt;!—记录日志的位置--&gt;​      &lt;parameter&gt;​        &lt;parameterName value=&quot;@location&quot; /&gt;​        &lt;dbType value=&quot;String&quot; /&gt;​        &lt;size value=&quot;2000&quot; /&gt;​        &lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&gt;​          &lt;conversionPattern value=&quot;%location&quot; /&gt;​        &lt;/layout&gt;​      &lt;/parameter&gt;​     ​      &lt;!—异常信息。ExceptionLayout 为异常输出的默认格式--&gt;​      &lt;parameter&gt;​        &lt;parameterName value=&quot;@exception&quot; /&gt;​        &lt;dbType value=&quot;String&quot; /&gt;​        &lt;size value=&quot;4000&quot; /&gt;​        &lt;layout type=&quot;log4net.Layout.ExceptionLayout&quot; /&gt;​      &lt;/parameter&gt;&lt;/appender&gt;\r\n注意：\r\n向表中输出的字段不能多于数据表本身字段，而反之则可以，但这些多余字段一定使其可以为空，否则便写不到数据库；\r\n输出字段的类型一定是对应数据表字段数据类型可以隐式转换的，而且长度也不能超过，否则也不能写入；\r\n数据表字段设置尽量可以为空，这样可以避免一条日志记录存在空数据导致后面的日志都记录不了。\r\n&lt;logger&gt;配置\r\n在配置文件 &lt;appender&gt;\r\n中的配置好了输出的介质，格式，过滤方式，还要定义日志对象\r\n&lt;logger&gt;。\r\n在框架的体系里，所有的日志对象都是根日志(root logger)的后代。\r\n因此如果一个日志对象没有在配置文件里显式定义，则框架使用根日志中定义的属性。在\r\n&lt;root&gt; 标签里，可以定义 level 级别值和 Appender\r\n的列表。如果没有定义LEVEL的值，则缺省为DEBUG。可以通过\r\n&lt;appender-ref&gt; 标签定义日志对象使用的 Appender\r\n对象。&lt;appender-ref&gt; 声明了在其他地方定义的 Appender\r\n对象的一个引用。在一个 logger 对象中的设置会覆盖根日志的设置。而对\r\nAppender 属性来说，子日志对象则会继承父日志对象的 Appender\r\n列表。这种缺省的行为方式也可以通过显式地设定 &lt;logger&gt;\r\n标签的 additivity 属性为 false 而改变。\r\n&lt;root&gt;\r\n不显式申明时使用默认的配置。我觉得在使用时不定义\r\n&lt;root&gt;，自定义多个&lt;logger&gt;，在程序中记录日志时直接使用&lt;logger&gt;的\r\nname 来查找相应的&lt;logger&gt;，这样更灵活一些。例如：\r\n\r\n&lt;logger name=&quot;ReflectionLayout&quot;&gt;      &lt;level value=&quot;DEBUG&quot;/&gt;      &lt;appender-ref ref=&quot;HashtableLayout&quot;/&gt;      &lt;appender-ref ref=&quot;ReflectionLayout&quot;/&gt;      &lt;appender-ref ref=&quot;ADONetAppender&quot;/&gt;&lt;/logger&gt;\r\n关联配置文件\r\nlog4net 默认关联的是应用程序的配置文件 App.config (BS 程序是\r\nWeb.config)，可以使用程序集自定义属性来进行设置。下面来介绍一下这个自定义属性：log4net.Config.XmlConifguratorAttribute。\r\nXmlConfiguratorAttribute 有 3 个属性：\r\n\r\nConfigFile： 配置文件的名字，文件路径相对于应用程序目录\r\n\r\n(AppDomain.CurrentDomain.BaseDirectory)。ConfigFile 属性不能和\r\nConfigFileExtension 属性一起使用。\r\n\r\nConfigFileExtension：\r\n配置文件的扩展名，文件路径相对于应用程序的目录。ConfigFileExtension\r\n属性不能和ConfigFile属性一起使用。\r\nWatch：\r\n如果将Watch属性设置为true，就会监视配置文件。当配置文件发生变化的时候，就会重新加载。\r\n\r\n如果 ConfigFile 和 ConfigFileExtension\r\n都没有设置，则使用应用程序的配置文件 App.config（Web.config）。\r\n可以在项目的AssemblyInfo.cs文件里添加以下的语句：\r\n // 监视默认的配置文件，App.exe.config   [assembly: log4net.Config.XmlConfigurator(Watch = true)]// 监视配置文件，App.exe.log4net。[assembly: log4net.Config.XmlConfigurator(ConfigFileExtension = &quot;log4net&quot;, Watch = true)]// 使用配置文件 log4net.config，不监视改变。注意 log4net.config 文件的目录，BS 程序在站点目录 \\ 下，CS 则在应用程序启动目录下，如调试时在 /bin/Debug 下，一般将文件属性的文件输出目录调为 \\ 始终复制即可[assembly: log4net.Config.XmlConfigurator(ConfigFile = &quot;log4net.config&quot;)]// 使用配置文件 App.exe.config ，不监视改变[assembly: log4net.Config.XmlConfigurator()]\r\n也可以在 Global.asax 的 Application_Start 里或者是 Program.cs 中的\r\nMain 方法中添加，注意这里一定是绝对路径，如下所示：\r\n//这是在BS程序下，使用自定义的配置文件log4net.xml，使用Server.MapPath(&quot;~&quot;) + //@&quot;/log4net.xml”来取得路径。/log4net.xml为相对于站点的路径// ConfigureAndWatch()相当于Configure(Watch = true)log4net.Config.XmlConfigurator.ConfigureAndWatch(new System.IO.FileInfo(Server.MapPath(&quot;~&quot;) + @&quot;/log4net.xml&quot;));//这是在CS程序下，可以用以下方法获得：string assemblyFilePath = Assembly.GetExecutingAssembly().Location;string assemblyDirPath = Path.GetDirectoryName(assemblyFilePath);string configFilePath = assemblyDirPath + &quot; //log4net.xml&quot;;log4net.Config.XmlConfigurator.ConfigureAndWatch(new FileInfo(configFilePath));\r\n或直接使用绝对路径：\r\n//使用自定义的配置文件，直接绝对路径为：c:/log4net.configlog4net.Config.XmlConfigurator.Configure(new System.IO.FileInfo(@&quot;c:/log4net.config&quot;));\r\n如何记录日志\r\nLog4net使用很方便，先申明一个封装类ILog 的对象，如下：\r\nlog4net.ILog log = log4net.LogManager.GetLogger(&quot;ReflectionLayout&quot;);\r\n其中 \"ReflectionLayout\" 便是我们自定义的日志对象\r\n&lt;logger&gt; 的 name 的值。\r\n对应5个日志输出级别，log 有 5\r\n个方法，每个方法都有两个重载，使用如下：\r\ntry&#123;    log.Debug(&quot;这是一个测试！&quot;);&#125;catch(Exception ec)&#123;    log.Error(&quot;出现错误！&quot;, ec);&#125;\r\n如果我们需要输出的消息是要区别开来，不按一个字符串全部输出，就需要进行一些扩展了。\r\nLog4net的简单扩展\r\n通过重写布局Layout输出传入的\r\nmessage对象的属性\r\n重写 Layout 类\r\n通过继承\r\nlog4net.Layout.PatternLayout类，使用log4net.Core.LoggingEvent类的方法得到了要输出的message类的名称，然后通过反射得到各个属性的值，使用PatternLayout类AddConverter方法传入得到的值。这里注意要引用用到的类的命名空间。\r\n代码见附注8.2。\r\n配置相应的配置文件\r\n配置文件其他地方不用改动，只是需要改动 &lt;appender&gt;\r\n中的 &lt;layout&gt;。例如：\r\n&lt;layout type=&quot;TGLog.ExpandLayout2.ReflectionLayout,TGLog&quot;&gt;  &lt;param name=&quot;ConversionPattern&quot; value=&quot;记录时间：%date    操作者ID：%property&#123;Operator&#125; 操作类型：%property&#123;Action&#125;%n  消息描述：%property&#123;Message&#125;%n 异常：%exception%n &quot; /&gt;&lt;/layout&gt;\r\n其中 &lt;layout&gt; 的 type 由原来的\r\nlog4net.Layout.PatternLayout\r\n换为自定义的TGLog.ExpandLayout2.ReflectionLayout（TGLog.ExpandLayout2为命名空间）。%property{Operator}\r\n输出的即为message类对象的属性Operator的值。数据库配置同样，相应的字段如果是自定义的，则输出选用自定义的&lt;layout&gt;。例：\r\n&lt;!--动作类型--&gt;&lt;parameter&gt;      &lt;parameterName value=&quot;@action_type&quot; /&gt;      &lt;dbType value=&quot;Int16&quot; /&gt;      &lt;layout type=&quot;TGLog.ExpandLayout2.ReflectionLayout,TGLog&quot;&gt;         &lt;conversionPattern value=&quot;%property&#123;ActionType&#125;&quot; /&gt;      &lt;/layout&gt;&lt;/parameter&gt;\r\n程序中如何使用\r\n和一般使用方法基本相同，只是传入的参数是一个自定义的类，类的属性和配置文件中\r\n&lt;layout&gt;\r\n所有的%property{属性}是一致的，即%property{属性}在输出的时候就查找传入message类中有无对应的属性，如果有就输出值，没有则输出null。例：\r\nlog4net.ILog log = log4net.LogManager.GetLogger(&quot;ReflectionLayout&quot;);// 使用try&#123;    log.Debug(new LogMessage(1,&quot;操作对象：0&quot;, (int)TGLog.ActionType.Other, &quot;这是四个参数测试&quot;));&#125;catch(Exception ec)&#123;    log.Error(new LogMessage(​1,&quot;操作对象：0&quot;, &quot;192.168.1.1&quot;,&quot;MyComputer&quot;,&quot;Maxthon(MyIE2)Fans&quot;),ec);&#125;\r\nLogMessage的全部属性的构造方法如下：\r\npublic LogMessage(int operatorID,string operand,int ActionType,string message,string ip,string machineName,string browser)&#123;  // ...&#125;\r\n通过重新实现ILog接口来增加输入的参数\r\n重写LogImpl，LogManager类及实现ILog接口\r\n这种方式是通过构造一个名为IMyLog接口，是继承Ilog接口而来，然后分别在MyLogImpl，MyLogManager重新实现IMyLog接口，增加了每种方法的参数。MyLogImpl，MyLogManager分别继承LogImpl，LogManager而来。\r\n代码分别见 8.3、8.4、8.5：\r\n配置相应的配置文件\r\n配置文件其他地方不用改动，只是需要改动中的元素name为ConversionPattern的value中输出格式。例如：\r\n\r\n​ \r\n​ \r\n%property{参数}中的参数在MyLogImpl类中定义，如语句：\r\nloggingEvent.Properties[\"Operator\"] = operatorID;\r\n就定义了Operator输出参数，即%property{Operator}输出的即为IMyLog中的参数operatorID的值。\r\n数据库配置同样。例：\r\n\r\n\r\n​ \r\n​ \r\n​ \r\n​ \r\n​ \r\n\r\n程序中如何使用\r\n先引用IMyLog\r\n，MyLogManager所在的命名空间，创建一个IMyLog对象，myLog的5\r\n个方法，每个方法都有四个重载，增加了多参数的重载。例：\r\nIMyLog myLog = MyLogManager.GetLogger(\"ExpandILog\");\r\ntry\r\n​ {\r\nmyLog.Debug(\"这是一个参数重载测试!\");\r\n}\r\n​ catch(Exception ec)\r\n​ {\r\n​ log.Error(\r\n​ 1,\r\n​ \"操作对象：0\",\r\n​ (int)TGLog.ActionType.Other,\r\n​ \"这是全部参数测试\",\r\n​ \"192.168.1.1\",\r\n​ \"MyComputer\",\r\n​ \"Maxthon(MyIE2)Fans\",\r\n​ ec\r\n);\r\n​ }\r\n总结\r\nLog4net\r\n功能很多，这里只是对已经尝试用过的功能总结一下，普通写日志已经足够。需要注意的是：\r\n\r\nLog4net本身也有一些缺陷，比如一个记录引起了log4net本身的异常，就会使后面的日志无法记录下来，尤其是在写入数据库时。例如使用6.1扩展后，int型的属性在\r\n&lt;appender&gt; 的元素 &lt;bufferSize&gt;\r\n设置不为1时，&lt;dbType value=\"Int32\" /&gt;时，就不能输出到数据库，而\r\n&lt;dbType value=\"Int16\"&gt;` 则没任何问题。\r\nLog4net本身出现了异常，比如配置文件出现错误，有些日志输出方式会记录下这些异常，例如应用程序控制台；有些则不会输出这些错误，如数据库与文件。\r\n扩展时也会留下一些问题。例如在使用6.1扩展输出字段时就会出现，在log.debug(object\r\nmessage)中，如果message是一个自定义的类，属性与配置文件中输出设置也一致，构造函数时也只构造一个参数的实例，写文件与写数据库都成功，而将message按没有扩展的方式直接传入一个字符串，即log.debug(“信息内容”)使用则只能写入文件，而数据库则没写入。自定义的Layout\r\n就是继承默认的PatternLayout，本来不应该出错，但出现了问题。原因分析是自定义的message类有类型为int的属性，作为一个对象传入时在默认值0，而直接使用字符串则int型的字段得不到默认值，引发异常。所以建议在有扩展存在时，最好多设几个,区分清楚，按照统一的形式记录日志，不要混合使用。\r\n配置文件的设置一定要准确，在一点不正确就会导致日志不能正常输出，所以在配置时先从最简单的开始，同时输出方式选择一种能输出log4net本身异常的方式，成功后一点一点加在新配置，这样出错了也容易找到那个地方配置有问题。\r\nlog4net扩展性很强，几乎所有的组件都可以重写，在配置文件中配置好就可以使用。\r\n\r\n附注\r\nPatterLayout格式化字符表\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n转换字符\r\n效果\r\n\r\n\r\n\r\n\r\na\r\n等价于appdomain\r\n\r\n\r\nappdomain\r\n引发日志事件的应用程序域的友好名称。（使用中一般是可执行文件的名字。）\r\n\r\n\r\nc\r\n等价于 logger\r\n\r\n\r\nC\r\n等价于 type\r\n\r\n\r\nclass\r\n等价于 type\r\n\r\n\r\nd\r\n等价于 date\r\n\r\n\r\ndate\r\n发生日志事件的本地时间。 使用 DE&gt;%utcdate\r\n输出UTC时间。date后面还可以跟一个日期格式，用大括号括起来。DE&gt;例如：%date{HH:mm:ss,fff}或者%date{dd\r\nMMM yyyy HH:mm:ss,fff}。如果date后面什么也不跟，将使用ISO8601 格式\r\n。日期格式和.Net中DateTime类的ToString方法中使用的格式是一样。另外log4net还有3个自己的格式Formatter。\r\n它们是 \"ABSOLUTE\", \"DATE\"和\"ISO8601\"分别代表 AbsoluteTimeDateFormatter,\r\nDateTimeDateFormatter和Iso8601DateFormatter。例如：%date{ISO8601}或%date{ABSOLUTE}。它们的性能要好于ToString。\r\n\r\n\r\nexception\r\n异常信息日志事件中必须存了一个异常对象，如果日志事件不包含没有异常对象，将什么也不输出。异常输出完毕后会跟一个换行。一般会在输出异常前加一个换行，并将异常放在最后。\r\n\r\n\r\nF\r\n等价于 file\r\n\r\n\r\nfile\r\n发生日志请求的源代码文件的名字。警告：只在调试的时候有效。调用本地信息会影响性能。\r\n\r\n\r\nidentity\r\n当前活动用户的名字(Principal.Identity.Name).警告：会影响性能。（我测试的时候%identity返回都是空的。）\r\n\r\n\r\nl\r\n等价于 location\r\n\r\n\r\nL\r\n等价于 line\r\n\r\n\r\nlocation\r\n引发日志事件的方法（包括命名空间和类名），以及所在的源文件和行号。警告：会影响性能。没有pdb文件的话，只有方法名，没有源文件名和行号。\r\n\r\n\r\nlevel\r\n日志事件等级\r\n\r\n\r\nline\r\n引发日志事件的行号警告：会影响性能。\r\n\r\n\r\nlogger\r\n记录日志事件的Logger对象的名字。可以使用精度说明符控制Logger的名字的输出层级，默认输出全名。注意，精度符的控制是从右开始的。例如：logger\r\n名为 \"a.b.c\"， 输出模型为%logger{2} ，将输出\"b.c\"。\r\n\r\n\r\nm\r\n等价于 message\r\n\r\n\r\nM\r\n等价于 method\r\n\r\n\r\nmessage\r\n由应用程序提供给日志事件的消息。\r\n\r\n\r\nmdc\r\nMDC (旧为：ThreadContext.Properties) 现在是事件属性的一部分。\r\n保留它是为了兼容性，它等价于 property。\r\n\r\n\r\nmethod\r\n发生日志请求的方法名（只有方法名而已）。警告：会影响性能。\r\n\r\n\r\nn\r\n等价于 newline\r\n\r\n\r\nnewline\r\n换行符\r\n\r\n\r\nndc\r\nNDC (nested diagnostic context)\r\n\r\n\r\np\r\n等价于 level\r\n\r\n\r\nP\r\n等价于 property\r\n\r\n\r\nproperties\r\n等价于 property\r\n\r\n\r\nproperty\r\n输出事件的特殊属性。例如： %property{user}\r\n输出user属性。属性是由loggers或appenders添加到时间中的。\r\n有一个默认的属性\"DE&gt;log4net:HostName\"总是会有。DE&gt;%property将输出所有的属性\r\n。（扩展后可以使用）\r\n\r\n\r\nr\r\n等价于 timestamp\r\n\r\n\r\nt\r\n等价于 thread\r\n\r\n\r\ntimestamp\r\n从程序启动到事件发生所经过的毫秒数。\r\n\r\n\r\nthread\r\n引发日志事件的线程，如果没有线程名就使用线程号。\r\n\r\n\r\ntype\r\n引发日志请求的类的全名。.可以使用精度控制符。例如： 类名是\r\n\"log4net.Layout.PatternLayout\", 格式模型是%type{1}\r\n将输出\"PatternLayout\"。（也是从右开始的。）警告：会影响性能。\r\n\r\n\r\nu\r\n等价于 identity\r\n\r\n\r\nusername\r\n当前用户的WindowsIdentity。（类似：HostName/Username）警告：会影响性能。\r\n\r\n\r\nutcdate\r\n发生日志事件的UTC时间。DE&gt;后面还可以跟一个日期格式，用大括号括起来。DE&gt;例如：%utcdate{HH:mm:ss,fff}或者%utcdate{dd\r\nMMM yyyy HH:mm:ss,fff}。如果utcdate后面什么也不跟，将使用ISO8601 格式\r\n。日期格式和.Net中DateTime类的ToString方法中使用的格式是一样。另外log4net还有3个自己的格式Formatter。\r\n它们是 \"ABSOLUTE\", \"DATE\"和\"ISO8601\"分别代表 AbsoluteTimeDateFormatter,\r\nDateTimeDateFormatter和Iso8601DateFormatter。例如：%date{ISO8601}或%date{ABSOLUTE}。它们的性能要好于ToString。\r\n\r\n\r\nw\r\n等价于 username\r\n\r\n\r\nx\r\n等价于 ndc\r\n\r\n\r\nX\r\n等价于 mdc\r\n\r\n\r\n%\r\n%%输出一个百分号\r\n\r\n\r\n\r\n关于调用本地信息（caller location information）的说明：\r\n%type %file %line %method %location %class %C %F %L %l %M\r\n都会调用本地信息。这样做会影响性能。本地信息使用System.Diagnostics.StackTrace得到。.Net\r\n1.0 不支持System.Diagnostics.StackTrace 类。\r\n本地信息在调试模式下可以正常获取，在非调试模式下可能获取不到，或只能获取一部分。（根据我的测试，其实是需要有一个程序数据库（.pdb）文件。）\r\n%property属性要用代码来设置才能使用（也就是扩展一下），\r\n默认属性log4net:HostName不用设置。\r\n转义字符的修饰符：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nFormat modifier\r\nleft justify\r\nminimum width\r\nmaximum width\r\ncomment\r\n\r\n\r\n\r\n\r\n%20logger\r\nfalse\r\n20\r\nnone\r\n如果logger名不足20个字符，就在左边补空格。\r\n\r\n\r\n%-20logger\r\ntrue\r\n20\r\nnone\r\n如果logger名不足20个字符，就在右边补空格。\r\n\r\n\r\n%.30logger\r\nNA\r\nnone\r\n30\r\n超过30个字符将截断。\r\n\r\n\r\n%20.30logger\r\nfalse\r\n20\r\n30\r\nlogger名要在20到30之间，少了在左边补空格，多了截断。\r\n\r\n\r\n%-20.30logger\r\ntrue\r\n20\r\n30\r\nlogger名要在20到30之间，少了在右边补空格，多了截断。\r\n\r\n\r\n\r\nLayout类代码\r\nusing System;using System.Collections.Generic;using System.Linq;using System.Text;using log4net.Layout;using log4net.Layout.Pattern;using System.Reflection;using System.Collections;using FastReflectionLib;namespace TGLog.ExpandLayout2&#123;   public class ReflectionLayout : PatternLayout   &#123;       public ReflectionLayout()       &#123;           this.AddConverter(&quot;property&quot;, typeof(ReflectionPatternConverter));       &#125;   &#125;   public class ReflectionPatternConverter : PatternLayoutConverter   &#123;       protected override void Convert(System.IO.TextWriter writer, log4net.Core.LoggingEvent loggingEvent)       &#123;           if (Option != null)           &#123;               // 写入指定键的值               WriteObject(writer, loggingEvent.Repository, LookupProperty(Option, loggingEvent));           &#125;           else           &#123;               // 写入所有关键值对               WriteDictionary(writer,loggingEvent.Repository, loggingEvent.GetProperties());           &#125;       &#125;       /// &lt;summary&gt;       /// 通过反射获取传入的日志对象的某个属性的值       /// &lt;/summary&gt;       /// &lt;param name=&quot;property&quot;&gt;&lt;/param&gt;       /// &lt;returns&gt;&lt;/returns&gt;       private object LookupProperty(string property, log4net.Core.LoggingEvent loggingEvent)       &#123;           object propertyValue = string.Empty;           PropertyInfo propertyInfo =loggingEvent.MessageObject.GetType().GetProperty(property);           if (propertyInfo != null)           &#123;               propertyValue =propertyInfo.GetValue(loggingEvent.MessageObject, null);           &#125;           return propertyValue;       &#125;   &#125;&#125;\r\nMyLogImpl类代码\r\nusing System;using System.Collections.Generic;using System.Linq;using System.Text;using log4net.Core;using log4net.Repository.Hierarchy;using static Bentley.DgnPlatformNET.DgnEC.PropertyCriterion;namespace TGLog.ExpandILog&#123;   public class MyLogImpl : LogImpl, IMyLog   &#123;       /// &lt;summary&gt;       /// The fully qualified name of this declaring type not the type of any subclass.       /// &lt;/summary&gt;       private readonly static Type ThisDeclaringType = typeof(MyLogImpl);       public MyLogImpl(ILogger logger)           : base(logger)       &#123;              &#125;       #region Implementation of IMyLog       public void Debug(int operatorID, string operand, int actionType, object message, string ip, string browser, string machineName)       &#123;           Debug(operatorID, operand, actionType, message, ip, browser, machineName, null);       &#125;       public void Debug(int operatorID, string operand, int actionType, object message, string ip, string browser, string machineName, System.Exception t)       &#123;           if (this.IsDebugEnabled)           &#123;               LoggingEvent loggingEvent = new LoggingEvent(ThisDeclaringType, Logger.Repository,                                      Logger.Name, Level.Info, message, t);               loggingEvent.Properties[&quot;Operator&quot;] = operatorID;               loggingEvent.Properties[&quot;Operand&quot;] = operand;               loggingEvent.Properties[&quot;ActionType&quot;] = actionType;               loggingEvent.Properties[&quot;IP&quot;] = ip;               loggingEvent.Properties[&quot;Browser&quot;] = browser;               loggingEvent.Properties[&quot;MachineName&quot;] = machineName;               Logger.Log(loggingEvent);           &#125;       &#125;       public void Info(int operatorID, string operand, int actionType, object message,string ip, string browser, string machineName)       &#123;           Info(operatorID, operand, actionType, message, ip, browser, machineName, null);       &#125;       public void Info(int operatorID, string operand, int actionType, object message, string ip, string browser, string machineName, System.Exception t)       &#123;           if (this.IsInfoEnabled)           &#123;               LoggingEvent loggingEvent = new LoggingEvent(ThisDeclaringType, Logger.Repository, Logger.Name, Level.Info, message, t);               loggingEvent.Properties[&quot;Operator&quot;] = operatorID;               loggingEvent.Properties[&quot;Operand&quot;] = operand;               loggingEvent.Properties[&quot;ActionType&quot;] = actionType;               loggingEvent.Properties[&quot;IP&quot;] = ip;               loggingEvent.Properties[&quot;Browser&quot;] = browser;               loggingEvent.Properties[&quot;MachineName&quot;] = machineName;               Logger.Log(loggingEvent);           &#125;       &#125;       public void Warn(int operatorID, string operand, int actionType, object message,string ip, string browser, string machineName)       &#123;           Warn(operatorID, operand, actionType, message, ip, browser, machineName, null);       &#125;       public void Warn(int operatorID, string operand, int actionType, object message, string ip, string browser, string machineName, System.Exception t)       &#123;           if (this.IsWarnEnabled)           &#123;               LoggingEvent loggingEvent = new LoggingEvent(ThisDeclaringType, Logger.Repository,Logger.Name, Level.Info, message, t);               loggingEvent.Properties[&quot;Operator&quot;] = operatorID;               loggingEvent.Properties[&quot;Operand&quot;] = operand;               loggingEvent.Properties[&quot;ActionType&quot;] = actionType;               loggingEvent.Properties[&quot;IP&quot;] = ip;               loggingEvent.Properties[&quot;Browser&quot;] = browser;               loggingEvent.Properties[&quot;MachineName&quot;] = machineName;               Logger.Log(loggingEvent);           &#125;       &#125;       public void Error(int operatorID, string operand, int actionType, object message,string ip, string browser, string machineName)       &#123;           Error(operatorID, operand, actionType, message, ip, browser, machineName, null);       &#125;       public void Error(int operatorID, string operand, int actionType, object message, string ip, string browser, string machineName, System.Exception t)       &#123;           if (this.IsErrorEnabled)           &#123;               LoggingEvent loggingEvent = new LoggingEvent(ThisDeclaringType, Logger.Repository, Logger.Name, Level.Info, message, t);               loggingEvent.Properties[&quot;Operator&quot;] = operatorID;               loggingEvent.Properties[&quot;Operand&quot;] = operand;               loggingEvent.Properties[&quot;ActionType&quot;] = actionType;               loggingEvent.Properties[&quot;IP&quot;] = ip;               loggingEvent.Properties[&quot;Browser&quot;] = browser;               loggingEvent.Properties[&quot;MachineName&quot;] = machineName;               Logger.Log(loggingEvent);           &#125;       &#125;       public void Fatal(int operatorID, string operand, int actionType, object message, string ip, string browser, string machineName)       &#123;           Fatal(operatorID, operand, actionType, message, ip, browser, machineName, null);       &#125;       public void Fatal(int operatorID, string operand, int actionType, object message, string ip, string browser, string machineName, System.Exception t)       &#123;           if (this.IsFatalEnabled)           &#123;               LoggingEvent loggingEvent = new LoggingEvent(ThisDeclaringType, Logger.Repository, Logger.Name, Level.Info, message, t);               loggingEvent.Properties[&quot;Operator&quot;] = operatorID;               loggingEvent.Properties[&quot;Operand&quot;] = operand;               loggingEvent.Properties[&quot;ActionType&quot;] = actionType;               loggingEvent.Properties[&quot;IP&quot;] = ip;               loggingEvent.Properties[&quot;Browser&quot;] = browser;               loggingEvent.Properties[&quot;MachineName&quot;] = machineName;               Logger.Log(loggingEvent);           &#125;       &#125;       #endregion   &#125;&#125;\r\nMyLogManager类代码\r\n//// Copyright 2001-2005 The Apache Software Foundation//// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);// you may not use this file except in compliance with the License.// You may obtain a copy of the License at//// http://www.apache.org/licenses/LICENSE-2.0//// Unless required by applicable law or agreed to in writing, software// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.// See the License for the specific language governing permissions and// limitations under the License.//using System;using System.Reflection;using System.Collections;using log4net;using log4net.Core;using log4net.Repository;using log4net.Repository.Hierarchy;namespace TGLog.ExpandILog&#123;   public class MyLogManager   &#123;       #region Static Member Variables       /// &lt;summary&gt;       /// The wrapper map to use to hold the &lt;see cref=&quot;EventIDLogImpl&quot;/&gt; objects       /// &lt;/summary&gt;       private static readonly WrapperMap s_wrapperMap = new WrapperMap(newWrapperCreationHandler(WrapperCreationHandler));       #endregion       #region Constructor       /// &lt;summary&gt;       /// Private constructor to prevent object creation       /// &lt;/summary&gt;       private MyLogManager() &#123; &#125;       #endregion       #region Type Specific Manager Methods       /// &lt;summary&gt;       /// Returns the named logger if it exists       /// &lt;/summary&gt;       /// &lt;remarks&gt;       /// &lt;para&gt;If the named logger exists (in the default hierarchy) then it       /// returns a reference to the logger, otherwise it returns       /// &lt;c&gt;null&lt;/c&gt;.&lt;/para&gt;       /// &lt;/remarks&gt;       /// &lt;param name=&quot;name&quot;&gt;The fully qualified logger name to look for&lt;/param&gt;       /// &lt;returns&gt;The logger found, or null&lt;/returns&gt;       public static IMyLog Exists(string name)       &#123;           return Exists(Assembly.GetCallingAssembly(), name);       &#125;       /// &lt;summary&gt;       /// Returns the named logger if it exists       /// &lt;/summary&gt;       /// &lt;remarks&gt;       /// &lt;para&gt;If the named logger exists (in the specified domain) then it       /// returns a reference to the logger, otherwise it returns       /// &lt;c&gt;null&lt;/c&gt;.&lt;/para&gt;       /// &lt;/remarks&gt;       /// &lt;param name=&quot;domain&quot;&gt;the domain to lookup in&lt;/param&gt;       /// &lt;param name=&quot;name&quot;&gt;The fully qualified logger name to look for&lt;/param&gt;       /// &lt;returns&gt;The logger found, or null&lt;/returns&gt;       public static IMyLog Exists(string domain, string name)       &#123;           return WrapLogger(LoggerManager.Exists(domain, name));       &#125;       /// &lt;summary&gt;       /// Returns the named logger if it exists       /// &lt;/summary&gt;       /// &lt;remarks&gt;       /// &lt;para&gt;If the named logger exists (in the specified assembly&#x27;s domain) then it       /// returns a reference to the logger, otherwise it returns       /// &lt;c&gt;null&lt;/c&gt;.&lt;/para&gt;       /// &lt;/remarks&gt;       /// &lt;param name=&quot;assembly&quot;&gt;the assembly to use to lookup the domain&lt;/param&gt;       /// &lt;param name=&quot;name&quot;&gt;The fully qualified logger name to look for&lt;/param&gt;       /// &lt;returns&gt;The logger found, or null&lt;/returns&gt;       public static IMyLog Exists(Assembly assembly, string name)       &#123;           return WrapLogger(LoggerManager.Exists(assembly, name));       &#125;       /// &lt;summary&gt;       /// Returns all the currently defined loggers in the default domain.       /// &lt;/summary&gt;       /// &lt;remarks&gt;       /// &lt;para&gt;The root logger is &lt;b&gt;not&lt;/b&gt; included in the returned array.&lt;/para&gt;       /// &lt;/remarks&gt;       /// &lt;returns&gt;All the defined loggers&lt;/returns&gt;       public static IMyLog[] GetCurrentLoggers()       &#123;           return GetCurrentLoggers(Assembly.GetCallingAssembly());       &#125;       /// &lt;summary&gt;       /// Returns all the currently defined loggers in the specified domain.       /// &lt;/summary&gt;       /// &lt;param name=&quot;domain&quot;&gt;the domain to lookup in&lt;/param&gt;       /// &lt;remarks&gt;       /// The root logger is &lt;b&gt;not&lt;/b&gt; included in the returned array.       /// &lt;/remarks&gt;       /// &lt;returns&gt;All the defined loggers&lt;/returns&gt;       public static IMyLog[] GetCurrentLoggers(string domain)       &#123;           return WrapLoggers(LoggerManager.GetCurrentLoggers(domain));       &#125;       /// &lt;summary&gt;       /// Returns all the currently defined loggers in the specified assembly&#x27;s domain.       /// &lt;/summary&gt;       /// &lt;param name=&quot;assembly&quot;&gt;the assembly to use to lookup the domain&lt;/param&gt;       /// &lt;remarks&gt;       /// The root logger is &lt;b&gt;not&lt;/b&gt; included in the returned array.       /// &lt;/remarks&gt;       /// &lt;returns&gt;All the defined loggers&lt;/returns&gt;       public static IMyLog[] GetCurrentLoggers(Assembly assembly)       &#123;           return WrapLoggers(LoggerManager.GetCurrentLoggers(assembly));       &#125;       /// &lt;summary&gt;       /// Retrieve or create a named logger.       /// &lt;/summary&gt;       /// &lt;remarks&gt;       /// &lt;para&gt;Retrieve a logger named as the &lt;paramref name=&quot;name&quot;/&gt;       /// parameter. If the named logger already exists, then the       /// existing instance will be returned. Otherwise, a new instance is       /// created.&lt;/para&gt;       ///       /// &lt;para&gt;By default, loggers do not have a set level but inherit       /// it from the hierarchy. This is one of the central features of       /// log4net.&lt;/para&gt;       /// &lt;/remarks&gt;       /// &lt;param name=&quot;name&quot;&gt;The name of the logger to retrieve.&lt;/param&gt;       /// &lt;returns&gt;the logger with the name specified&lt;/returns&gt;       public static IMyLog GetLogger(string name)       &#123;           return GetLogger(Assembly.GetCallingAssembly(), name);       &#125;       /// &lt;summary&gt;       /// Retrieve or create a named logger.       /// &lt;/summary&gt;       /// &lt;remarks&gt;       /// &lt;para&gt;Retrieve a logger named as the &lt;paramref name=&quot;name&quot;/&gt;       /// parameter. If the named logger already exists, then the       /// existing instance will be returned. Otherwise, a new instance is       /// created.&lt;/para&gt;       ///       /// &lt;para&gt;By default, loggers do not have a set level but inherit       /// it from the hierarchy. This is one of the central features of       /// log4net.&lt;/para&gt;       /// &lt;/remarks&gt;       /// &lt;param name=&quot;domain&quot;&gt;the domain to lookup in&lt;/param&gt;       /// &lt;param name=&quot;name&quot;&gt;The name of the logger to retrieve.&lt;/param&gt;       /// &lt;returns&gt;the logger with the name specified&lt;/returns&gt;       public static IMyLog GetLogger(string domain, string name)       &#123;           return WrapLogger(LoggerManager.GetLogger(domain, name));       &#125;       /// &lt;summary&gt;       /// Retrieve or create a named logger.       /// &lt;/summary&gt;       /// &lt;remarks&gt;       /// &lt;para&gt;Retrieve a logger named as the &lt;paramref name=&quot;name&quot;/&gt;       /// parameter. If the named logger already exists, then the       /// existing instance will be returned. Otherwise, a new instance is       /// created.&lt;/para&gt;       ///       /// &lt;para&gt;By default, loggers do not have a set level but inherit       /// it from the hierarchy. This is one of the central features of       /// log4net.&lt;/para&gt;       /// &lt;/remarks&gt;       /// &lt;param name=&quot;assembly&quot;&gt;the assembly to use to lookup the domain&lt;/param&gt;       /// &lt;param name=&quot;name&quot;&gt;The name of the logger to retrieve.&lt;/param&gt;       /// &lt;returns&gt;the logger with the name specified&lt;/returns&gt;       public static IMyLog GetLogger(Assembly assembly, string name)       &#123;           return WrapLogger(LoggerManager.GetLogger(assembly, name));       &#125;       /// &lt;summary&gt;       /// Shorthand for &lt;see cref=&quot;LogManager.GetLogger(string)&quot;/&gt;.       /// &lt;/summary&gt;       /// &lt;remarks&gt;       /// Get the logger for the fully qualified name of the type specified.       /// &lt;/remarks&gt;       /// &lt;param name=&quot;type&quot;&gt;The full name of &lt;paramref name=&quot;type&quot;/&gt; will       /// be used as the name of the logger to retrieve.&lt;/param&gt;       /// &lt;returns&gt;the logger with the name specified&lt;/returns&gt;       public static IMyLog GetLogger(Type type)       &#123;           return GetLogger(Assembly.GetCallingAssembly(), type.FullName);       &#125;       /// &lt;summary&gt;       /// Shorthand for &lt;see cref=&quot;LogManager.GetLogger(string)&quot;/&gt;.       /// &lt;/summary&gt;       /// &lt;remarks&gt;       /// Get the logger for the fully qualified name of the type specified.       /// &lt;/remarks&gt;       /// &lt;param name=&quot;domain&quot;&gt;the domain to lookup in&lt;/param&gt;       /// &lt;param name=&quot;type&quot;&gt;The full name of &lt;paramref name=&quot;type&quot;/&gt; will       /// be used as the name of the logger to retrieve.&lt;/param&gt;       /// &lt;returns&gt;the logger with the name specified&lt;/returns&gt;       public static IMyLog GetLogger(string domain, Type type)       &#123;           return WrapLogger(LoggerManager.GetLogger(domain, type));       &#125;       /// &lt;summary&gt;       /// Shorthand for &lt;see cref=&quot;LogManager.GetLogger(string)&quot;/&gt;.       /// &lt;/summary&gt;       /// &lt;remarks&gt;       /// Get the logger for the fully qualified name of the type specified.       /// &lt;/remarks&gt;       /// &lt;param name=&quot;assembly&quot;&gt;the assembly to use to lookup the domain&lt;/param&gt;       /// &lt;param name=&quot;type&quot;&gt;The full name of &lt;paramref name=&quot;type&quot;/&gt; will       /// be used as the name of the logger to retrieve.&lt;/param&gt;       /// &lt;returns&gt;the logger with the name specified&lt;/returns&gt;       public static IMyLog GetLogger(Assembly assembly, Type type)       &#123;           return WrapLogger(LoggerManager.GetLogger(assembly, type));       &#125;       #endregion       #region Extension Handlers       /// &lt;summary&gt;       /// Lookup the wrapper object for the logger specified       /// &lt;/summary&gt;       /// &lt;param name=&quot;logger&quot;&gt;the logger to get the wrapper for&lt;/param&gt;       /// &lt;returns&gt;the wrapper for the logger specified&lt;/returns&gt;       private static IMyLog WrapLogger(ILogger logger)       &#123;           return (IMyLog)s_wrapperMap.GetWrapper(logger);       &#125;       /// &lt;summary&gt;       /// Lookup the wrapper objects for the loggers specified       /// &lt;/summary&gt;       /// &lt;param name=&quot;loggers&quot;&gt;the loggers to get the wrappers for&lt;/param&gt;       /// &lt;returns&gt;Lookup the wrapper objects for the loggers specified&lt;/returns&gt;       private static IMyLog[] WrapLoggers(ILogger[] loggers)       &#123;           IMyLog[] results = new IMyLog[loggers.Length];           for (int i = 0; i &lt; loggers.Length; i++)           &#123;               results[i] = WrapLogger(loggers[i]);           &#125;           return results;       &#125;       /// &lt;summary&gt;       /// Method to create the &lt;see cref=&quot;ILoggerWrapper&quot;/&gt; objects used by       /// this manager.       /// &lt;/summary&gt;       /// &lt;param name=&quot;logger&quot;&gt;The logger to wrap&lt;/param&gt;       /// &lt;returns&gt;The wrapper for the logger specified&lt;/returns&gt;       private static ILoggerWrapper WrapperCreationHandler(ILogger logger)       &#123;           return new MyLogImpl(logger);       &#125;       #endregion   &#125;&#125;\r\nIMyLog类代码\r\nusing System;using System.Collections.Generic;using System.Linq;using System.Text;using log4net;namespace TGLog.ExpandILog&#123;   public interface IMyLog : ILog   &#123;       void Debug(int operatorID, string operand, int actionType, object message,string ip, string browser, string machineName);       void Debug(int operatorID, string operand, int actionType,object message,string ip, string browser, string machineName, Exception t);       void Info(int operatorID, string operand, int actionType, object message,string ip, string browser, string machineName);       void Info(int operatorID, string operand, int actionType, object message,string ip, string browser, string machineName, Exception t);       void Warn(int operatorID, string operand, int actionType, object message,string ip, string browser, string machineName);       void Warn(int operatorID, string operand, int actionType, object message, string ip, string browser, string machineName, Exception t);       void Error(int operatorID, string operand, int actionType, object message,string ip, string browser, string machineName);       void Error(int operatorID, string operand, int actionType, object message,string ip, string browser, string machineName, Exception t);       void Fatal(int operatorID, string operand, int actionType, object message,string ip, string browser, string machineName);       void Fatal(int operatorID, string operand, int actionType, object message,string ip, string browser, string machineName, Exception t);   &#125;&#125;\r\n参考\r\n\r\n非常完善的Log4net详细说明-CSDN博客\r\nApache\r\nlog4net – Apache log4net Manual: Configuration - Apache log4net\r\nWhat\r\nIs Structured Logging and Why Developers Need It - Stackify\r\n使用log4net记录日志\r\n\r\n","categories":["Develop","DotNET","日志"],"tags":[".NET","Log4net"]},{"title":"C# 判断文件是否被占用","url":"/posts/2022/E348XP.html","content":"在C#中判断文件是否被占用一般有两种方法，一是利用FileStream结合try...catch...finally实现，二是调用Windows API实现，下面给出两种方法的代码。\r\n\r\n文件流法\r\nusing System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks;namespace ConsoleApp3&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            string filePath = @&quot;D:\\data.xlsx&quot;;            bool occupied = IsOccupied(filePath);            if (occupied)            &#123;                Console.WriteLine(&quot;文件被占用&quot;);            &#125;            else            &#123;                Console.WriteLine(&quot;文件未被占用&quot;);            &#125;            Console.ReadKey(true);        &#125;        static bool IsOccupied(string filePath)        &#123;            FileStream stream = null;            try            &#123;                stream = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.None);                return false;            &#125;            catch            &#123;                return true;            &#125;            finally            &#123;                if (stream != null)                &#123;                    stream.Close();                &#125;            &#125;        &#125;    &#125;&#125;\r\nWindows API法\r\nusing System;using System.Runtime.InteropServices;namespace ConsoleApp3&#123;    class Program    &#123;        // 判断文件是否打开        [DllImport(&quot;kernel32.dll&quot;)]        public static extern IntPtr _lopen(string lpPathName, int iReadWrite);        // 关闭文件句柄        [DllImport(&quot;kernel32.dll&quot;)]        public static extern bool CloseHandle(IntPtr hObject);        // 常量        public const int OF_READWRITE = 2;        public const int OF_SHARE_DENY_NONE = 0x40;        public static readonly IntPtr HFILE_ERROR = new IntPtr(-1);        static void Main(string[] args)        &#123;            string filePath = @&quot;D:\\data.xlsx&quot;;            bool occupied = IsOccupied(filePath);            if (occupied)            &#123;                Console.WriteLine(&quot;文件被占用&quot;);            &#125;            else            &#123;                Console.WriteLine(&quot;文件未被占用&quot;);            &#125;            Console.ReadKey(true);        &#125;        static bool IsOccupied(string filePath)        &#123;            IntPtr handler = _lopen(filePath, OF_READWRITE | OF_SHARE_DENY_NONE);            CloseHandle(handler);            return handler == HFILE_ERROR;        &#125;    &#125;&#125;\r\n参考\r\n原谅链接：https://blog.csdn.net/HerryDong/article/details/115626620\r\n","categories":["Develop","DotNET","实用代码"],"tags":["C#"]},{"title":"C# 获取当前程序运行路径的方法集合","url":"/posts/2023/2JYPDKM.html","content":"本文介绍了如何在 C#\r\n中获取当前程序的运行路径，同时对比这些方法的差别。\r\n\r\n获取方式\r\n\r\n获取当前进程的完整路径，包含文件名(进程名)\r\nstring str = this.GetType().Assembly.Location;result: X:\\xxx\\xxx\\xxx.exe (.exe文件所在的目录+.exe文件名)\r\n获取新的 Process\r\n组件并将其与当前活动的进程关联的主模块的完整路径，包含文件名(进程名)。\r\nstring str = System.Diagnostics.Process.GetCurrentProcess().MainModule.FileName;result: X:\\xxx\\xxx\\xxx.exe (.exe文件所在的目录+.exe文件名)\r\n获取和设置当前目录（即该进程从中启动的目录）的完全限定路径。\r\nstring str = System.Environment.CurrentDirectory;result: X:\\xxx\\xxx (.exe文件所在的目录)\r\n获取当前 Thread\r\n的当前应用程序域的基目录，它由程序集冲突解决程序用来探测程序集。\r\nstring str = System.AppDomain.CurrentDomain.BaseDirectory;result: X:\\xxx\\xxx\\ (.exe文件所在的目录+&quot;\\&quot;)\r\n获取和设置包含该应用程序的目录的名称。(推荐)\r\nstring str = System.AppDomain.CurrentDomain.SetupInformation.ApplicationBase;result: X:\\xxx\\xxx\\ (.exe文件所在的目录+&quot;\\&quot;)\r\n获取启动了应用程序的可执行文件的路径，不包括可执行文件的名称。\r\nstring str = System.Windows.Forms.Application.StartupPath;result: X:\\xxx\\xxx (.exe文件所在的目录)\r\n获取启动了应用程序的可执行文件的路径，包括可执行文件的名称。\r\nstring str = System.Windows.Forms.Application.ExecutablePath;result: X:\\xxx\\xxx\\xxx.exe (.exe文件所在的目录+.exe文件名)\r\n获取应用程序的当前工作目录(不可靠)。\r\nstring str = System.IO.Directory.GetCurrentDirectory();result: X:\\xxx\\xxx (.exe文件所在的目录)\r\n包含应用程序的基目录的字符串，不包括尾部分隔符。这通常是启动程序集的目录。\r\nAppContext.BaseDirectory\r\n获取包含当前执行的程序集的文件的路径\r\nAssembly.GetExecutingAssembly().Location\r\n\r\n这个方法也可以用于获取其他程序集的路径，只要你传入那个程序集的类型。\r\n\r\n\r\n区别\r\n\r\nDirectory.GetCurrentDirectory() 和\r\nEnvironment.CurrentDirectory\r\n都返回当前工作目录的完全限定路径，它们通常是相同的。但是，Directory.GetCurrentDirectory()\r\n返回的路径可能会因为工作目录的改变而改变，而\r\nEnvironment.CurrentDirectory\r\n只是获取当前工作目录的值，不会随着工作目录的改变而改变。\r\nAppContext.BaseDirectory\r\n返回应用程序的基目录，这个目录通常是启动程序集的目录，不包括尾部分隔符。\r\nAssembly.GetExecutingAssembly().Location\r\n获取包含当前执行的程序集的文件的路径，它通常是一个完整的文件路径。使用这个方法时，需要注意，当程序集是从网络上下载时，可能无法获取到它的位置。\r\n\r\n总结\r\n具体使用哪种方法获取当前路径取决于你的具体需求。一般来说，如果你需要获取应用程序的基目录，应该使用\r\nAppContext.BaseDirectory；如果需要获取包含当前执行程序集的文件路径，应该使用\r\nAssembly.GetExecutingAssembly().Location。如果需要获取当前工作目录的路径，可以使用\r\nDirectory.GetCurrentDirectory() 或\r\nEnvironment.CurrentDirectory。\r\n","categories":["Develop","DotNET","实用代码"],"tags":["C#"]},{"title":"Windows 中安装 PaddleOCR","url":"/posts/2022/2775XKA.html","content":"本文记录了如何在 Windows 的环境下(Windows Server 2008 R2)安装\r\nPaddleOCR。\r\n\r\nPython环境搭建\r\n安装Anaconda\r\n\r\n说明：使用paddlepaddle需要先安装python环境，这里我们选择python集成环境Anaconda工具包\r\n\r\nAnaconda是1个常用的python包管理程序\r\n安装完Anaconda后，可以安装python环境，以及numpy等所需的工具包环境。\r\n\r\nAnaconda下载：\r\n\r\n地址：https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/?C=M&amp;O=D\r\n大部分win10电脑均为64位操作系统，选择x86_64版本；若电脑为32位操作系统，则选择x86.exe\r\n\r\n\r\nanaconda download\r\n\r\n下载完成后，双击安装程序进入图形界面\r\n默认安装位置为C盘，建议将安装位置更改到D盘：\r\n\r\n勾选conda加入环境变量，忽略警告：\r\n\r\n\r\n\r\n可以使用 scoop 进行安装：\r\nscoop install miniconda3\r\n打开终端并创建conda环境\r\n\r\n打开Anaconda Prompt终端：左下角Windows Start Menu -&gt; Anaconda3\r\n-&gt; Anaconda Prompt启动控制台\r\n\r\n\r\n创建新的conda环境\r\n# 在命令行输入以下命令，创建名为paddle_env的环境# 此处为加速下载，使用清华源conda create --name paddle_env python=3.8 --channel https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/  # 这是一行命令\r\n该命令会创建1个名为paddle_env、python版本为3.8的可执行环境，根据网络状态，需要花费一段时间\r\n之后命令行中会输出提示信息，输入y并回车继续安装\r\n\r\n激活刚创建的conda环境，在命令行中输入以下命令：\r\n# 激活 paddle_env 环境conda activate paddle_env# 查看当前python的位置where python\r\n\r\n\r\n以上 anaconda 环境和 python 环境安装完毕!\r\n保持 paddle_env\r\n处于激活状态，下面两步都需要在这个环境中进行安装。\r\n\r\n安装PaddlePaddle\r\n\r\n您的机器安装的是CUDA9或CUDA10，请运行以下命令安装\r\npython -m pip install paddlepaddle-gpu -i https://mirror.baidu.com/pypi/simple\r\n您的机器是CPU，请运行以下命令安装\r\npython -m pip install paddlepaddle -i https://mirror.baidu.com/pypi/simple\r\n\r\n安装PaddleOCR whl包\r\npip install &quot;paddleocr&gt;=2.0.1&quot; # 推荐使用2.0.1+版本\r\n对于Windows环境用户：直接通过pip安装的shapely库可能出现[winRrror 126] 找不到指定模块的问题。建议从这里下载shapely安装包完成安装。\r\n其中 cp38 中的 38 代表 python 版本号。\r\n# 卸载原来的 shapelypip uninstall shapely# 复制下载的安装文件到当前目录，执行如下命令pip install Shapely-1.8.2-cp39-cp39-win_amd64.whl\r\n测试\r\npaddleocr --image_dir ./imgs/11.jpg --use_angle_cls true --use_gpu false\r\n","categories":["Develop","Python","PaddleOCR"],"tags":["PaddleOCR"]},{"title":"Python 中函数的参数","url":"/posts/2023/JKVCZP.html","content":"函数的参数有 4 种，本文对这 4\r\n种进行简要列举，方便回忆，详细请阅读后文中的参考链接。\r\n\r\n位置参数\r\n用法如下 ：\r\ndef power(x):    return x * x\r\n使用要点：\r\n\r\n在调用时，必须按顺序给位置参数传递值\r\n\r\n默认参数\r\n用法如下：\r\ndef power(x, n=2):    s = 1    while n &gt; 0:        n = n - 1        s = s * x    return s\r\n使用要点：\r\n\r\n默认参数应在位置参数后面\r\n在调用时，默认参数可以不传递值。没有值时取默认值\r\n默认参数必须指向不变对象\r\n\r\n\r\n在类的定义中，可以使用默认参数来实现函数的重载\r\n\r\n可变参数\r\n可变参数定义如下：\r\ndef calc(*numbers):    sum = 0    for n in numbers:        sum = sum + n * n    return sum\r\n调用：\r\n# 使用方式1nums = [1, 2, 3]calc(nums[0], nums[1], nums[2])# 使用方式2nums2 = (1,2,3) # 定义一个 tuplecal(*nums2)\r\n使用要点：\r\n\r\n可变参数接收者是 tuple 类型\r\n\r\n关键字参数\r\n关键字参数允许传入任意个(包含 0\r\n个)含参数名的参数，这些关键字参数在函数内部自动组装为一个 dict\r\n类型。\r\n非命名关键字参数\r\ndef person(name, age, **kw):    print(&#x27;name:&#x27;, name, &#x27;age:&#x27;, age, &#x27;other:&#x27;, kw)\r\n命名关键字参数\r\n如果要限制关键字参数的名字，就可以用命名关键字参数。\r\n使用时，只能传入指定的关键字名，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。\r\ndef person(name, age, *, city, job=“dev”):    print(name, age, city, job)\r\n使用要点：\r\n\r\n使用时，只能传入指定的关键字名。\r\n命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。\r\n如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*：\r\n命名参数可以设置默认值\r\n没有默认值的命名参数，必须要传入值\r\n\r\n参数组合\r\n当必选参数、默认参数、可变参数、关键字参数和命名关键字参数组合使用时，其定义顺序为：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。\r\ndef f1(a, b, c=0, *args, **kw):    print(&#x27;a =&#x27;, a, &#x27;b =&#x27;, b, &#x27;c =&#x27;, c, &#x27;args =&#x27;, args, &#x27;kw =&#x27;, kw)\r\n可以通过 tuple 和 dic 调用上述函数：\r\nargs = (1, 2, 3, 4)kw = &#123;&#x27;d&#x27;: 99, &#x27;x&#x27;: &#x27;#&#x27;&#125;f1(*args, **kw)\r\n\r\n注意前面的 * 号\r\n\r\n所以：对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的。\r\n致谢\r\n本文参考以下文章，在此报以诚挚谢意！\r\n\r\n函数的参数-廖雪峰的官方网站\r\n\r\n","categories":["Develop","Python","Base"],"tags":["Python"]},{"title":"聚合","url":"/posts/2021/MAACZD.html","content":"聚合操作将来自多个文档分组在一起，并可以对分组数据执行各种操作，然后返回单个结果。\r\n\r\nMongoDB提供了三种聚合方式:\r\n\r\nAggregation Pipeline\r\nMap-Reduce Function\r\nSingle Purpose Aggreation Methods\r\n\r\nAggregations Pipeline\r\n聚合管道主要用于对数据的查询，转换和修改。\r\n格式：\r\ndb.orders.aggregate([   &#123; $match: &#123; status: &quot;A&quot; &#125; &#125;,   &#123; $group: &#123; _id: &quot;$cust_id&quot;, total: &#123; $sum: &quot;$amount&quot; &#125; &#125; &#125;])\r\n基础的聚合使用 聚合操作\r\n来进行查询。聚合操作也可以在分布式集合（Sharding\r\nCollection）中使用。\r\n优化：\r\n聚合管道还可以通过索引来优化性能。\r\nSingle Purpose\r\nAggregation Operations\r\nMongodb 使用\r\nestimateDocumentCount()、count()、distinct()\r\n来从集合中聚合文档。\r\nMap-Reduce\r\n从 5.0 开始，map-reduce 已经弃用。\r\nMap-reduce 操作将大量的数据转成有用的聚合数据。\r\n","categories":["Develop","Database","Mongodb","Aggregation"],"tags":["MongoDB","Aggregation"]},{"title":"mongodb聚合中将多个数组合并成一个数组","url":"/posts/2022/2GHTM80.html","content":"需求\r\n有时候，我们需要在查询结果中将某个字段(其类型是数组)合并起来，仅返回一个数组。\r\n\r\n例子\r\n假设集合 user：\r\n// 小明&#123;     &quot;_id&quot; : ObjectId(&quot;5eb6bb5bc95fdd10d0f6d21e&quot;),     &quot;name&quot; : &quot;小明&quot;,     &quot;education&quot; : &quot;本科&quot;,     &quot;experiences&quot; : [        &#123;            &quot;profession&quot; : &quot;程序员&quot;,             &quot;ability&quot; : [                &quot;java&quot;,                 &quot;nodejs&quot;,                 &quot;golang&quot;            ]        &#125;    ]&#125;// 小红&#123;     &quot;_id&quot; : ObjectId(&quot;5eb6bbdbc95fdd10d0f6d220&quot;),     &quot;name&quot; : &quot;小红&quot;,     &quot;education&quot; : &quot;本科&quot;,     &quot;experiences&quot; : [        &#123;            &quot;profession&quot; : &quot;销售&quot;,             &quot;ability&quot; : [                &quot;沟通&quot;,                 &quot;财务计算&quot;            ]        &#125;,         &#123;            &quot;profession&quot; : &quot;采购员&quot;,             &quot;ability&quot; : [                &quot;英语&quot;,                 &quot;统计&quot;            ]        &#125;    ]&#125;// 小三&#123;     &quot;_id&quot; : ObjectId(&quot;5eb6bdbbc95fdd10d0f6d23f&quot;),     &quot;name&quot; : &quot;小三&quot;,     &quot;education&quot; : &quot;大专&quot;,     &quot;experiences&quot; : [        &#123;            &quot;profession&quot; : &quot;行政助理&quot;,             &quot;ability&quot; : [                &quot;英语&quot;            ]        &#125;    ]&#125;\r\n接下来我想查询出所有学历为 本科\r\n的阅历(experiences)列表，并把它们合并成一个数组返回，返回期望结果如下：\r\n&#123;     &quot;_id&quot; : &quot;1&quot;,     &quot;experiences&quot; : [        &#123; &quot;profession&quot; : &quot;销售&quot;, &quot;ability&quot; : [&quot;沟通&quot;, &quot;财务计算&quot;] &#125;,         &#123; &quot;profession&quot; : &quot;采购员&quot;, &quot;ability&quot; : [&quot;英语&quot;,  &quot;统计&quot;]&#125;,         &#123; &quot;profession&quot; : &quot;程序员&quot;, &quot;ability&quot; : [&quot;java&quot;, &quot;nodejs&quot;, &quot;golang&quot;]&#125;    ]&#125;\r\nAggregate 实现\r\ndb.getCollection(&quot;user&quot;).aggregate(    [        &#123;             &quot;$match&quot; : &#123; &quot;education&quot; : &quot;本科&quot; &#125;        &#125;,         &#123;             &quot;$group&quot; : &#123;                &quot;_id&quot; : &quot;1&quot;,                 &quot;experiences&quot; : &#123;                    &quot;$addToSet&quot; : &quot;$experiences&quot;                &#125;            &#125;        &#125;,         &#123;             &quot;$project&quot; : &#123;                &quot;experiences&quot; : &#123;                    &quot;$reduce&quot; : &#123;                        &quot;input&quot; : &quot;$experiences&quot;,                         &quot;initialValue&quot; : [],                         // this 是指每个迭代的数组元素，value 指上一次操作的结果值                        &quot;in&quot; : &#123; &quot;$concatArrays&quot; : [&quot;$$value&quot;, &quot;$$this&quot;] &#125;                    &#125;                &#125;            &#125;        &#125;    ])\r\n参考\r\n本文摘抄至以下文章，在此表示诚挚感谢！\r\n\r\nmongo\r\n使用聚合合并字段\r\nhttps://docs.mongodb.com/manual/reference/operator/aggregation/reduce/\r\n\r\n","categories":["Develop","Database","Mongodb","Aggregation"],"tags":["MongoDB","Database"]},{"title":"MongoDB 中的数组字段 $lookup 技巧","url":"/posts/2022/1X1W7HR.html","content":"在 MongoDB 中可以直接对数组字段进行\r\n$lookup，完全不需要先将数组进行 $unwind。\r\n\r\n以下面的代码为例：\r\nconst userLevelRoles = await this.model(&#x27;user&#x27;).aggregate([  &#123;    $match: &#123;      userId: &#123; $eq: userId &#125;    &#125;  &#125;,  // 用户与角色  &#123;    $lookup: &#123;      from: &#x27;user_role&#x27;,      localField: &#x27;_id&#x27;,      foreignField: &#x27;userId&#x27;,      as: &#x27;userRoles&#x27;    &#125;  &#125;,  // 角色  &#123;    $lookup: &#123;      from: &#x27;role&#x27;,      localField: &#x27;userRoles.roleId&#x27;,      foreignField: &#x27;_id&#x27;,      as: &#x27;rolesOfUser&#x27;    &#125;  &#125;])\r\n从上面的查询中我们可以看到，第一个 $lookup 出来的\r\nuserRoles\r\n是一个数组，当用这个字段再次进行查询时，只需要将它当成一个对象使用即可。\r\n","categories":["Develop","Database","Mongodb","Aggregation"],"tags":["MongoDB","Aggregation"]},{"title":"Python 中使用 APScheduler 配置异步任务","url":"/posts/2025/298WWWS.html","content":"在 Python 开发中，经常需要执行一些定时任务，本文对比了\r\nAPScheduler、Celery、Celery\r\n三个定时库，最终选择 APScheduler 作为定时器框架。\r\n本文主要介绍如何在 FastApi\r\n中集成异步的定时任务，同时列出自己配置过程中遇到的坑点。\r\n\r\n测试代码\r\n可以将下列代码保存为 .py 文件，运行测试。\r\n# 需要提前安装  pip install apschedulerimport asynciofrom apscheduler.schedulers.asyncio import AsyncIOSchedulerasync def async_job():    print(&quot;这是一个异步任务&quot;)    await asyncio.sleep(1)  # 模拟异步IO操作async def main():    scheduler = AsyncIOScheduler()    scheduler.add_job(async_job, &quot;interval&quot;, seconds=3)    scheduler.start()    # 保持程序运行，直到中断    try:        await asyncio.sleep(float(&quot;inf&quot;))    except (KeyboardInterrupt, SystemExit):        pass# 使用 asyncio.run 启动异步主函数asyncio.run(main())\r\nFastAPI 集成\r\n为了更好的复用，在 python 中，对 schedule 进一步乾抽象，UML\r\n图如下所示：\r\nclassDiagram    class BaseScheduleJob &#123;        +job_id: str        +start()        +run_async()    &#125;    class BaseIntervalScheduleJob &#123;        +interval: int        +start()    &#125;    class BaseCronScheduleJob &#123;        +corn: str        +start()            &#125;    class IntervalTestScheduleJob &#123;        +run_async()    &#125;        BaseScheduleJob &lt;|-- BaseIntervalScheduleJob : inherits    BaseScheduleJob &lt;|-- BaseCronScheduleJob : inherits    BaseIntervalScheduleJob &lt;|-- IntervalTestScheduleJob : inherits\r\n在启动时，注入生命周期函数，在该函数中启动调度器：\r\n@asynccontextmanagerasync def lifespan(app: FastAPI):    &quot;&quot;&quot;    生命周期管理    &quot;&quot;&quot;    logger.info(&quot;应用生命周期启动...&quot;)    # region 定时任务    # 在这里可以放置应用启动时需要执行的代码    from app.schedule.scheduler import use_scheduler    logger.info(&quot;初始化定时任务调度器...&quot;)    use_scheduler()    logger.info(&quot;定时任务调度器初始化完成!&quot;)    # endregion    # yield 之前的代码（如加载 ML 模型）在上下文进入时执行，即应用启动时。    # yield 之后的代码（如清理模型）在上下文退出时执行，即应用关闭时。    yield    # Clean up the ML models and release the resources    logger.info(&quot;应用生命周期结束...&quot;)app = FastAPI(lifespan=lifespan)\r\nscheduler 初始化的代码节选如下：\r\n# 用于持久化的设置，使用MongoDB# client 用于设置你自己的 MongoDB 的 handler, 即 MongoClient对象# database 为 apschedulerjobstores = &#123;&quot;default&quot;: MongoDBJobStore(client=pymongo_client)&#125;# 要特别注意，executors 只能在 BackgroundScheduler 中使用，在 AsyncIOScheduler 不要配置，会报错# executors = &#123;&quot;default&quot;: ThreadPoolExecutor()&#125;job_defaults = &#123;&quot;coalesce&quot;: False, &quot;max_instances&quot;: 5&#125;# 这里使用 BackgroundScheduler 即可scheduler = AsyncIOScheduler(    jobstores=jobstores,    # executors=executors,    job_defaults=job_defaults,    timezone=datetime.timezone.utc,)\r\n遇到的坑\r\n设置 ThreadPoolExecutor 后，提示 never\r\nawaited，导致计划不执行\r\nRuntimeWarning: coroutine &#x27;BaseScheduleJob.run_async&#x27; was never awaited  del work_item\r\n使用 AsyncIOScheduler 时不应设置 executors\r\n持久化到数据库后，内部状态无法持久保存\r\n当将计划持久到数据库后，对象类中的状态无法被更新，应将触发的回调当做静态函数使用。\r\n猜测是因为每次执行时，都会从数据库中重新实例化对象。\r\n参考\r\n本文参考以下文章，在此致以诚挚谢意！\r\n\r\nPython定时任务-schedule\r\nvs. Celery vs. APScheduler 比较_python\r\nshced和apscheduler区别-CSDN博客\r\n\r\n","categories":["Develop","Python","Base"],"tags":["Python"]},{"title":"Vue2.x帮助文档读书笔记","url":"/posts/2021/17EC6DQ.html","content":"随着工作中不断使用 vue，总感觉对 vue\r\n的使用不够随心所欲，所以，本篇为重新学习 vue\r\n的帮助文档，并将精华部分整理成笔记。本记录 Vue.js 2.x 的帮助文档。\r\n\r\n基础\r\nVue 实例\r\n\r\n创建实例\r\n当一个 Vue 实例被创建时，它将 data 对象中的所有的\r\nproperty 加入到 Vue 的响应式系统中。\r\n/ 我们的数据对象var data = &#123; a: 1 &#125;// 该对象被加入到一个 Vue 实例中var vm = new Vue(&#123;  data: data&#125;)\r\n\r\n值得注意的是只有当实例被创建时就已经存在于 data 中的\r\nproperty 才是响应式的。\r\n使用 Object.freeze(obj)，这会阻止修改现有的\r\nproperty，也意味着响应系统无法再追踪变化。\r\n\r\n访问实例的 property 和方法\r\nvue 本身 property 和方法，它们都有前缀\r\n$，以便与用户定义的 property 区分开来\r\nvar data = &#123; a: 1 &#125;var vm = new Vue(&#123;  el: &#x27;#example&#x27;,  data: data&#125;)vm.$data === data // =&gt; truevm.$el === document.getElementById(&#x27;example&#x27;) // =&gt; true// $watch 是一个实例方法vm.$watch(&#x27;a&#x27;, function (newValue, oldValue) &#123;  // 这个回调将在 `vm.a` 改变后调用&#125;)\r\n\r\n模板语法\r\n","categories":["Develop","Javascript","Vue","Vue2.x"],"tags":["vue"]},{"title":"vue 中 this.$forceUpdate 生效范围","url":"/posts/2022/39S6V31.html","content":"在 vue 中，当使用 $forceUpdate\r\n时，要特别注意，该方法仅对被 vue 监听的字段生效。\r\n\r\n所以，在使用中，如果需要更新某个字段时，使用 this.$set()\r\n来修改或添加字段。\r\n参考\r\nvue\r\n强制更新\r\n","categories":["Develop","Javascript","Vue","Vue2.x"],"tags":["vue"]},{"title":".NET 中对所有类添加 IgnoreExtraElements 属性","url":"/posts/2022/JME2G9.html","content":"在将 mongodb 中的数据映射到类的时候，当 mongodb\r\n中的字段与定义的实体类的字段不一样时，会报错，此时只需要在类上添加\r\nBsonIgnoreExtraElements 特性，即可解决。\r\n\r\n正文\r\n假设有如下 mongodb 数据：\r\n[  &#123;    &quot;Name&quot;: &quot;zhangsan&quot;,    &quot;Age&quot;: 20,    &quot;Gender&quot;: &quot;男&quot;  &#125;,  &#123;    &quot;Name&quot;: &quot;xiaofang&quot;,    &quot;Age&quot;: 18  &#125;]\r\n数据库对应的类的定义为：\r\n[BsonIgnoreExtraElements]public calss Person&#123;    public string Name&#123;get;set;&#125;    public int Age&#123;get;set;&#125;&#125;\r\n为了使 mongodb 在映射到 Person 时不报错，要在\r\nPerson 上添加 [BsonIgnoreExtraElements]\r\n特性。\r\n\r\nBsonIgnoreExtraElements 位于命名空间\r\nMongoDB.Bson.Serialization.Attributes 中\r\n\r\n这种方式有个弊端，如果要在每一个类上添加\r\n[BsonIgnoreExtraElements]，那写代码时简直难受，且代码侵入性很大。\r\n有没有办法将 BsonIgnoreExtraElements\r\n应用于所有的类呢？\r\n当然有，其方法如下，只需要在初始化 MongoClient\r\n之前运行一次如下代码即可。该设置是单例的，下次初始化时就不需要运行了。\r\n// mongodb 全局设置var pack = new ConventionPack();// 在反序列化时，忽略多出的字段pack.Add(new IgnoreExtraElementsConvention(true));pack.Add(new IgnoreIfNullConvention(true));\r\n\r\nConventionPack 位于命名空间 MongoDB.Bson.Serialization.Conventions\r\n中\r\n\r\n\r\nIgnoreExtraElementsConvention：忽略库中有但是类中没有定义的字段。这个一般用于敏感字段处理，例如密码字段，它会存在用户\r\nCollection\r\n中，但是这个字段只是登录校验的时候会用到（这时可以用js来查询），其他用户查询（linq查询）基本都不需要用到密码字段。\r\nIgnoreIfNullConvention：如果字段\r\nnull，则不存这个字段，简单来说就是省空间，假设一个类中有\r\nA，B 两个字段，其中 A\r\n字段为空，如果指定该设置，存为 {B:'B'}，否则，存为\r\n{A:null, B:'B'}。\r\n\r\n参考\r\n\r\nMongoDB系列（二）：C#应用\r\nMongoDB\r\nC#驱动程序 - 忽略绑定上的字段\r\n\r\n","categories":["Develop","Database","Mongodb","DotNet"],"tags":[".NET","MongoDB"]},{"title":"Vue 如何同时传递子组件和父组件的参数给方法","url":"/posts/2022/3Q3PPSM.html","content":"前言\r\n在 vue 自定义事件中，子组件会通过 emit\r\n向父组件传递参数，父组件执行回调函数。但是有时候父组件再执行回调时也需要传入参数，如果直接给父组件回调函数传入参数会覆盖掉子组件的参数。我们有三种解决办法。\r\n正文\r\n$event 方法\r\n// 子组件中 Child.vue&lt;script setup&gt;  const &#123; proxy &#125; = getCurrentInstance()  function edit (item) &#123;      console.log(&#x27;子组件参数&#x27;, childParam)      proxy.$emit(&#x27;edit&#x27;, childParam)  &#125;&lt;/script&gt;// 父组件接收参数&lt;Child @edit=&quot;editFun($event, parentParam)&quot;&gt;&lt;/Child&gt;\r\n当子组件有参数返回时，在父组件中使用 $event 作为占位符，这里 $event\r\n就代表了子组件返回的参数。这里 $event\r\n位置没有限制，可以在第一位，也可以在最后一位。\r\n\r\n局限性：\r\n只适合子组件返回一个参数的情况，如果子组件有多个参数返回，只能接收到第一个参数\r\n\r\n箭头函数法\r\n// 子组件中 Child.vue&lt;script setup&gt;  const &#123; proxy &#125; = getCurrentInstance()  function edit (item) &#123;      proxy.$emit(&#x27;edit&#x27;, childParam1, childParam2)  &#125;&lt;/script&gt;......// 父组件接收参数&lt;Child @edit=&quot;(param1,param2)=&gt;editFun(param1,param2,parentParam)&quot;&quot;&gt;&lt;/Child&gt;&lt;script setup&gt;function editFun(p1,p2,p3)&#123;  ...&#125;&lt;/script&gt;\r\n这种方法利用了一个箭头函数先把子模块返回的参数接收，然后再传递到回调函数中。\r\n\r\n使用是注意先接收子模块返回的参数，此方法对参数个数没有限制\r\n\r\narguments 方法\r\n此方法类似于方法一，只不过是用 arguments 作为占位符,这里 argument\r\n是一个数组\r\n// 父组件接收参数&lt;Child @edit=&quot;editFun(arguments, scope.row)&quot;&gt;&lt;/Child&gt;&lt;script setup&gt;function editFun(p1,p2)&#123;  ...&#125;&lt;/script&gt;\r\n参考\r\n本文摘抄至以下文章，在此表示诚挚感谢！\r\n\r\nVue3自定义事件中，子组件有返回参数，父组件也有参数的处理方法\r\n\r\n","categories":["Develop","Javascript","Vue","Vue2.x"],"tags":["vue"]},{"title":"vue 中完美地二次封装 UI 组件","url":"/posts/2022/2H9CDXZ.html","content":"当我们全局引用UI框架（类似于 Quasar\r\nFramework）的时候，为了使得整个项目风格统一，需要对某些组件进行二次封装，使得可以集中管理组件风格，使得代码易于维护。\r\n\r\n封装需求\r\n\r\n属性传递\r\n二次封装后的组件与被封装组件和具有同样的参数\r\n&lt;xxx-xxx v-bind=&quot;$attrs&quot;&gt;&lt;/xxx-xxx&gt;\r\n事件传递\r\n&lt;xxx-xxx v-on=&quot;$listeners&quot;&gt;&lt;/xxx-xxx&gt;\r\n插槽传递\r\n&lt;xxx-xxx&gt;\t&lt;template v-for=&quot;name in $scopedSlots&quot; :slot=&quot;name&quot;&gt;\t\t&lt;slot :name=&quot;name&quot; /&gt;\t&lt;/template&gt;&lt;/xxx-xxx&gt;\r\n\r\nvue 相关知识点\r\nvm.$attrs\r\n官方解释：\r\n\r\n包含了父作用域中不作为 prop 被识别 (且获取) 的 attribute 绑定\r\n(class 和 style 除外)。当一个组件没有声明任何\r\nprop 时，这里会包含所有父作用域的绑定 (class 和\r\nstyle 除外)，并且可以通过 v-bind=\"$attrs\"\r\n传入内部组件——在创建高级别的组件时非常有用。\r\n\r\n通俗的理解就是，子组件可以通过 $attrs\r\n可以访问父组件传过来的所有属性，但需要注意的是如果父组件所传的属性中有在子组件\r\nprops 中有过声明，那么该属性不会出现在 $attrs\r\n对象中。\r\nvm.$listeners\r\n官方解释：\r\n\r\n包含了父作用域中的 (不含 .native 修饰器的)\r\nv-on 事件监听器。它可以通过 v-on=\"$listeners\"\r\n传入内部组件——在创建更高层次的组件时非常有用。\r\n\r\nvm.$props\r\n官方解释：\r\n\r\n当前组件接收到的 props 对象。Vue 实例代理了对其 props 对象 property\r\n的访问。\r\n\r\ninheritAttrs\r\n官方的解释让人看着头大，通俗来讲，其实默认情况就是把\r\n$attrs 对象上没在子组件 props\r\n中声明的属性加在子组件的根 html 标签上。\r\nvm.$scopedSlots\r\n官方解释：\r\n\r\n用来访问作用域插槽。对于包括\r\n默认 slot 在内的每一个插槽，该对象都包含一个返回相应 VNode\r\n的函数。\r\n\r\n通俗讲，就是通过该属性，可以访问所有的插槽。\r\n封装示例\r\n为了能够实现上述两个需求，我们使用\r\n$attrs、$props和$listeners\r\n这三个属性来实现。下文将通过封装 quasar 组件中的\r\nQTable 来举例说明\r\n原始组件\r\n从 QTable\r\nAPI 中我们可以知道，其有63个属性，19 个插槽，9\r\n个事件，在封装的时候，我们需要通过预设一些属性，使得表格符合我们的使用，但是又得保证其灵活性。\r\n\r\n\r\nimage-20220406214311656\r\n\r\n二次封装\r\n具体解释见里面的备注\r\n&lt;template&gt;  &lt;q-table v-bind=&quot;$attrs&quot; :dense=&quot;dense&quot; v-on=&quot;$listeners&quot;&gt;    &lt;!--示例: 在封装组件中增加插槽，通过后备内容进行自定义，方便父组件覆盖当前插槽--&gt;    &lt;template v-slot:top=&quot;props&quot;&gt;      &lt;slot name=&quot;top&quot; v-bind=&quot;props&quot;&gt;        &lt;q-space /&gt;        &lt;q-input          v-model=&quot;filter&quot;          dense          debounce=&quot;300&quot;          placeholder=&quot;搜索&quot;          color=&quot;primary&quot;        &gt;          &lt;template v-slot:append&gt;            &lt;q-icon name=&quot;search&quot; /&gt;          &lt;/template&gt;        &lt;/q-input&gt;      &lt;/slot&gt;    &lt;/template&gt;    &lt;!--根据父类插槽定义，传递插槽到被封装组件--&gt;    &lt;template v-for=&quot;slotName in scopedSlotsName&quot; v-slot:[slotName]=&quot;props&quot;&gt;      &lt;!-- v-bind 是向插槽中传递参数，使得父类的插槽可以使用--&gt;      &lt;slot :name=&quot;slotName&quot; v-bind=&quot;props&quot; /&gt;    &lt;/template&gt;  &lt;/q-table&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  // 默认为 true,为 true 时会把 `$attrs` 对象上没在子组件 `props` 中声明的属性加在子组件的根 `html` 标签上。  inheritAttrs: false,  props: &#123;    // 设置组件的默认值    dense: &#123;      type: Boolean,      default() &#123;        return true      &#125;    &#125;  &#125;,  data() &#123;    return &#123;      filter: &#x27;filter2&#x27;    &#125;  &#125;,  computed: &#123;    attrs() &#123;      // 因为 $attrs 不包含 $props 中的值，在此处对属性进行合并，然后供被封装组件使用      // 由于 Object.assign 是浅复制，所以不会影响字段的 getter 和 setter      return Object.assign(&#123;&#125;, this.$attrs, this.$props)    &#125;,    // 作用域内的插槽名称    scopedSlotsName() &#123;      let keys = Object.keys(this.$scopedSlots)      // 过滤掉以$开头的字段,$ 开头的是 vue 框架的值      keys = keys.filter(key =&gt; !key.startsWith(&#x27;$&#x27;))      // 过滤掉已经添加插槽名称      const existSlotNames = [&#x27;top&#x27;]      keys = keys.filter(key =&gt; !existSlotNames.includes(key))      return keys    &#125;  &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;&gt;\r\n组件使用\r\n&lt;template&gt;  &lt;wrapped-table :data=&quot;data&quot; :columns=&quot;columns&quot; :dense=&quot;dense&quot;&gt;    &lt;template v-slot:body-cell-index=&quot;props&quot;&gt;      &lt;q-td&gt;&#123;&#123; props.value &#125;&#125;_1&lt;/q-td&gt;    &lt;/template&gt;  &lt;/wrapped-table&gt;&lt;/template&gt;&lt;script&gt;import WrappedTable from &#x27;./index.vue&#x27;export default &#123;  components: &#123; WrappedTable &#125;,  data() &#123;    return &#123;      columns: [        &#123;          name: &#x27;index&#x27;,          label: &#x27;序号&#x27;,          align: &#x27;left&#x27;,          field: &#x27;name&#x27;        &#125;,        &#123;          name: &#x27;name&#x27;,          align: &#x27;center&#x27;,          label: &#x27;名称&#x27;,          field: &#x27;name&#x27;,          sortable: true        &#125;      ],      data: [        &#123;          index: 1,          name: &#x27;Frozen Yogurt&#x27;        &#125;,        &#123;          index: 1,          name: &#x27;Ice cream sandwich&#x27;        &#125;      ],      dense: false    &#125;  &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;\r\n参考\r\n\r\n解决Vue2.x中二次封装Vue组件时批量继承属性，方法，插槽的方法\r\nVue二次封装组件，并传递props和v-on事件\r\n基于UI库二次组件封装\r\n- SegmentFault 思否\r\n浅谈 Vue2.4.0\r\n$attrs 与 inheritAttrs - SegmentFault 思否\r\n插槽 —\r\nVue.js (vuejs.org)\r\n\r\n","categories":["Develop","Javascript","Vue","Vue2.x"],"tags":["Vue"]},{"title":"vue 中 v-model 的最佳实现","url":"/posts/2022/DPK9DJ.html","content":"在利用 vue\r\n开发一个组件时，可能需要它能够实时响应变化的值，这个时候我们就需要用到\r\nv-model。\r\n然而在实际使用中，如果有两个相互影响的变量要进行实时变化时，就可能导致无限循环，提升编码难度。\r\n本文给出了一个 v-model 的最佳实践，可以参考使用。\r\n\r\n需求示例\r\n假设我们需要编写一个部门用户选择组件，它能够同时返回选择的部门和用户，同时在初始化时，可以回显到界面。\r\n下面大致分析一下可能导致的问题：\r\n如果用户数据改变后，则返回的部门也需要触发变化，而返回的部门改变了，又会去触发用户改变，这样就构成了一个无限循环。\r\n要如何解决这个问题呢？继续向下阅读。\r\n实现代码\r\n&lt;template&gt;  &lt;div&gt;    &lt;DepartmentTree v-model=&quot;_departmentIds&quot;&gt;部门树&lt;/DepartmentTree&gt;    &lt;UsersTable v-model=&quot;_users&quot;&gt;用户列表&lt;/UsersTable&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import DepartmentTree from &#x27;./departmentTree.vue&#x27;import UsersTable from &#x27;./usersTable.vue&#x27;export default &#123;  components: &#123; DepartmentTree, UsersTable &#125;,  props: &#123;    departmentIds: &#123;      type: Array,      default: () =&gt; []    &#125;,    users: &#123;      type: Array,      default: () =&gt; []    &#125;  &#125;,  data() &#123;    return &#123;      _departmentIds: this.users,      _users: this.departmentIds    &#125;  &#125;,  computed: &#123;    // 使得每次返回的值不是同一个引用    // 在 watch 时可以解决新旧值一样的问题    usersCp() &#123;      return JSON.parse(JSON.stringify(this.users))    &#125;  &#125;,  watch: &#123;    // 外部更改后，触发更新    departmentIds(newValues) &#123;      // 判断与 this._departmentIds 的区别，如果是完全一样，则不继续执行      if (newValues.lenght === this._departmentIds.length) return      // 如果不一样时,通过部门来更新 _users 数据      // 触发 users 更改      this.usersChanged()      // 此处不需要触发 departments 修改，因为这个函数调用是由于外部的变化传递进来的    &#125;,    // 直接 watch users 的话，newValues 和 oldValues 是一样的    // 此处 watch 计算属性，这样就使得每次的结果不是同一个引用，新旧值就会不一样了    usersCp(newValues, oldValues) &#123;      // 判断与 this._users 是否一样      if (this._users.length === newValues.lenght) return      // 将用户对应的 departmentIds 更新到 this._departmentIds 中      this._departmentIds = Array.from(new Set(this.users.map(x =&gt; x.departmentId)))      // 触发 departmentIds 改变      this.departmentIdsChanged()      // departmentIds 改变后，会触发 departmentIds watch 事件,      // 在这个事件执行时，会先匹配是否与当前实例保存的值一样，如果一样就不执行      // 这样就不会导致无限循环了    &#125;  &#125;,  methods: &#123;    usersChanged() &#123;      this.$emit(&#x27;update:users&#x27;, this._users)    &#125;,    departmentIdsChanged() &#123;      this.$emit(&#x27;update:departmentIds&#x27;, this._departmentIds)    &#125;  &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;\r\n上述代码的主要思想如下：\r\n\r\n将外部变化与内部变化分开处理，外部变化处理通过 watch props\r\n来实现，内部变化通过内部方法来实现\r\n变化完成后，再向外传递变化结果\r\n每次外部变化影响到内部时，都要进行验证，防止循环\r\n\r\nwatch 数组时新旧值相同处理\r\n如果被 watch\r\n的字段是一个数组时，它的新旧值都是一样的，因为引用相同，为了得到不一样的值，可以增加一个计算属性来进行过渡。\r\n如上例中的 usersCp。\r\n参考\r\n自定义组件的\r\nv-model\r\n","categories":["Develop","Javascript","Vue","Vue2.x"],"tags":["Vue"]},{"title":"asyncComputed 的原理浅析及使用","url":"/posts/2022/3G3ZXDE.html","content":"在 vue 的计算属性中，是不能使用异步的，这个时候就需要用到 vue-async-computed\r\n这个包提供的 asyncComputed 来实现异步计算属性。\r\n本文将浅析其实现原理，然后介绍使用方法。\r\n\r\n主要步骤\r\n\r\n利用 asyncComputed 的 key 在 data 中初始化数据\r\n将 asyncComputed 的计算属性重命名赋值给 computed\r\nwatch 重命名后的计算属性\r\n当重命名的计算属性更改后，watch 生效，将值赋给 data\r\n中对应的字段\r\n\r\n\r\n在使用 this.asyncComputedField 时，其实是读取的 data\r\n中对应名称的字段的值\r\n\r\n参考\r\nvue-async-computed\r\nVue\r\n异步计算属性实现\r\nasyncComputed源码解析\r\nasyncComputed\r\n异步计算属性\r\n","categories":["Develop","Javascript","Vue","Vue2.x"],"tags":["Vue"]},{"title":"如何优雅地实现 echarts 的自适应","url":"/posts/2023/1G6444M.html","content":"要实现 echarts 窗口自适应变化，可以使用 ResizeObserver API\r\n监听容器元素的大小变化，并在容器大小变化时调用 echarts 实例的\r\nresize() 方法重新渲染图表。\r\n代码如下：\r\n\r\nimport &#123; watch &#125; from &#x27;vue&#x27;/** * eCharts 图表自适应 * 在 chart 值就去时会自动注册自适应逻辑 * @param &#123;ref&#125; echartRef */export function resizeECharts(echartRef) &#123;  if (!echartRef) return  function resizeCallback() &#123;    if (echartRef &amp;&amp; echartRef.value) echartRef.value.resize()  &#125;  watch(echart, newValue =&gt; &#123;    if (!newValue) return    const parentDom = newValue._dom.parentElement    // 监听 parentDom 元素的大小变化    const observer = new ResizeObserver(() =&gt; &#123;      resizeCallback()    &#125;)    observer.observe(parentDom)  &#125;)&#125;\r\n","categories":["Develop","Javascript","Vue","Vue2.x"],"tags":["Vue","Vue2.x"]},{"title":"vue3 如何在 setup 中调用异步方法","url":"/posts/2023/2KBPKH9.html","content":"\r\n\r\nasync-await\r\n\r\n到目前为止，vue3 中的 setup\r\n本身不能是异步函数，因此我们如果需要使用 async\r\n函数，要将异步操作包装起来。可以通过以下方式实现：\r\n\r\n方法一：使用 suspense\r\n使用suspense 包裹你的组件，然后使用\r\nasync setup()。这种方式目前为实验性功能，不稳定。\r\n&lt;Suspense&gt;  &lt;!-- 具有深层异步依赖的组件 --&gt;  &lt;Dashboard /&gt;  &lt;!-- 在 #fallback 插槽中显示 “正在加载中” --&gt;  &lt;template #fallback&gt;    Loading...  &lt;/template&gt;&lt;/Suspense&gt;# 若使用 script setup 语法时，可以直接在里面使用 await 等待异步返回&lt;script setup&gt;export default &#123;  async setup() &#123;    // 在 `setup` 内部使用 `await` 需要非常小心    // 因为大多数组合式 API 函数只会在    // 第一个 `await` 之前工作    const res = await fetch(...)    const posts = await res.json()    return &#123;      posts    &#125;  &#125;&#125;&lt;/script&gt;\r\n方法二：使用生命周期钩子\r\n可以在生命周期钩子中调用异步方法：\r\n&lt;script&gt;export default &#123;  setup() &#123;    const users = ref([]);    onBeforeMount(async () =&gt; &#123;      const res = await axios.get(&quot;https://jsonplaceholder.typicode.com/users&quot;);      users.value = res.data;      console.log(res);    &#125;);    return &#123;      users,    &#125;;  &#125;,&#125;&lt;/script&gt;\r\n方法三：将调用包裹在异步函数中\r\n该方法与 方法二 原理相同：\r\n&lt;template&gt;  &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; ref &#125; from &#x27;vue&#x27;;export default &#123;  setup() &#123;    const message = ref(&#x27;&#x27;);    async function fetchData() &#123;      const response = await fetch(&#x27;/api/data&#x27;);      const data = await response.json();      message.value = data.message;    &#125;    fetchData();    return &#123;      message,    &#125;;  &#125;,&#125;;&lt;/script&gt;\r\n参考\r\n本文参考了以下文章，在此报以诚挚谢意！\r\n\r\nvue3.0\r\n中 如何在setup中使用async await\r\nSuspense\r\n| Vue.js (vuejs.org)\r\n\r\n","categories":["Develop","Javascript","Vue","Vue3.x"],"tags":["Vue","Vue3.x"]},{"title":"Vue3 模板 vscode 代码片段","url":"/posts/2023/3MXXBNW.html","content":"Ctrl+Shift+p 搜\r\n\"代码片段(snipets)\"，新建一个应用于当前项目的代码版本，在文件中增加如下内容：\r\n\r\n&#123;  &quot;vue3&quot;: &#123;    &quot;prefix&quot;: &quot;vue3&quot;,    &quot;scope&quot;: &quot;vue&quot;, // 表示仅在 vue 文件中生效    &quot;body&quot;: [      &quot;&lt;template&gt;&quot;,      &quot;  &lt;div&gt;&quot;,      &quot;$1&quot;,      &quot;  &lt;/div&gt;&quot;,      &quot;&lt;/template&gt;\\n&quot;,      &quot;&lt;script lang=\\&quot;ts\\&quot; setup&gt;&quot;,      &quot;import &#123; ref &#125; from \\&quot;vue\\&quot; &quot;,      &quot;$2&quot;,      &quot;&lt;/script&gt;\\n&quot;,      &quot;&lt;style lang=\\&quot;scss\\&quot; scoped&gt;&quot;,      &quot;$3&quot;,      &quot;&lt;/style&gt;&quot;    ],    &quot;description&quot;: &quot;vue3&quot;  &#125;&#125;\r\n然后在 vue 文件中，输入 vue3 ，按 tab\r\n键就可以自动生成代码片段了。\r\n","categories":["Develop","Javascript","Vue","Vue3.x"],"tags":["vue3","snipets"]},{"title":"一文理清在 vue2.x 中 compositionAPI 与 optionsAPI 混合使用要点","url":"/posts/2023/3E7GWG0.html","content":"由于项目基于 vue2 框架，随着项目规模的增加，mixin\r\n的组织方式越来越不方便维护，因此将其升级到 vue2.7，使用 composition API\r\n与 options API 混合开发。\r\n本文将一步一步梳理混合开发的步骤及要点，让大家对混合开发有一个全局的掌握。\r\n\r\n向后移植的功能\r\n\r\nComposition\r\nAPI\r\nSFC &lt;script setup&gt;\r\nSFC CSS\r\nv-bind\r\ndefineComponent()：具有改进的类型推断（与Vue.extend相比）\r\nh()、useSlot()、useAttrs()、useCssModules()\r\nset()、del()和 nextTick() 在 ESM\r\n构建中也作为命名导出提供\r\n支持\r\nemits，但仅用作类型检查用途（不影响运行时行为）。\r\nVue2.7 还支持在模板表达式中使用 ESNext 语法\r\n在模版里面用可选链，如formData?.userInfo?.userId\r\n\r\n关于被导出的 API 的注意事项\r\n\r\n在 ESM 构建版本中，这些 API 会 (且仅会) 被导出为具名 API：\r\nimport Vue, &#123; ref &#125; from &quot;vue&quot;;Vue.ref; // undefined，请换为使用具名导出的 API\r\n在 UMD 和 CJS 构建版本里，这些 API 会被导出为全局对象\r\nVue 的属性。\r\n当调用外置的 CJS 版本进行打包时，打包工具应该有能力处理与 ESM\r\n模块的互操作 (ESM interop)。\r\n\r\n与 Vue3 的差异\r\nComposition API 使用 Vue2 的基于 getter/setter\r\n的响应式系统进行反向移植，以确保浏览器兼容性。这意味着与 Vue3 的基于\r\nproxy 的系统存在一些重要的行为差异：\r\n\r\n所有 Vue2 更改检测警告仍然适用；\r\nreactive()、ref() 和 shallowReactive()\r\n将直接转换原始对象而不是创建代理：\r\n\r\nhtml复制代码// 在2.7中可行，在3.x中不可行reactive(foo) === foo\r\n\r\nreadonly()\r\n确实创建了一个单独的对象，但它不会跟踪新添加的属性并且不适用于数组；\r\n避免在 reactive() 中使用数组作为 root\r\n值，因为如果没有属性访问，则不会跟踪数组的变化（这将导致警告）；\r\nReactivity APIs 忽略带有 symbol 键的属性。\r\n\r\n此外，以下功能是未移植的：\r\n\r\n❌ createApp()（Vue2 没有独立的应用范围）\r\n❌ 在 &lt;script setup&gt; 顶层使用 await\r\n(Vue 2 不支持异步组件初始化)\r\n❌ 模板表达式中的 TypeScript 语法（与 Vue2 解析器不兼容）\r\n❌ Reactivity transform（仍处于试验阶段）\r\n❌ options 组件不支持 expose\r\n选项（但在&lt;script setup&gt; 中支持\r\ndefineExpose() )\r\n\r\nvue2.x 升级为 vue2.7\r\n请查看官方升级文档 升级指南\r\n如何在vue2.x项目中使用\r\ncompositionAPI\r\n适用场景\r\n当将 vue2.x 升级到 vue2.7 后，有时候需要维护原来的组件，分 3\r\n种情况讨论：\r\n\r\n若修改原来的功能，建议直接使用选项式 API 的方式开发，因为在\r\nsetup 中无法获取到 this，无法调用一些现有的\r\ndata、methods 等等。\r\n若新增加功能且与现有功能不耦合，可以直接添加 setup()\r\n函数，在该函数中增加新功能逻辑。当然，若有多个功能，可以将功能拆分成多个文件，然后在\r\nsetup() 函数中来聚合\r\n若开发新组件，可以直接使用 &lt;script setup&gt;\r\n的方式\r\n\r\n开发需知\r\n\r\nreactive()、ref()、shallowReactive()\r\n将直接转换原始对象而不是创建代理\r\n使用组件时，不要使用自闭合标签，应\r\n&lt;component&gt;&lt;/component&gt;\r\n对于数组，使用 ref，不要使用\r\nreactive\r\n\r\nref 与 reactive\r\n\r\nreactive 一般用于对象/数组类型的数据，都不需要使用\r\n.value；\r\nref一般用于基础数据类型的数据，在 JS\r\n中读取和修改时，需要使用\r\n.value，在模版中使用时则不需要；\r\nreactive 可以修改深层属性值，并保持响应；\r\nreactive 返回值和源对象不同；\r\nreactive的属性值可以是 ref值；\r\nref 本质也是\r\nreactive，ref(obj)等价于\r\nreactive({value: obj})。\r\n\r\n参考\r\n本文参考以下文章，在此报以诚挚谢意！\r\n\r\nVue 2.7\r\n\"Naruto\" Released | The Vue Point (vuejs.org)\r\n迁移至\r\nVue 2.7 — Vue.js (vuejs.org)\r\nVue2.7正式发布，终于可以在Vue2项目中使用Vue3的特性了\r\n- 掘金 (juejin.cn)\r\n\r\n","categories":["Develop","Javascript","Vue","Vue2.x"],"tags":["NexT","vue2.x","compositionAPI"]},{"title":"16款优秀的Vue UI组件库推荐","url":"/posts/2020/28N842C.html","content":"Vue\r\n是一个轻巧、高性能、可组件化的MVVM库，API简洁明了，上手快。从Vue推出以来，得到众多Web开发者的认可。\r\n在公司的Web前端项目开发中，多个项目采用基于Vue的UI组件框架开发，并投入正式使用。\r\n开发团队在使用Vue.js框架和UI组件库以后，开发效率大大提高，自己写的代码也少了，很多界面效果组件已经封装好了。\r\n在选择Vue\r\nUI组件库的过程中，通过GitHub上根据star数量、文档丰富程度、更新的频率以及维护等因素，也收集整理了一些优秀的Vue\r\nUI组件库。\r\n\r\nPS：国内的UI组件大部分都只有一部分的，常用的头部导航，底部导航，listview，grid表格很多都是没有的。\r\n后面才发现，基于Vue的Quasar Framework 介绍\r\n这个框架UI组件很全面，准备下次使用这个框架了\r\n基于Vue的Quasar Framework 中文网 http://www.quasarchs.com/\r\nquasarframework/quasar: Quasar Framework\r\nhttps://github.com/quasarframework/quasar\r\nQuasar（发音为/kweɪ.zɑɹ/)是MIT许可的开源框架（基于Vue），可帮助Web开发人员创建：\r\n响应式网站 PWA（Progressive Web App） 通过Apache\r\nCordova构建移动APP（Android，iOS，…） 多平台桌面应用程序（使用Electron）\r\nQuasar允许开发人员编写一次代码，然后使用相同的代码库同时部署为网站、PWA、Mobile\r\nApp和Electron\r\nApp。使用最先进的CLI设计应用程序，并提供精心编写，速度非常快的Quasar\r\nWeb组件。\r\n当使用Quasar时，你不需要像Hammerjs，Momentjs或Bootstrap这样的额外重型库。它拥有这些功能，而且体积很小！\r\n\r\n1、 iView UI组件库\r\niView 是一套基于 Vue.js 的开源 UI 组件库，主要服务于 PC\r\n界面的中后台产品。iView的组件还是比较齐全的，更新也很快，文档写得很详细。有公司团队维护，比较可靠的Vue\r\nUI组件框架。iView生态也做得很好，还有开源了一个iView\r\nAdmin，做后台非常方便。官网上介绍，iView已经应用在TalkingData、阿里巴巴、百度、腾讯、今日头条、京东、滴滴出行、美团、新浪、联想等大型公司的产品中。\r\niView官网：https://www.iviewui.com/\r\n2、Vux UI组件库\r\nVux是基于WeUI和Vue2.x开发的移动端UI组件库，主要服务于微信页面。Vux的定位已经很明确了，一是：Vue移动端UI组件库，二是：WeUI的基础样式库。Vux的组件涵盖了所有的WeUI的内容，还扩展了一些常用的组件。比如：Sticky、timeline、v-chart、XCircle。Vux是个人维护的。但是GitHub上star还是很高的，达到13k。在GitHub上看到对issue的关闭还是很迅速的。Vux文档基本的组件用法和效果都讲解到位了。在vux官网上也展示了很多Vux的使用案例。在微信页面开发中，基本没有太多的bug，开发还是比较顺手的。\r\nVux官网：https://vux.li/\r\n3、Element UI组件库\r\nElement，一套为开发者、设计师和产品经理准备的基于 Vue 2.0\r\n的桌面端组件库。Element是饿了么前端开源维护的Vue\r\nUI组件库，更新频率还是很高的，基本一周到半个月都会发布一个新版本。组件齐全，基本涵盖后台所需的所有组件，文档讲解详细，例子也很丰富。没有实际使用过，网上的Element教程和文章比较多。Element应该是一个质量比较高的Vue\r\nUI组件库。 Element官网：http://element.eleme.io/#/zh-CN\r\n4、Mint UI组件库\r\nMint UI基于 Vue.js 的移动端组件库，同样出自饿了么前端的项目。Mint\r\nUI是真正意义上的按需加载组件。可以只加载声明过的组件及其样式文件。Mint\r\nUI 采用 CSS3\r\n处理各种动效，避免浏览器进行不必要的重绘和重排，从而使用户获得流畅顺滑的体验。网上的视频教程很多都是基于Mint\r\nUI来讲的，开发移动端web项目还是很方便，文档也很简介明了。很多页面Mint\r\nUI组件都已经封装好，基本可以照着例子写，简单的调整一下就可以实现。不过，在GitHub上看最后一次代码提交在2018年1月16日。不知道是项目比较稳定没有更新，还是项目有被废弃的可能。\r\nMint UI官网：http://mint-ui.github.io/#!/zh-cn\r\n5、Bootstrap-Vue UI组件库\r\nBootstrap-VUE提供了基于vue2的Bootstrap\r\nV4组件和网格系统的实现，完成了广泛和自动化的WAI\r\nARA可访问性标记。Bootstrap 4是最新发布的版本，与 Bootstrap3\r\n相比拥有了更多的具体的类以及把一些有关的部分变成了相关的组件。同时\r\nBootstrap.min.css 的体积减少了40%以上。Bootstrap4 放弃了对 IE8 以及 iOS\r\n6 的支持，现在仅仅支持 IE9 以上 以及 iOS 7\r\n以上版本的浏览器。想当初刚流行响应式网站的时候，Bootstrap是世界上最受欢迎的建立移动优先网站的框架，Bootstrap可以说风靡全球。就算放在现在很多企业网站都是采用Bootstrap做的响应式。Bootstrap-Vue可以让你在Vue中也实现Bootstrap的效果。\r\nBootstrap-Vue官网：https://bootstrap-vue.js.org/\r\n6、Ant Design Vue UI组件库\r\nAnt Design Vue是 Ant Design 3.X 的 Vue\r\n实现，开发和服务于企业级后台产品。在GitHub上可以找到几个Ant\r\nDesign的Vue组件。不过相比较而言，Ant Design Vue更胜一筹。Ant Design\r\nVue共享Ant Design of React设计工具体系，实现了所有Ant Design of\r\nReact的组件，支持现代浏览器和 IE9 及以上（需要\r\npolyfills）。可以让熟悉Ant Design的在使用Vue时，很容易的上手。 Ant\r\nDesign\r\nVue官网：https://vuecomponent.github.io/ant-design-vue/docs/vue/introduce-cn/\r\n7、AT-UI UI组件库\r\nAT-UI 是一款基于 Vue.js 2.0 的前端 UI 组件库，主要用于快速开发 PC\r\n网站中后台产品，支持现代浏览器和 IE9 及以上。AT-UI\r\n更加精简，实现了后台常用的组件。\r\nAT_UI官网：https://at-ui.github.io/at-ui/#/zh\r\n8、Vant UI组件库\r\nVant是一个轻量、可靠的移动端 Vue\r\n组件库。Vant是有赞团队开源的，主要维护也是有赞团队。Vant Weapp\r\n是有赞移动端组件库 Vant 的小程序版本，两者基于相同的视觉规范，提供一致的\r\nAPI 接口，助力开发者快速搭建小程序应用。截止到目前，Vant已经开源了50+\r\n个经过有赞线上业务检验的组件。比如：、AddressEdit 地址编辑、AddressList\r\n地址列表、Area 省市区选择、Card 卡片、Contact 联系人、Coupon\r\n优惠券、GoodsAction 商品页行动点、SubmitBar 提交订单栏、Sku\r\n商品规格弹层。如果做商城的，不太在意界面，实现业务逻辑的话，用Vant组件库开发还是很快的。\r\nVant官网：https://youzan.github.io/vant/#/zh-CN/intro\r\n9、cube-ui UI组件库\r\ncube-ui 是基于 Vue.js\r\n实现的精致移动端组件库。由滴滴内部组件库精简提炼而来，经历了业务一年多的考验，并且每个组件都有充分单元测试，为后续集成提供保障。在交互体验方面追求极致。遵循统一的设计交互标准，高度还原设计效果；接口标准化，统一规范使用方式，开发更加简单高效。支持按需引入和后编译，轻量灵活；扩展性强，可以方便地基于现有组件实现二次开发。\r\ncube-ui官网：https://didi.github.io/cube-ui/#/zh-CN\r\n10、Muse-UI UI组件库\r\nMuse-UI基于 Vue 2.0 优雅的 Material Design UI 组件库。Muse UI\r\n拥有40多个UI 组件，用于适应不同业务环境。Muse UI\r\n仅需少量代码即可完成主题样式替换。Muse UI 可用于开发的复杂单页应用\r\nMuse-UI官网：https://muse-ui.org/#/zh-CN\r\n11、N3-components UI组件库\r\nN3组件库是基于Vue.js构建的，让前端工程师和全栈工程师能快速构建页面和应用。N3-components超过60个组件\r\n组件列表、自定义样式、支持多种模化范式（UMD）、使用ES6进行开发。\r\nN3官网：https://n3-components.github.io/N3-components/component.html\r\n12、Mand Mobile\r\nMand\r\nMobile是面向金融场景的Vue移动端UI组件库，丰富、灵活、实用，快速搭建优质的金融类产品，让复杂的金融场景变简单。Mand\r\nMobile含有丰富的组件30+的基础组件，覆盖金融场景，极高的易用性组件均有详细说明文档、案例演示，汲取最前沿技术，组件化轻量化实现，兼顾稳定和品质，努力实现金融场景的全覆盖。\r\nMand Mobile官网：https://didi.github.io/mand-mobile/#/zh-CN/home\r\n下面是1.x的文档和演示地址：（文档地址已经迁移了）\r\nhttps://mand-mobile.github.io/1x-doc/\r\nhttps://mand-mobile.github.io/2x-doc/\r\n之前的地址打不开了\r\n13、we-vue UI组件库\r\nwe-vue 是一套基于 Vue.js 的移动关组件库，结合 weui.css\r\n样式库，封装了一系列组件，非常适于微信公众号等移动端开发。we-vue 包含35+\r\n个组件，单元测试覆盖率超 98%，支持\r\nbabel-plugin-import，完善的在线文档，详细的在线示例。\r\nwe-vue官网：https://wevue.org/\r\n14、veui UI组件库\r\nveui是一个由百度EFE\r\nteam开发的Vue企业级UI组件库。目前文档还没有，只有demo。\r\nGitHub上说是正在进行的一项工作。那我们就耐心等待吧。\r\nveui官网：https://ecomfe.github.io/veui/components/#/\r\n15、Semantic-UI-Vue UI组件库\r\nSemantic-UI-Vue是基于 Vue.js对Semantic-UI 框架的实现。\r\nSemantic作为一款开发框架，帮助开发者使用对人类友好的HTML语言构建优雅的响应式布局。Semantic-UI-Vue提供了一个类似于\r\nSemantic-UI 的 API 以及一组可定制的主题。\r\nSemantic-UI-Vue官网：https://semantic-ui-vue.github.io/#/\r\n在选择框架的时候一定要根据实际Web开发情况和团队的熟悉程度来选择。一个好的UI组件库对一个Web项目来说很重要\r\n16.Vue.js\r\nMaterial Component Framework — Vuetify.js\r\nhttps://vuetifyjs.com/zh-Hans\r\nVuetify完全根据Material\r\nDesign规范开发。每个组件都是手工制作的，为您的下一个伟大的应用程序带来最好的UI工具。开发并没有停留在Google规范中的核心组件上。通过社区成员和赞助商的支持，更多的组件将被设计并提供给大家享受。\r\n这个主要是国外比较流行的vue\r\nui组件，各种功能都有，有中文翻译的，但有些还是英文的，翻译得不是很好\r\nPS：国内的UI组件大部分都只有一部分的，常用的头部导航，底部导航，listview，grid表格很多都是没有的。\r\n致谢\r\n本文摘至：16款优秀的Vue\r\nUI组件库推荐\r\n","categories":["Develop","Javascript","Vue","VueBasic"],"tags":["vue"]},{"title":"Vue3 语法摘要","url":"/posts/2023/3CG1P9K.html","content":"\r\n本文将 Vue3 中的组合式语法精简为快速笔记，方便在使用中总览 Vue\r\n特性，灵活应用。\r\n\r\n该文不会介绍具体用法，建议先通读一遍 官方帮助文档，记得风格偏好中选择自己喜欢的网络\r\n如果某些概念读不懂，可以先去看官方文档\r\n\r\n\r\n简写扫盲\r\n\r\n\r\n\r\n简写\r\n全称\r\n中文\r\n\r\n\r\n\r\n\r\nSFC\r\nSingle File Component\r\n单文件组件\r\n\r\n\r\nE2E\r\nEnd to End\r\n端到端的测试\r\n\r\n\r\n\r\n开发工具建议\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n类别\r\n技术名称\r\n\r\n\r\n\r\n\r\n脚手架\r\nVite\r\n\r\n\r\nIED\r\nVSCode + Vue\r\n语言特性 (Volar)\r\n\r\n\r\n\r\nTypeScript\r\n\r\n\r\nVite 项目测试\r\nVitest\r\n\r\n\r\nE2E 测试\r\nCypress\r\n\r\n\r\n代码规范\r\neslint-plugin-vue\r\n\r\n\r\n字符串内联模板语法高亮\r\nes6-string-html\r\n\r\n\r\n\r\n基础\r\n模板\r\n模板语法\r\n可以不采用模块，而是 直接手写渲染函数。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n类别\r\n概要\r\n\r\n\r\n\r\n\r\n文本插值\r\n采用“Mustache”语法 (即双大括号)：Message:\r\n\r\n\r\n\r\n使用原始 HTML\r\nv-html\r\n指令：\r\n\r\n\r\nAttribute 绑定\r\nv-bind\r\n指令：v-bind:id= 或 :id=\r\n\r\n\r\n布尔型 Attribute 绑定\r\n不赋值时，为真\r\n&lt;button disabled&gt;Button&lt;/button&gt;\r\n\r\n\r\n多个值动态绑定\r\n&lt;div v-bind=\"objectOfAttrs\"&gt;&lt;/div&gt;\r\n\r\n\r\n表达式\r\n用在 双大括号 中或 Vue\r\n指令中，可以使用有限的全局对象，例Math 和\r\nDate\r\n\r\n\r\n指令参数\r\n在指定后添加 : 作为参数，\r\n\r\n\r\n指令动态参数\r\n&lt;a v-bind:[attributeName]=\"url\" /&gt;，attributeName\r\n可以是表达式或计算属性\r\n\r\n\r\n\r\nref 模板引用\r\n但在某些情况下，我们使用元素的 ref 属性来直接访问底层 DOM 元素。\r\n&lt;input ref=&quot;input&quot;&gt;\r\n声明一个同名的 ref 来访问 ref 指定的 DOM\r\n&lt;script setup&gt;import &#123; ref, onMounted &#125; from &#x27;vue&#x27;// 声明一个 ref 来存放该元素的引用// 必须和模板里的 ref 同名// input 在 DOM 初次渲染和卸载后，会是 nullconst input = ref(null)onMounted(() =&gt; &#123;  input.value.focus()&#125;)&lt;/script&gt;&lt;template&gt;  &lt;input ref=&quot;input&quot; /&gt;&lt;/template&gt;\r\n如果不使用 &lt;script setup&gt;，需确保从\r\nsetup() 返回 ref：\r\nexport default &#123;  setup() &#123;    const input = ref(null)    // ...    return &#123;      input    &#125;  &#125;&#125;\r\n函数模板引用\r\n&lt;input :ref=&quot;(el) =&gt; &#123; /* 将 el 赋值给一个数据属性或 ref 变量 */ &#125;&quot;&gt;\r\n每次组件更新时，绑定的元素被卸载时都会调用函数\r\n组件 ref 限制\r\n使用了 &lt;script setup&gt;\r\n的组件是默认私有的，可以通过 defineExpose\r\n宏显式向外暴露访问内容。\r\n&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const a = 1const b = ref(2)// 像 defineExpose 这样的编译器宏不需要导入defineExpose(&#123;  a,  b&#125;)&lt;/script&gt;\r\n指令\r\n指令是带有 v- 前缀的特殊 attribute。\r\n指令定义\r\n\r\n参数 Arguments\r\n某些指令会需要一个“参数”，在指令名后通过一个冒号隔开做标识。\r\n动态参数\r\n在指令参数上也可以使用一个 JavaScript 表达式。\r\n限制：\r\n动态参数中表达式的值应当是一个字符串，或者是\r\nnull。特殊值 null 意为显式移除该绑定。\r\n动态参数表达式不能正在空格和引号，它们在 HTML attribute\r\n名称中都是不合法的。可以使用计算属性来代替表达式。\r\n内置指令\r\n点击跳转-&gt;完整文档\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名称\r\n缩写\r\n期望值\r\n描述\r\n\r\n\r\n\r\n\r\nv-text\r\n\r\nstring\r\n等同于 &#123;&#123;content&#125;&#125; 语法\r\n\r\n\r\nv-html\r\n\r\nstring\r\n更新元素的 innerHTML，scoped\r\n样式将不会作用于 v-html 里的内容\r\n\r\n\r\nv-show\r\n\r\nany\r\n通过设置内联样式的 display CSS 属性来工作\r\n\r\n\r\nv-if\r\n\r\nany\r\n条件性地渲染，触发时元素及其所包含的指令/组件都会销毁和重构\r\n\r\n\r\nv-else/v-else-if\r\n\r\n\r\n\r\n\r\n\r\nv-for\r\n\r\nArray | Object | number | string | Iterable\r\n&lt;div v-for=\"(item, index) in items\"&gt;&lt;/div&gt;&lt;div v-for=\"(value, key) in object\"&gt;&lt;/div&gt;&lt;div v-for=\"(value, name, index) in object\"&gt;&lt;/div&gt;\r\n\r\n\r\nv-on\r\n@\r\nFunction | Inline Statement | Object (不带参数)\r\n给元素绑定事件监听器。\r\n\r\n\r\nv-bind\r\n:\r\nany (带参数) | Object (不带参数)\r\n动态的绑定一个或多个 attribute，也可以是组件的 prop\r\n\r\n\r\nv-model\r\n\r\n\r\n在表单输入元素或组件上创建双向绑定\r\n\r\n\r\nv-slot\r\n#\r\n\r\n用于声明具名插槽或是期望接收 props 的作用域插槽\r\n\r\n\r\nv-pre\r\n\r\n\r\n跳过该元素及其所有子元素的编译。最常见的用例就是显示原始双大括号标签及内容。\r\n\r\n\r\nv-once\r\n\r\n\r\n仅渲染元素和组件一次，并跳过之后的更新。\r\n\r\n\r\nv-memo\r\n\r\n\r\n缓存一个模板的子树。\r\n\r\n\r\nv-cloak\r\n\r\n\r\n用于隐藏尚未完成编译的 DOM 模板。\r\n\r\n\r\n\r\n响应式基础\r\n用 reactive()\r\n定义响应式变量\r\n使用 reactive()\r\n函数创建一个响应式对象或数组：\r\nimport &#123; reactive &#125; from &#x27;vue&#x27;const state = reactive(&#123; count: 0 &#125;)\r\n响应式对象是 JavaScript\r\nProxy\r\nreactive() 创建的是深层响应，可以使用 shallowreactive\r\n来创建仅第一级响应。\r\nreactive()缺点\r\nreactive() API 有两条限制：\r\n\r\n仅对对象类型有效（对象、数组和 Map、Set\r\n这样的集合类型），而对\r\nstring、number 和 boolean 这样的\r\n原始类型\r\n无效。\r\n因为 Vue 的响应式系统是通过属性访问进行追踪的，使用时必须使用\r\n响应式对象.属性\r\n的方式访问和赋值，如果赋值给其它变量，则不会传递响应式效果\r\n\r\n响应式代理\r\n开发中建议仅使用声明对象的代理版本。\r\n对同一个原始对象调用 reactive()\r\n会总是返回同样的代理对象，而对一个已存在的代理对象调用\r\nreactive() 会返回其本身。\r\n响应式对象内的嵌套对象依然是代理。\r\n用 ref() 定义响应式变量\r\nimport &#123; ref &#125; from &#x27;vue&#x27;const count = ref(0)\r\nref()\r\n方法来允许创建任何值类型的响应式 ref。\r\nref() 将传入参数的值包装为一个带 .value\r\n属性的 ref 对象，通过 .value 来访问。\r\n当值为对象类型时，会用 reactive() 自动转换它的\r\n.value。\r\n当 ref\r\n在模板中作为顶层属性被访问时，它们会被自动“解包”，所以不需要使用\r\n.value。\r\n当一个 ref\r\n被嵌套在一个响应式对象中，作为属性被访问或更改时，它会自动解包。\r\n当 ref 作为响应式数组或像 Map\r\n这种原生集合类型的元素被访问时，不会进行解包。\r\n暴露响应式状态\r\n要在组件模板中使用响应式状态，需要在 setup()\r\n函数中定义并返回。\r\nimport &#123; reactive &#125; from &#x27;vue&#x27;export default &#123;  // `setup` 是一个专门用于组合式 API 的特殊钩子函数  setup() &#123;    const state = reactive(&#123; count: 0 &#125;)    // 暴露 state 到模板    return &#123;      state    &#125;  &#125;&#125;\r\n&lt;script setup&gt;\r\n使用 &lt;script setup&gt; 来简化手动暴露状态和方法。\r\n&lt;script setup&gt;import &#123; reactive &#125; from &#x27;vue&#x27;const state = reactive(&#123; count: 0 &#125;)function increment() &#123;  state.count++&#125;&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;increment&quot;&gt;    &#123;&#123; state.count &#125;&#125;  &lt;/button&gt;&lt;/template&gt;\r\n顶层的导入和变量声明可在同一组件的模板中直接使用，相当于自动暴露给模板了。\r\nDOM 更新时机\r\n无论你进行了多少次状态更改，每个组件都只更新一次。\r\n若要等待一个状态改变后的 DOM 更新完成，你可以使用 nextTick()\r\n这个全局 API。\r\n计算属性\r\nimport &#123; computed &#125; from &#x27;vue&#x27;\r\n返回值会自动打包成一个 ref\r\n可以通过 get() 和 set(newValue)\r\n控制计算属性的读写\r\nclass 绑定\r\nclass 与 style 在使用 v-bind\r\n时，除字符串外，表达式的值也可以是对象或数组。\r\n对象和数组可以是内联的，也可以是独立的，还可以是 computed 类型\r\n绑定对象\r\nconst isActive = ref(true)const error = ref(null)const classObject = computed(() =&gt; (&#123;  active: isActive.value &amp;&amp; !error.value,  &#x27;text-danger&#x27;: error.value &amp;&amp; error.value.type === &#x27;fatal&#x27;&#125;))&lt;div :class=&quot;&#123; className: isActive &#125;&quot;&gt;&lt;/div&gt;\r\n绑定数组\r\n字符串数组形式：\r\nconst activeClassName = ref(&#x27;active&#x27;)const errorClassName = ref(&#x27;text-danger&#x27;)&lt;div :class=&quot;[activeClassName, errorClassName]&quot;&gt;&lt;/div&gt;\r\n三元表达式形式：\r\n&lt;div :class=&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;&gt;&lt;/div&gt;\r\n对象数组形式：\r\n&lt;div :class=&quot;[&#123; active: isActive &#125;, errorClass]&quot;&gt;&lt;/div&gt;\r\n组件的 class 规则\r\n只有一个根元素的组件，组件上绑定的 class 自动与根元素合并\r\n有多个根元素时，通过 $attrs 来指定绑定\r\n&lt;!-- MyComponent 模板使用 $attrs 时 --&gt;&lt;p :class=&quot;$attrs.class&quot;&gt;Hi!&lt;/p&gt;&lt;span&gt;This is a child component&lt;/span&gt;\r\nstyle 绑定\r\n绑定对象\r\n&lt;div :style=&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt;\r\n绑定数组\r\n绑定一个包含多个样式对象的数组，对象会被合并。\r\n&lt;div :style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt;\r\n自动前缀\r\n当在 :style 中使用了需要浏览器特殊前缀的\r\nCSS 属性时，Vue 会自动为他们加上相应的前缀\r\n样式多值\r\n数组仅会渲染浏览器支持的最后一个值\r\n&lt;div :style=&quot;&#123; display: [&#x27;-webkit-box&#x27;, &#x27;-ms-flexbox&#x27;, &#x27;flex&#x27;] &#125;&quot;&gt;&lt;/div&gt;\r\nv-if 条件渲染\r\nv-if、v-else-if、v-else、v-show\r\nv-if 有更高的切换开销，而 v-show\r\n有更高的初始渲染开销。\r\nv-if 的优先级高于 v-for，v-if\r\n的条件将无法访问到 v-for 作用域内定义的变量别名\r\n同时使用 v-if 和 v-for\r\n是不推荐的，可以通过包装一层 template 来解决\r\n&lt;template v-for=&quot;todo in todos&quot;&gt;  &lt;li v-if=&quot;!todo.isComplete&quot;&gt;    &#123;&#123; todo.name &#125;&#125;  &lt;/li&gt;&lt;/template&gt;\r\nv-for 列表渲染\r\n&lt;li v-for=&quot;(value, key, index) in myObject&quot;&gt;  &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;/li&gt;\r\nv-for 可以直接接受一个整数值。\r\n&lt;span v-for=&quot;n in 10&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/span&gt;// 此处 n 的初值是从 1 开始\r\n可以在任何时候为 v-for 提供一个 key，提高渲染效率。\r\n数组更新、替换后，不会重新渲染整个列表，而是最大化重用。\r\n事件处理\r\n使用 v-on 指令 (简写为 @) 来监听 DOM\r\n事件，并在事件触发时执行对应的\r\nJavaScript。用法：v-on:click=\"methodName\" 或\r\n@click=\"handler\"。\r\n$event\r\n变量代表原生事件，可以通过内联事件传递给事件处理函数。\r\n@click=&quot;handler(message,$event)&quot;\r\n事件修饰符\r\n&lt;!-- 修饰语可以使用链式书写 --&gt;&lt;a @click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n序号\r\n修饰符\r\n作用\r\n\r\n\r\n\r\n\r\n1\r\n.stop\r\n单击事件将停止传递\r\n\r\n\r\n2\r\n.prevent\r\n如果此事件没有被显式处理，阻止事件的默认行为。比如 submit\r\n的提交后会刷新界面的行为就该事件的默认行为\r\n\r\n\r\n3\r\n.self\r\n仅当 event.target 是元素本身时才会触发事件处理器\r\n\r\n\r\n4\r\n.capture\r\n在事件在捕获阶段到达该元素时触发\r\n\r\n\r\n5\r\n.once\r\n仅执行一次\r\n\r\n\r\n6\r\n.passive\r\n事件的默认行为立即执行\r\n\r\n\r\n7\r\n.&#123;keyAlias&#125;\r\n只在某些按键下触发处理函数。\r\n\r\n\r\n\r\n\r\n使用修饰符时需要注意调用顺序，因为相关代码是以相同的顺序生成的。\r\n因此使用 @click.prevent.self\r\n会阻止元素及其子元素的所有点击事件的默认行为，\r\n而 @click.self.prevent\r\n则只会阻止对元素本身的点击事件的默认行为。\r\n\r\n按键修饰符\r\n用于监听键盘事件。使用 KeyboardEvent.key\r\n暴露的按键名称作为修饰符，但需要转为 kebab-case 形式。\r\n&lt;input @keyup.page-down=&quot;onPageDown&quot; /&gt;\r\n按键别名：\r\n.enter、.tab、.delete\r\n(捕获“Delete”和“Backspace”两个按键)、.esc、\r\n.space、.up、 .down、\r\n.left、 .right\r\n系统按键：\r\n.ctrl、 .alt、 .shift、\r\n.meta\r\n鼠标按键修饰符：\r\n.left、.right、.middle\r\n.exact 修饰符：\r\n仅响应确定组合的事件\r\n&lt;!-- 当按下 Ctrl 时，即使同时按下 Alt 或 Shift 也会触发 --&gt;&lt;button @click.ctrl=&quot;onClick&quot;&gt;A&lt;/button&gt;&lt;!-- 仅当按下 Ctrl 且未按任何其他键时才会触发 --&gt;&lt;button @click.ctrl.exact=&quot;onCtrlClick&quot;&gt;A&lt;/button&gt;&lt;!-- 仅当没有按下任何系统按键时触发 --&gt;&lt;button @click.exact=&quot;onClick&quot;&gt;A&lt;/button&gt;\r\nv-model 输入绑定\r\nv-model 将 value 绑定到元素上，并监听 value\r\n的变化，达到数据绑定的效果。\r\n\r\n文本类型的 &lt;input&gt; 和\r\n&lt;textarea&gt; 元素会绑定 value property\r\n并侦听 input 事件；\r\n&lt;input type=\"checkbox\"&gt; 和\r\n&lt;input type=\"radio\"&gt; 会绑定 checked\r\nproperty 并侦听 change 事件；\r\n&lt;select&gt; 会绑定 value property\r\n并侦听 change 事件。\r\n\r\nv-model 会忽略任何表单元素上初始的\r\nvalue、checked 或 selected\r\nattribute。\r\n修饰符\r\n&lt;!-- 在 &quot;change&quot; 事件后同步更新而不是 &quot;input&quot; --&gt;&lt;input v-model.lazy=&quot;msg&quot; /&gt;\r\n\r\n\r\n\r\n修饰符\r\n作用\r\n\r\n\r\n\r\n\r\n.lazy\r\n将数据修改从 input 事件修改到 change 事件后触发\r\n\r\n\r\n.number\r\n用户输入自动转换为数字\r\n\r\n\r\n.trim\r\n自动去除用户输入内容中两端的空格\r\n\r\n\r\n\r\n生命周期\r\n\r\n监听器\r\nwatch\r\nwatch 的第一个参数可以是不同形式的“数据源”：它可以是一个\r\nref (包括计算属性)、一个响应式对象、一个 getter\r\n函数、或多个数据源组成的数组：\r\nconst x = ref(0)const y = ref(0)// 单个 refwatch(x, (newX) =&gt; &#123;  console.log(`x is $&#123;newX&#125;`)&#125;)// getter 函数watch(  () =&gt; x.value + y.value,  (sum) =&gt; &#123;    console.log(`sum of x + y is: $&#123;sum&#125;`)  &#125;,  &#123;    deep: false, // 默认 false, 表示非深层监听    immediate: fale, // 默认 false, 表示创建监听时不立即执行  &#125;)// 多个来源组成的数组watch([x, () =&gt; y.value], ([newX, newY]) =&gt; &#123;  console.log(`x is $&#123;newX&#125; and y is $&#123;newY&#125;`)&#125;)\r\n不能直接监听响应式对象的属性值，必须使用像上例中的 getter\r\n函数形式。\r\nwatch 默认是深层监听器，如果只想监听某个属性，可以使用 getter\r\n函数方式\r\nwatchEffect\r\nwatchEffect\r\n的回调会立即执行一次，它会自动追踪依赖，有点类似\r\ncomputed\r\n\r\nwatchEffect\r\n仅会在其同步执行期间，才追踪依赖。在使用异步回调时，只有在第一个\r\nawait 正常工作前访问到的属性才会被追踪。\r\n\r\n回调触发\r\n默认情况下，用户创建的侦听器回调，都会在 Vue\r\n组件更新之前被调用。在侦听器回调中访问的 DOM 是被 Vue\r\n更新之前的状态。\r\n使用 flush: 'post' 来设置监听回调在 DOM 更新后触发。\r\nwatch(source, callback, &#123;  flush: &#x27;post&#x27;&#125;)watchEffect(callback, &#123;  flush: &#x27;post&#x27;&#125;)\r\nwatchPostEffect\r\n等效于：\r\nwatchEffect(callback, &#123;  flush: &#x27;post&#x27;&#125;)\r\n停止侦听器\r\n同步语句创建的侦听器，会自动停止，但是在异步中调用创建的监听器需要调用其返回值手动停止\r\n&lt;script setup&gt;import &#123; watchEffect &#125; from &#x27;vue&#x27;// 它会自动停止watchEffect(() =&gt; &#123;&#125;)// ...这个则不会！setTimeout(() =&gt; &#123;  const unwatch = watchEffect(() =&gt; &#123;&#125;)  // 手动停止  unwatch()&#125;, 100)&lt;/script&gt;\r\n组件\r\n组件基础\r\n组件定义\r\nscript setup 形式：\r\n&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const count = ref(0)&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;count++&quot;&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&lt;/template&gt;\r\n非 setup 形式：\r\nimport &#123; ref &#125; from &#x27;vue&#x27;export default &#123;  setup() &#123;    const count = ref(0)    return &#123; count &#125;  &#125;,  template: `    &lt;button @click=&quot;count++&quot;&gt;      You clicked me &#123;&#123; count &#125;&#125; times.    &lt;/button&gt;`  // 或者 `template: &#x27;#my-template-element&#x27;`&#125;\r\n组件使用\r\n&lt;script setup&gt;// 在 setup 中直接导入即可import ButtonCounter from &#x27;./ButtonCounter.vue&#x27;&lt;/script&gt;&lt;template&gt;  &lt;h1&gt;Here is a child component!&lt;/h1&gt;  &lt;ButtonCounter /&gt;&lt;/template&gt;\r\n传递 props\r\nscript setup 使用 defineProps 定义：\r\n&lt;script setup&gt;defineProps([&#x27;title&#x27;])&lt;/script&gt;\r\n非 setup，使用 props 定义，在\r\nsetup(props,ctx) 中读取值\r\n触发事件\r\n通过 defineEmits\r\n宏来声明需要抛出的事件。\r\n在 script setup 中：\r\nconst emit = defineEmits([&#x27;eventName&#x27;])emit(eventName,data)\r\n在 setup() 中：\r\nexport default &#123;  emits: [&#x27;enlarge-text&#x27;],  setup(props, ctx) &#123;    ctx.emit(&#x27;enlarge-text&#x27;)  &#125;&#125;\r\n插槽\r\n使用 &lt;slot /&gt; 来点位\r\n动态组件\r\n使用 is 属性实现\r\n&lt;!-- currentTab 改变时组件也改变 --&gt;&lt;component :is=&quot;tabs[currentTab]&quot;&gt;&lt;/component&gt;\r\n被传给 :is 的值可以是以下几种：\r\n\r\n被注册的组件名\r\n导入的组件对象\r\n\r\n当使用 &lt;component :is=\"...\"&gt;\r\n来在多个组件间作切换时，被切换掉的组件会被卸载。\r\n通过 KeepAlive强制被切换掉的组件仍然保持“存活”的状态。\r\n大小写\r\nHTML\r\n标签和属性名称是不分大小写的，所以浏览器会把任何大写的字符解释为小写。\r\nVue 对组件元素做了预处理，因此在使用时，建议组件使用 PascalCase\r\n命名方式。\r\n组件可以使用 &lt;/&gt; 作为关闭标签。\r\n注册组件\r\n全局注册\r\n使用 Vue 实例的 app.component() 方法，注册全局组件\r\nimport &#123; createApp &#125; from &#x27;vue&#x27;const app = createApp(&#123;&#125;)app.component(  // 注册的名字  &#x27;MyComponent&#x27;,  // 组件的实现  &#123;    /* ... */  &#125;)\r\n单文件组件注册成全局组件：\r\nimport MyComponent from &#x27;./App.vue&#x27;app.component(&#x27;MyComponent&#x27;, MyComponent)\r\napp.component() 方法可以被链式调用。\r\n局部注册\r\n在使用 &lt;script setup&gt;\r\n的单文件组件中，导入的组件可以直接在模板中使用，无需注册。\r\n如果没有使用 &lt;script setup&gt;，则需要使用\r\ncomponents 选项来显式注册。\r\nprops\r\nprops 定义\r\n在使用 &lt;script setup&gt; 的单文件组件中，props\r\n可以使用 defineProps() 宏来声明：\r\n&lt;script setup&gt;const props = defineProps([&#x27;foo&#x27;])console.log(props.foo)&lt;/script&gt;\r\n在没有使用 &lt;script setup&gt; 的组件中，prop 可以使用\r\nprops\r\n选项来声明：\r\nexport default &#123;  props: [&#x27;foo&#x27;],  setup(props) &#123;    // setup() 接收 props 作为第一个参数    console.log(props.foo)  &#125;&#125;\r\ndefineProps 与 props 中传递的参数是一样，它们有以下几种形式：\r\n\r\n字符串数组，[propName1,propName2,...]，每个字符串表示特性名称\r\n对象\r\n// 使用 &lt;script setup&gt;defineProps(&#123;  title: String,  likes: Number&#125;)\r\n\r\n&lt;script setup&gt; 还可以使用类型标注来声明：\r\n&lt;script setup lang=&quot;ts&quot;&gt;defineProps&lt;&#123;  title?: string  likes?: number&#125;&gt;()&lt;/script&gt;\r\n传递值给 props\r\n&lt;!-- 传入静态值 --&gt;&lt;BlogPost likes=&quot;basketball&quot; readonly/&gt;&lt;!-- 根据一个变量的值动态传入 --&gt;&lt;BlogPost :likes=&quot;post.likes&quot;/&gt;\r\n使用一个对象绑定多个 prop\r\n可以将一个对象的所有属性都当作 props 传入\r\nconst post = &#123;  id: 1,  title: &#x27;My Journey with Vue&#x27;&#125;&lt;BlogPost v-bind=&quot;post&quot; /&gt;// 等效于&lt;BlogPost :id=&quot;post.id&quot; :title=&quot;post.title&quot; /&gt;\r\n单向绑定\r\nprops\r\n因父组件的更新而变化，自然地将新的状态向下流往子组件，而不会逆向传递。\r\n不应该在子组件中去更改一个 prop。\r\n导致想要更改一个 prop 的需求通常来源于以下两种场景：\r\n\r\nprop\r\n被用于传入初始值；而子组件想在之后将其作为一个局部数据属性。在这种情况下，最好是新定义一个局部数据属性，从\r\nprops 上获取初始值即可：\r\nconst props = defineProps([&#x27;initialCounter&#x27;])// 计数器只是将 props.initialCounter 作为初始值// 像下面这样做就使 prop 和后续更新无关了const counter = ref(props.initialCounter)\r\n需要对传入的 prop\r\n值做进一步的转换。在这种情况中，最好是基于该 prop\r\n值定义一个计算属性：\r\nconst props = defineProps([&#x27;size&#x27;])// 该 prop 变更时计算属性也会自动更新const normalizedSize = computed(() =&gt; props.size.trim().toLowerCase())\r\n\r\nprops 校验\r\n校验形式如下：\r\ndefineProps(&#123;  // 基础类型检查  // （给出 `null` 和 `undefined` 值则会跳过任何类型检查）  propA: Number,  // 多种可能的类型  propB: [String, Number],  // 必传，且为 String 类型  propC: &#123;    type: String,    required: true // 默认为 false  &#125;,  // Number 类型的默认值  propD: &#123;    type: Number,    default: 100  &#125;,  // 对象类型的默认值  propE: &#123;    type: Object,    // 对象或数组的默认值    // 必须从一个工厂函数返回。    // 该函数接收组件所接收到的原始 prop 作为参数。    default(rawProps) &#123;      return &#123; message: &#x27;hello&#x27; &#125;    &#125;  &#125;,  // 自定义类型校验函数  propF: &#123;    validator(value) &#123;      // The value must match one of these strings      return [&#x27;success&#x27;, &#x27;warning&#x27;, &#x27;danger&#x27;].includes(value)    &#125;  &#125;,  // 函数类型的默认值  propG: &#123;    type: Function,    // 不像对象或数组的默认，这不是一个    // 工厂函数。这会是一个用来作为默认值的函数    default() &#123;      return &#x27;Default function&#x27;    &#125;  &#125;&#125;)\r\n校验中的 type 有：\r\n\r\nString\r\nNumber\r\nBoolean\r\nArray\r\nObject\r\nDate\r\nFunction\r\nSymbol\r\n也可以是自定义类型，vue 通过 instanceof 来匹配\r\n\r\n事件\r\n声明\r\n$emit 只能在模板中使用。\r\n在 script setup 中无法使用，可以通过\r\ndefineEmits 来获取 emit\r\nconst emit = defineEmits([&#x27;inFocus&#x27;, &#x27;submit&#x27;])// 触发emit(&#x27;submit&#x27;)\r\ndefineEmits() 宏必须直接放置在\r\n&lt;script setup&gt; 的顶级作用域下。\r\n非 &lt;script setup&gt;中，事件需要通过 emits\r\n选项来定义，emit 函数也被暴露在 setup()\r\n的上下文对象上：\r\nexport default &#123;  emits: [&#x27;inFocus&#x27;, &#x27;submit&#x27;],  setup(props, ctx) &#123;    ctx.emit(&#x27;submit&#x27;)  &#125;&#125;\r\n事件定义支持对象语法，它允许对触发事件的参数进行验证：\r\n&lt;script setup&gt;const emit = defineEmits(&#123;  submit(payload) &#123;    // 通过返回值为 `true` 还是为 `false` 来判断    // 验证是否通过  &#125;&#125;)&lt;/script&gt;\r\n也可以使用 TypeScript 的类型标注来验证：\r\n&lt;script setup lang=&quot;ts&quot;&gt;const emit = defineEmits&lt;&#123;  (e: &#x27;change&#x27;, id: number): void  (e: &#x27;update&#x27;, value: string): void&#125;&gt;()&lt;/script&gt;\r\n触发\r\n事件通过 v-on(简写为 @) 来进行监听。\r\n在组件的模板表达式中，也可以直接使用 $emit\r\n方法触发自定义事件。\r\n&lt;button @click=&quot;$emit(&#x27;someEvent&#x27;)&quot;&gt;click me&lt;/button&gt;\r\n组件触发的事件没有冒泡机制\r\n参数\r\n第一个参数为事件名，第二个参数为事件参数\r\nemit(emitName,eventArgs)\r\n校验\r\n在对象定义中，通过添加 submit 来进行验证\r\n&lt;script setup&gt;const emit = defineEmits(&#123;  submit(payload) &#123;    // 通过返回值为 `true` 还是为 `false` 来判断    // 验证是否通过  &#125;&#125;)&lt;/script&gt;\r\n组件 v-model\r\nv-model 本质\r\nv-model 通过属性绑定和事件监听实现的。\r\n&lt;input v-model=&quot;searchText&quot; /&gt;&lt;!--等效于：--&gt;&lt;input  :value=&quot;searchText&quot;  @input=&quot;searchText = $event.target.value&quot;/&gt;\r\nv-model 实现方式\r\n\r\n定义一个 props，名为 modelValue\r\n当 props 变化时，触发 update:modelValue 事件\r\n\r\n事件传递的参数即为 v-model 的新值\r\n&lt;CustomInput  :modelValue=&quot;searchText&quot;  @update:modelValue=&quot;newValue =&gt; searchText = newValue&quot;/&gt;\r\n还可以使用 computed 属性来实现\r\n&lt;!-- CustomInput.vue --&gt;&lt;script setup&gt;import &#123; computed &#125; from &#x27;vue&#x27;const props = defineProps([&#x27;modelValue&#x27;])const emit = defineEmits([&#x27;update:modelValue&#x27;])const value = computed(&#123;  get() &#123;    return props.modelValue  &#125;,  set(value) &#123;    emit(&#x27;update:modelValue&#x27;, value)  &#125;&#125;)&lt;/script&gt;&lt;template&gt;  &lt;input v-model=&quot;value&quot; /&gt;&lt;/template&gt;\r\n多个 v-model\r\n默认情况下，v-model 在组件上都是使用\r\nmodelValue 作为 prop，并以 update:modelValue\r\n作为对应的事件。\r\n可以通过给 v-model 指定一个参数来更改\r\nv-model 映射。\r\n&lt;UserName  v-model:first-name=&quot;first&quot;  v-model:last-name=&quot;last&quot;/&gt;\r\n自定义修饰符\r\n自定义的修饰符通过 props.modelModifiers\r\n可以访问到。在触发事件时，可以判断 Modifiers\r\n中是否有修饰符，如果有，根据修饰符对数据进行处理后再触发事件。\r\n&lt;script setup&gt;const props = defineProps(&#123;  modelValue: String,  modelModifiers: &#123; default: () =&gt; (&#123;&#125;) &#125;&#125;)const emit = defineEmits([&#x27;update:modelValue&#x27;])function emitValue(e) &#123;  let value = e.target.value  if (props.modelModifiers.capitalize) &#123;    value = value.charAt(0).toUpperCase() + value.slice(1)  &#125;  emit(&#x27;update:modelValue&#x27;, value)&#125;&lt;/script&gt;&lt;template&gt;  &lt;input type=&quot;text&quot; :value=&quot;modelValue&quot; @input=&quot;emitValue&quot; /&gt;&lt;/template&gt;\r\n又有参数又有修饰符的 v-model 绑定，生成的 prop 名将是\r\narg + \"Modifiers\"\r\n&lt;MyComponent v-model:title.capitalize=&quot;myText&quot;&gt;// 访问console.log(props.titleModifiers) // &#123; capitalize: true &#125;\r\nAttributes 继承\r\n父组件向子组件传递 Attributes 时，若子组件没有在 props 和 emits\r\n中声明，则会向下继承。\r\n当一个组件以单个元素为根作渲染时，继承的 attribute\r\n会自动被添加到根元素上。\r\n继承的 class 和 style\r\n会与子组件上的相同属性合并。\r\n访问继承\r\n在 &lt;script setup&gt; 中使用 useAttrs()\r\nAPI 来访问一个组件继承的所有 attribute\r\n&lt;script setup&gt;import &#123; useAttrs &#125; from &#x27;vue&#x27;const attrs = useAttrs()&lt;/script&gt;\r\n在 setup(props,ctx) 函数中通过 ctx.attrs\r\n来访问\r\nattrs 对象总是反映为最新的\r\nattribute，但它并不是响应式的。\r\n禁用继承\r\n设置 inheritAttrs: false 来禁用自动继承。\r\n&lt;script&gt;// 使用普通的 &lt;script&gt; 来声明选项export default &#123;  inheritAttrs: false&#125;&lt;/script&gt;&lt;script setup&gt;// ...setup 部分逻辑&lt;/script&gt;\r\n继承的 Attributes 可以在模板中直接用 $attrs 访问到。\r\n这个 $attrs 对象包含了除组件所声明的 props\r\n和 emits 之外的所有其他 attribute，例如\r\nclass，style，v-on\r\n监听器等等。\r\n有几点需要注意：\r\n\r\n和 props 有所不同，继承的 attributes 在 JavaScript\r\n中保留了它们原始的大小写，所以像 foo-bar 这样的一个\r\nattribute 需要通过 $attrs['foo-bar'] 来访问。\r\n像 @click 这样的一个 v-on\r\n事件监听器将在此对象下被暴露为一个函数\r\n$attrs.onClick。\r\n\r\n指定继承\r\n可以在子组件中通过 v-bind 来将 attributes 绑定到其它组件上\r\n&lt;div class=&quot;btn-wrapper&quot;&gt;  &lt;button class=&quot;btn&quot; v-bind=&quot;$attrs&quot;&gt;click me&lt;/button&gt;&lt;/div&gt;\r\n多根节点的 Attributes 继承\r\n需要手动指定继承，无法像单根节点一样，自动继承\r\n插槽 Slots\r\n&lt;slot&gt; 元素是一个插槽出口 (slot\r\noutlet)，标示了父元素提供的插槽内容 (slot content)\r\n将在哪里被渲染。\r\n\r\n渲染作用域\r\n插槽内容可以访问到父组件的数据作用域，无法访问子组件的数据。\r\n默认内容\r\n放置 &lt;slot&gt;\r\n标签时，标签之间的内容作为默认内容。\r\n具名插槽\r\n带 name 属性的插槽叫具名插槽。没有提供 name\r\n的 &lt;slot&gt; 出口会隐式地命名为“default”。\r\n使用 v-slot:slotName(简写为 #slotName)\r\n方式来指定所使用的插槽。\r\n默认插槽不用指定。\r\n当一个组件同时接收默认插槽和具名插槽时，所有位于顶级的非\r\n&lt;template&gt;\r\n节点都被隐式地视为默认插槽的内容。如下：\r\n&lt;BaseLayout&gt;  &lt;template #header&gt;    &lt;h1&gt;Here might be a page title&lt;/h1&gt;  &lt;/template&gt;  &lt;!-- 隐式的默认插槽 --&gt;  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;  &lt;p&gt;And another one.&lt;/p&gt;  &lt;template #footer&gt;    &lt;p&gt;Here&#x27;s some contact info&lt;/p&gt;  &lt;/template&gt;&lt;/BaseLayout&gt;\r\n动态插槽\r\n通过指令的动态参数传递不同的名称实现动态插槽。\r\n插槽传递参数\r\n插槽的内容无法访问到子组件的状态，在定义插槽时，我们需要先将组件数组绑定到插槽上，使用时，再从插槽中获取。\r\n\r\n数据绑定：\r\n&lt;!-- &lt;MyComponent&gt; 的模板 --&gt;&lt;div&gt;  &lt;slot :text=&quot;greetingMessage&quot; :count=&quot;1&quot;&gt;&lt;/slot&gt;&lt;/div&gt;\r\n参数接收：\r\n\r\n默认插槽使用 v-slot=\"slotProps\" 或者\r\n#default=\"slotProps\"来接收参数\r\n具名插槽使用 #slotName=\"slotProps\" 来接收参数\r\n\r\n无渲染组件\r\n一些组件可能只包括了逻辑而不需要自己渲染内容，视图输出通过作用域插槽全权交给了消费者组件。我们将这种类型的组件称为无渲染组件。\r\n依赖注入\r\n依赖注入用于多级父子组件传值，解决 props 传值链路长的问题。\r\nprops 传值：\r\n\r\n依赖注入：\r\n\r\nProvide (提供)\r\n&lt;script setup&gt;import &#123; provide &#125; from &#x27;vue&#x27;provide(/* 注入名 */ &#x27;message&#x27;, /* 值 */ &#x27;hello!&#x27;)&lt;/script&gt;\r\n第一个参数被称为注入名，可以是一个字符串或是一个\r\nSymbol\r\n第二个参数是提供的值，值可以是任意类型，包括响应式的状态\r\n可以在应用层进行依赖注入：\r\nimport &#123; createApp &#125; from &#x27;vue&#x27;const app = createApp(&#123;&#125;)app.provide(/* 注入名 */ &#x27;message&#x27;, /* 值 */ &#x27;hello!&#x27;)\r\nInject (注入)\r\n使用 inject()\r\n函数注入上层组件提供的数据。\r\nimport &#123; inject &#125; from &#x27;vue&#x27;export default &#123;  setup() &#123;    // 第二个参数是默认值    const value = inject(&#x27;key&#x27;, () =&gt; new ExpensiveClass())    return &#123; value &#125;  &#125;&#125;\r\n使用建议\r\n当提供 /\r\n注入响应式的数据时，建议尽可能将任何对响应式状态的变更都保持在供给方组件中。这样可以确保所提供状态的声明和变更操作都内聚在同一个组件内，使其更容易维护。\r\n&lt;!-- 在供给方组件内 --&gt;&lt;script setup&gt;import &#123; provide, ref &#125; from &#x27;vue&#x27;const location = ref(&#x27;North Pole&#x27;)function updateLocation() &#123;  location.value = &#x27;South Pole&#x27;&#125;provide(&#x27;location&#x27;, &#123;  location,  updateLocation&#125;)&lt;/script&gt;\r\n&lt;!-- 在注入方组件 --&gt;&lt;script setup&gt;import &#123; inject &#125; from &#x27;vue&#x27;const &#123; location, updateLocation &#125; = inject(&#x27;location&#x27;)&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;updateLocation&quot;&gt;&#123;&#123; location &#125;&#125;&lt;/button&gt;&lt;/template&gt;\r\n只读数据\r\n可以使用 readonly()\r\n来包装提供的值使其不能被修改\r\n异步组件\r\n定义\r\n使用 defineAsyncComponent\r\n方法来实现按需从服务器加载相关组件。\r\nimport &#123; defineAsyncComponent &#125; from &#x27;vue&#x27;const AsyncComp = defineAsyncComponent(() =&gt; &#123;  return new Promise((resolve, reject) =&gt; &#123;    // ...从服务器获取组件    resolve(/* 获取到的组件 */)  &#125;)&#125;)// ... 像使用其他一般组件一样使用 `AsyncComp`\r\nES\r\n模块动态导入也会返回一个 Promise，所以多数情况下我们会将它和\r\ndefineAsyncComponent 搭配使用。类似 Vite 和 Webpack\r\n这样的构建工具也支持此语法\r\n(并且会将它们作为打包时的代码分割点)，因此我们也可以用它来导入 Vue\r\n单文件组件：\r\nimport &#123; defineAsyncComponent &#125; from &#x27;vue&#x27;const AsyncComp = defineAsyncComponent(() =&gt;  import(&#x27;./components/MyComponent.vue&#x27;))\r\n加载与错误状态\r\nconst AsyncComp = defineAsyncComponent(&#123;  // 加载函数  loader: () =&gt; import(&#x27;./Foo.vue&#x27;),  // 加载异步组件时使用的组件  loadingComponent: LoadingComponent,  // 展示加载组件前的延迟时间，默认为 200ms  delay: 200,  // 加载失败后展示的组件  errorComponent: ErrorComponent,  // 如果提供了一个 timeout 时间限制，并超时了  // 也会显示这里配置的报错组件，默认值是：Infinity  timeout: 3000&#125;)\r\n逻辑复用\r\n组合式函数\r\n“组合式函数”(Composables) 是一个利用 Vue 的组合式 API\r\n来封装和复用有状态逻辑的函数。在开发中可以将功能细分成一个个组合式函数，最后组合成功能。\r\n约定和最佳实践\r\n命名\r\n组合式函数约定用驼峰命名法命名，并以“use”作为开头。\r\n输入参数兼容 ref\r\n使用 unref 来兼容输入参数\r\nimport &#123; unref &#125; from &#x27;vue&#x27;function useFeature(maybeRef) &#123;  // 若 maybeRef 确实是一个 ref，它的 .value 会被返回  // 否则，maybeRef 会被原样返回  const value = unref(maybeRef)&#125;\r\n返回值\r\n组合式函数应始终返回一个包含多个 ref\r\n的普通的非响应式对象，这样该对象在组件中被解构为 ref\r\n之后仍可以保持响应性。\r\n从组合式函数返回一个响应式对象会导致在对象解构过程中丢失与组合式函数内状态的响应性连接。\r\n如果更希望以对象属性的形式来使用组合式函数中返回的状态，可以将返回的对象用\r\nreactive() 包装一次，这样其中的 ref\r\n会被自动解包，例如：\r\nconst mouse = reactive(useMouse())// mouse.x 链接到了原来的 x refconsole.log(mouse.x)\r\n额外操作\r\n如果你的应用用到了服务端渲染\r\n(SSR)，请确保在组件挂载后(onMounted)才调用的生命周期钩子中执行\r\nDOM 相关的其它操作，并在 onUnmounted() 中释放资源。\r\n使用限制\r\n组合式函数在 &lt;script setup&gt; 或\r\nsetup() 钩子中，应始终被同步地调用。\r\n通过抽取组合式函数改善代码结构\r\n可以基于逻辑问题将组件代码拆分成更小的函数\r\n&lt;script setup&gt;import &#123; useFeatureA &#125; from &#x27;./featureA.js&#x27;import &#123; useFeatureB &#125; from &#x27;./featureB.js&#x27;import &#123; useFeatureC &#125; from &#x27;./featureC.js&#x27;const &#123; foo, bar &#125; = useFeatureA()const &#123; baz &#125; = useFeatureB(foo)const &#123; qux &#125; = useFeatureC(baz)&lt;/script&gt;\r\n在选项式 API\r\n中使用组合式函数\r\n如果你正在使用选项式 API，组合式函数必须在 setup()\r\n中调用。且其返回的绑定必须在 setup() 中返回，以便暴露给\r\nthis 及其模板\r\n自定义指令\r\n定义与使用\r\n在 &lt;script setup&gt; 中，任何以 v\r\n开头的驼峰式命名的变量都可以被用作一个自定义指令。例如vFocus\r\n可以在模板中以 v-focus 的形式使用。\r\n在没有使用 &lt;script setup&gt;\r\n的情况下，自定义指令需要通过 directives 选项注册。\r\nexport default &#123;  setup() &#123;    /*...*/  &#125;,  directives: &#123;    // 在模板中启用 v-focus    focus: &#123;      /* ... */    &#125;  &#125;&#125;\r\n指令钩子\r\n一个指令的定义对象可以提供几种钩子函数 (都是可选的)：\r\nconst myDirective = &#123;  // 在绑定元素的 attribute 前  // 或事件监听器应用前调用  created(el, binding, vnode, prevVnode) &#123;    // 下面会介绍各个参数的细节  &#125;,  // 在元素被插入到 DOM 前调用  beforeMount(el, binding, vnode, prevVnode) &#123;&#125;,  // 在绑定元素的父组件  // 及他自己的所有子节点都挂载完成后调用  mounted(el, binding, vnode, prevVnode) &#123;&#125;,  // 绑定元素的父组件更新前调用  beforeUpdate(el, binding, vnode, prevVnode) &#123;&#125;,  // 在绑定元素的父组件  // 及他自己的所有子节点都更新后调用  updated(el, binding, vnode, prevVnode) &#123;&#125;,  // 绑定元素的父组件卸载前调用  beforeUnmount(el, binding, vnode, prevVnode) &#123;&#125;,  // 绑定元素的父组件卸载后调用  unmounted(el, binding, vnode, prevVnode) &#123;&#125;&#125;\r\n简化形式\r\napp.directive(&#x27;color&#x27;, (el, binding) =&gt; &#123;  // 这会在 `mounted` 和 `updated` 时都调用  el.style.color = binding.value&#125;)\r\n在组件上使用\r\n当在组件上使用自定义指令时，它会始终应用于组件的根节点。\r\n指令不能通过 v-bind=\"$attrs\"\r\n来传递给一个不同的元素。\r\n插件\r\n插件没有严格定义的使用范围，但是插件发挥作用的常见场景主要包括以下几种：\r\n\r\n通过 app.component()\r\n和 app.directive()\r\n注册一到多个全局组件或自定义指令。\r\n通过 app.provide()\r\n使一个资源可被注入进整个应用。\r\n向 app.config.globalProperties\r\n中添加一些全局实例属性或方法\r\n一个可能上述三种都包含了的功能库 (例如 vue-router)。\r\n\r\n// 定义const myPlugin = &#123;  install(app, options) &#123;    // 配置此应用  &#125;&#125;// 使用import &#123; createApp &#125; from &#x27;vue&#x27;const app = createApp(&#123;&#125;)app.use(myPlugin, &#123;  /* 可选的选项 */&#125;)\r\n内置组件\r\nTransition\r\nVue 提供了两个内置组件来制作基于状态变化的过渡和动画：\r\n\r\n&lt;Transition&gt; 会在一个元素或组件进入和离开 DOM\r\n时应用动画。\r\n&lt;TransitionGroup&gt; 会在一个 v-for\r\n列表中的元素或组件被插入，移动，或移除时应用动画。\r\n\r\n应用规模化\r\n最佳实践\r\nTypeScript\r\n参考\r\n\r\nVue 深度指南\r\n(官方)\r\n\r\n","categories":["Develop","Javascript","Vue","Vue3.x"],"tags":["NexT","Vue"]},{"title":"Vue3 语法摘要","url":"/posts/2023/3CG1P9K.html","content":"\r\n本文将 Vue3 中的组合式语法精简为快速笔记，方便在使用中总览 Vue\r\n特性，灵活应用。\r\n\r\n该文不会介绍具体用法，建议先通读一遍 官方帮助文档，记得风格偏好中选择自己喜欢的网络\r\n如果某些概念读不懂，可以先去看官方文档\r\n\r\n\r\n简写扫盲\r\n\r\n\r\n\r\n简写\r\n全称\r\n中文\r\n\r\n\r\n\r\n\r\nSFC\r\nSingle File Component\r\n单文件组件\r\n\r\n\r\nE2E\r\nEnd to End\r\n端到端的测试\r\n\r\n\r\n\r\n开发工具建议\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n类别\r\n技术名称\r\n\r\n\r\n\r\n\r\n脚手架\r\nVite\r\n\r\n\r\nIED\r\nVSCode + Vue\r\n语言特性 (Volar)\r\n\r\n\r\n\r\nTypeScript\r\n\r\n\r\nVite 项目测试\r\nVitest\r\n\r\n\r\nE2E 测试\r\nCypress\r\n\r\n\r\n代码规范\r\neslint-plugin-vue\r\n\r\n\r\n字符串内联模板语法高亮\r\nes6-string-html\r\n\r\n\r\n\r\n基础\r\n模板\r\n模板语法\r\n可以不采用模块，而是 直接手写渲染函数。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n类别\r\n概要\r\n\r\n\r\n\r\n\r\n文本插值\r\n采用“Mustache”语法 (即双大括号)：Message:\r\n\r\n\r\n\r\n使用原始 HTML\r\nv-html\r\n指令：\r\n\r\n\r\nAttribute 绑定\r\nv-bind\r\n指令：v-bind:id= 或 :id=\r\n\r\n\r\n布尔型 Attribute 绑定\r\n不赋值时，为真\r\n&lt;button disabled&gt;Button&lt;/button&gt;\r\n\r\n\r\n多个值动态绑定\r\n&lt;div v-bind=\"objectOfAttrs\"&gt;&lt;/div&gt;\r\n\r\n\r\n表达式\r\n用在 双大括号 中或 Vue\r\n指令中，可以使用有限的全局对象，例Math 和\r\nDate\r\n\r\n\r\n指令参数\r\n在指定后添加 : 作为参数，\r\n\r\n\r\n指令动态参数\r\n&lt;a v-bind:[attributeName]=\"url\" /&gt;，attributeName\r\n可以是表达式或计算属性\r\n\r\n\r\n\r\nref 模板引用\r\n但在某些情况下，我们使用元素的 ref 属性来直接访问底层 DOM 元素。\r\n&lt;input ref=&quot;input&quot;&gt;\r\n声明一个同名的 ref 来访问 ref 指定的 DOM\r\n&lt;script setup&gt;import &#123; ref, onMounted &#125; from &#x27;vue&#x27;// 声明一个 ref 来存放该元素的引用// 必须和模板里的 ref 同名// input 在 DOM 初次渲染和卸载后，会是 nullconst input = ref(null)onMounted(() =&gt; &#123;  input.value.focus()&#125;)&lt;/script&gt;&lt;template&gt;  &lt;input ref=&quot;input&quot; /&gt;&lt;/template&gt;\r\n如果不使用 &lt;script setup&gt;，需确保从\r\nsetup() 返回 ref：\r\nexport default &#123;  setup() &#123;    const input = ref(null)    // ...    return &#123;      input    &#125;  &#125;&#125;\r\n函数模板引用\r\n&lt;input :ref=&quot;(el) =&gt; &#123; /* 将 el 赋值给一个数据属性或 ref 变量 */ &#125;&quot;&gt;\r\n每次组件更新时，绑定的元素被卸载时都会调用函数\r\n组件 ref 限制\r\n使用了 &lt;script setup&gt;\r\n的组件是默认私有的，可以通过 defineExpose\r\n宏显式向外暴露访问内容。\r\n&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const a = 1const b = ref(2)// 像 defineExpose 这样的编译器宏不需要导入defineExpose(&#123;  a,  b&#125;)&lt;/script&gt;\r\n指令\r\n指令是带有 v- 前缀的特殊 attribute。\r\n指令定义\r\n\r\n参数 Arguments\r\n某些指令会需要一个“参数”，在指令名后通过一个冒号隔开做标识。\r\n动态参数\r\n在指令参数上也可以使用一个 JavaScript 表达式。\r\n限制：\r\n动态参数中表达式的值应当是一个字符串，或者是\r\nnull。特殊值 null 意为显式移除该绑定。\r\n动态参数表达式不能正在空格和引号，它们在 HTML attribute\r\n名称中都是不合法的。可以使用计算属性来代替表达式。\r\n内置指令\r\n点击跳转-&gt;完整文档\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n名称\r\n缩写\r\n期望值\r\n描述\r\n\r\n\r\n\r\n\r\nv-text\r\n\r\nstring\r\n等同于 &#123;&#123;content&#125;&#125; 语法\r\n\r\n\r\nv-html\r\n\r\nstring\r\n更新元素的 innerHTML，scoped\r\n样式将不会作用于 v-html 里的内容\r\n\r\n\r\nv-show\r\n\r\nany\r\n通过设置内联样式的 display CSS 属性来工作\r\n\r\n\r\nv-if\r\n\r\nany\r\n条件性地渲染，触发时元素及其所包含的指令/组件都会销毁和重构\r\n\r\n\r\nv-else/v-else-if\r\n\r\n\r\n\r\n\r\n\r\nv-for\r\n\r\nArray | Object | number | string | Iterable\r\n&lt;div v-for=\"(item, index) in items\"&gt;&lt;/div&gt;&lt;div v-for=\"(value, key) in object\"&gt;&lt;/div&gt;&lt;div v-for=\"(value, name, index) in object\"&gt;&lt;/div&gt;\r\n\r\n\r\nv-on\r\n@\r\nFunction | Inline Statement | Object (不带参数)\r\n给元素绑定事件监听器。\r\n\r\n\r\nv-bind\r\n:\r\nany (带参数) | Object (不带参数)\r\n动态的绑定一个或多个 attribute，也可以是组件的 prop\r\n\r\n\r\nv-model\r\n\r\n\r\n在表单输入元素或组件上创建双向绑定\r\n\r\n\r\nv-slot\r\n#\r\n\r\n用于声明具名插槽或是期望接收 props 的作用域插槽\r\n\r\n\r\nv-pre\r\n\r\n\r\n跳过该元素及其所有子元素的编译。最常见的用例就是显示原始双大括号标签及内容。\r\n\r\n\r\nv-once\r\n\r\n\r\n仅渲染元素和组件一次，并跳过之后的更新。\r\n\r\n\r\nv-memo\r\n\r\n\r\n缓存一个模板的子树。\r\n\r\n\r\nv-cloak\r\n\r\n\r\n用于隐藏尚未完成编译的 DOM 模板。\r\n\r\n\r\n\r\n响应式基础\r\n用 reactive()\r\n定义响应式变量\r\n使用 reactive()\r\n函数创建一个响应式对象或数组：\r\nimport &#123; reactive &#125; from &#x27;vue&#x27;const state = reactive(&#123; count: 0 &#125;)\r\n响应式对象是 JavaScript\r\nProxy\r\nreactive() 创建的是深层响应，可以使用 shallowreactive\r\n来创建仅第一级响应。\r\nreactive()缺点\r\nreactive() API 有两条限制：\r\n\r\n仅对对象类型有效（对象、数组和 Map、Set\r\n这样的集合类型），而对\r\nstring、number 和 boolean 这样的\r\n原始类型\r\n无效。\r\n因为 Vue 的响应式系统是通过属性访问进行追踪的，使用时必须使用\r\n响应式对象.属性\r\n的方式访问和赋值，如果赋值给其它变量，则不会传递响应式效果\r\n\r\n响应式代理\r\n开发中建议仅使用声明对象的代理版本。\r\n对同一个原始对象调用 reactive()\r\n会总是返回同样的代理对象，而对一个已存在的代理对象调用\r\nreactive() 会返回其本身。\r\n响应式对象内的嵌套对象依然是代理。\r\n用 ref() 定义响应式变量\r\nimport &#123; ref &#125; from &#x27;vue&#x27;const count = ref(0)\r\nref()\r\n方法来允许创建任何值类型的响应式 ref。\r\nref() 将传入参数的值包装为一个带 .value\r\n属性的 ref 对象，通过 .value 来访问。\r\n当值为对象类型时，会用 reactive() 自动转换它的\r\n.value。\r\n当 ref\r\n在模板中作为顶层属性被访问时，它们会被自动“解包”，所以不需要使用\r\n.value。\r\n当一个 ref\r\n被嵌套在一个响应式对象中，作为属性被访问或更改时，它会自动解包。\r\n当 ref 作为响应式数组或像 Map\r\n这种原生集合类型的元素被访问时，不会进行解包。\r\n暴露响应式状态\r\n要在组件模板中使用响应式状态，需要在 setup()\r\n函数中定义并返回。\r\nimport &#123; reactive &#125; from &#x27;vue&#x27;export default &#123;  // `setup` 是一个专门用于组合式 API 的特殊钩子函数  setup() &#123;    const state = reactive(&#123; count: 0 &#125;)    // 暴露 state 到模板    return &#123;      state    &#125;  &#125;&#125;\r\n&lt;script setup&gt;\r\n使用 &lt;script setup&gt; 来简化手动暴露状态和方法。\r\n&lt;script setup&gt;import &#123; reactive &#125; from &#x27;vue&#x27;const state = reactive(&#123; count: 0 &#125;)function increment() &#123;  state.count++&#125;&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;increment&quot;&gt;    &#123;&#123; state.count &#125;&#125;  &lt;/button&gt;&lt;/template&gt;\r\n顶层的导入和变量声明可在同一组件的模板中直接使用，相当于自动暴露给模板了。\r\nDOM 更新时机\r\n无论你进行了多少次状态更改，每个组件都只更新一次。\r\n若要等待一个状态改变后的 DOM 更新完成，你可以使用 nextTick()\r\n这个全局 API。\r\n计算属性\r\nimport &#123; computed &#125; from &#x27;vue&#x27;\r\n返回值会自动打包成一个 ref\r\n可以通过 get() 和 set(newValue)\r\n控制计算属性的读写\r\nclass 绑定\r\nclass 与 style 在使用 v-bind\r\n时，除字符串外，表达式的值也可以是对象或数组。\r\n对象和数组可以是内联的，也可以是独立的，还可以是 computed 类型\r\n绑定对象\r\nconst isActive = ref(true)const error = ref(null)const classObject = computed(() =&gt; (&#123;  active: isActive.value &amp;&amp; !error.value,  &#x27;text-danger&#x27;: error.value &amp;&amp; error.value.type === &#x27;fatal&#x27;&#125;))&lt;div :class=&quot;&#123; className: isActive &#125;&quot;&gt;&lt;/div&gt;\r\n绑定数组\r\n字符串数组形式：\r\nconst activeClassName = ref(&#x27;active&#x27;)const errorClassName = ref(&#x27;text-danger&#x27;)&lt;div :class=&quot;[activeClassName, errorClassName]&quot;&gt;&lt;/div&gt;\r\n三元表达式形式：\r\n&lt;div :class=&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;&gt;&lt;/div&gt;\r\n对象数组形式：\r\n&lt;div :class=&quot;[&#123; active: isActive &#125;, errorClass]&quot;&gt;&lt;/div&gt;\r\n组件的 class 规则\r\n只有一个根元素的组件，组件上绑定的 class 自动与根元素合并\r\n有多个根元素时，通过 $attrs 来指定绑定\r\n&lt;!-- MyComponent 模板使用 $attrs 时 --&gt;&lt;p :class=&quot;$attrs.class&quot;&gt;Hi!&lt;/p&gt;&lt;span&gt;This is a child component&lt;/span&gt;\r\nstyle 绑定\r\n绑定对象\r\n&lt;div :style=&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt;\r\n绑定数组\r\n绑定一个包含多个样式对象的数组，对象会被合并。\r\n&lt;div :style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt;\r\n自动前缀\r\n当在 :style 中使用了需要浏览器特殊前缀的\r\nCSS 属性时，Vue 会自动为他们加上相应的前缀\r\n样式多值\r\n数组仅会渲染浏览器支持的最后一个值\r\n&lt;div :style=&quot;&#123; display: [&#x27;-webkit-box&#x27;, &#x27;-ms-flexbox&#x27;, &#x27;flex&#x27;] &#125;&quot;&gt;&lt;/div&gt;\r\nv-if 条件渲染\r\nv-if、v-else-if、v-else、v-show\r\nv-if 有更高的切换开销，而 v-show\r\n有更高的初始渲染开销。\r\nv-if 的优先级高于 v-for，v-if\r\n的条件将无法访问到 v-for 作用域内定义的变量别名\r\n同时使用 v-if 和 v-for\r\n是不推荐的，可以通过包装一层 template 来解决\r\n&lt;template v-for=&quot;todo in todos&quot;&gt;  &lt;li v-if=&quot;!todo.isComplete&quot;&gt;    &#123;&#123; todo.name &#125;&#125;  &lt;/li&gt;&lt;/template&gt;\r\nv-for 列表渲染\r\n&lt;li v-for=&quot;(value, key, index) in myObject&quot;&gt;  &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;/li&gt;\r\nv-for 可以直接接受一个整数值。\r\n&lt;span v-for=&quot;n in 10&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/span&gt;// 此处 n 的初值是从 1 开始\r\n可以在任何时候为 v-for 提供一个 key，提高渲染效率。\r\n数组更新、替换后，不会重新渲染整个列表，而是最大化重用。\r\n事件处理\r\n使用 v-on 指令 (简写为 @) 来监听 DOM\r\n事件，并在事件触发时执行对应的\r\nJavaScript。用法：v-on:click=\"methodName\" 或\r\n@click=\"handler\"。\r\n$event\r\n变量代表原生事件，可以通过内联事件传递给事件处理函数。\r\n@click=&quot;handler(message,$event)&quot;\r\n事件修饰符\r\n&lt;!-- 修饰语可以使用链式书写 --&gt;&lt;a @click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n序号\r\n修饰符\r\n作用\r\n\r\n\r\n\r\n\r\n1\r\n.stop\r\n单击事件将停止传递\r\n\r\n\r\n2\r\n.prevent\r\n如果此事件没有被显式处理，阻止事件的默认行为。比如 submit\r\n的提交后会刷新界面的行为就该事件的默认行为\r\n\r\n\r\n3\r\n.self\r\n仅当 event.target 是元素本身时才会触发事件处理器\r\n\r\n\r\n4\r\n.capture\r\n在事件在捕获阶段到达该元素时触发\r\n\r\n\r\n5\r\n.once\r\n仅执行一次\r\n\r\n\r\n6\r\n.passive\r\n事件的默认行为立即执行\r\n\r\n\r\n7\r\n.&#123;keyAlias&#125;\r\n只在某些按键下触发处理函数。\r\n\r\n\r\n\r\n\r\n使用修饰符时需要注意调用顺序，因为相关代码是以相同的顺序生成的。\r\n因此使用 @click.prevent.self\r\n会阻止元素及其子元素的所有点击事件的默认行为，\r\n而 @click.self.prevent\r\n则只会阻止对元素本身的点击事件的默认行为。\r\n\r\n按键修饰符\r\n用于监听键盘事件。使用 KeyboardEvent.key\r\n暴露的按键名称作为修饰符，但需要转为 kebab-case 形式。\r\n&lt;input @keyup.page-down=&quot;onPageDown&quot; /&gt;\r\n按键别名：\r\n.enter、.tab、.delete\r\n(捕获“Delete”和“Backspace”两个按键)、.esc、\r\n.space、.up、 .down、\r\n.left、 .right\r\n系统按键：\r\n.ctrl、 .alt、 .shift、\r\n.meta\r\n鼠标按键修饰符：\r\n.left、.right、.middle\r\n.exact 修饰符：\r\n仅响应确定组合的事件\r\n&lt;!-- 当按下 Ctrl 时，即使同时按下 Alt 或 Shift 也会触发 --&gt;&lt;button @click.ctrl=&quot;onClick&quot;&gt;A&lt;/button&gt;&lt;!-- 仅当按下 Ctrl 且未按任何其他键时才会触发 --&gt;&lt;button @click.ctrl.exact=&quot;onCtrlClick&quot;&gt;A&lt;/button&gt;&lt;!-- 仅当没有按下任何系统按键时触发 --&gt;&lt;button @click.exact=&quot;onClick&quot;&gt;A&lt;/button&gt;\r\nv-model 输入绑定\r\nv-model 将 value 绑定到元素上，并监听 value\r\n的变化，达到数据绑定的效果。\r\n\r\n文本类型的 &lt;input&gt; 和\r\n&lt;textarea&gt; 元素会绑定 value property\r\n并侦听 input 事件；\r\n&lt;input type=\"checkbox\"&gt; 和\r\n&lt;input type=\"radio\"&gt; 会绑定 checked\r\nproperty 并侦听 change 事件；\r\n&lt;select&gt; 会绑定 value property\r\n并侦听 change 事件。\r\n\r\nv-model 会忽略任何表单元素上初始的\r\nvalue、checked 或 selected\r\nattribute。\r\n修饰符\r\n&lt;!-- 在 &quot;change&quot; 事件后同步更新而不是 &quot;input&quot; --&gt;&lt;input v-model.lazy=&quot;msg&quot; /&gt;\r\n\r\n\r\n\r\n修饰符\r\n作用\r\n\r\n\r\n\r\n\r\n.lazy\r\n将数据修改从 input 事件修改到 change 事件后触发\r\n\r\n\r\n.number\r\n用户输入自动转换为数字\r\n\r\n\r\n.trim\r\n自动去除用户输入内容中两端的空格\r\n\r\n\r\n\r\n生命周期\r\n\r\n监听器\r\nwatch\r\nwatch 的第一个参数可以是不同形式的“数据源”：它可以是一个\r\nref (包括计算属性)、一个响应式对象、一个 getter\r\n函数、或多个数据源组成的数组：\r\nconst x = ref(0)const y = ref(0)// 单个 refwatch(x, (newX) =&gt; &#123;  console.log(`x is $&#123;newX&#125;`)&#125;)// getter 函数watch(  () =&gt; x.value + y.value,  (sum) =&gt; &#123;    console.log(`sum of x + y is: $&#123;sum&#125;`)  &#125;,  &#123;    deep: false, // 默认 false, 表示非深层监听    immediate: fale, // 默认 false, 表示创建监听时不立即执行  &#125;)// 多个来源组成的数组watch([x, () =&gt; y.value], ([newX, newY]) =&gt; &#123;  console.log(`x is $&#123;newX&#125; and y is $&#123;newY&#125;`)&#125;)\r\n不能直接监听响应式对象的属性值，必须使用像上例中的 getter\r\n函数形式。\r\nwatch 默认是深层监听器，如果只想监听某个属性，可以使用 getter\r\n函数方式\r\nwatchEffect\r\nwatchEffect\r\n的回调会立即执行一次，它会自动追踪依赖，有点类似\r\ncomputed\r\n\r\nwatchEffect\r\n仅会在其同步执行期间，才追踪依赖。在使用异步回调时，只有在第一个\r\nawait 正常工作前访问到的属性才会被追踪。\r\n\r\n回调触发\r\n默认情况下，用户创建的侦听器回调，都会在 Vue\r\n组件更新之前被调用。在侦听器回调中访问的 DOM 是被 Vue\r\n更新之前的状态。\r\n使用 flush: 'post' 来设置监听回调在 DOM 更新后触发。\r\nwatch(source, callback, &#123;  flush: &#x27;post&#x27;&#125;)watchEffect(callback, &#123;  flush: &#x27;post&#x27;&#125;)\r\nwatchPostEffect\r\n等效于：\r\nwatchEffect(callback, &#123;  flush: &#x27;post&#x27;&#125;)\r\n停止侦听器\r\n同步语句创建的侦听器，会自动停止，但是在异步中调用创建的监听器需要调用其返回值手动停止\r\n&lt;script setup&gt;import &#123; watchEffect &#125; from &#x27;vue&#x27;// 它会自动停止watchEffect(() =&gt; &#123;&#125;)// ...这个则不会！setTimeout(() =&gt; &#123;  const unwatch = watchEffect(() =&gt; &#123;&#125;)  // 手动停止  unwatch()&#125;, 100)&lt;/script&gt;\r\n组件\r\n组件基础\r\n组件定义\r\nscript setup 形式：\r\n&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const count = ref(0)&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;count++&quot;&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&lt;/template&gt;\r\n非 setup 形式：\r\nimport &#123; ref &#125; from &#x27;vue&#x27;export default &#123;  setup() &#123;    const count = ref(0)    return &#123; count &#125;  &#125;,  template: `    &lt;button @click=&quot;count++&quot;&gt;      You clicked me &#123;&#123; count &#125;&#125; times.    &lt;/button&gt;`  // 或者 `template: &#x27;#my-template-element&#x27;`&#125;\r\n组件使用\r\n&lt;script setup&gt;// 在 setup 中直接导入即可import ButtonCounter from &#x27;./ButtonCounter.vue&#x27;&lt;/script&gt;&lt;template&gt;  &lt;h1&gt;Here is a child component!&lt;/h1&gt;  &lt;ButtonCounter /&gt;&lt;/template&gt;\r\n传递 props\r\nscript setup 使用 defineProps 定义：\r\n&lt;script setup&gt;defineProps([&#x27;title&#x27;])&lt;/script&gt;\r\n非 setup，使用 props 定义，在\r\nsetup(props,ctx) 中读取值\r\n触发事件\r\n通过 defineEmits\r\n宏来声明需要抛出的事件。\r\n在 script setup 中：\r\nconst emit = defineEmits([&#x27;eventName&#x27;])emit(eventName,data)\r\n在 setup() 中：\r\nexport default &#123;  emits: [&#x27;enlarge-text&#x27;],  setup(props, ctx) &#123;    ctx.emit(&#x27;enlarge-text&#x27;)  &#125;&#125;\r\n插槽\r\n使用 &lt;slot /&gt; 来点位\r\n动态组件\r\n使用 is 属性实现\r\n&lt;!-- currentTab 改变时组件也改变 --&gt;&lt;component :is=&quot;tabs[currentTab]&quot;&gt;&lt;/component&gt;\r\n被传给 :is 的值可以是以下几种：\r\n\r\n被注册的组件名\r\n导入的组件对象\r\n\r\n当使用 &lt;component :is=\"...\"&gt;\r\n来在多个组件间作切换时，被切换掉的组件会被卸载。\r\n通过 KeepAlive强制被切换掉的组件仍然保持“存活”的状态。\r\n大小写\r\nHTML\r\n标签和属性名称是不分大小写的，所以浏览器会把任何大写的字符解释为小写。\r\nVue 对组件元素做了预处理，因此在使用时，建议组件使用 PascalCase\r\n命名方式。\r\n组件可以使用 &lt;/&gt; 作为关闭标签。\r\n注册组件\r\n全局注册\r\n使用 Vue 实例的 app.component() 方法，注册全局组件\r\nimport &#123; createApp &#125; from &#x27;vue&#x27;const app = createApp(&#123;&#125;)app.component(  // 注册的名字  &#x27;MyComponent&#x27;,  // 组件的实现  &#123;    /* ... */  &#125;)\r\n单文件组件注册成全局组件：\r\nimport MyComponent from &#x27;./App.vue&#x27;app.component(&#x27;MyComponent&#x27;, MyComponent)\r\napp.component() 方法可以被链式调用。\r\n局部注册\r\n在使用 &lt;script setup&gt;\r\n的单文件组件中，导入的组件可以直接在模板中使用，无需注册。\r\n如果没有使用 &lt;script setup&gt;，则需要使用\r\ncomponents 选项来显式注册。\r\nprops\r\nprops 定义\r\n在使用 &lt;script setup&gt; 的单文件组件中，props\r\n可以使用 defineProps() 宏来声明：\r\n&lt;script setup&gt;const props = defineProps([&#x27;foo&#x27;])console.log(props.foo)&lt;/script&gt;\r\n在没有使用 &lt;script setup&gt; 的组件中，prop 可以使用\r\nprops\r\n选项来声明：\r\nexport default &#123;  props: [&#x27;foo&#x27;],  setup(props) &#123;    // setup() 接收 props 作为第一个参数    console.log(props.foo)  &#125;&#125;\r\ndefineProps 与 props 中传递的参数是一样，它们有以下几种形式：\r\n\r\n字符串数组，[propName1,propName2,...]，每个字符串表示特性名称\r\n对象\r\n// 使用 &lt;script setup&gt;defineProps(&#123;  title: String,  likes: Number&#125;)\r\n\r\n&lt;script setup&gt; 还可以使用类型标注来声明：\r\n&lt;script setup lang=&quot;ts&quot;&gt;defineProps&lt;&#123;  title?: string  likes?: number&#125;&gt;()&lt;/script&gt;\r\n传递值给 props\r\n&lt;!-- 传入静态值 --&gt;&lt;BlogPost likes=&quot;basketball&quot; readonly/&gt;&lt;!-- 根据一个变量的值动态传入 --&gt;&lt;BlogPost :likes=&quot;post.likes&quot;/&gt;\r\n使用一个对象绑定多个 prop\r\n可以将一个对象的所有属性都当作 props 传入\r\nconst post = &#123;  id: 1,  title: &#x27;My Journey with Vue&#x27;&#125;&lt;BlogPost v-bind=&quot;post&quot; /&gt;// 等效于&lt;BlogPost :id=&quot;post.id&quot; :title=&quot;post.title&quot; /&gt;\r\n单向绑定\r\nprops\r\n因父组件的更新而变化，自然地将新的状态向下流往子组件，而不会逆向传递。\r\n不应该在子组件中去更改一个 prop。\r\n导致想要更改一个 prop 的需求通常来源于以下两种场景：\r\n\r\nprop\r\n被用于传入初始值；而子组件想在之后将其作为一个局部数据属性。在这种情况下，最好是新定义一个局部数据属性，从\r\nprops 上获取初始值即可：\r\nconst props = defineProps([&#x27;initialCounter&#x27;])// 计数器只是将 props.initialCounter 作为初始值// 像下面这样做就使 prop 和后续更新无关了const counter = ref(props.initialCounter)\r\n需要对传入的 prop\r\n值做进一步的转换。在这种情况中，最好是基于该 prop\r\n值定义一个计算属性：\r\nconst props = defineProps([&#x27;size&#x27;])// 该 prop 变更时计算属性也会自动更新const normalizedSize = computed(() =&gt; props.size.trim().toLowerCase())\r\n\r\nprops 校验\r\n校验形式如下：\r\ndefineProps(&#123;  // 基础类型检查  // （给出 `null` 和 `undefined` 值则会跳过任何类型检查）  propA: Number,  // 多种可能的类型  propB: [String, Number],  // 必传，且为 String 类型  propC: &#123;    type: String,    required: true // 默认为 false  &#125;,  // Number 类型的默认值  propD: &#123;    type: Number,    default: 100  &#125;,  // 对象类型的默认值  propE: &#123;    type: Object,    // 对象或数组的默认值    // 必须从一个工厂函数返回。    // 该函数接收组件所接收到的原始 prop 作为参数。    default(rawProps) &#123;      return &#123; message: &#x27;hello&#x27; &#125;    &#125;  &#125;,  // 自定义类型校验函数  propF: &#123;    validator(value) &#123;      // The value must match one of these strings      return [&#x27;success&#x27;, &#x27;warning&#x27;, &#x27;danger&#x27;].includes(value)    &#125;  &#125;,  // 函数类型的默认值  propG: &#123;    type: Function,    // 不像对象或数组的默认，这不是一个    // 工厂函数。这会是一个用来作为默认值的函数    default() &#123;      return &#x27;Default function&#x27;    &#125;  &#125;&#125;)\r\n校验中的 type 有：\r\n\r\nString\r\nNumber\r\nBoolean\r\nArray\r\nObject\r\nDate\r\nFunction\r\nSymbol\r\n也可以是自定义类型，vue 通过 instanceof 来匹配\r\n\r\n事件\r\n声明\r\n$emit 只能在模板中使用。\r\n在 script setup 中无法使用，可以通过\r\ndefineEmits 来获取 emit\r\nconst emit = defineEmits([&#x27;inFocus&#x27;, &#x27;submit&#x27;])// 触发emit(&#x27;submit&#x27;)\r\ndefineEmits() 宏必须直接放置在\r\n&lt;script setup&gt; 的顶级作用域下。\r\n非 &lt;script setup&gt;中，事件需要通过 emits\r\n选项来定义，emit 函数也被暴露在 setup()\r\n的上下文对象上：\r\nexport default &#123;  emits: [&#x27;inFocus&#x27;, &#x27;submit&#x27;],  setup(props, ctx) &#123;    ctx.emit(&#x27;submit&#x27;)  &#125;&#125;\r\n事件定义支持对象语法，它允许对触发事件的参数进行验证：\r\n&lt;script setup&gt;const emit = defineEmits(&#123;  submit(payload) &#123;    // 通过返回值为 `true` 还是为 `false` 来判断    // 验证是否通过  &#125;&#125;)&lt;/script&gt;\r\n也可以使用 TypeScript 的类型标注来验证：\r\n&lt;script setup lang=&quot;ts&quot;&gt;const emit = defineEmits&lt;&#123;  (e: &#x27;change&#x27;, id: number): void  (e: &#x27;update&#x27;, value: string): void&#125;&gt;()&lt;/script&gt;\r\n触发\r\n事件通过 v-on(简写为 @) 来进行监听。\r\n在组件的模板表达式中，也可以直接使用 $emit\r\n方法触发自定义事件。\r\n&lt;button @click=&quot;$emit(&#x27;someEvent&#x27;)&quot;&gt;click me&lt;/button&gt;\r\n组件触发的事件没有冒泡机制\r\n参数\r\n第一个参数为事件名，第二个参数为事件参数\r\nemit(emitName,eventArgs)\r\n校验\r\n在对象定义中，通过添加 submit 来进行验证\r\n&lt;script setup&gt;const emit = defineEmits(&#123;  submit(payload) &#123;    // 通过返回值为 `true` 还是为 `false` 来判断    // 验证是否通过  &#125;&#125;)&lt;/script&gt;\r\n组件 v-model\r\nv-model 本质\r\nv-model 通过属性绑定和事件监听实现的。\r\n&lt;input v-model=&quot;searchText&quot; /&gt;&lt;!--等效于：--&gt;&lt;input  :value=&quot;searchText&quot;  @input=&quot;searchText = $event.target.value&quot;/&gt;\r\nv-model 实现方式\r\n\r\n定义一个 props，名为 modelValue\r\n当 props 变化时，触发 update:modelValue 事件\r\n\r\n事件传递的参数即为 v-model 的新值\r\n&lt;CustomInput  :modelValue=&quot;searchText&quot;  @update:modelValue=&quot;newValue =&gt; searchText = newValue&quot;/&gt;\r\n还可以使用 computed 属性来实现\r\n&lt;!-- CustomInput.vue --&gt;&lt;script setup&gt;import &#123; computed &#125; from &#x27;vue&#x27;const props = defineProps([&#x27;modelValue&#x27;])const emit = defineEmits([&#x27;update:modelValue&#x27;])const value = computed(&#123;  get() &#123;    return props.modelValue  &#125;,  set(value) &#123;    emit(&#x27;update:modelValue&#x27;, value)  &#125;&#125;)&lt;/script&gt;&lt;template&gt;  &lt;input v-model=&quot;value&quot; /&gt;&lt;/template&gt;\r\n多个 v-model\r\n默认情况下，v-model 在组件上都是使用\r\nmodelValue 作为 prop，并以 update:modelValue\r\n作为对应的事件。\r\n可以通过给 v-model 指定一个参数来更改\r\nv-model 映射。\r\n&lt;UserName  v-model:first-name=&quot;first&quot;  v-model:last-name=&quot;last&quot;/&gt;\r\n自定义修饰符\r\n自定义的修饰符通过 props.modelModifiers\r\n可以访问到。在触发事件时，可以判断 Modifiers\r\n中是否有修饰符，如果有，根据修饰符对数据进行处理后再触发事件。\r\n&lt;script setup&gt;const props = defineProps(&#123;  modelValue: String,  modelModifiers: &#123; default: () =&gt; (&#123;&#125;) &#125;&#125;)const emit = defineEmits([&#x27;update:modelValue&#x27;])function emitValue(e) &#123;  let value = e.target.value  if (props.modelModifiers.capitalize) &#123;    value = value.charAt(0).toUpperCase() + value.slice(1)  &#125;  emit(&#x27;update:modelValue&#x27;, value)&#125;&lt;/script&gt;&lt;template&gt;  &lt;input type=&quot;text&quot; :value=&quot;modelValue&quot; @input=&quot;emitValue&quot; /&gt;&lt;/template&gt;\r\n又有参数又有修饰符的 v-model 绑定，生成的 prop 名将是\r\narg + \"Modifiers\"\r\n&lt;MyComponent v-model:title.capitalize=&quot;myText&quot;&gt;// 访问console.log(props.titleModifiers) // &#123; capitalize: true &#125;\r\nAttributes 继承\r\n父组件向子组件传递 Attributes 时，若子组件没有在 props 和 emits\r\n中声明，则会向下继承。\r\n当一个组件以单个元素为根作渲染时，继承的 attribute\r\n会自动被添加到根元素上。\r\n继承的 class 和 style\r\n会与子组件上的相同属性合并。\r\n访问继承\r\n在 &lt;script setup&gt; 中使用 useAttrs()\r\nAPI 来访问一个组件继承的所有 attribute\r\n&lt;script setup&gt;import &#123; useAttrs &#125; from &#x27;vue&#x27;const attrs = useAttrs()&lt;/script&gt;\r\n在 setup(props,ctx) 函数中通过 ctx.attrs\r\n来访问\r\nattrs 对象总是反映为最新的\r\nattribute，但它并不是响应式的。\r\n禁用继承\r\n设置 inheritAttrs: false 来禁用自动继承。\r\n&lt;script&gt;// 使用普通的 &lt;script&gt; 来声明选项export default &#123;  inheritAttrs: false&#125;&lt;/script&gt;&lt;script setup&gt;// ...setup 部分逻辑&lt;/script&gt;\r\n继承的 Attributes 可以在模板中直接用 $attrs 访问到。\r\n这个 $attrs 对象包含了除组件所声明的 props\r\n和 emits 之外的所有其他 attribute，例如\r\nclass，style，v-on\r\n监听器等等。\r\n有几点需要注意：\r\n\r\n和 props 有所不同，继承的 attributes 在 JavaScript\r\n中保留了它们原始的大小写，所以像 foo-bar 这样的一个\r\nattribute 需要通过 $attrs['foo-bar'] 来访问。\r\n像 @click 这样的一个 v-on\r\n事件监听器将在此对象下被暴露为一个函数\r\n$attrs.onClick。\r\n\r\n指定继承\r\n可以在子组件中通过 v-bind 来将 attributes 绑定到其它组件上\r\n&lt;div class=&quot;btn-wrapper&quot;&gt;  &lt;button class=&quot;btn&quot; v-bind=&quot;$attrs&quot;&gt;click me&lt;/button&gt;&lt;/div&gt;\r\n多根节点的 Attributes 继承\r\n需要手动指定继承，无法像单根节点一样，自动继承\r\n插槽 Slots\r\n&lt;slot&gt; 元素是一个插槽出口 (slot\r\noutlet)，标示了父元素提供的插槽内容 (slot content)\r\n将在哪里被渲染。\r\n\r\n渲染作用域\r\n插槽内容可以访问到父组件的数据作用域，无法访问子组件的数据。\r\n默认内容\r\n放置 &lt;slot&gt;\r\n标签时，标签之间的内容作为默认内容。\r\n具名插槽\r\n带 name 属性的插槽叫具名插槽。没有提供 name\r\n的 &lt;slot&gt; 出口会隐式地命名为“default”。\r\n使用 v-slot:slotName(简写为 #slotName)\r\n方式来指定所使用的插槽。\r\n默认插槽不用指定。\r\n当一个组件同时接收默认插槽和具名插槽时，所有位于顶级的非\r\n&lt;template&gt;\r\n节点都被隐式地视为默认插槽的内容。如下：\r\n&lt;BaseLayout&gt;  &lt;template #header&gt;    &lt;h1&gt;Here might be a page title&lt;/h1&gt;  &lt;/template&gt;  &lt;!-- 隐式的默认插槽 --&gt;  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;  &lt;p&gt;And another one.&lt;/p&gt;  &lt;template #footer&gt;    &lt;p&gt;Here&#x27;s some contact info&lt;/p&gt;  &lt;/template&gt;&lt;/BaseLayout&gt;\r\n动态插槽\r\n通过指令的动态参数传递不同的名称实现动态插槽。\r\n插槽传递参数\r\n插槽的内容无法访问到子组件的状态，在定义插槽时，我们需要先将组件数组绑定到插槽上，使用时，再从插槽中获取。\r\n\r\n数据绑定：\r\n&lt;!-- &lt;MyComponent&gt; 的模板 --&gt;&lt;div&gt;  &lt;slot :text=&quot;greetingMessage&quot; :count=&quot;1&quot;&gt;&lt;/slot&gt;&lt;/div&gt;\r\n参数接收：\r\n\r\n默认插槽使用 v-slot=\"slotProps\" 或者\r\n#default=\"slotProps\"来接收参数\r\n具名插槽使用 #slotName=\"slotProps\" 来接收参数\r\n\r\n无渲染组件\r\n一些组件可能只包括了逻辑而不需要自己渲染内容，视图输出通过作用域插槽全权交给了消费者组件。我们将这种类型的组件称为无渲染组件。\r\n依赖注入\r\n依赖注入用于多级父子组件传值，解决 props 传值链路长的问题。\r\nprops 传值：\r\n\r\n依赖注入：\r\n\r\nProvide (提供)\r\n&lt;script setup&gt;import &#123; provide &#125; from &#x27;vue&#x27;provide(/* 注入名 */ &#x27;message&#x27;, /* 值 */ &#x27;hello!&#x27;)&lt;/script&gt;\r\n第一个参数被称为注入名，可以是一个字符串或是一个\r\nSymbol\r\n第二个参数是提供的值，值可以是任意类型，包括响应式的状态\r\n可以在应用层进行依赖注入：\r\nimport &#123; createApp &#125; from &#x27;vue&#x27;const app = createApp(&#123;&#125;)app.provide(/* 注入名 */ &#x27;message&#x27;, /* 值 */ &#x27;hello!&#x27;)\r\nInject (注入)\r\n使用 inject()\r\n函数注入上层组件提供的数据。\r\nimport &#123; inject &#125; from &#x27;vue&#x27;export default &#123;  setup() &#123;    // 第二个参数是默认值    const value = inject(&#x27;key&#x27;, () =&gt; new ExpensiveClass())    return &#123; value &#125;  &#125;&#125;\r\n使用建议\r\n当提供 /\r\n注入响应式的数据时，建议尽可能将任何对响应式状态的变更都保持在供给方组件中。这样可以确保所提供状态的声明和变更操作都内聚在同一个组件内，使其更容易维护。\r\n&lt;!-- 在供给方组件内 --&gt;&lt;script setup&gt;import &#123; provide, ref &#125; from &#x27;vue&#x27;const location = ref(&#x27;North Pole&#x27;)function updateLocation() &#123;  location.value = &#x27;South Pole&#x27;&#125;provide(&#x27;location&#x27;, &#123;  location,  updateLocation&#125;)&lt;/script&gt;\r\n&lt;!-- 在注入方组件 --&gt;&lt;script setup&gt;import &#123; inject &#125; from &#x27;vue&#x27;const &#123; location, updateLocation &#125; = inject(&#x27;location&#x27;)&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;updateLocation&quot;&gt;&#123;&#123; location &#125;&#125;&lt;/button&gt;&lt;/template&gt;\r\n只读数据\r\n可以使用 readonly()\r\n来包装提供的值使其不能被修改\r\n异步组件\r\n定义\r\n使用 defineAsyncComponent\r\n方法来实现按需从服务器加载相关组件。\r\nimport &#123; defineAsyncComponent &#125; from &#x27;vue&#x27;const AsyncComp = defineAsyncComponent(() =&gt; &#123;  return new Promise((resolve, reject) =&gt; &#123;    // ...从服务器获取组件    resolve(/* 获取到的组件 */)  &#125;)&#125;)// ... 像使用其他一般组件一样使用 `AsyncComp`\r\nES\r\n模块动态导入也会返回一个 Promise，所以多数情况下我们会将它和\r\ndefineAsyncComponent 搭配使用。类似 Vite 和 Webpack\r\n这样的构建工具也支持此语法\r\n(并且会将它们作为打包时的代码分割点)，因此我们也可以用它来导入 Vue\r\n单文件组件：\r\nimport &#123; defineAsyncComponent &#125; from &#x27;vue&#x27;const AsyncComp = defineAsyncComponent(() =&gt;  import(&#x27;./components/MyComponent.vue&#x27;))\r\n加载与错误状态\r\nconst AsyncComp = defineAsyncComponent(&#123;  // 加载函数  loader: () =&gt; import(&#x27;./Foo.vue&#x27;),  // 加载异步组件时使用的组件  loadingComponent: LoadingComponent,  // 展示加载组件前的延迟时间，默认为 200ms  delay: 200,  // 加载失败后展示的组件  errorComponent: ErrorComponent,  // 如果提供了一个 timeout 时间限制，并超时了  // 也会显示这里配置的报错组件，默认值是：Infinity  timeout: 3000&#125;)\r\n逻辑复用\r\n组合式函数\r\n“组合式函数”(Composables) 是一个利用 Vue 的组合式 API\r\n来封装和复用有状态逻辑的函数。在开发中可以将功能细分成一个个组合式函数，最后组合成功能。\r\n约定和最佳实践\r\n命名\r\n组合式函数约定用驼峰命名法命名，并以“use”作为开头。\r\n输入参数兼容 ref\r\n使用 unref 来兼容输入参数\r\nimport &#123; unref &#125; from &#x27;vue&#x27;function useFeature(maybeRef) &#123;  // 若 maybeRef 确实是一个 ref，它的 .value 会被返回  // 否则，maybeRef 会被原样返回  const value = unref(maybeRef)&#125;\r\n返回值\r\n组合式函数应始终返回一个包含多个 ref\r\n的普通的非响应式对象，这样该对象在组件中被解构为 ref\r\n之后仍可以保持响应性。\r\n从组合式函数返回一个响应式对象会导致在对象解构过程中丢失与组合式函数内状态的响应性连接。\r\n如果更希望以对象属性的形式来使用组合式函数中返回的状态，可以将返回的对象用\r\nreactive() 包装一次，这样其中的 ref\r\n会被自动解包，例如：\r\nconst mouse = reactive(useMouse())// mouse.x 链接到了原来的 x refconsole.log(mouse.x)\r\n额外操作\r\n如果你的应用用到了服务端渲染\r\n(SSR)，请确保在组件挂载后(onMounted)才调用的生命周期钩子中执行\r\nDOM 相关的其它操作，并在 onUnmounted() 中释放资源。\r\n使用限制\r\n组合式函数在 &lt;script setup&gt; 或\r\nsetup() 钩子中，应始终被同步地调用。\r\n通过抽取组合式函数改善代码结构\r\n可以基于逻辑问题将组件代码拆分成更小的函数\r\n&lt;script setup&gt;import &#123; useFeatureA &#125; from &#x27;./featureA.js&#x27;import &#123; useFeatureB &#125; from &#x27;./featureB.js&#x27;import &#123; useFeatureC &#125; from &#x27;./featureC.js&#x27;const &#123; foo, bar &#125; = useFeatureA()const &#123; baz &#125; = useFeatureB(foo)const &#123; qux &#125; = useFeatureC(baz)&lt;/script&gt;\r\n在选项式 API\r\n中使用组合式函数\r\n如果你正在使用选项式 API，组合式函数必须在 setup()\r\n中调用。且其返回的绑定必须在 setup() 中返回，以便暴露给\r\nthis 及其模板\r\n自定义指令\r\n定义与使用\r\n在 &lt;script setup&gt; 中，任何以 v\r\n开头的驼峰式命名的变量都可以被用作一个自定义指令。例如vFocus\r\n可以在模板中以 v-focus 的形式使用。\r\n在没有使用 &lt;script setup&gt;\r\n的情况下，自定义指令需要通过 directives 选项注册。\r\nexport default &#123;  setup() &#123;    /*...*/  &#125;,  directives: &#123;    // 在模板中启用 v-focus    focus: &#123;      /* ... */    &#125;  &#125;&#125;\r\n指令钩子\r\n一个指令的定义对象可以提供几种钩子函数 (都是可选的)：\r\nconst myDirective = &#123;  // 在绑定元素的 attribute 前  // 或事件监听器应用前调用  created(el, binding, vnode, prevVnode) &#123;    // 下面会介绍各个参数的细节  &#125;,  // 在元素被插入到 DOM 前调用  beforeMount(el, binding, vnode, prevVnode) &#123;&#125;,  // 在绑定元素的父组件  // 及他自己的所有子节点都挂载完成后调用  mounted(el, binding, vnode, prevVnode) &#123;&#125;,  // 绑定元素的父组件更新前调用  beforeUpdate(el, binding, vnode, prevVnode) &#123;&#125;,  // 在绑定元素的父组件  // 及他自己的所有子节点都更新后调用  updated(el, binding, vnode, prevVnode) &#123;&#125;,  // 绑定元素的父组件卸载前调用  beforeUnmount(el, binding, vnode, prevVnode) &#123;&#125;,  // 绑定元素的父组件卸载后调用  unmounted(el, binding, vnode, prevVnode) &#123;&#125;&#125;\r\n简化形式\r\napp.directive(&#x27;color&#x27;, (el, binding) =&gt; &#123;  // 这会在 `mounted` 和 `updated` 时都调用  el.style.color = binding.value&#125;)\r\n在组件上使用\r\n当在组件上使用自定义指令时，它会始终应用于组件的根节点。\r\n指令不能通过 v-bind=\"$attrs\"\r\n来传递给一个不同的元素。\r\n插件\r\n插件没有严格定义的使用范围，但是插件发挥作用的常见场景主要包括以下几种：\r\n\r\n通过 app.component()\r\n和 app.directive()\r\n注册一到多个全局组件或自定义指令。\r\n通过 app.provide()\r\n使一个资源可被注入进整个应用。\r\n向 app.config.globalProperties\r\n中添加一些全局实例属性或方法\r\n一个可能上述三种都包含了的功能库 (例如 vue-router)。\r\n\r\n// 定义const myPlugin = &#123;  install(app, options) &#123;    // 配置此应用  &#125;&#125;// 使用import &#123; createApp &#125; from &#x27;vue&#x27;const app = createApp(&#123;&#125;)app.use(myPlugin, &#123;  /* 可选的选项 */&#125;)\r\n内置组件\r\nTransition\r\nVue 提供了两个内置组件来制作基于状态变化的过渡和动画：\r\n\r\n&lt;Transition&gt; 会在一个元素或组件进入和离开 DOM\r\n时应用动画。\r\n&lt;TransitionGroup&gt; 会在一个 v-for\r\n列表中的元素或组件被插入，移动，或移除时应用动画。\r\n\r\n应用规模化\r\n最佳实践\r\nTypeScript\r\n参考\r\n\r\nVue 深度指南\r\n(官方)\r\n\r\n","categories":["Develop","Javascript","Vue","Vue3.x"],"tags":["NexT","Vue"]},{"title":"Query 和 Projection 操作符","url":"/posts/2022/TZZNFQ.html","content":"本文总结了 mongoDB 中的查询和映射操作符。\r\n\r\n具体使用方法可以单击操作符跳转查看\r\n\r\n\r\nQuery Selectors，查询操作符\r\nComparison，比较\r\nFor comparison of different BSON type values, see the specified\r\nBSON comparison order.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nName\r\nDescription\r\n\r\n\r\n\r\n\r\n$eq\r\nMatches values that are equal to a\r\nspecified value.\r\n\r\n\r\n$gt\r\nMatches values that are greater than a\r\nspecified value.\r\n\r\n\r\n$gte\r\nMatches values that are greater than or\r\nequal to a specified value.\r\n\r\n\r\n$in\r\nMatches any of the values specified in an\r\narray.\r\n\r\n\r\n$lt\r\nMatches values that are less than a\r\nspecified value.\r\n\r\n\r\n$lte\r\nMatches values that are less than or equal\r\nto a specified value.\r\n\r\n\r\n$ne\r\nMatches all values that are not equal to a\r\nspecified value.\r\n\r\n\r\n$nin\r\nMatches none of the values specified in an\r\narray.\r\n\r\n\r\n\r\nLogical，逻辑\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nName\r\nDescription\r\n\r\n\r\n\r\n\r\n$and\r\nJoins query clauses with a logical\r\nAND returns all documents that match the conditions of both\r\nclauses.\r\n\r\n\r\n$not\r\nInverts the effect of a query expression\r\nand returns documents that do not match the query\r\nexpression.\r\n\r\n\r\n$nor\r\nJoins query clauses with a logical\r\nNOR returns all documents that fail to match both\r\nclauses.\r\n\r\n\r\n$or\r\nJoins query clauses with a logical\r\nOR returns all documents that match the conditions of\r\neither clause.\r\n\r\n\r\n\r\nElement，单元\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nName\r\nDescription\r\n\r\n\r\n\r\n\r\n$exists\r\nMatches documents that have the specified\r\nfield.\r\n\r\n\r\n$type\r\nSelects documents if a field is of the\r\nspecified type.\r\n\r\n\r\n\r\nEvaluation，判断\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nName\r\nDescription\r\n\r\n\r\n\r\n\r\n$expr\r\nAllows use of aggregation expressions\r\nwithin the query language.\r\n\r\n\r\n$jsonSchema\r\nValidate documents against the given JSON\r\nSchema.\r\n\r\n\r\n$mod\r\nPerforms a modulo operation on the value\r\nof a field and selects documents with a specified result.\r\n\r\n\r\n$regex\r\nSelects documents where values match a\r\nspecified regular expression.\r\n\r\n\r\n$text\r\nPerforms text search.\r\n\r\n\r\n$where\r\nMatches documents that satisfy a\r\nJavaScript expression.\r\n\r\n\r\n\r\nGeospatial，地理空间\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nName\r\nDescription\r\n\r\n\r\n\r\n\r\n$geoIntersects\r\nSelects geometries that intersect with a\r\nGeoJSON\r\ngeometry. The 2dsphere\r\nindex supports $geoIntersects.\r\n\r\n\r\n$geoWithin\r\nSelects geometries within a bounding GeoJSON\r\ngeometry. The 2dsphere\r\nand 2d\r\nindexes support $geoWithin.\r\n\r\n\r\n$near\r\nReturns geospatial objects in proximity to\r\na point. Requires a geospatial index. The 2dsphere\r\nand 2d\r\nindexes support $near.\r\n\r\n\r\n$nearSphere\r\nReturns geospatial objects in proximity to\r\na point on a sphere. Requires a geospatial index. The 2dsphere\r\nand 2d\r\nindexes support $nearSphere.\r\n\r\n\r\n\r\nArray，数组\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nName\r\nDescription\r\n\r\n\r\n\r\n\r\n$all\r\nMatches arrays that contain all elements\r\nspecified in the query.\r\n\r\n\r\n$elemMatch\r\nSelects documents if element in the array\r\nfield matches all the specified $elemMatch\r\nconditions.\r\n\r\n\r\n$size\r\nSelects documents if the array field is a\r\nspecified size.\r\n\r\n\r\n\r\nBitwise，位\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nName\r\nDescription\r\n\r\n\r\n\r\n\r\n$bitsAllClear\r\nMatches numeric or binary values in which\r\na set of bit positions all have a value of 0.\r\n\r\n\r\n$bitsAllSet\r\nMatches numeric or binary values in which\r\na set of bit positions all have a value of 1.\r\n\r\n\r\n$bitsAnyClear\r\nMatches numeric or binary values in which\r\nany bit from a set of bit positions has a value of\r\n0.\r\n\r\n\r\n$bitsAnySet\r\nMatches numeric or binary values in which\r\nany bit from a set of bit positions has a value of\r\n1.\r\n\r\n\r\n\r\nProjection\r\nOperators，映射操作符\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nName\r\nDescription\r\n\r\n\r\n\r\n\r\n$\r\nProjects the first element in an array\r\nthat matches the query condition.\r\n\r\n\r\n$elemMatch\r\nProjects the first element in an array\r\nthat matches the specified $elemMatch\r\ncondition.\r\n\r\n\r\n$meta\r\nProjects the document's score assigned\r\nduring $text\r\noperation.\r\n\r\n\r\n$slice\r\nLimits the number of elements projected\r\nfrom an array. Supports skip and limit slices.\r\n\r\n\r\n\r\nMiscellaneous\r\nOperators，其它操作符\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nName\r\nDescription\r\n\r\n\r\n\r\n\r\n$comment\r\nAdds a comment to a query predicate.\r\n\r\n\r\n$rand\r\nGenerates a random float between 0 and\r\n1.\r\n\r\n\r\n\r\n参考\r\nQuery\r\nand Projection Operators\r\n","categories":["Develop","Database","Mongodb","Operators"],"tags":["MongoDB"]},{"title":"vue通信及组件之间传值","url":"/posts/2020/2H8Y4ZN.html","content":"常用 vue 通信大概有这几种方式进行：\r\n\r\n组件间的父子之间的传值\r\n组件间的子父之间的传值\r\n非组件间的组件间的传值（简称：EventBus）\r\nsessionStorage 缓存传值\r\n路由带参数跳转进行传值\r\nvuex 进行传值\r\n\r\n\r\n组件间的父子之间的传值\r\n思路：父组件调用子组件 dom\r\n位置声明一个名称，然后在子组件接收这名称，便可直接调用。\r\n\r\n父组件（谁是父组件个人理解：谁引用谁的组件，谁就是父组件）：\r\n\r\n\r\n\r\np1\r\n\r\n\r\n子组件：\r\n\r\n\r\n\r\np2\r\n\r\n组件间的子父之间的传值\r\n思路：在子组件通过触发一个事件带值，让父组件接受这个事件，解析这个值\r\n\r\n子组件：\r\n\r\n\r\n\r\np3\r\n\r\n\r\n父组件：\r\n\r\n\r\n\r\np4\r\n\r\n非组件间的组件间的传值（简称：EventBus）\r\n先用例子来解释下组件间的关联：组件 A 比作一个路由器，通过中继器\r\n(eventBus.js) 让其他房子接收到信号（组件B）\r\n思路：首先在src目录下创建一个eventBus.js文件，复制这行代码进去\r\nimport Vue from &#x27;vue&#x27;let connect = new Vue()    // 实例export default connect\r\n\r\n组件A：\r\n\r\n\r\n\r\np5\r\n\r\n\r\n组件 B：\r\n\r\n\r\n\r\np6\r\n\r\n效果展示如下:\r\n\r\n\r\np7\r\n\r\n\r\n\r\np8\r\n\r\nsessionStorage 缓存\r\n\r\n组件 A：\r\n\r\n\r\n\r\np9\r\n\r\n\r\n组件 B：\r\n\r\n\r\n\r\np10\r\n\r\n路由带参数跳转\r\n\r\n组件 A：有路由默认的页面\r\n\r\n\r\n\r\n11\r\n\r\n\r\n组件 B：路由其他页面 children\r\n\r\n\r\n\r\np12\r\n\r\n效果如下：\r\n\r\n\r\np13\r\n\r\n\r\n\r\np14\r\n\r\nvuex\r\n主要做数据交互，维护公共状态或数据\r\n官方网站：Vuex\r\n多看几遍这图，vuex 基本就会使用，多加运用就会更加熟练。\r\n\r\n\r\np15\r\n\r\nsrc下创建一个store的文件夹，里面创建index.js文件\r\nimport Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;Vue.use(Vuex)export default new Vuex.Store(&#123;   state: &#123;   city: &quot;上海&quot;   &#125;,    actions: &#123;     handleCity(ctx, city) &#123;   // console.log(ctx, city)       ctx.commit(&quot;handleCity&quot;, city)    &#125;  &#125;,mutations: &#123;     handleCity(state, city) &#123;      state.city = city   &#125;   &#125;&#125;)\r\n某文件触发事件\r\nmethods: &#123;    handleCityClick(city) &#123;      this.$store.dispatch(&quot;handleCity&quot;, &quot;北京&quot;);    &#125;,\r\n展示页面\r\n&lt;h1&gt;&#123;&#123;this.$store.state.city&#125;&#125;&lt;/h1&gt;\r\n致谢\r\n本文摘抄至：vue通信及组件之间传值\r\n","categories":["Develop","Javascript","Vue","VueBasic"],"tags":["vue"]},{"title":"LearnVue 介绍","url":"/posts/2020/3W94T82.html","content":"计划系统的对 Vue.js 的源代码进行深入学习。以 learnVue\r\n入门，因为它当前的 star 数已经破 9k了, 肯定是干货满满的。\r\n本文记录了在学习过程中的一些个人见解，同时，对于以前未涉及的知识点作一个总结和记录，以便今后回顾，如果也有小白恰好看到了这篇文章，希望也能帮到你，节省一些查找资料的时间。\r\n当然，我所理解的可能会存在偏差，欢迎提留言指出，共同学习，共同进步。\r\n最后，再次感谢 answershuto 的 learnVue。\r\n","categories":["Develop","Javascript","Vue","VueBasic"],"tags":["vue","LearnVue"]},{"title":"在组件内怎么监听 Vuex 中 state 的变化","url":"/posts/2020/2B9D6M8.html","content":"最近在项目中需要使用 Vuex\r\n来维护一个全局字段，同时在子组件里需要根据该字段的变化向后端请求数据来展示。\r\n\r\n有两个办法解决上面的问题：\r\n\r\n用 computed 属性\r\n\r\n本方案有个缺陷，就是如果在组件内的模板区域内没有使用该计算属性，它是不会响应\r\nstate\r\n中值的变化的，而本项目就遇到了这个坑，后面采用下面的方法解决了。\r\n\r\n用 watch 属性\r\n\r\n直接 watch state 里面的属性值，这里也有一个注意的地方，不能使用 lamda\r\n表达式，而是要使用完整的方法定义，见下面的代码：\r\nwatch: &#123;    &#x27;$store.getters.loginedProjectGroupId&#x27;: function(value) &#123;      this.getProjectInfo(value)    &#125;  &#125;,\r\n","categories":["Develop","Javascript","Vue","VueBasic"],"tags":["vue"]},{"title":"Vue 中对跨域的 iframe 进行缓存","url":"/posts/2023/1EARQ0T.html","content":"在 vue 应用程序中，有时候需要使用 iframe\r\n嵌入其它网站的内容，并希望可以缓存 iframe\r\n的状态。但如果被链接的源(origin) 与当前的 origin\r\n不同时，iframe\r\n就会发生跨域加载，这个时候，就不能在当前程序中获取 iframe 中的内容，包括\r\nsrc，从而无法获取 iframe 中的状态，导致无法在初始化 iframe\r\n时对状态进行恢复。\r\n可以按以下方法来实现对 iframe 的缓存：\r\n\r\n尝试过的方法\r\n\r\n使用 keep-alive\r\nKeepAlive 缓存的是 vnode 节点，vnode\r\n上面会有对应的真实DOM。组件“销毁”时，会将真实 DOM\r\n移动到“隐藏容器”中，组件重新“渲染”时会从 vnode 上取到真实\r\nDOM，再重新插入到页面中。这样对普通元素是没有影响的，但是 iframe\r\n很特别，当其插入到页面时会重新加载，这是浏览器特性，与 Vue\r\n无关。\r\n保存 iframe 实例，当组件挂载后添加到对应位置\r\n失败的原因与第 1 点相同，当其重新插入到页面时会重新加载。\r\n\r\n解决方案\r\n实现步骤\r\n\r\n思路：路由第一次加载时将 iframe\r\n渲染到页面中，路由切换时通过 v-show 改变显/隐。\r\n\r\n\r\n在路由中，将 component 赋值为一个空组件 index.vue\r\n\r\n&#123;  path: &quot;/chathub&quot;,  name: &quot;chathub&quot;,  component: ()=&gt;import(&quot;@/chathub/index.vue&quot;)&#125;,\r\nindex.js 代码：\r\n&lt;template&gt;  &lt;div class=&quot;iframe-example-index row justify-center&quot;&gt;    &lt;div class=&quot;column justify-center text-h6 text-secondary&quot;&gt;加载中...&lt;/div&gt;      &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; onMounted, ref &#125; from &#x27;vue&#x27;import store from &#x27;@/store/index&#x27;import &#123; useRoute &#125; from &#x27;@/compositions/vueRouter&#x27;export default &#123;  name: &quot;iframeContainer&quot;,  setup() &#123;    const src = ref(&quot;www.baidu.com&quot;)    function getIframeElement() &#123;      const iframeElement = document.getElementById(&#x27;iframe-example-body&#x27;)      return iframeElement    &#125;    async function restoreSrc() &#123;      const iframeElement = getIframeElement()      if (!iframeElement) return      // 设置值      iframeElement.setAttribute(&#x27;src&#x27;, src.value)    &#125;    function initIFrame(force = false) &#123;      if (!force &amp;&amp; iframeSetting.initialized) return      console.log(&#x27;开始创建 iframe&#x27;)      // 初始化 iframe      const iframeTemp = document.createElement(&#x27;iframe&#x27;)      iframeTemp.setAttribute(&#x27;id&#x27;, &#x27;iframe-example-body&#x27;)      iframeTemp.setAttribute(&#x27;width&#x27;, &#x27;100%&#x27;)      iframeTemp.setAttribute(&#x27;height&#x27;, &#x27;100%&#x27;)      const container = document.getElementById(&#x27;iframe-example-container&#x27;)      // 判断是否有 children,有的话，移除      if (container.children.length &gt; 0) &#123;        container.removeChild(container.children[0])      &#125;      container.appendChild(iframeTemp)      iframeTemp.setAttribute(&#x27;src&#x27;, src.value)    &#125;    onMounted(async () =&gt; &#123;      // 修改 iframe      getIframeElement()      // 创建一个 iframe，保存到 iframe-example-container children 中      initIFrame()      // 从 url 中获取 src      await restoreSrc()    &#125;)    return &#123; src &#125;  &#125;,&#125;&lt;/script&gt;.iframe-example-index &#123;  position: absolute;  top: 0px;  left: 0px;  width: 100%;  height: 100%;&#125;\r\n\r\n在 router-view 处，加载一个 container 容器组件，通过\r\nv-if、 v-show 来控制显示隐藏\r\n\r\n&lt;Container v-if=&quot;iframeVisited&quot; v-show=&quot;isIFramePageVisible&quot;&gt;&lt;/Container&gt;&lt;router-view v-slot=&quot;&#123; Component &#125;&quot;&gt;  &lt;keep-alive :include=&quot;keepAliveList&quot;&gt;    &lt;component :is=&quot;Component&quot;&gt;&lt;/component&gt;  &lt;/keep-alive&gt;&lt;/router-view&gt;\r\ncontainer.js 代码：\r\n&lt;template&gt;  &lt;div id=&quot;iframe-example-container&quot;&gt;  &lt;/div&gt;&lt;/template&gt;\r\n\r\n通过监听路由path的变化，改变 ChatHub 的显/隐，间接控制 iframe\r\n的显示\r\n\r\nconst isIFramePageVisible = ref(false)// 这里是个优化，想的是只有页面访问过该路由才渲染，没访问过就不渲染该组件const iframeVisited = ref(false) watch(  () =&gt; routes.path,  (value) =&gt; &#123;    if (value === &#x27;/iframe&#x27;) &#123;      iframeVisited.value = true      isIFramePageVisible.value = true    &#125; else &#123;      isIFramePageVisible.value = false    &#125;  &#125;,  &#123;    immediate: true  &#125;)\r\n注意事项\r\niframe 只有处于显示时，才会加载 iframe 里面的内容。因此，必须保证\r\niframe 不在后台实例化，可以通过以下方式实现：\r\n\r\n通过 v-if 来控制初始化加载\r\n在 index.vue 第一次加载时，使用 js 初始化\r\niframe，然后添加到 ChatHub 作为其子元素。\r\n\r\n\r\n如果后台先实例了 iframe 后，会导致从其它页面切换到 /chathub\r\n页面时，无法正常加载 iframe 里面的内容，并影响性能。\r\n\r\n参考\r\n本文参考以下文章，在此报以诚挚谢意！\r\n\r\nvue缓存iframe的解决方法\r\nVue\r\nKeepAlive 为什么不能缓存 iframe\r\n\r\n","categories":["Develop","Javascript","Vue","VueBasic"],"tags":["Vue","iframe"]},{"title":"MongoDB 聚合管道优化","url":"/posts/2022/1S7MQ2A.html","content":"MongoDB\r\n在聚合之前会有一个优化阶段来提升性能。在开发中，也可以参考这些优化方式，来优化咱们的聚合查询。\r\n\r\n映射优化\r\n聚合管道可以确定它是否只需要文档中字段的一个子集就可以获得结果。\r\n如果是这样，管道将只使用那些必需的字段，从而减少通过管道传递的数据量。\r\n\r\n在 $match 后，可以先 $project\r\n掉一些不需要的字段（通过 {fileName: 0 || false}\r\n来实现）。\r\n\r\n管道序列优化\r\n($project or $unset or\r\n$addFields or $set) + $match\r\n序列优化。\r\n参考\r\n聚合管道优化\r\n","categories":["Develop","Database","Mongodb","查询优化"],"tags":["MongoDB"]},{"title":"mongodb查询优化方法","url":"/posts/2022/2N28YC5.html","content":"详见参考文档。\r\n\r\n参考\r\n\r\nQuery\r\nOptimization\r\nExplain\r\nResults\r\n\r\n","categories":["Develop","Database","Mongodb","查询优化"],"tags":["MongoDB"]},{"title":"LearnVue 响应式原理","url":"/posts/2020/1P0TW1J.html","content":"Vue.js的响应式原理依赖于 Object.defineProperty，尤大大在\r\nVue.js文档\r\n中就已经提到过，这也是 Vue.js 不支持 IE8 以及更低版本浏览器的原因。Vue\r\n通过设定对象属性的 setter/getter 方法来监听数据的变化，通过 getter\r\n进行依赖收集，而每个 setter\r\n方法就是一个观察者，在数据变更的时候通知订阅者更新视图。\r\n\r\n将数据data变成可观察（observable）的\r\n注解\r\n\r\nObject.defineProperty(\r\nobj, propName, descriptor )\r\n在对象上定义一个新的属性，或者修改一个存在的属性，然后返回该对象\r\n其中 descriptor 有以下参数\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n描述符\r\n作用\r\n默认值\r\n\r\n\r\n\r\n\r\nconfigurable\r\n是否 可更改属性类型和可删除\r\nfalse\r\n\r\n\r\nenumerable\r\n是否 可枚举属性该属性。如果为 true,\r\n在枚举属性的时候，会显示该属性\r\nfalse\r\n\r\n\r\nvlue\r\n属性的值, 可以是任意的 js 值类型\r\nundefined\r\n\r\n\r\nwritable\r\n是否 属性值是否可以通过赋值运算符进行修改\r\nfalse\r\n\r\n\r\nget\r\n存取器\r\nundefined\r\n\r\n\r\nset\r\n存取器\r\nundefined\r\n\r\n\r\n\r\nObject.keys()\r\n返回对象所有的属性\r\n\r\n疑问？\r\nclass Vue &#123;    constructor(options) &#123;        this._data = options.data;        observe(this._data, options.render)    &#125;&#125;\r\n如果是 component ，它的 data 是一个函数，那它的 data\r\n是怎么处理的呢？\r\n代理\r\n我们可以在Vue的构造函数constructor中为data执行一个代理proxy。这样我们就把data上面的属性代理到了vm实例上。\r\n\r\ncall()\r\n使用给定的 this 值和单独提供的参数调用函数。\r\n这样，在 _proxy 函数里面就可以调用 this 值了。\r\n\r\n问题？\r\n为什么不直接将 data 中的参数定义到 vm (vue 的实例) 上，而是要先定义到\r\nvm._data, 然后再代理到 vm 呢？\r\n我猜测是因为：\r\n\r\n如果直接定义到 this 实例上，那 data 就没有定义\r\n而通过代理，data 传递引用给 vm._data, 在 _data上定义，就代表在 data\r\n上也定义了，然后再代理到 vm 上，这样，可以通过 vm.propertyName\r\n访问了\r\n\r\n后记\r\n本文是在学习 LearnVue\r\n时的个人注解，如果需要参考，请先阅读 LearnVue 。\r\n","categories":["Develop","Javascript","Vue","VueBasic"],"tags":["vue","LearnVue"]},{"title":"动态路由深度克隆路由导致VueRouter component重载","url":"/posts/2021/119HBCA.html","content":"今天在一个以 vue-element-admin\r\n为框架的项目中遇到这样一个问题：固定路由与动态路由切换时，vue 会重新加载\r\nLayout 组件。\r\n\r\n后经过排查，发现是由于在进行动态路由添加时，使用了 lodash 的\r\ncloneDeep() 对原来的路由进行克隆导致的。\r\n路由配置文件：\r\nimport Layout from &#x27;@/layout&#x27;// 固定路由export const constantRoutes = [  ...  &#123;    path: &#x27;/&#x27;,    component: Layout,    redirect: &#x27;/dashboard&#x27;,    name: &#x27;DashboardIndex&#x27;,    children: [      &#123;        path: &#x27;dashboard&#x27;,        component: () =&gt; import(&#x27;@/views/dashboard/index&#x27;),        name: &#x27;Dashboard&#x27;,        meta: &#123; title: &#x27;首页&#x27;, icon: &#x27;dashboard&#x27;, affix: true &#125;      &#125;    ]  &#125;,]// 动态路由export const asyncRoutes = [  &#123;    path: &#x27;/workflow&#x27;,    name: &#x27;workflow&#x27;,    component: Layout,    meta: &#123;      title: &#x27;工作流程&#x27;,      icon: &#x27;workflow&#x27;,      functionCode: &#x27;router/workflow&#x27;    &#125;,    redirect: &#x27;/workflow/ownWorkflow/searchWorkflow&#x27;,    children: [      &#123;        path: &#x27;createWorkflow&#x27;,        component: () =&gt; import(&#x27;@/views/workflow/own-workflow/create-workflow&#x27;),        name: &#x27;CreateWorkFlow&#x27;,        meta: &#123;          title: &#x27;新建工作&#x27;,          icon: &#x27;add-document&#x27;,          functionCode: &#x27;router/createWorkflow&#x27;,          noCache: true        &#125;      &#125;,    ]  &#125;]\r\n动态路由生成：\r\n// store中生成路由generateRoutes(&#123; commit &#125;, access) &#123;  return new Promise(resolve =&gt; &#123;    let accessedRoutes    if (access.includes(&#x27;*&#x27;)) &#123;      const cloneDatas = _.cloneDeep(asyncRoutes)      accessedRoutes = cloneDatas    &#125; else &#123;      accessedRoutes = filterAsyncRoutes(asyncRoutes, access)    &#125;    commit(&#x27;SET_ROUTES&#x27;, accessedRoutes)    resolve(accessedRoutes)  &#125;)&#125;\r\n原理分析 为什么使用 clone\r\n后的路由配置，在切换时就会重新加载路由里面的 component 组件呢？\r\n原来是因为 cloneDeep() 会进行深度克隆，路由中的 component\r\n也会变成新的对象，该对象与固定路由中的 component\r\n不是同一个，所以两者在进行切换时，会重载 Layout 布局。\r\n","categories":["Develop","Javascript","Vue","VueRouter"],"tags":["VueRouter"]},{"title":"如何获得Stylet中IContainer的引用","url":"/posts/2021/2MV52X2.html","content":"使用 Stylet 框架进行 MVVM 开发，采用 IoC 时，我们可能需要传递 IoC\r\n生成的 IContainer\r\n引用，这样可以在其它地方自由地获取实例，比如整个程序的配置文件。\r\n\r\n正文\r\n想要获取 IContainer，可以在 Bootstrapper\r\n中获取。代码如下：\r\nusing System;using Stylet;using StyletIoC;using log4net.Core;using log4net;using Server.Pages;using Server.Database;using Server.Config;using Server.Http;namespace Server&#123;    public class Bootstrapper : Bootstrapper&lt;ShellViewModel&gt;    &#123;        private readonly ILog _logger = LogManager.GetLogger(typeof(Bootstrapper));        private HttpServiceMain _httpServer;        protected override void ConfigureIoC(IStyletIoCBuilder builder)        &#123;            // Configure the IoC container in here            // 注册 IoC            var userConfig = new UserConfig();            builder.Bind&lt;UserConfig&gt;().ToInstance(userConfig);            builder.Bind&lt;LiteDBManager&gt;().ToInstance(new LiteDBManager(userConfig));            base.ConfigureIoC(builder);        &#125;        // 在此处获取 Container, 其它地方获取的都是空        protected override void Configure()        &#123;            // Perform any other configuration before the application starts\t\t\t            // 加载静态网页服务            _httpServer = new HttpServiceMain();            _httpServer.Start(Container);            // 加载 websocket        &#125;        protected override void OnStart()        &#123;            Stylet.Logging.LogManager.Enabled = true;            // 添加对所有未捕获异常的读取            AppDomain.CurrentDomain.UnhandledException += CurrentDomain_UnhandledException;        &#125;        private void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)        &#123;            _logger.Error(&quot;未捕获异常:&quot; + e.ExceptionObject.ToString());        &#125;    &#125;&#125;\r\n参考\r\n[1]. IoC:\r\nStatic Service Locator\r\n","categories":["Develop","DotNET","Stylet 框架","StyletIoC"],"tags":["Stylet","IoC"]},{"title":"WPF MVVM Stylet使用文档（中文）19-1 LabelledValue","url":"/posts/2020/PBS08B.html","content":"有时您希望向用户显示一些对象，但您希望将自定义(字符串)标签与之关联，视图中将显示该标签。因此要创建易用类来包装对象并关联这个标签。\r\n\r\n然后你会想要重写 ToString 以及 Equals 和\r\nGetHashCode，这样你的视图就只显示标签，这样它们就能在含有SelectedItem\r\n的类中工作 (例如，ComboBox)。最后，您将希望实现\r\nINotifyPropertyChanged，以便视图能够对其进行更改。\r\n这就是LabelledValue&lt;T&gt;\r\n的全部内容——一个具有字符串Label属性和 T\r\nValue 属性的类。加上一个重写的 ToString，\r\nGetHashCode， Equals，并实现了\r\nINotifyPropertyChanged。\r\n例如:\r\npublic enum MyEnum&#123;   Foo,   Bar,   Baz&#125;class MyViewModel&#123;   // Implement INotifyPropertyChanged if you want   public BindableCollection&lt;LabelledValue&lt;MyEnum&gt;&gt; EnumValues &#123; get; private set; &#125;   public LabelledValue&lt;MyEnum&gt; SelectedEnumValue &#123; get; set; &#125;   public MyViewModel()   &#123;      this.EnumValues = new BindableCollection&lt;LabelledValue&lt;MyEnum&gt;&gt;()      &#123;         LabelledValue.Create(&quot;Foo Value&quot;, MyEnum.Foo),         LabelledValue.Create(&quot;Bar Value&quot;, MyEnum.Bar),         LabelledValue.Create(&quot;Baz Value&quot;, MyEnum.Baz),      &#125;;      this.SelectedEnumValue = this.EnumValues[0];   &#125;&#125;\r\n然后，在视图中：\r\n&lt;ComboBox ItemsSource=&quot;&#123;Binding EnumValues&#125;&quot; SelectedItem=&quot;&#123;Binding SelectedEnumValue&#125;&quot;/&gt;\r\n","categories":["Develop","DotNET","Stylet 框架","Misc"],"tags":["MVVM","WPF"]},{"title":"WPF MVVM Stylet使用文档（中文）19-2 Debug Converter","url":"/posts/2020/AEXRX4.html","content":"在我曾经需要调试绑定的每个项目上，最简单的方法是在绑定上放置一个转换器，它只记录它看到的值。`DebugConverter\r\n就是这样一个转换器的实现，它将记录对 Visual Studio\r\n输出窗口的每次调用，前提是你正在运行一个调试版本。\r\n\r\n基本用法很简单:\r\n&lt;TextBox Text=&quot;&#123;Binding MyProperty, Converter=&#123;x:Static s:DebugConverter.Instance&#125;&#125;&quot;/&gt;\r\n如果您希望同时激活多个实例，并希望为每个实例指定一个名称(包含在其输出中)，您可以这样做:\r\n&lt;!-- In any .Resources section - doesn&#x27;t have to be Window.Resources --&gt;&lt;Window.Resources&gt;   &lt;s:DebugConverter x:key=&quot;debugConverter&quot; Name=&quot;MySpecialName&quot;/&gt;&lt;/Window.Resources&gt;&lt;!-- Later in code --&gt;&lt;TextBlock Text=&quot;&#123;Binding MyProperty, Converter=&#123;StaticResource debugConverter&#125;&#125;&quot;/&gt;\r\n","categories":["Develop","DotNET","Stylet 框架","Misc"],"tags":["MVVM","WPF"]},{"title":"WPF MVVM Stylet使用文档（中文）19-4 IoC：Static Service Locator","url":"/posts/2020/1R7P97F.html","content":"\r\nCaliburn.Micro 附带了一个名为 IoC\r\n的静态服务定位器。这让你可以从代码中的任何地方访问 IoC\r\n容器，就像这样:\r\nvar vm = IoC.Get&lt;MyDialogViewModel&gt;();this.windowManager.ShowDialog(vm);\r\nStylet\r\n没有包含这个，而且有很好的理由:我不想鼓励人们编写如此糟糕的代码。服务定位器模式经常被称为反模式。现在每个类都有一个对\r\nIoC\r\n的依赖(而不是它所依赖的实际类)，您不能仅通过查看类的构造函数就知道它的依赖关系是什么，相反，您必须遍历代码以才能得知它对IoC.Get的调用。\r\nIoC 也在 Caliburn 内部使用导致产生了一些糟糕的设计选择。这些已经在\r\nStylet 中重新架构，因此内部不再需要IoC。\r\n如果你真的需要 IoC\r\n的支持(尽管它会导致糟糕的代码风格)，那么你可以很容易地编写自己的\r\nIoC。首先创建这个静态 IoC 类:\r\npublic static class IoC&#123;    public static Func&lt;Type, string, object&gt; GetInstance = (service, key) =&gt; &#123; throw new InvalidOperationException(&quot;IoC is not initialized&quot;); &#125;;    public static Func&lt;Type, IEnumerable&lt;object&gt;&gt; GetAllInstances = service =&gt; &#123; throw new InvalidOperationException(&quot;IoC is not initialized&quot;); &#125;;    public static Action&lt;object&gt; BuildUp = instance =&gt; &#123; throw new InvalidOperationException(&quot;IoC is not initialized&quot;); &#125;;    public static T Get&lt;T&gt;(string key = null)    &#123;        return (T)GetInstance(typeof(T), key);    &#125;    public static IEnumerable&lt;T&gt; GetAll&lt;T&gt;()    &#123;        return GetAllInstances(typeof(T)).Cast&lt;T&gt;();    &#125;&#125;\r\n然后在引导程序中添加下面的代码：\r\nprotected override void Configure()&#123;   IoC.GetInstance = this.Container.Get;   IoC.GetAllInstances = this.Container.GetAll;   IoC.BuildUp = this.Container.BuildUp;&#125;\r\n","categories":["Develop","DotNET","Stylet 框架","Misc"],"tags":["MVVM","WPF"]},{"title":"WPF MVVM Stylet使用文档（中文）14-1-Introduction of StyletIoC","url":"/posts/2020/3CQNFDK.html","content":"StyletIoC 是一个非常轻量和非常快的 IoC\r\n容器。它被设计来只做很少的事情，但做得很好，且直观。\r\n\r\n它使用一个流畅的接口进行配置——没有任何XML垃圾，也没有依赖关系。\r\n现在，我假设您对 IoC\r\n容器的概念有一定的了解——如果没有，请阅读一些资料，然后再回来。我以后可能会写一篇更深入的介绍。\r\n服务和实现（Services and\r\nImplementations）\r\nStyletIoC\r\n是围绕服务的概念构建的。服务是具体类型、抽象类型或接口，由具体类型实现(或可以实现)，例如:\r\ninterface IVehicle &#123; ... &#125;class HotHatchback : IVehicle &#123; ... &#125;\r\n这里，IVehicle 是服务，HotHatchback\r\n是实现服务的具体类型。注意 HotHatchback\r\n也是一个服务，它是由 HotHatchback 类本身实现的。\r\n配置 StyletIoC\r\n时，要定义一组关系。每个关系都是服务与实现它的类型(或多个类型)之间的关系。所以这里，我们可以告诉\r\nStyletIoC: \"在服务 IVehicle 和类型\r\nHotHatchback 之间创建一个关系”。\r\n稍后，当你想要一个 IVehicle 的实现时，你可以请求\r\nStyletIoC: “给我一个实现服务 IVehicle\r\n的实例\"，然后StyletIoC 会构造一个 HotHatchback\r\n并将它传递给你。\r\n处理类型——服务定位符和注入（Resolving\r\nTypes - The Service Locator and Injection）\r\n有3种方法让 StyletIoC 为我们构建一个类型:\r\n\r\n通过直接调用 IContainer.Get\r\n构造函数注入\r\n属性注入\r\n\r\n直接调用 IContainer.Get\r\n是最容易解释的，它看起来像这样:\r\nvar ioc = ... // Covered in lots of detail elsewherevar vehicle = ioc.Get&lt;IVehicle&gt;();\r\n尽管这看起来很诱人，但这只应该在应用程序的根目录中完成——在其他地方使用构造函数注入和参数注入。\r\n当 StyletIoC\r\n为您构造一个类型时，它将寻找一个构造函数，该构造函数具有它知道如何解析的类型的参数。然后，它将解析这些类型，并将它们注入构造函数。例如:\r\nclass Engine &#123; ... &#125;class Car&#123;   public Car(Engine engine)   &#123;      // &#x27;engine&#x27; contains a new instance of Engine   &#125;&#125;\r\n这是 StyletIoC 之外的创建新实例最常见的方式——StyletIoC\r\n构造的每一个类型都会在它的构造函数中列出它的依赖项，而 StyletIoC\r\n会构造每一个，注入它的依赖项。\r\n如果你愿意，你也可以做参数注入，如果要注入的参数有属性\r\n[Inject]，例如:\r\nclass Engine &#123; ... &#125;class Car&#123;   [Inject]   public Engine Engine &#123; get; set; &#125;&#125;\r\n每种方法的各种优点，我们将在其他地方讨论。\r\n","categories":["Develop","DotNET","Stylet 框架","StyletIoC"],"tags":["MVVM","WPF"]},{"title":"WPF MVVM Stylet使用文档（中文）19-3 BoolToVisibilityConverter","url":"/posts/2020/10KD94C.html","content":"在几乎每个项目中，我都需要根据 ViewModel 中的一些 bool\r\n值隐藏/显示一个元素。您可以使用 DataTriggers\r\n或使用转换器来实现这一点。\r\n\r\n转换器实现非常简单: 当绑定到一个 bool 属性时，如果它读取一个 true\r\n值，它将返回一个(预配置的)可见性，如果它读取一个 false\r\n值，它将返回另一个。\r\n如果你绑定到一个类型的属性而不是 bool，它将使用以下规则:\r\n\r\n如果该值为null，则视为false\r\n如果值为0 (比如 int、float、double等)，则将其视为false\r\n如果值是空集合、字典等，则将其视为 false\r\n否则，它就被当作是真的\r\n\r\n这与许多语言中的 “真实/虚假”\r\n规则相匹配。比如说，当且仅当绑定到的集合不是空的时候，才显示一个\r\nListView，这个很方便。\r\n基本示例用法:\r\n&lt;!-- In any .Resources section - doesn&#x27;t have to be Window.Resources --&gt;&lt;Window.Resources&gt;   &lt;s:BoolToVisibilityConverter x:Key=&quot;boolToVisConverter&quot; TrueVisibility=&quot;Visible&quot; FalseVisibility=&quot;Hidden&quot;/&gt;&lt;/Window.Resources&gt;&lt;!-- Later in code --&gt;&lt;TextBlock Visibility=&quot;&#123;Binding SomeBoolProperty, Converter=&#123;StaticResource boolToVisConverter&#125;&#125;&quot;/&gt;\r\n如果你想要(通常的)的转换器是这种情况时：true\r\n的情况是Visiblity.Visible ，false 的情况是\r\nVisibility.Collapsed 。这是简化方式：\r\n&lt;TextBlock Visibility=&quot;&#123;Binding SomeBoolProperty, Converter=&#123;x:Static s:BoolToVisibilityConverter.Instance&#125;&#125;&quot;/&gt;\r\n同样地，如果你想要(稍微不太常见的)是：true 时是\r\nVisibility.Collapsed，而 false 是\r\nVisibility.Visible 。这也有一个简化方式：\r\n&lt;TextBlock Visibility=&quot;&#123;Binding SomeBoolProperty, Converter=&#123;x:Static s:BoolToVisibilityConverter.InverseInstance&#125;&#125;&quot;/&gt;\r\n","categories":["Develop","DotNET","Stylet 框架","Misc"],"tags":["MVVM","WPF"]}]